<!--
  丘멆잺 AUTO-GENERATED FILE - DO NOT EDIT MANUALLY

  This file is automatically generated by the publishing pipeline.
  Any manual edits will be overwritten when the pipeline runs.

  To modify this file:
  - Run: bun run pipeline
  - Or edit: scripts/publish/generate.ts

  For project information, see ABOUT.md
-->

> [!WARNING]
> **This is an auto-generated file.** Manual edits will be overwritten by the publishing pipeline.
> For project information, see [ABOUT.md](./ABOUT.md)

# The Effect Patterns Hub

A community-driven knowledge base of practical, goal-oriented patterns for building robust applications with Effect-TS.

This repository is designed to be a living document that helps developers move from core concepts to advanced architectural strategies by focusing on the "why" behind the code.

**Looking for machine-readable rules for AI IDEs and coding agents? See the [AI Coding Rules](#ai-coding-rules) section below.**

## Table of Contents

### Effect Patterns

- [Getting Started](#getting-started)
- [Core Concepts](#core-concepts)
- [Error Management](#error-management)
- [Resource Management](#resource-management)
- [Concurrency](#concurrency)
- [Streams](#streams)
- [Platform](#platform)
- [Scheduling](#scheduling)
- [Domain Modeling](#domain-modeling)
- [Building APIs](#building-apis)
- [Building Data Pipelines](#building-data-pipelines)
- [Making HTTP Requests](#making-http-requests)
- [Testing](#testing)
- [Observability](#observability)
- [Tooling and Debugging](#tooling-and-debugging)



---

## Getting Started
First steps with Effect - hello world, basic concepts

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Why Effect? Comparing Effect to Promise](#getting-started-effect-vs-promise) | 游릭 **Beginner** | Understand what Effect gives you that Promise doesn't: type-safe errors, dependency injection, and composability. |
| [Hello World: Your First Effect](#getting-started-hello-world) | 游릭 **Beginner** | Create and run your very first Effect program using Effect.succeed and Effect.runSync. |
| [Transform Values with Effect.map](#getting-started-transform-with-map) | 游릭 **Beginner** | Use Effect.map to transform the success value of an Effect without changing its error or dependency types. |
| [Handle Your First Error with Effect.fail and catchAll](#getting-started-handle-errors) | 游릭 **Beginner** | Learn how to create Effects that can fail and how to recover from those failures using Effect.fail and Effect.catchAll. |
| [Run Multiple Effects in Parallel with Effect.all](#getting-started-run-in-parallel) | 游릭 **Beginner** | Use Effect.all to run multiple Effects at the same time and collect all their results. |
| [Retry a Failed Operation with Effect.retry](#getting-started-retry-on-failure) | 游릭 **Beginner** | Use Effect.retry with a Schedule to automatically retry failed operations with customizable delays and limits. |

### Why Effect? Comparing Effect to Promise {#getting-started-effect-vs-promise}
Understand what Effect gives you that Promise doesn't: type-safe errors, dependency injection, and composability.

### Hello World: Your First Effect {#getting-started-hello-world}
Create and run your very first Effect program using Effect.succeed and Effect.runSync.

### Transform Values with Effect.map {#getting-started-transform-with-map}
Use Effect.map to transform the success value of an Effect without changing its error or dependency types.

### Handle Your First Error with Effect.fail and catchAll {#getting-started-handle-errors}
Learn how to create Effects that can fail and how to recover from those failures using Effect.fail and Effect.catchAll.

### Run Multiple Effects in Parallel with Effect.all {#getting-started-run-in-parallel}
Use Effect.all to run multiple Effects at the same time and collect all their results.

### Retry a Failed Operation with Effect.retry {#getting-started-retry-on-failure}
Use Effect.retry with a Schedule to automatically retry failed operations with customizable delays and limits.

## Core Concepts
Fundamental Effect patterns - generators, pipes, dependencies

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Accumulate Multiple Errors with Either](#data-either) | 游릭 **Beginner** | Use Either<E, A> to represent computations that can fail, allowing you to accumulate multiple errors instead of short-circuiting on the first one. |
| [Chaining Computations with flatMap](#combinator-flatmap) | 游릭 **Beginner** | Use flatMap to chain together computations where each step may itself be effectful, optional, or error-prone. |
| [Combining Values with zip](#combinator-zip) | 游릭 **Beginner** | Use zip to combine two computations, pairing their results together in Effect, Stream, Option, or Either. |
| [Comparing Data by Value with Data.struct](#data-struct) | 游릭 **Beginner** | Use Data.struct to create immutable, structurally-typed objects that can be compared by value, not by reference. |
| [Comparing Data by Value with Structural Equality](#comparing-data-by-value-with-structural-equality) | 游릭 **Beginner** | Use Data.struct and Equal.equals to safely compare objects by their value instead of their reference, avoiding common JavaScript pitfalls. |
| [Conditional Branching with if, when, and cond](#combinator-conditional) | 游릭 **Beginner** | Use combinators like if, when, and cond to express conditional logic declaratively across Effect, Stream, Option, and Either. |
| [Converting from Nullable, Option, or Either](#constructor-from-nullable-option-either) | 游릭 **Beginner** | Use fromNullable, fromOption, and fromEither to convert nullable values, Option, or Either into Effects or Streams, enabling safe and composable interop. |
| [Create Pre-resolved Effects with succeed and fail](#create-pre-resolved-effect) | 游릭 **Beginner** | Use Effect.succeed(value) to create an Effect that immediately succeeds with a value, and Effect.fail(error) for an Effect that immediately fails. |
| [Creating from Collections](#constructor-from-iterable) | 游릭 **Beginner** | Use fromIterable and fromArray to create Streams or Effects from arrays, iterables, or other collections, enabling batch and streaming operations. |
| [Creating from Synchronous and Callback Code](#constructor-sync-async) | 游릭 **Beginner** | Use sync and async to lift synchronous or callback-based computations into Effect, enabling safe and composable interop with legacy code. |
| [Filtering Results with filter](#combinator-filter) | 游릭 **Beginner** | Use filter to keep or discard results based on a predicate, across Effect, Stream, Option, and Either. |
| [Lifting Errors and Absence with fail, none, and left](#constructor-fail-none-left) | 游릭 **Beginner** | Use fail, none, and left to represent errors or absence in Effect, Option, or Either, making failures explicit and type-safe. |
| [Lifting Values with succeed, some, and right](#constructor-succeed-some-right) | 游릭 **Beginner** | Use succeed, some, and right to lift plain values into Effect, Option, or Either, making them composable and type-safe. |
| [Model Optional Values Safely with Option](#data-option) | 游릭 **Beginner** | Use Option<A> to explicitly represent a value that may or may not exist, eliminating null and undefined errors. |
| [Solve Promise Problems with Effect](#solve-promise-problems-with-effect) | 游릭 **Beginner** | Understand how Effect solves the fundamental problems of native Promises, such as untyped errors, lack of dependency injection, and no built-in cancellation. |
| [Transform Effect Values with map and flatMap](#transform-effect-values) | 游릭 **Beginner** | Use Effect.map for synchronous transformations and Effect.flatMap to chain operations that return another Effect. |
| [Transforming Values with map](#combinator-map) | 游릭 **Beginner** | Use map to transform the result of an Effect, Stream, Option, or Either in a declarative, type-safe way. |
| [Understand that Effects are Lazy Blueprints](#effects-are-lazy) | 游릭 **Beginner** | An Effect is a lazy, immutable blueprint describing a computation, which does nothing until it is explicitly executed by a runtime. |
| [Understand the Three Effect Channels (A, E, R)](#understand-effect-channels) | 游릭 **Beginner** | Learn about the three generic parameters of an Effect: the success value (A), the failure error (E), and the context requirements (R). |
| [Use .pipe for Composition](#use-pipe-for-composition) | 游릭 **Beginner** | Use the .pipe() method to chain multiple operations onto an Effect in a readable, top-to-bottom sequence. |
| [Working with Immutable Arrays using Data.array](#data-array) | 游릭 **Beginner** | Use Data.array to create immutable, type-safe arrays that support value-based equality and safe functional operations. |
| [Working with Tuples using Data.tuple](#data-tuple) | 游릭 **Beginner** | Use Data.tuple to create immutable, type-safe tuples that support value-based equality and pattern matching. |
| [Wrap Asynchronous Computations with tryPromise](#wrap-asynchronous-computations) | 游릭 **Beginner** | Use Effect.tryPromise to safely convert a function that returns a Promise into an Effect, capturing rejections in the error channel. |
| [Wrap Synchronous Computations with sync and try](#wrap-synchronous-computations) | 游릭 **Beginner** | Use Effect.sync for non-throwing synchronous code and Effect.try for synchronous code that might throw an exception. |
| [Wrapping Synchronous and Asynchronous Computations](#constructor-try-trypromise) | 游릭 **Beginner** | Use try and tryPromise to safely wrap synchronous or asynchronous computations that may throw or reject, capturing errors in the Effect world. |
| [Write Sequential Code with Effect.gen](#write-sequential-code-with-gen) | 游릭 **Beginner** | Use Effect.gen with yield* to write sequential, asynchronous code in a style that looks and feels like familiar async/await. |
| [Access Configuration from the Context](#access-config-in-context) | 游리 **Intermediate** | Access your type-safe configuration within an Effect.gen block by yielding the Config object you defined. |
| [Beyond the Date Type - Real World Dates, Times, and Timezones](#beyond-the-date-type) | 游리 **Intermediate** | Use the Clock service for testable access to the current time and prefer immutable primitives for storing and passing timestamps. |
| [Control Flow with Conditional Combinators](#control-flow-with-combinators) | 游리 **Intermediate** | Use combinators like Effect.if, Effect.when, and Effect.cond to handle conditional logic in a declarative, composable way. |
| [Define a Type-Safe Configuration Schema](#define-config-schema) | 游리 **Intermediate** | Use Effect.Config primitives to define a schema for your application's configuration, ensuring type-safety and separation from code. |
| [Handling Errors with catchAll, orElse, and match](#combinator-error-handling) | 游리 **Intermediate** | Use catchAll, orElse, and match to recover from errors, provide fallbacks, or transform errors in Effect, Either, and Option. |
| [Manage Shared State Safely with Ref](#data-ref) | 游리 **Intermediate** | Use Ref<A> to model shared, mutable state in a concurrent environment, ensuring all updates are atomic and free of race conditions. |
| [Mapping and Chaining over Collections with forEach and all](#combinator-foreach-all) | 游리 **Intermediate** | Use forEach and all to apply effectful functions to collections and combine the results, enabling batch and parallel processing. |
| [Modeling Effect Results with Exit](#data-exit) | 游리 **Intermediate** | Use Exit<E, A> to represent the result of running an Effect, capturing both success and failure (including defects) in a type-safe way. |
| [Modeling Tagged Unions with Data.case](#data-case) | 游리 **Intermediate** | Use Data.case to create tagged unions (algebraic data types) for robust, type-safe domain modeling and pattern matching. |
| [Process Streaming Data with Stream](#process-streaming-data-with-stream) | 游리 **Intermediate** | Use Stream<A, E, R> to represent and process data that arrives over time, such as file reads, WebSocket messages, or paginated API results. |
| [Provide Configuration to Your App via a Layer](#provide-config-layer) | 游리 **Intermediate** | Use Config.layer(schema) to create a Layer that provides your configuration schema to the application's context. |
| [Redact and Handle Sensitive Data](#data-redacted) | 游리 **Intermediate** | Use Redacted to securely handle sensitive data, ensuring secrets are not accidentally logged or exposed. |
| [Representing Time Spans with Duration](#data-duration) | 游리 **Intermediate** | Use Duration to represent time intervals in a type-safe, human-readable, and composable way. |
| [Representing Time Spans with Duration](#representing-time-spans-with-duration) | 游리 **Intermediate** | Use the Duration data type to represent time intervals in a type-safe, human-readable, and composable way. |
| [Sequencing with andThen, tap, and flatten](#combinator-sequencing) | 游리 **Intermediate** | Use andThen, tap, and flatten to sequence computations, run side effects, and flatten nested structures in Effect, Stream, Option, and Either. |
| [Type Classes for Equality, Ordering, and Hashing with Data.Class](#data-class) | 游리 **Intermediate** | Use Data.Class to derive and implement type classes for equality, ordering, and hashing, enabling composable and type-safe abstractions. |
| [Understand Layers for Dependency Injection](#understand-layers-for-dependency-injection) | 游리 **Intermediate** | A Layer is a blueprint that describes how to build a service, detailing its own requirements and any potential errors during its construction. |
| [Use Chunk for High-Performance Collections](#data-chunk) | 游리 **Intermediate** | Use Chunk<A> as a high-performance, immutable alternative to JavaScript's Array, especially for data processing pipelines. |
| [Use Chunk for High-Performance Collections](#use-chunk-for-high-performance-collections) | 游리 **Intermediate** | Use Chunk<A> as a high-performance, immutable alternative to JavaScript's Array, especially for data processing pipelines. |
| [Work with Arbitrary-Precision Numbers using BigDecimal](#data-bigdecimal) | 游리 **Intermediate** | Use BigDecimal for arbitrary-precision decimal arithmetic, avoiding rounding errors and loss of precision in financial or scientific calculations. |
| [Work with Dates and Times using DateTime](#data-datetime) | 游리 **Intermediate** | Use DateTime for immutable, time-zone-aware date and time values, enabling safe and precise time calculations. |
| [Work with Immutable Sets using HashSet](#data-hashset) | 游리 **Intermediate** | Use HashSet<A> to model immutable, high-performance sets for efficient membership checks and set operations. |
| [Handle Unexpected Errors by Inspecting the Cause](#data-cause) | 游 **Advanced** | Use Cause<E> to get rich, structured information about errors and failures, including defects, interruptions, and error traces. |

### Accumulate Multiple Errors with Either {#data-either}
Use Either<E, A> to represent computations that can fail, allowing you to accumulate multiple errors instead of short-circuiting on the first one.

### Chaining Computations with flatMap {#combinator-flatmap}
Use flatMap to chain together computations where each step may itself be effectful, optional, or error-prone.

### Combining Values with zip {#combinator-zip}
Use zip to combine two computations, pairing their results together in Effect, Stream, Option, or Either.

### Comparing Data by Value with Data.struct {#data-struct}
Use Data.struct to create immutable, structurally-typed objects that can be compared by value, not by reference.

### Comparing Data by Value with Structural Equality {#comparing-data-by-value-with-structural-equality}
Use Data.struct and Equal.equals to safely compare objects by their value instead of their reference, avoiding common JavaScript pitfalls.

### Conditional Branching with if, when, and cond {#combinator-conditional}
Use combinators like if, when, and cond to express conditional logic declaratively across Effect, Stream, Option, and Either.

### Converting from Nullable, Option, or Either {#constructor-from-nullable-option-either}
Use fromNullable, fromOption, and fromEither to convert nullable values, Option, or Either into Effects or Streams, enabling safe and composable interop.

### Create Pre-resolved Effects with succeed and fail {#create-pre-resolved-effect}
Use Effect.succeed(value) to create an Effect that immediately succeeds with a value, and Effect.fail(error) for an Effect that immediately fails.

### Creating from Collections {#constructor-from-iterable}
Use fromIterable and fromArray to create Streams or Effects from arrays, iterables, or other collections, enabling batch and streaming operations.

### Creating from Synchronous and Callback Code {#constructor-sync-async}
Use sync and async to lift synchronous or callback-based computations into Effect, enabling safe and composable interop with legacy code.

### Filtering Results with filter {#combinator-filter}
Use filter to keep or discard results based on a predicate, across Effect, Stream, Option, and Either.

### Lifting Errors and Absence with fail, none, and left {#constructor-fail-none-left}
Use fail, none, and left to represent errors or absence in Effect, Option, or Either, making failures explicit and type-safe.

### Lifting Values with succeed, some, and right {#constructor-succeed-some-right}
Use succeed, some, and right to lift plain values into Effect, Option, or Either, making them composable and type-safe.

### Model Optional Values Safely with Option {#data-option}
Use Option<A> to explicitly represent a value that may or may not exist, eliminating null and undefined errors.

### Solve Promise Problems with Effect {#solve-promise-problems-with-effect}
Understand how Effect solves the fundamental problems of native Promises, such as untyped errors, lack of dependency injection, and no built-in cancellation.

### Transform Effect Values with map and flatMap {#transform-effect-values}
Use Effect.map for synchronous transformations and Effect.flatMap to chain operations that return another Effect.

### Transforming Values with map {#combinator-map}
Use map to transform the result of an Effect, Stream, Option, or Either in a declarative, type-safe way.

### Understand that Effects are Lazy Blueprints {#effects-are-lazy}
An Effect is a lazy, immutable blueprint describing a computation, which does nothing until it is explicitly executed by a runtime.

### Understand the Three Effect Channels (A, E, R) {#understand-effect-channels}
Learn about the three generic parameters of an Effect: the success value (A), the failure error (E), and the context requirements (R).

### Use .pipe for Composition {#use-pipe-for-composition}
Use the .pipe() method to chain multiple operations onto an Effect in a readable, top-to-bottom sequence.

### Working with Immutable Arrays using Data.array {#data-array}
Use Data.array to create immutable, type-safe arrays that support value-based equality and safe functional operations.

### Working with Tuples using Data.tuple {#data-tuple}
Use Data.tuple to create immutable, type-safe tuples that support value-based equality and pattern matching.

### Wrap Asynchronous Computations with tryPromise {#wrap-asynchronous-computations}
Use Effect.tryPromise to safely convert a function that returns a Promise into an Effect, capturing rejections in the error channel.

### Wrap Synchronous Computations with sync and try {#wrap-synchronous-computations}
Use Effect.sync for non-throwing synchronous code and Effect.try for synchronous code that might throw an exception.

### Wrapping Synchronous and Asynchronous Computations {#constructor-try-trypromise}
Use try and tryPromise to safely wrap synchronous or asynchronous computations that may throw or reject, capturing errors in the Effect world.

### Write Sequential Code with Effect.gen {#write-sequential-code-with-gen}
Use Effect.gen with yield* to write sequential, asynchronous code in a style that looks and feels like familiar async/await.

### Access Configuration from the Context {#access-config-in-context}
Access your type-safe configuration within an Effect.gen block by yielding the Config object you defined.

### Beyond the Date Type - Real World Dates, Times, and Timezones {#beyond-the-date-type}
Use the Clock service for testable access to the current time and prefer immutable primitives for storing and passing timestamps.

### Control Flow with Conditional Combinators {#control-flow-with-combinators}
Use combinators like Effect.if, Effect.when, and Effect.cond to handle conditional logic in a declarative, composable way.

### Define a Type-Safe Configuration Schema {#define-config-schema}
Use Effect.Config primitives to define a schema for your application's configuration, ensuring type-safety and separation from code.

### Handling Errors with catchAll, orElse, and match {#combinator-error-handling}
Use catchAll, orElse, and match to recover from errors, provide fallbacks, or transform errors in Effect, Either, and Option.

### Manage Shared State Safely with Ref {#data-ref}
Use Ref<A> to model shared, mutable state in a concurrent environment, ensuring all updates are atomic and free of race conditions.

### Mapping and Chaining over Collections with forEach and all {#combinator-foreach-all}
Use forEach and all to apply effectful functions to collections and combine the results, enabling batch and parallel processing.

### Modeling Effect Results with Exit {#data-exit}
Use Exit<E, A> to represent the result of running an Effect, capturing both success and failure (including defects) in a type-safe way.

### Modeling Tagged Unions with Data.case {#data-case}
Use Data.case to create tagged unions (algebraic data types) for robust, type-safe domain modeling and pattern matching.

### Process Streaming Data with Stream {#process-streaming-data-with-stream}
Use Stream<A, E, R> to represent and process data that arrives over time, such as file reads, WebSocket messages, or paginated API results.

### Provide Configuration to Your App via a Layer {#provide-config-layer}
Use Config.layer(schema) to create a Layer that provides your configuration schema to the application's context.

### Redact and Handle Sensitive Data {#data-redacted}
Use Redacted to securely handle sensitive data, ensuring secrets are not accidentally logged or exposed.

### Representing Time Spans with Duration {#data-duration}
Use Duration to represent time intervals in a type-safe, human-readable, and composable way.

### Representing Time Spans with Duration {#representing-time-spans-with-duration}
Use the Duration data type to represent time intervals in a type-safe, human-readable, and composable way.

### Sequencing with andThen, tap, and flatten {#combinator-sequencing}
Use andThen, tap, and flatten to sequence computations, run side effects, and flatten nested structures in Effect, Stream, Option, and Either.

### Type Classes for Equality, Ordering, and Hashing with Data.Class {#data-class}
Use Data.Class to derive and implement type classes for equality, ordering, and hashing, enabling composable and type-safe abstractions.

### Understand Layers for Dependency Injection {#understand-layers-for-dependency-injection}
A Layer is a blueprint that describes how to build a service, detailing its own requirements and any potential errors during its construction.

### Use Chunk for High-Performance Collections {#data-chunk}
Use Chunk<A> as a high-performance, immutable alternative to JavaScript's Array, especially for data processing pipelines.

### Use Chunk for High-Performance Collections {#use-chunk-for-high-performance-collections}
Use Chunk<A> as a high-performance, immutable alternative to JavaScript's Array, especially for data processing pipelines.

### Work with Arbitrary-Precision Numbers using BigDecimal {#data-bigdecimal}
Use BigDecimal for arbitrary-precision decimal arithmetic, avoiding rounding errors and loss of precision in financial or scientific calculations.

### Work with Dates and Times using DateTime {#data-datetime}
Use DateTime for immutable, time-zone-aware date and time values, enabling safe and precise time calculations.

### Work with Immutable Sets using HashSet {#data-hashset}
Use HashSet<A> to model immutable, high-performance sets for efficient membership checks and set operations.

### Handle Unexpected Errors by Inspecting the Cause {#data-cause}
Use Cause<E> to get rich, structured information about errors and failures, including defects, interruptions, and error traces.

## Error Management
Handle errors, create typed errors, recovery strategies

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Checking Option and Either Cases](#pattern-option-either-checks) | 游릭 **Beginner** | Use isSome, isNone, isLeft, and isRight to check Option and Either cases for simple, type-safe branching. |
| [Matching on Success and Failure with match](#pattern-match) | 游릭 **Beginner** | Use match to handle both success and failure cases in a single, declarative place for Effect, Option, and Either. |
| [Pattern Match on Option and Either](#pattern-option-either-match) | 游릭 **Beginner** | Use declarative match() combinators to handle optional and error-prone values |
| [Your First Error Handler](#error-management-hello-world) | 游릭 **Beginner** | Learn the basics of handling errors in Effect with catchAll and catchTag. |
| [Conditionally Branching Workflows](#conditionally-branching-workflows) | 游리 **Intermediate** | Use predicate-based operators like Effect.filter and Effect.if to make decisions and control the flow of your application based on runtime values. |
| [Control Repetition with Schedule](#control-repetition-with-schedule) | 游리 **Intermediate** | Use Schedule to create composable, stateful policies that define precisely how an effect should be repeated or retried. |
| [Effectful Pattern Matching with matchEffect](#pattern-matcheffect) | 游리 **Intermediate** | Use matchEffect to perform effectful branching based on success or failure, enabling rich workflows in the Effect world. |
| [Handle Errors with catchTag, catchTags, and catchAll](#handle-errors-with-catch) | 游리 **Intermediate** | Use catchTag for type-safe recovery from specific tagged errors, and catchAll to recover from any possible failure. |
| [Handle Flaky Operations with Retries and Timeouts](#handle-flaky-operations-with-retry-timeout) | 游리 **Intermediate** | Use Effect.retry and Effect.timeout to build resilience against slow or intermittently failing operations, such as network requests. |
| [Handling Specific Errors with catchTag and catchTags](#pattern-catchtag) | 游리 **Intermediate** | Use catchTag and catchTags to recover from or handle specific error types in the Effect failure channel, enabling precise and type-safe error recovery. |
| [Leverage Effect's Built-in Structured Logging](#leverage-structured-logging) | 游리 **Intermediate** | Use Effect's built-in logging functions (Effect.log, Effect.logInfo, etc.) for structured, configurable, and context-aware logging. |
| [Mapping Errors to Fit Your Domain](#mapping-errors-to-fit-your-domain) | 游리 **Intermediate** | Use Effect.mapError to transform specific, low-level errors into more general domain errors, creating clean architectural boundaries. |
| [Matching Tagged Unions with matchTag and matchTags](#pattern-matchtag) | 游리 **Intermediate** | Use matchTag and matchTags to pattern match on specific tagged union cases, enabling precise and type-safe branching. |
| [Retry Operations Based on Specific Errors](#retry-based-on-specific-errors) | 游리 **Intermediate** | Use Effect.retry and predicate functions to selectively retry an operation only when specific, recoverable errors occur. |
| [Handle Unexpected Errors by Inspecting the Cause](#handle-unexpected-errors-with-cause) | 游 **Advanced** | Use Effect.catchAllCause or Effect.runFork to inspect the Cause of a failure, distinguishing between expected errors (Fail) and unexpected defects (Die). |

### Checking Option and Either Cases {#pattern-option-either-checks}
Use isSome, isNone, isLeft, and isRight to check Option and Either cases for simple, type-safe branching.

### Matching on Success and Failure with match {#pattern-match}
Use match to handle both success and failure cases in a single, declarative place for Effect, Option, and Either.

### Pattern Match on Option and Either {#pattern-option-either-match}
Use declarative match() combinators to handle optional and error-prone values.

### Your First Error Handler {#error-management-hello-world}
Learn the basics of handling errors in Effect with catchAll and catchTag.

### Conditionally Branching Workflows {#conditionally-branching-workflows}
Use predicate-based operators like Effect.filter and Effect.if to make decisions and control the flow of your application based on runtime values.

### Control Repetition with Schedule {#control-repetition-with-schedule}
Use Schedule to create composable, stateful policies that define precisely how an effect should be repeated or retried.

### Effectful Pattern Matching with matchEffect {#pattern-matcheffect}
Use matchEffect to perform effectful branching based on success or failure, enabling rich workflows in the Effect world.

### Handle Errors with catchTag, catchTags, and catchAll {#handle-errors-with-catch}
Use catchTag for type-safe recovery from specific tagged errors, and catchAll to recover from any possible failure.

### Handle Flaky Operations with Retries and Timeouts {#handle-flaky-operations-with-retry-timeout}
Use Effect.retry and Effect.timeout to build resilience against slow or intermittently failing operations, such as network requests.

### Handling Specific Errors with catchTag and catchTags {#pattern-catchtag}
Use catchTag and catchTags to recover from or handle specific error types in the Effect failure channel, enabling precise and type-safe error recovery.

### Leverage Effect's Built-in Structured Logging {#leverage-structured-logging}
Use Effect's built-in logging functions (Effect.log, Effect.logInfo, etc.) for structured, configurable, and context-aware logging.

### Mapping Errors to Fit Your Domain {#mapping-errors-to-fit-your-domain}
Use Effect.mapError to transform specific, low-level errors into more general domain errors, creating clean architectural boundaries.

### Matching Tagged Unions with matchTag and matchTags {#pattern-matchtag}
Use matchTag and matchTags to pattern match on specific tagged union cases, enabling precise and type-safe branching.

### Retry Operations Based on Specific Errors {#retry-based-on-specific-errors}
Use Effect.retry and predicate functions to selectively retry an operation only when specific, recoverable errors occur.

### Handle Unexpected Errors by Inspecting the Cause {#handle-unexpected-errors-with-cause}
Use Effect.catchAllCause or Effect.runFork to inspect the Cause of a failure, distinguishing between expected errors (Fail) and unexpected defects (Die).

## Resource Management
Acquire and release resources safely with Scope

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Safely Bracket Resource Usage with `acquireRelease`](#safely-bracket-resource-usage) | 游릭 **Beginner** | Use `Effect.acquireRelease` to guarantee a resource's cleanup logic runs, even if errors or interruptions occur. |
| [Compose Resource Lifecycles with `Layer.merge`](#compose-scoped-layers) | 游리 **Intermediate** | Combine multiple resource-managing layers, letting Effect automatically handle the acquisition and release order. |
| [Create a Service Layer from a Managed Resource](#scoped-service-layer) | 游리 **Intermediate** | Use `Layer.scoped` with `Effect.Service` to transform a managed resource into a shareable, application-wide service. |
| [Handle Resource Timeouts](#resource-timeouts) | 游리 **Intermediate** | Set timeouts on resource acquisition and usage to prevent hanging operations. |
| [Pool Resources for Reuse](#resource-pooling) | 游리 **Intermediate** | Create and manage a pool of reusable resources like database connections or workers. |
| [Create a Managed Runtime for Scoped Resources](#create-managed-runtime-for-scoped-resources) | 游 **Advanced** | Use Layer.launch to safely manage the lifecycle of layers containing scoped resources, ensuring finalizers are always run. |
| [Manage Hierarchical Resources](#resource-hierarchies) | 游 **Advanced** | Manage parent-child resource relationships where children must be released before parents. |
| [Manually Manage Lifecycles with `Scope`](#manual-scope-management) | 游 **Advanced** | Use `Scope` directly to manage complex resource lifecycles or when building custom layers. |

### Safely Bracket Resource Usage with `acquireRelease` {#safely-bracket-resource-usage}
Use `Effect.acquireRelease` to guarantee a resource's cleanup logic runs, even if errors or interruptions occur.

### Compose Resource Lifecycles with `Layer.merge` {#compose-scoped-layers}
Combine multiple resource-managing layers, letting Effect automatically handle the acquisition and release order.

### Create a Service Layer from a Managed Resource {#scoped-service-layer}
Use `Layer.scoped` with `Effect.Service` to transform a managed resource into a shareable, application-wide service.

### Handle Resource Timeouts {#resource-timeouts}
Set timeouts on resource acquisition and usage to prevent hanging operations.

### Pool Resources for Reuse {#resource-pooling}
Create and manage a pool of reusable resources like database connections or workers.

### Create a Managed Runtime for Scoped Resources {#create-managed-runtime-for-scoped-resources}
Use Layer.launch to safely manage the lifecycle of layers containing scoped resources, ensuring finalizers are always run.

### Manage Hierarchical Resources {#resource-hierarchies}
Manage parent-child resource relationships where children must be released before parents.

### Manually Manage Lifecycles with `Scope` {#manual-scope-management}
Use `Scope` directly to manage complex resource lifecycles or when building custom layers.


## Concurrency
Run effects in parallel, manage fibers, coordinate async work

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Race Effects and Handle Timeouts](#concurrency-race-timeout) | 游릭 **Beginner** | Race multiple effects to get the fastest result, or add timeouts to prevent hanging operations. |
| [Understanding Fibers](#concurrency-understanding-fibers) | 游릭 **Beginner** | Learn what fibers are, how they differ from threads, and why they make Effect powerful for concurrent programming. |
| [Your First Parallel Operation](#concurrency-hello-world) | 游릭 **Beginner** | Run multiple effects in parallel with Effect.all and understand when to use parallel vs sequential execution. |
| [Concurrency Pattern 1: Coordinate Async Operations with Deferred](#concurrency-pattern-coordinate-with-deferred) | 游리 **Intermediate** | Use Deferred to coordinate async operations where multiple fibers wait for a single event to complete, enabling producer-consumer patterns and async signaling without polling. |
| [Concurrency Pattern 2: Rate Limit Concurrent Access with Semaphore](#concurrency-pattern-rate-limit-with-semaphore) | 游리 **Intermediate** | Use Semaphore to limit the number of concurrent operations, enabling connection pooling, API rate limiting, and controlled resource access without overload. |
| [Concurrency Pattern 3: Coordinate Multiple Fibers with Latch](#concurrency-pattern-coordinate-with-latch) | 游리 **Intermediate** | Use Latch to synchronize multiple fibers, enabling patterns like coordinating N async tasks, fan-out/fan-in, and barrier synchronization. |
| [Concurrency Pattern 4: Distribute Work with Queue](#concurrency-pattern-queue-work-distribution) | 游리 **Intermediate** | Use Queue to decouple producers and consumers, enabling work distribution, pipeline stages, and backpressure handling across concurrent fibers. |
| [Concurrency Pattern 5: Broadcast Events with PubSub](#concurrency-pattern-pubsub-event-broadcast) | 游리 **Intermediate** | Use PubSub to broadcast events to multiple subscribers, enabling event-driven architectures and fan-out patterns without direct coupling. |
| [Concurrency Pattern 6: Race and Timeout Competing Effects](#concurrency-pattern-race-timeout) | 游리 **Intermediate** | Use race and timeout to compete multiple effects and enforce deadlines, enabling timeout handling and choosing fastest result. |
| [Manage Shared State Safely with Ref](#manage-shared-state-with-ref) | 游리 **Intermediate** | Use Ref<A> to model shared, mutable state in a concurrent environment, ensuring all updates are atomic and free of race conditions. |
| [Process a Collection in Parallel with Effect.forEach](#process-collection-in-parallel-with-foreach) | 游리 **Intermediate** | Use Effect.forEach with the `concurrency` option to process a collection of items in parallel with a fixed limit, preventing resource exhaustion. |
| [Race Concurrent Effects for the Fastest Result](#race-concurrent-effects) | 游리 **Intermediate** | Use Effect.race to run multiple effects concurrently and proceed with the result of the one that succeeds first, automatically interrupting the others. |
| [Run Independent Effects in Parallel with Effect.all](#run-effects-in-parallel-with-all) | 游리 **Intermediate** | Use Effect.all to run multiple independent effects concurrently and collect all their results into a single tuple. |
| [Add Caching by Wrapping a Layer](#add-caching-by-wrapping-a-layer) | 游 **Advanced** | Implement caching by creating a new layer that wraps a live service, intercepting method calls to add caching logic without modifying the original service. |
| [Decouple Fibers with Queues and PubSub](#decouple-fibers-with-queue-pubsub) | 游 **Advanced** | Use Queue for point-to-point work distribution and PubSub for broadcast messaging to enable safe, decoupled communication between concurrent fibers. |
| [Execute Long-Running Apps with Effect.runFork](#execute-long-running-apps-with-runfork) | 游 **Advanced** | Use Effect.runFork at the application's entry point to launch a long-running process as a detached fiber, allowing for graceful shutdown. |
| [Implement Graceful Shutdown for Your Application](#implement-graceful-shutdown) | 游 **Advanced** | Use Effect.runFork and listen for OS signals (SIGINT, SIGTERM) to trigger a Fiber.interrupt, ensuring all resources are safely released. |
| [Manage Resource Lifecycles with Scope](#manage-resource-lifecycles-with-scope) | 游 **Advanced** | Use Scope for fine-grained, manual control over resource lifecycles, ensuring cleanup logic (finalizers) is always executed. |
| [Poll for Status Until a Task Completes](#poll-for-status-until-task-completes) | 游 **Advanced** | Use Effect.race to run a repeating polling effect alongside a main task, automatically stopping the polling when the main task finishes. |
| [Run Background Tasks with Effect.fork](#run-background-tasks-with-fork) | 游 **Advanced** | Use Effect.fork to start a computation in a background fiber, allowing the parent fiber to continue its work without waiting. |
| [State Management Pattern 1: Synchronized Reference with SynchronizedRef](#state-management-pattern-synchronized-ref) | 游 **Advanced** | Use SynchronizedRef to safely share mutable state across concurrent fibers, with atomic updates and guaranteed consistency. |
| [State Management Pattern 2: Observable State with SubscriptionRef](#state-management-pattern-subscription-ref) | 游 **Advanced** | Build observable state that notifies subscribers on changes, enabling reactive patterns and state-driven architecture. |
| [Understand Fibers as Lightweight Threads](#understand-fibers-as-lightweight-threads) | 游 **Advanced** | A Fiber is a lightweight, virtual thread managed by the Effect runtime, enabling massive concurrency on a single OS thread without the overhead of traditional threading. |

### Race Effects and Handle Timeouts {#concurrency-race-timeout}
Race multiple effects to get the fastest result, or add timeouts to prevent hanging operations.

### Understanding Fibers {#concurrency-understanding-fibers}
Learn what fibers are, how they differ from threads, and why they make Effect powerful for concurrent programming.

### Your First Parallel Operation {#concurrency-hello-world}
Run multiple effects in parallel with Effect.all and understand when to use parallel vs sequential execution.

### Concurrency Pattern 1: Coordinate Async Operations with Deferred {#concurrency-pattern-coordinate-with-deferred}
Use Deferred to coordinate async operations where multiple fibers wait for a single event to complete, enabling producer-consumer patterns and async signaling without polling.

### Concurrency Pattern 2: Rate Limit Concurrent Access with Semaphore {#concurrency-pattern-rate-limit-with-semaphore}
Use Semaphore to limit the number of concurrent operations, enabling connection pooling, API rate limiting, and controlled resource access without overload.

### Concurrency Pattern 3: Coordinate Multiple Fibers with Latch {#concurrency-pattern-coordinate-with-latch}
Use Latch to synchronize multiple fibers, enabling patterns like coordinating N async tasks, fan-out/fan-in, and barrier synchronization.

### Concurrency Pattern 4: Distribute Work with Queue {#concurrency-pattern-queue-work-distribution}
Use Queue to decouple producers and consumers, enabling work distribution, pipeline stages, and backpressure handling across concurrent fibers.

### Concurrency Pattern 5: Broadcast Events with PubSub {#concurrency-pattern-pubsub-event-broadcast}
Use PubSub to broadcast events to multiple subscribers, enabling event-driven architectures and fan-out patterns without direct coupling.

### Concurrency Pattern 6: Race and Timeout Competing Effects {#concurrency-pattern-race-timeout}
Use race and timeout to compete multiple effects and enforce deadlines, enabling timeout handling and choosing fastest result.

### Manage Shared State Safely with Ref {#manage-shared-state-with-ref}
Use Ref<A> to model shared, mutable state in a concurrent environment, ensuring all updates are atomic and free of race conditions.

### Process a Collection in Parallel with Effect.forEach {#process-collection-in-parallel-with-foreach}
Use Effect.forEach with the `concurrency` option to process a collection of items in parallel with a fixed limit, preventing resource exhaustion.

### Race Concurrent Effects for the Fastest Result {#race-concurrent-effects}
Use Effect.race to run multiple effects concurrently and proceed with the result of the one that succeeds first, automatically interrupting the others.

### Run Independent Effects in Parallel with Effect.all {#run-effects-in-parallel-with-all}
Use Effect.all to run multiple independent effects concurrently and collect all their results into a single tuple.

### Add Caching by Wrapping a Layer {#add-caching-by-wrapping-a-layer}
Implement caching by creating a new layer that wraps a live service, intercepting method calls to add caching logic without modifying the original service.

### Decouple Fibers with Queues and PubSub {#decouple-fibers-with-queue-pubsub}
Use Queue for point-to-point work distribution and PubSub for broadcast messaging to enable safe, decoupled communication between concurrent fibers.

### Execute Long-Running Apps with Effect.runFork {#execute-long-running-apps-with-runfork}
Use Effect.runFork at the application's entry point to launch a long-running process as a detached fiber, allowing for graceful shutdown.

### Implement Graceful Shutdown for Your Application {#implement-graceful-shutdown}
Use Effect.runFork and listen for OS signals (SIGINT, SIGTERM) to trigger a Fiber.interrupt, ensuring all resources are safely released.

### Manage Resource Lifecycles with Scope {#manage-resource-lifecycles-with-scope}
Use Scope for fine-grained, manual control over resource lifecycles, ensuring cleanup logic (finalizers) is always executed.

### Poll for Status Until a Task Completes {#poll-for-status-until-task-completes}
Use Effect.race to run a repeating polling effect alongside a main task, automatically stopping the polling when the main task finishes.

### Run Background Tasks with Effect.fork {#run-background-tasks-with-fork}
Use Effect.fork to start a computation in a background fiber, allowing the parent fiber to continue its work without waiting.

### State Management Pattern 1: Synchronized Reference with SynchronizedRef {#state-management-pattern-synchronized-ref}
Use SynchronizedRef to safely share mutable state across concurrent fibers, with atomic updates and guaranteed consistency.

### State Management Pattern 2: Observable State with SubscriptionRef {#state-management-pattern-subscription-ref}
Build observable state that notifies subscribers on changes, enabling reactive patterns and state-driven architecture.

### Understand Fibers as Lightweight Threads {#understand-fibers-as-lightweight-threads}
A Fiber is a lightweight, virtual thread managed by the Effect runtime, enabling massive concurrency on a single OS thread without the overhead of traditional threading.

## Streams
Process sequences of data with Stream

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Running and Collecting Stream Results](#stream-running-collecting) | 游릭 **Beginner** | Learn the different ways to run a stream and collect its results: runCollect, runForEach, runDrain, and more. |
| [Stream Pattern 1: Transform Streams with Map and Filter](#stream-pattern-map-filter-transformations) | 游릭 **Beginner** | Use Stream.map and Stream.filter to transform and select stream elements, enabling data pipelines that reshape and filter data in flight. |
| [Stream vs Effect - When to Use Which](#stream-vs-effect) | 游릭 **Beginner** | Understand when to use Effect (single value) vs Stream (sequence of values) for your use case. |
| [Take and Drop Stream Elements](#stream-take-drop) | 游릭 **Beginner** | Control how many stream elements to process using take, drop, takeWhile, and dropWhile. |
| [Your First Stream](#stream-hello-world) | 游릭 **Beginner** | Create your first Effect Stream and understand what makes streams different from regular arrays. |
| [Sink Pattern 1: Batch Insert Stream Records into Database](#sink-pattern-batch-insert-stream-records-into-database) | 游리 **Intermediate** | Use Sink to batch stream records and insert them efficiently into a database in groups, rather than one-by-one, for better performance and resource usage. |
| [Sink Pattern 2: Write Stream Events to Event Log](#sink-pattern-write-stream-events-to-event-log) | 游리 **Intermediate** | Use Sink to append stream events to an event log with metadata and causal ordering, enabling event sourcing and audit trail patterns. |
| [Sink Pattern 3: Write Stream Lines to File](#sink-pattern-write-stream-lines-to-file) | 游리 **Intermediate** | Use Sink to write stream data as lines to a file with buffering for efficiency, supporting log files and line-oriented formats. |
| [Sink Pattern 4: Send Stream Records to Message Queue](#sink-pattern-send-stream-records-to-message-queue) | 游리 **Intermediate** | Use Sink to publish stream records to a message queue with partitioning, batching, and acknowledgment handling for distributed systems. |
| [Sink Pattern 5: Fall Back to Alternative Sink on Failure](#sink-pattern-fall-back-to-alternative-sink-on-failure) | 游리 **Intermediate** | Use Sink to attempt writing to a primary destination, and automatically fall back to an alternative destination if the primary fails, enabling progressive degradation and high availability. |
| [Sink Pattern 6: Retry Failed Stream Operations](#sink-pattern-retry-failed-stream-operations) | 游리 **Intermediate** | Use Sink with configurable retry policies to automatically retry failed operations with exponential backoff, enabling recovery from transient failures without losing data. |
| [Stream Pattern 2: Merge and Combine Multiple Streams](#stream-pattern-merge-combine) | 游리 **Intermediate** | Use Stream.merge, Stream.concat, and Stream.mergeAll to combine multiple streams into a single stream, enabling multi-source data aggregation. |
| [Stream Pattern 3: Control Backpressure in Streams](#stream-pattern-backpressure-control) | 游리 **Intermediate** | Use Stream throttling, buffering, and chunk operations to manage backpressure, preventing upstream from overwhelming downstream consumers. |
| [Stream Pattern 4: Stateful Operations with Scan and Fold](#stream-pattern-stateful-operations) | 游리 **Intermediate** | Use Stream.scan and Stream.fold to maintain state across stream elements, enabling cumulative operations, counters, aggregations, and stateful transformations. |
| [Stream Pattern 5: Grouping and Windowing Streams](#stream-pattern-grouping-windowing) | 游 **Advanced** | Use grouping and windowing to organize streams by key or time window, enabling batch operations and temporal aggregations. |
| [Stream Pattern 6: Resource Management in Streams](#stream-pattern-resource-management) | 游 **Advanced** | Properly manage resources (connections, files, memory) in streams using acquire/release patterns and ensuring cleanup on error or completion. |
| [Stream Pattern 7: Error Handling in Streams](#stream-pattern-error-handling) | 游 **Advanced** | Handle errors gracefully in streams with recovery strategies, resuming after failures, and maintaining stream integrity. |
| [Stream Pattern 8: Advanced Stream Transformations](#stream-pattern-advanced-transformations) | 游 **Advanced** | Apply complex transformations across streams including custom operators, effect-based transformations, and composition patterns. |

### Running and Collecting Stream Results {#stream-running-collecting}
Learn the different ways to run a stream and collect its results: runCollect, runForEach, runDrain, and more.

### Stream Pattern 1: Transform Streams with Map and Filter {#stream-pattern-map-filter-transformations}
Use Stream.map and Stream.filter to transform and select stream elements, enabling data pipelines that reshape and filter data in flight.

### Stream vs Effect - When to Use Which {#stream-vs-effect}
Understand when to use Effect (single value) vs Stream (sequence of values) for your use case.

### Take and Drop Stream Elements {#stream-take-drop}
Control how many stream elements to process using take, drop, takeWhile, and dropWhile.

### Your First Stream {#stream-hello-world}
Create your first Effect Stream and understand what makes streams different from regular arrays.

### Sink Pattern 1: Batch Insert Stream Records into Database {#sink-pattern-batch-insert-stream-records-into-database}
Use Sink to batch stream records and insert them efficiently into a database in groups, rather than one-by-one, for better performance and resource usage.

### Sink Pattern 2: Write Stream Events to Event Log {#sink-pattern-write-stream-events-to-event-log}
Use Sink to append stream events to an event log with metadata and causal ordering, enabling event sourcing and audit trail patterns.

### Sink Pattern 3: Write Stream Lines to File {#sink-pattern-write-stream-lines-to-file}
Use Sink to write stream data as lines to a file with buffering for efficiency, supporting log files and line-oriented formats.

### Sink Pattern 4: Send Stream Records to Message Queue {#sink-pattern-send-stream-records-to-message-queue}
Use Sink to publish stream records to a message queue with partitioning, batching, and acknowledgment handling for distributed systems.

### Sink Pattern 5: Fall Back to Alternative Sink on Failure {#sink-pattern-fall-back-to-alternative-sink-on-failure}
Use Sink to attempt writing to a primary destination, and automatically fall back to an alternative destination if the primary fails, enabling progressive degradation and high availability.

### Sink Pattern 6: Retry Failed Stream Operations {#sink-pattern-retry-failed-stream-operations}
Use Sink with configurable retry policies to automatically retry failed operations with exponential backoff, enabling recovery from transient failures without losing data.

### Stream Pattern 2: Merge and Combine Multiple Streams {#stream-pattern-merge-combine}
Use Stream.merge, Stream.concat, and Stream.mergeAll to combine multiple streams into a single stream, enabling multi-source data aggregation.

### Stream Pattern 3: Control Backpressure in Streams {#stream-pattern-backpressure-control}
Use Stream throttling, buffering, and chunk operations to manage backpressure, preventing upstream from overwhelming downstream consumers.

### Stream Pattern 4: Stateful Operations with Scan and Fold {#stream-pattern-stateful-operations}
Use Stream.scan and Stream.fold to maintain state across stream elements, enabling cumulative operations, counters, aggregations, and stateful transformations.

### Stream Pattern 5: Grouping and Windowing Streams {#stream-pattern-grouping-windowing}
Use grouping and windowing to organize streams by key or time window, enabling batch operations and temporal aggregations.

### Stream Pattern 6: Resource Management in Streams {#stream-pattern-resource-management}
Properly manage resources (connections, files, memory) in streams using acquire/release patterns and ensuring cleanup on error or completion.

### Stream Pattern 7: Error Handling in Streams {#stream-pattern-error-handling}
Handle errors gracefully in streams with recovery strategies, resuming after failures, and maintaining stream integrity.

### Stream Pattern 8: Advanced Stream Transformations {#stream-pattern-advanced-transformations}
Apply complex transformations across streams including custom operators, effect-based transformations, and composition patterns.

## Platform
System operations - files, commands, environment

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Access Environment Variables](#platform-environment-variables) | 游릭 **Beginner** | Read environment variables safely with Effect Platform, handling missing values gracefully. |
| [Platform Pattern 2: Filesystem Operations](#platform-filesystem-operations) | 游릭 **Beginner** | Use FileSystem module to read, write, list, and manage files with proper resource cleanup and error handling. |
| [Platform Pattern 4: Interactive Terminal I/O](#platform-terminal-interactive) | 游릭 **Beginner** | Use Terminal module to read user input and write formatted output, enabling interactive CLI applications with proper buffering and encoding. |
| [Your First Platform Operation](#platform-hello-world) | 游릭 **Beginner** | Get started with Effect Platform by reading a file and understanding how Platform differs from Node.js APIs. |
| [Platform Pattern 1: Execute Shell Commands](#platform-pattern-command-execution) | 游리 **Intermediate** | Use Command module to execute shell commands, capture output, and handle exit codes, enabling integration with system tools and external programs. |
| [Platform Pattern 3: Persistent Key-Value Storage](#platform-keyvaluestore-persistence) | 游리 **Intermediate** | Use KeyValueStore for simple persistent key-value storage, enabling caching, session management, and lightweight data persistence. |
| [Platform Pattern 5: Cross-Platform Path Manipulation](#platform-pattern-path-manipulation) | 游리 **Intermediate** | Use platform-aware path operations to handle file system paths correctly across Windows, macOS, and Linux with proper resolution and normalization. |
| [Platform Pattern 6: Advanced FileSystem Operations](#platform-pattern-advanced-filesystem) | 游 **Advanced** | Handle complex file system scenarios including watching files, recursive operations, atomic writes, and efficient bulk operations. |

## Scheduling
Schedule and repeat effects with Schedule

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Retry Failed Operations](#scheduling-retry-basics) | 游릭 **Beginner** | Use Effect.retry with Schedule to automatically retry operations that fail. |
| [Your First Schedule](#scheduling-hello-world) | 游릭 **Beginner** | Learn the basics of scheduling in Effect - retry operations and repeat them on intervals. |
| [Scheduling Pattern 1: Repeat an Effect on a Fixed Interval](#scheduling-pattern-repeat-effect-on-fixed-interval) | 游리 **Intermediate** | Use Schedule.fixed to repeat an effect at regular intervals, enabling polling, health checks, and periodic background tasks without busy-waiting or manual timing logic. |
| [Scheduling Pattern 3: Schedule Tasks with Cron Expressions](#scheduling-pattern-cron-expressions) | 游리 **Intermediate** | Use cron expressions to schedule tasks at specific times and intervals, enabling calendar-based scheduling with timezone support. |
| [Scheduling Pattern 4: Debounce and Throttle Execution](#scheduling-pattern-debounce-throttle) | 游리 **Intermediate** | Use debouncing and throttling to limit how often effects execute, preventing runaway operations and handling rapid event sequences. |
| [Scheduling Pattern 5: Advanced Retry Chains and Circuit Breakers](#scheduling-pattern-advanced-retry-chains) | 游 **Advanced** | Build sophisticated retry chains with circuit breakers, fallbacks, and complex failure patterns for production-grade reliability. |

## Domain Modeling
Model business domains with branded types and services

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Create Type-Safe Errors](#domain-modeling-tagged-errors) | 游릭 **Beginner** | Define domain-specific errors using Data.TaggedError for type-safe error handling. |
| [Handle Missing Values with Option](#domain-modeling-option-basics) | 游릭 **Beginner** | Use Option to explicitly model values that might not exist, avoiding null/undefined bugs. |
| [Your First Domain Model](#domain-modeling-hello-world) | 游릭 **Beginner** | Create a simple domain model using TypeScript interfaces and Effect to represent your business entities. |
| [Accumulate Multiple Errors with Either](#accumulate-multiple-errors-with-either) | 游리 **Intermediate** | Use Either<E, A> to represent computations that can fail, allowing you to accumulate multiple errors instead of short-circuiting on the first one. |
| [Avoid Long Chains of .andThen; Use Generators Instead](#avoid-long-andthen-chains) | 游리 **Intermediate** | Prefer Effect.gen over long chains of .andThen for sequential logic to improve readability and maintainability. |
| [Define Contracts Upfront with Schema](#define-contracts-with-schema) | 游리 **Intermediate** | Use Schema to define the types for your data models and function signatures before writing the implementation, creating clear, type-safe contracts. |
| [Define Type-Safe Errors with Data.TaggedError](#define-tagged-errors) | 游리 **Intermediate** | Create custom, type-safe error classes by extending Data.TaggedError to make error handling robust, predictable, and self-documenting. |
| [Distinguish 'Not Found' from Errors](#distinguish-not-found-from-errors) | 游리 **Intermediate** | Use Effect<Option<A>> to clearly distinguish between a recoverable 'not found' case (None) and a true failure (Fail). |
| [Model Optional Values Safely with Option](#model-optional-values-with-option) | 游리 **Intermediate** | Use Option<A> to explicitly represent a value that may or may not exist, eliminating null and undefined errors. |
| [Model Validated Domain Types with Brand](#model-validated-domain-types-with-brand) | 游리 **Intermediate** | Use Brand to turn primitive types like string or number into specific, validated domain types like Email or PositiveInt, making illegal states unrepresentable. |
| [Modeling Validated Domain Types with Brand](#brand-model-domain-type) | 游리 **Intermediate** | Use Brand to create domain-specific types from primitives, making illegal states unrepresentable and preventing accidental misuse. |
| [Parse and Validate Data with Schema.decode](#parse-with-schema-decode) | 游리 **Intermediate** | Use Schema.decode(schema) to create an Effect that parses and validates unknown data, which integrates seamlessly with Effect's error handling. |
| [Transform Data During Validation with Schema](#transform-data-with-schema) | 游리 **Intermediate** | Use Schema.transform to safely convert data from one type to another during the parsing phase, such as from a string to a Date. |
| [Use Effect.gen for Business Logic](#use-gen-for-business-logic) | 游리 **Intermediate** | Encapsulate sequential business logic, control flow, and dependency access within Effect.gen for improved readability and maintainability. |
| [Validating and Parsing Branded Types](#brand-validate-parse) | 游리 **Intermediate** | Use Schema and Brand together to validate and parse branded types at runtime, ensuring only valid values are constructed. |

### Create Type-Safe Errors {#domain-modeling-tagged-errors}
Define domain-specific errors using Data.TaggedError for type-safe error handling.

### Handle Missing Values with Option {#domain-modeling-option-basics}
Use Option to explicitly model values that might not exist, avoiding null/undefined bugs.

### Your First Domain Model {#domain-modeling-hello-world}
Create a simple domain model using TypeScript interfaces and Effect to represent your business entities.

### Accumulate Multiple Errors with Either {#accumulate-multiple-errors-with-either}
Use Either<E, A> to represent computations that can fail, allowing you to accumulate multiple errors instead of short-circuiting on the first one.

### Avoid Long Chains of .andThen; Use Generators Instead {#avoid-long-andthen-chains}
Prefer Effect.gen over long chains of .andThen for sequential logic to improve readability and maintainability.

### Define Contracts Upfront with Schema {#define-contracts-with-schema}
Use Schema to define the types for your data models and function signatures before writing the implementation, creating clear, type-safe contracts.

### Define Type-Safe Errors with Data.TaggedError {#define-tagged-errors}
Create custom, type-safe error classes by extending Data.TaggedError to make error handling robust, predictable, and self-documenting.

### Distinguish 'Not Found' from Errors {#distinguish-not-found-from-errors}
Use Effect<Option<A>> to clearly distinguish between a recoverable 'not found' case (None) and a true failure (Fail).

### Model Optional Values Safely with Option {#model-optional-values-with-option}
Use Option<A> to explicitly represent a value that may or may not exist, eliminating null and undefined errors.

### Model Validated Domain Types with Brand {#model-validated-domain-types-with-brand}
Use Brand to turn primitive types like string or number into specific, validated domain types like Email or PositiveInt, making illegal states unrepresentable.

### Modeling Validated Domain Types with Brand {#brand-model-domain-type}
Use Brand to create domain-specific types from primitives, making illegal states unrepresentable and preventing accidental misuse.

### Parse and Validate Data with Schema.decode {#parse-with-schema-decode}
Use Schema.decode(schema) to create an Effect that parses and validates unknown data, which integrates seamlessly with Effect's error handling.

### Transform Data During Validation with Schema {#transform-data-with-schema}
Use Schema.transform to safely convert data from one type to another during the parsing phase, such as from a string to a Date.

### Use Effect.gen for Business Logic {#use-gen-for-business-logic}
Encapsulate sequential business logic, control flow, and dependency access within Effect.gen for improved readability and maintainability.

### Validating and Parsing Branded Types {#brand-validate-parse}
Use Schema and Brand together to validate and parse branded types at runtime, ensuring only valid values are constructed.

## Building APIs
Build HTTP APIs and services

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Create a Basic HTTP Server](#launch-http-server) | 游릭 **Beginner** | Launch a simple, effect-native HTTP server to respond to incoming requests. |
| [Extract Path Parameters](#extract-path-parameters) | 游릭 **Beginner** | Capture and use dynamic segments from a request URL, such as a resource ID. |
| [Handle a GET Request](#handle-get-request) | 游릭 **Beginner** | Define a route that responds to a specific HTTP GET request path. |
| [Send a JSON Response](#send-json-response) | 游릭 **Beginner** | Create and send a structured JSON response with the correct headers and status code. |
| [Add Rate Limiting to APIs](#api-rate-limiting) | 游리 **Intermediate** | Protect your API from abuse by limiting request rates per client. |
| [Compose API Middleware](#api-middleware) | 游리 **Intermediate** | Build reusable middleware for logging, authentication, validation, and more. |
| [Configure CORS for APIs](#api-cors) | 游리 **Intermediate** | Enable Cross-Origin Resource Sharing to allow browser clients from different domains. |
| [Handle API Errors](#handle-api-errors) | 游리 **Intermediate** | Translate application-specific errors from the Effect failure channel into meaningful HTTP error responses. |
| [Implement API Authentication](#api-authentication) | 游리 **Intermediate** | Add JWT or session-based authentication to protect your API endpoints. |
| [Make an Outgoing HTTP Client Request](#make-http-client-request) | 游리 **Intermediate** | Use the built-in Effect HTTP client to make safe and composable requests to external services from within your API. |
| [Provide Dependencies to Routes](#provide-dependencies-to-routes) | 游리 **Intermediate** | Inject services like database connections into HTTP route handlers using Layer and Effect.Service. |
| [Validate Request Body](#validate-request-body) | 游리 **Intermediate** | Safely parse and validate an incoming JSON request body against a predefined Schema. |
| [Generate OpenAPI Documentation](#api-openapi) | 游 **Advanced** | Auto-generate OpenAPI/Swagger documentation from your Effect HTTP API definitions. |

## Building Data Pipelines
Process and transform data at scale

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Collect All Results into a List](#stream-collect-results) | 游릭 **Beginner** | Run a pipeline and gather all of its results into an in-memory array. |
| [Create a Stream from a List](#stream-from-iterable) | 游릭 **Beginner** | Turn a simple in-memory array or list into a foundational data pipeline using Stream. |
| [Run a Pipeline for its Side Effects](#stream-run-for-effects) | 游릭 **Beginner** | Execute a pipeline for its effects without collecting the results, saving memory. |
| [Automatically Retry Failed Operations](#stream-retry-on-failure) | 游리 **Intermediate** | Build a self-healing pipeline that can automatically retry failed processing steps using a configurable backoff strategy. |
| [Merge Multiple Streams](#pipeline-merge) | 游리 **Intermediate** | Combine data from multiple streams into a single unified stream. |
| [Process a Large File with Constant Memory](#stream-from-file) | 游리 **Intermediate** | Create a data pipeline from a file on disk, processing it line-by-line without loading the entire file into memory. |
| [Process collections of data asynchronously](#process-a-collection-of-data-asynchronously) | 游리 **Intermediate** | Process collections of data asynchronously in a lazy, composable, and resource-safe manner using Effect's Stream. |
| [Process Items Concurrently](#stream-process-concurrently) | 游리 **Intermediate** | Perform an asynchronous action for each item in a stream with controlled parallelism to dramatically improve performance. |
| [Process Items in Batches](#stream-process-in-batches) | 游리 **Intermediate** | Group items into chunks for efficient bulk operations, like database inserts or batch API calls. |
| [Turn a Paginated API into a Single Stream](#stream-from-paginated-api) | 游리 **Intermediate** | Convert a paginated API into a continuous, easy-to-use stream, abstracting away the complexity of fetching page by page. |
| [Fan Out to Multiple Consumers](#pipeline-fan-out) | 游 **Advanced** | Distribute stream data to multiple parallel consumers for processing. |
| [Implement Backpressure in Pipelines](#pipeline-backpressure) | 游 **Advanced** | Control data flow rates to prevent overwhelming slow consumers. |
| [Implement Dead Letter Queues](#pipeline-dead-letter-queue) | 游 **Advanced** | Route failed items to a separate queue for later analysis and reprocessing. |
| [Manage Resources Safely in a Pipeline](#stream-manage-resources) | 游 **Advanced** | Ensure resources like file handles or connections are safely acquired at the start of a pipeline and always released at the end, even on failure. |

## Making HTTP Requests
HTTP client patterns with Effect

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Parse JSON Responses Safely](#http-json-responses) | 游릭 **Beginner** | Use Effect Schema to validate and parse HTTP JSON responses with type safety. |
| [Your First HTTP Request](#http-hello-world) | 游릭 **Beginner** | Learn how to make HTTP requests using Effect's HttpClient with proper error handling. |
| [Add Timeouts to HTTP Requests](#http-timeouts) | 游리 **Intermediate** | Set timeouts on HTTP requests to prevent hanging operations. |
| [Cache HTTP Responses](#http-caching) | 游리 **Intermediate** | Implement response caching to reduce API calls and improve performance. |
| [Create a Testable HTTP Client Service](#create-a-testable-http-client-service) | 游리 **Intermediate** | Define an HttpClient service with separate 'Live' and 'Test' layers to enable robust, testable interactions with external APIs. |
| [Handle Rate Limiting Responses](#http-rate-limit-handling) | 游리 **Intermediate** | Gracefully handle 429 responses and respect API rate limits. |
| [Log HTTP Requests and Responses](#http-logging) | 游리 **Intermediate** | Add request/response logging for debugging and observability. |
| [Model Dependencies as Services](#model-dependencies-as-services) | 游리 **Intermediate** | Abstract external dependencies and capabilities into swappable, testable services using Effect's dependency injection system. |
| [Retry HTTP Requests with Backoff](#http-retries) | 游리 **Intermediate** | Implement robust retry logic for HTTP requests with exponential backoff. |
| [Build a Basic HTTP Server](#build-a-basic-http-server) | 游 **Advanced** | Combine Layer, Runtime, and Effect to create a simple, robust HTTP server using Node.js's built-in http module. |

## Testing
Test Effect applications

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Test Effects with Services](#testing-with-services) | 游릭 **Beginner** | Learn how to test Effect programs that depend on services by providing test implementations. |
| [Your First Effect Test](#testing-hello-world) | 游릭 **Beginner** | Write your first test for an Effect program using Vitest and Effect's testing utilities. |
| [Accessing the Current Time with Clock](#accessing-current-time-with-clock) | 游리 **Intermediate** | Use the Clock service to access the current time in a testable, deterministic way, avoiding direct calls to Date.now(). |
| [Mocking Dependencies in Tests](#mocking-dependencies-in-tests) | 游리 **Intermediate** | Use a test-specific Layer to provide mock implementations of services your code depends on, enabling isolated and deterministic unit tests. |
| [Use the Auto-Generated .Default Layer in Tests](#use-default-layer-for-tests) | 游리 **Intermediate** | When testing, always use the MyService.Default layer that is automatically generated by the Effect.Service class for dependency injection. |
| [Write Tests That Adapt to Application Code](#write-tests-that-adapt-to-application-code) | 游리 **Intermediate** | A cardinal rule of testing: Tests must adapt to the application's interface, not the other way around. Never modify application code solely to make a test pass. |
| [Organize Layers into Composable Modules](#organize-layers-into-composable-modules) | 游 **Advanced** | Structure a large application by grouping related services into 'module' layers, which are then composed together with a shared base layer. |
| [Property-Based Testing with Effect](#testing-property-based) | 游 **Advanced** | Use fast-check with Effect for property-based testing of pure functions and effects. |
| [Test Concurrent Code](#testing-concurrent-code) | 游 **Advanced** | Test race conditions, parallelism, and concurrent behavior in Effect programs. |
| [Test Streaming Effects](#testing-streams) | 游 **Advanced** | Write tests for Stream operations, transformations, and error handling. |

## Observability
Logging, tracing, and metrics

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Debug Effect Programs](#observability-debugging) | 游릭 **Beginner** | Learn techniques for debugging Effect programs using logging, tap, and cause inspection. |
| [Your First Logs](#observability-hello-world) | 游릭 **Beginner** | Learn the basics of logging in Effect using the built-in structured logging system. |
| [Add Custom Metrics to Your Application](#add-custom-metrics) | 游리 **Intermediate** | Use Effect's Metric module to instrument your code with counters, gauges, and histograms to track key business and performance indicators. |
| [Add Custom Metrics to Your Application](#observability-custom-metrics) | 游리 **Intermediate** | Use Effect's Metric module to instrument your code with counters, gauges, and histograms to track key business and performance indicators. |
| [Instrument and Observe Function Calls with Effect.fn](#observability-effect-fn) | 游리 **Intermediate** | Use Effect.fn to wrap, instrument, and observe function calls, enabling composable logging, metrics, and tracing at function boundaries. |
| [Leverage Effect's Built-in Structured Logging](#observability-structured-logging) | 游리 **Intermediate** | Use Effect's built-in logging functions for structured, configurable, and context-aware logging. |
| [Trace Operations Across Services with Spans](#observability-tracing-spans) | 游리 **Intermediate** | Use Effect.withSpan to create custom tracing spans, providing detailed visibility into the performance and flow of your application's operations. |
| [Trace Operations Across Services with Spans](#trace-operations-with-spans) | 游리 **Intermediate** | Use Effect.withSpan to create custom tracing spans, providing detailed visibility into the performance and flow of your application's operations. |
| [Create Observability Dashboards](#observability-dashboards) | 游 **Advanced** | Design effective dashboards to visualize your Effect application metrics. |
| [Export Metrics to Prometheus](#observability-prometheus) | 游 **Advanced** | Expose application metrics in Prometheus format for monitoring and alerting. |
| [Implement Distributed Tracing](#observability-distributed-tracing) | 游 **Advanced** | Set up end-to-end distributed tracing across services with trace context propagation. |
| [Integrate Effect Tracing with OpenTelemetry](#observability-opentelemetry) | 游 **Advanced** | Connect Effect's tracing spans to OpenTelemetry for end-to-end distributed tracing and visualization. |
| [Set Up Alerting](#observability-alerting) | 游 **Advanced** | Configure alerts to notify you when your Effect application has problems. |

## Tooling and Debugging
Debug and profile Effect applications

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| [Read Effect Type Errors](#tooling-type-errors) | 游릭 **Beginner** | Learn how to read and understand Effect's TypeScript error messages. |
| [Set Up Your Effect Development Environment](#tooling-hello-world) | 游릭 **Beginner** | Configure your editor and tools for the best Effect development experience. |
| [Configure Linting for Effect](#tooling-linting) | 游리 **Intermediate** | Set up Biome or ESLint with Effect-specific rules for code quality. |
| [Set Up CI/CD for Effect Projects](#tooling-ci-cd) | 游리 **Intermediate** | Configure GitHub Actions to build, test, and deploy Effect applications. |
| [Supercharge Your Editor with the Effect LSP](#supercharge-your-editor-with-the-effect-lsp) | 游리 **Intermediate** | Install the Effect Language Server (LSP) extension for your editor to get rich, inline type information and enhanced error checking for your Effect code. |
| [Use Effect DevTools](#tooling-devtools) | 游리 **Intermediate** | Debug Effect applications with specialized developer tools. |
| [Profile Effect Applications](#tooling-profiling) | 游 **Advanced** | Measure and optimize performance of Effect applications. |
| [Teach your AI Agents Effect with the MCP Server](#teach-your-ai-agents-effect-with-the-mcp-server) | 游 **Advanced** | Use the Effect MCP server to provide live, contextual information about your application's structure directly to AI coding agents. |

