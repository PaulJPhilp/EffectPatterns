<!--
  丘멆잺 AUTO-GENERATED FILE - DO NOT EDIT MANUALLY

  This file is automatically generated by the publishing pipeline.
  Any manual edits will be overwritten when the pipeline runs.

  To modify this file:
  - Run: bun run pipeline
  - Or edit: scripts/publish/generate.ts

  For project information, see ABOUT.md
-->

> [!WARNING]
> **This is an auto-generated file.** Manual edits will be overwritten by the publishing pipeline.
> For project information, see [ABOUT.md](./ABOUT.md)

# The Effect Patterns Hub

A community-driven knowledge base of practical, goal-oriented patterns for building robust applications with Effect-TS.

This repository is designed to be a living document that helps developers move from core concepts to advanced architectural strategies by focusing on the "why" behind the code.

**Looking for machine-readable rules for AI IDEs and coding agents? See the AI Coding Rules section below.**

## Table of Contents

### Effect Patterns

- Getting Started
- Core Concepts
- Error Management
- Resource Management
- Concurrency
- Streams
- Platform
- Scheduling
- Domain Modeling
- Building APIs
- Building Data Pipelines
- Making HTTP Requests
- Testing
- Observability
- Tooling and Debugging



---

## Getting Started
First steps with Effect - hello world, basic concepts

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Why Effect? Comparing Effect to Promise | 游릭 **Beginner** | Understand what Effect gives you that Promise doesn't: type-safe errors, dependency injection, and composability. |
| Hello World: Your First Effect | 游릭 **Beginner** | Create and run your very first Effect program using Effect.succeed and Effect.runSync. |
| Transform Values with Effect.map | 游릭 **Beginner** | Use Effect.map to transform the success value of an Effect without changing its error or dependency types. |
| Handle Your First Error with Effect.fail and catchAll | 游릭 **Beginner** | Learn how to create Effects that can fail and how to recover from those failures using Effect.fail and Effect.catchAll. |
| Run Multiple Effects in Parallel with Effect.all | 游릭 **Beginner** | Use Effect.all to run multiple Effects at the same time and collect all their results. |
| Retry a Failed Operation with Effect.retry | 游릭 **Beginner** | Use Effect.retry with a Schedule to automatically retry failed operations with customizable delays and limits. |

## Core Concepts
Fundamental Effect patterns - generators, pipes, dependencies

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Accumulate Multiple Errors with Either | 游릭 **Beginner** | Use Either<E, A> to represent computations that can fail, allowing you to accumulate multiple errors instead of short-circuiting on the first one. |
| Chaining Computations with flatMap | 游릭 **Beginner** | Use flatMap to chain together computations where each step may itself be effectful, optional, or error-prone. |
| Combining Values with zip | 游릭 **Beginner** | Use zip to combine two computations, pairing their results together in Effect, Stream, Option, or Either. |
| Comparing Data by Value with Data.struct | 游릭 **Beginner** | Use Data.struct to create immutable, structurally-typed objects that can be compared by value, not by reference. |
| Comparing Data by Value with Structural Equality | 游릭 **Beginner** | Use Data.struct and Equal.equals to safely compare objects by their value instead of their reference, avoiding common JavaScript pitfalls. |
| Conditional Branching with if, when, and cond | 游릭 **Beginner** | Use combinators like if, when, and cond to express conditional logic declaratively across Effect, Stream, Option, and Either. |
| Converting from Nullable, Option, or Either | 游릭 **Beginner** | Use fromNullable, fromOption, and fromEither to convert nullable values, Option, or Either into Effects or Streams, enabling safe and composable interop. |
| Create Pre-resolved Effects with succeed and fail | 游릭 **Beginner** | Use Effect.succeed(value) to create an Effect that immediately succeeds with a value, and Effect.fail(error) for an Effect that immediately fails. |
| Creating from Collections | 游릭 **Beginner** | Use fromIterable and fromArray to create Streams or Effects from arrays, iterables, or other collections, enabling batch and streaming operations. |
| Creating from Synchronous and Callback Code | 游릭 **Beginner** | Use sync and async to lift synchronous or callback-based computations into Effect, enabling safe and composable interop with legacy code. |
| Filtering Results with filter | 游릭 **Beginner** | Use filter to keep or discard results based on a predicate, across Effect, Stream, Option, and Either. |
| Lifting Errors and Absence with fail, none, and left | 游릭 **Beginner** | Use fail, none, and left to represent errors or absence in Effect, Option, or Either, making failures explicit and type-safe. |
| Lifting Values with succeed, some, and right | 游릭 **Beginner** | Use succeed, some, and right to lift plain values into Effect, Option, or Either, making them composable and type-safe. |
| Model Optional Values Safely with Option | 游릭 **Beginner** | Use Option<A> to explicitly represent a value that may or may not exist, eliminating null and undefined errors. |
| Solve Promise Problems with Effect | 游릭 **Beginner** | Understand how Effect solves the fundamental problems of native Promises, such as untyped errors, lack of dependency injection, and no built-in cancellation. |
| Transform Effect Values with map and flatMap | 游릭 **Beginner** | Use Effect.map for synchronous transformations and Effect.flatMap to chain operations that return another Effect. |
| Transforming Values with map | 游릭 **Beginner** | Use map to transform the result of an Effect, Stream, Option, or Either in a declarative, type-safe way. |
| Understand that Effects are Lazy Blueprints | 游릭 **Beginner** | An Effect is a lazy, immutable blueprint describing a computation, which does nothing until it is explicitly executed by a runtime. |
| Understand the Three Effect Channels (A, E, R) | 游릭 **Beginner** | Learn about the three generic parameters of an Effect: the success value (A), the failure error (E), and the context requirements (R). |
| Use .pipe for Composition | 游릭 **Beginner** | Use the .pipe() method to chain multiple operations onto an Effect in a readable, top-to-bottom sequence. |
| Working with Immutable Arrays using Data.array | 游릭 **Beginner** | Use Data.array to create immutable, type-safe arrays that support value-based equality and safe functional operations. |
| Working with Tuples using Data.tuple | 游릭 **Beginner** | Use Data.tuple to create immutable, type-safe tuples that support value-based equality and pattern matching. |
| Wrap Asynchronous Computations with tryPromise | 游릭 **Beginner** | Use Effect.tryPromise to safely convert a function that returns a Promise into an Effect, capturing rejections in the error channel. |
| Wrap Synchronous Computations with sync and try | 游릭 **Beginner** | Use Effect.sync for non-throwing synchronous code and Effect.try for synchronous code that might throw an exception. |
| Wrapping Synchronous and Asynchronous Computations | 游릭 **Beginner** | Use try and tryPromise to safely wrap synchronous or asynchronous computations that may throw or reject, capturing errors in the Effect world. |
| Write Sequential Code with Effect.gen | 游릭 **Beginner** | Use Effect.gen with yield* to write sequential, asynchronous code in a style that looks and feels like familiar async/await. |
| Access Configuration from the Context | 游리 **Intermediate** | Access your type-safe configuration within an Effect.gen block by yielding the Config object you defined. |
| Beyond the Date Type - Real World Dates, Times, and Timezones | 游리 **Intermediate** | Use the Clock service for testable access to the current time and prefer immutable primitives for storing and passing timestamps. |
| Control Flow with Conditional Combinators | 游리 **Intermediate** | Use combinators like Effect.if, Effect.when, and Effect.cond to handle conditional logic in a declarative, composable way. |
| Define a Type-Safe Configuration Schema | 游리 **Intermediate** | Use Effect.Config primitives to define a schema for your application's configuration, ensuring type-safety and separation from code. |
| Handling Errors with catchAll, orElse, and match | 游리 **Intermediate** | Use catchAll, orElse, and match to recover from errors, provide fallbacks, or transform errors in Effect, Either, and Option. |
| Manage Shared State Safely with Ref | 游리 **Intermediate** | Use Ref<A> to model shared, mutable state in a concurrent environment, ensuring all updates are atomic and free of race conditions. |
| Mapping and Chaining over Collections with forEach and all | 游리 **Intermediate** | Use forEach and all to apply effectful functions to collections and combine the results, enabling batch and parallel processing. |
| Modeling Effect Results with Exit | 游리 **Intermediate** | Use Exit<E, A> to represent the result of running an Effect, capturing both success and failure (including defects) in a type-safe way. |
| Modeling Tagged Unions with Data.case | 游리 **Intermediate** | Use Data.case to create tagged unions (algebraic data types) for robust, type-safe domain modeling and pattern matching. |
| Process Streaming Data with Stream | 游리 **Intermediate** | Use Stream<A, E, R> to represent and process data that arrives over time, such as file reads, WebSocket messages, or paginated API results. |
| Provide Configuration to Your App via a Layer | 游리 **Intermediate** | Use Config.layer(schema) to create a Layer that provides your configuration schema to the application's context. |
| Redact and Handle Sensitive Data | 游리 **Intermediate** | Use Redacted to securely handle sensitive data, ensuring secrets are not accidentally logged or exposed. |
| Representing Time Spans with Duration | 游리 **Intermediate** | Use Duration to represent time intervals in a type-safe, human-readable, and composable way. |
| Representing Time Spans with Duration | 游리 **Intermediate** | Use the Duration data type to represent time intervals in a type-safe, human-readable, and composable way. |
| Sequencing with andThen, tap, and flatten | 游리 **Intermediate** | Use andThen, tap, and flatten to sequence computations, run side effects, and flatten nested structures in Effect, Stream, Option, and Either. |
| Type Classes for Equality, Ordering, and Hashing with Data.Class | 游리 **Intermediate** | Use Data.Class to derive and implement type classes for equality, ordering, and hashing, enabling composable and type-safe abstractions. |
| Understand Layers for Dependency Injection | 游리 **Intermediate** | A Layer is a blueprint that describes how to build a service, detailing its own requirements and any potential errors during its construction. |
| Use Chunk for High-Performance Collections | 游리 **Intermediate** | Use Chunk<A> as a high-performance, immutable alternative to JavaScript's Array, especially for data processing pipelines. |
| Use Chunk for High-Performance Collections | 游리 **Intermediate** | Use Chunk<A> as a high-performance, immutable alternative to JavaScript's Array, especially for data processing pipelines. |
| Work with Arbitrary-Precision Numbers using BigDecimal | 游리 **Intermediate** | Use BigDecimal for arbitrary-precision decimal arithmetic, avoiding rounding errors and loss of precision in financial or scientific calculations. |
| Work with Dates and Times using DateTime | 游리 **Intermediate** | Use DateTime for immutable, time-zone-aware date and time values, enabling safe and precise time calculations. |
| Work with Immutable Sets using HashSet | 游리 **Intermediate** | Use HashSet<A> to model immutable, high-performance sets for efficient membership checks and set operations. |
| Handle Unexpected Errors by Inspecting the Cause | 游 **Advanced** | Use Cause<E> to get rich, structured information about errors and failures, including defects, interruptions, and error traces. |

## Error Management
Handle errors, create typed errors, recovery strategies

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Checking Option and Either Cases | 游릭 **Beginner** | Use isSome, isNone, isLeft, and isRight to check Option and Either cases for simple, type-safe branching. |
| Matching on Success and Failure with match | 游릭 **Beginner** | Use match to handle both success and failure cases in a single, declarative place for Effect, Option, and Either. |
| Pattern Match on Option and Either | 游릭 **Beginner** | Use declarative match() combinators to handle optional and error-prone values |
| Your First Error Handler | 游릭 **Beginner** | Learn the basics of handling errors in Effect with catchAll and catchTag. |
| Conditionally Branching Workflows | 游리 **Intermediate** | Use predicate-based operators like Effect.filter and Effect.if to make decisions and control the flow of your application based on runtime values. |
| Control Repetition with Schedule | 游리 **Intermediate** | Use Schedule to create composable, stateful policies that define precisely how an effect should be repeated or retried. |
| Effectful Pattern Matching with matchEffect | 游리 **Intermediate** | Use matchEffect to perform effectful branching based on success or failure, enabling rich workflows in the Effect world. |
| Handle Errors with catchTag, catchTags, and catchAll | 游리 **Intermediate** | Use catchTag for type-safe recovery from specific tagged errors, and catchAll to recover from any possible failure. |
| Handle Flaky Operations with Retries and Timeouts | 游리 **Intermediate** | Use Effect.retry and Effect.timeout to build resilience against slow or intermittently failing operations, such as network requests. |
| Handling Specific Errors with catchTag and catchTags | 游리 **Intermediate** | Use catchTag and catchTags to recover from or handle specific error types in the Effect failure channel, enabling precise and type-safe error recovery. |
| Leverage Effect's Built-in Structured Logging | 游리 **Intermediate** | Use Effect's built-in logging functions (Effect.log, Effect.logInfo, etc.) for structured, configurable, and context-aware logging. |
| Mapping Errors to Fit Your Domain | 游리 **Intermediate** | Use Effect.mapError to transform specific, low-level errors into more general domain errors, creating clean architectural boundaries. |
| Matching Tagged Unions with matchTag and matchTags | 游리 **Intermediate** | Use matchTag and matchTags to pattern match on specific tagged union cases, enabling precise and type-safe branching. |
| Retry Operations Based on Specific Errors | 游리 **Intermediate** | Use Effect.retry and predicate functions to selectively retry an operation only when specific, recoverable errors occur. |
| Handle Unexpected Errors by Inspecting the Cause | 游 **Advanced** | Use Effect.catchAllCause or Effect.runFork to inspect the Cause of a failure, distinguishing between expected errors (Fail) and unexpected defects (Die). |

## Resource Management
Acquire and release resources safely with Scope

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Safely Bracket Resource Usage with `acquireRelease` | 游릭 **Beginner** | Use `Effect.acquireRelease` to guarantee a resource's cleanup logic runs, even if errors or interruptions occur. |
| Compose Resource Lifecycles with `Layer.merge` | 游리 **Intermediate** | Combine multiple resource-managing layers, letting Effect automatically handle the acquisition and release order. |
| Create a Service Layer from a Managed Resource | 游리 **Intermediate** | Use `Layer.scoped` with `Effect.Service` to transform a managed resource into a shareable, application-wide service. |
| Handle Resource Timeouts | 游리 **Intermediate** | Set timeouts on resource acquisition and usage to prevent hanging operations. |
| Pool Resources for Reuse | 游리 **Intermediate** | Create and manage a pool of reusable resources like database connections or workers. |
| Create a Managed Runtime for Scoped Resources | 游 **Advanced** | Use Layer.launch to safely manage the lifecycle of layers containing scoped resources, ensuring finalizers are always run. |
| Manage Hierarchical Resources | 游 **Advanced** | Manage parent-child resource relationships where children must be released before parents. |
| Manually Manage Lifecycles with `Scope` | 游 **Advanced** | Use `Scope` directly to manage complex resource lifecycles or when building custom layers. |

## Concurrency
Run effects in parallel, manage fibers, coordinate async work

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Race Effects and Handle Timeouts | 游릭 **Beginner** | Race multiple effects to get the fastest result, or add timeouts to prevent hanging operations. |
| Understanding Fibers | 游릭 **Beginner** | Learn what fibers are, how they differ from threads, and why they make Effect powerful for concurrent programming. |
| Your First Parallel Operation | 游릭 **Beginner** | Run multiple effects in parallel with Effect.all and understand when to use parallel vs sequential execution. |
| Concurrency Pattern 1: Coordinate Async Operations with Deferred | 游리 **Intermediate** | Use Deferred to coordinate async operations where multiple fibers wait for a single event to complete, enabling producer-consumer patterns and async signaling without polling. |
| Concurrency Pattern 2: Rate Limit Concurrent Access with Semaphore | 游리 **Intermediate** | Use Semaphore to limit the number of concurrent operations, enabling connection pooling, API rate limiting, and controlled resource access without overload. |
| Concurrency Pattern 3: Coordinate Multiple Fibers with Latch | 游리 **Intermediate** | Use Latch to synchronize multiple fibers, enabling patterns like coordinating N async tasks, fan-out/fan-in, and barrier synchronization. |
| Concurrency Pattern 4: Distribute Work with Queue | 游리 **Intermediate** | Use Queue to decouple producers and consumers, enabling work distribution, pipeline stages, and backpressure handling across concurrent fibers. |
| Concurrency Pattern 5: Broadcast Events with PubSub | 游리 **Intermediate** | Use PubSub to broadcast events to multiple subscribers, enabling event-driven architectures and fan-out patterns without direct coupling. |
| Concurrency Pattern 6: Race and Timeout Competing Effects | 游리 **Intermediate** | Use race and timeout to compete multiple effects and enforce deadlines, enabling timeout handling and choosing fastest result. |
| Manage Shared State Safely with Ref | 游리 **Intermediate** | Use Ref<A> to model shared, mutable state in a concurrent environment, ensuring all updates are atomic and free of race conditions. |
| Process a Collection in Parallel with Effect.forEach | 游리 **Intermediate** | Use Effect.forEach with the `concurrency` option to process a collection of items in parallel with a fixed limit, preventing resource exhaustion. |
| Race Concurrent Effects for the Fastest Result | 游리 **Intermediate** | Use Effect.race to run multiple effects concurrently and proceed with the result of the one that succeeds first, automatically interrupting the others. |
| Run Independent Effects in Parallel with Effect.all | 游리 **Intermediate** | Use Effect.all to run multiple independent effects concurrently and collect all their results into a single tuple. |
| Add Caching by Wrapping a Layer | 游 **Advanced** | Implement caching by creating a new layer that wraps a live service, intercepting method calls to add caching logic without modifying the original service. |
| Decouple Fibers with Queues and PubSub | 游 **Advanced** | Use Queue for point-to-point work distribution and PubSub for broadcast messaging to enable safe, decoupled communication between concurrent fibers. |
| Execute Long-Running Apps with Effect.runFork | 游 **Advanced** | Use Effect.runFork at the application's entry point to launch a long-running process as a detached fiber, allowing for graceful shutdown. |
| Implement Graceful Shutdown for Your Application | 游 **Advanced** | Use Effect.runFork and listen for OS signals (SIGINT, SIGTERM) to trigger a Fiber.interrupt, ensuring all resources are safely released. |
| Manage Resource Lifecycles with Scope | 游 **Advanced** | Use Scope for fine-grained, manual control over resource lifecycles, ensuring cleanup logic (finalizers) is always executed. |
| Poll for Status Until a Task Completes | 游 **Advanced** | Use Effect.race to run a repeating polling effect alongside a main task, automatically stopping the polling when the main task finishes. |
| Run Background Tasks with Effect.fork | 游 **Advanced** | Use Effect.fork to start a computation in a background fiber, allowing the parent fiber to continue its work without waiting. |
| State Management Pattern 1: Synchronized Reference with SynchronizedRef | 游 **Advanced** | Use SynchronizedRef to safely share mutable state across concurrent fibers, with atomic updates and guaranteed consistency. |
| State Management Pattern 2: Observable State with SubscriptionRef | 游 **Advanced** | Build observable state that notifies subscribers on changes, enabling reactive patterns and state-driven architecture. |
| Understand Fibers as Lightweight Threads | 游 **Advanced** | A Fiber is a lightweight, virtual thread managed by the Effect runtime, enabling massive concurrency on a single OS thread without the overhead of traditional threading. |

## Streams
Process sequences of data with Stream

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Running and Collecting Stream Results | 游릭 **Beginner** | Learn the different ways to run a stream and collect its results: runCollect, runForEach, runDrain, and more. |
| Stream Pattern 1: Transform Streams with Map and Filter | 游릭 **Beginner** | Use Stream.map and Stream.filter to transform and select stream elements, enabling data pipelines that reshape and filter data in flight. |
| Stream vs Effect - When to Use Which | 游릭 **Beginner** | Understand when to use Effect (single value) vs Stream (sequence of values) for your use case. |
| Take and Drop Stream Elements | 游릭 **Beginner** | Control how many stream elements to process using take, drop, takeWhile, and dropWhile. |
| Your First Stream | 游릭 **Beginner** | Create your first Effect Stream and understand what makes streams different from regular arrays. |
| Sink Pattern 1: Batch Insert Stream Records into Database | 游리 **Intermediate** | Use Sink to batch stream records and insert them efficiently into a database in groups, rather than one-by-one, for better performance and resource usage. |
| Sink Pattern 2: Write Stream Events to Event Log | 游리 **Intermediate** | Use Sink to append stream events to an event log with metadata and causal ordering, enabling event sourcing and audit trail patterns. |
| Sink Pattern 3: Write Stream Lines to File | 游리 **Intermediate** | Use Sink to write stream data as lines to a file with buffering for efficiency, supporting log files and line-oriented formats. |
| Sink Pattern 4: Send Stream Records to Message Queue | 游리 **Intermediate** | Use Sink to publish stream records to a message queue with partitioning, batching, and acknowledgment handling for distributed systems. |
| Sink Pattern 5: Fall Back to Alternative Sink on Failure | 游리 **Intermediate** | Use Sink to attempt writing to a primary destination, and automatically fall back to an alternative destination if the primary fails, enabling progressive degradation and high availability. |
| Sink Pattern 6: Retry Failed Stream Operations | 游리 **Intermediate** | Use Sink with configurable retry policies to automatically retry failed operations with exponential backoff, enabling recovery from transient failures without losing data. |
| Stream Pattern 2: Merge and Combine Multiple Streams | 游리 **Intermediate** | Use Stream.merge, Stream.concat, and Stream.mergeAll to combine multiple streams into a single stream, enabling multi-source data aggregation. |
| Stream Pattern 3: Control Backpressure in Streams | 游리 **Intermediate** | Use Stream throttling, buffering, and chunk operations to manage backpressure, preventing upstream from overwhelming downstream consumers. |
| Stream Pattern 4: Stateful Operations with Scan and Fold | 游리 **Intermediate** | Use Stream.scan and Stream.fold to maintain state across stream elements, enabling cumulative operations, counters, aggregations, and stateful transformations. |
| Stream Pattern 5: Grouping and Windowing Streams | 游 **Advanced** | Use grouping and windowing to organize streams by key or time window, enabling batch operations and temporal aggregations. |
| Stream Pattern 6: Resource Management in Streams | 游 **Advanced** | Properly manage resources (connections, files, memory) in streams using acquire/release patterns and ensuring cleanup on error or completion. |
| Stream Pattern 7: Error Handling in Streams | 游 **Advanced** | Handle errors gracefully in streams with recovery strategies, resuming after failures, and maintaining stream integrity. |
| Stream Pattern 8: Advanced Stream Transformations | 游 **Advanced** | Apply complex transformations across streams including custom operators, effect-based transformations, and composition patterns. |

## Platform
System operations - files, commands, environment

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Access Environment Variables | 游릭 **Beginner** | Read environment variables safely with Effect Platform, handling missing values gracefully. |
| Platform Pattern 2: Filesystem Operations | 游릭 **Beginner** | Use FileSystem module to read, write, list, and manage files with proper resource cleanup and error handling. |
| Platform Pattern 4: Interactive Terminal I/O | 游릭 **Beginner** | Use Terminal module to read user input and write formatted output, enabling interactive CLI applications with proper buffering and encoding. |
| Your First Platform Operation | 游릭 **Beginner** | Get started with Effect Platform by reading a file and understanding how Platform differs from Node.js APIs. |
| Platform Pattern 1: Execute Shell Commands | 游리 **Intermediate** | Use Command module to execute shell commands, capture output, and handle exit codes, enabling integration with system tools and external programs. |
| Platform Pattern 3: Persistent Key-Value Storage | 游리 **Intermediate** | Use KeyValueStore for simple persistent key-value storage, enabling caching, session management, and lightweight data persistence. |
| Platform Pattern 5: Cross-Platform Path Manipulation | 游리 **Intermediate** | Use platform-aware path operations to handle file system paths correctly across Windows, macOS, and Linux with proper resolution and normalization. |
| Platform Pattern 6: Advanced FileSystem Operations | 游 **Advanced** | Handle complex file system scenarios including watching files, recursive operations, atomic writes, and efficient bulk operations. |

## Scheduling
Schedule and repeat effects with Schedule

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Retry Failed Operations | 游릭 **Beginner** | Use Effect.retry with Schedule to automatically retry operations that fail. |
| Your First Schedule | 游릭 **Beginner** | Learn the basics of scheduling in Effect - retry operations and repeat them on intervals. |
| Scheduling Pattern 1: Repeat an Effect on a Fixed Interval | 游리 **Intermediate** | Use Schedule.fixed to repeat an effect at regular intervals, enabling polling, health checks, and periodic background tasks without busy-waiting or manual timing logic. |
| Scheduling Pattern 3: Schedule Tasks with Cron Expressions | 游리 **Intermediate** | Use cron expressions to schedule tasks at specific times and intervals, enabling calendar-based scheduling with timezone support. |
| Scheduling Pattern 4: Debounce and Throttle Execution | 游리 **Intermediate** | Use debouncing and throttling to limit how often effects execute, preventing runaway operations and handling rapid event sequences. |
| Scheduling Pattern 5: Advanced Retry Chains and Circuit Breakers | 游 **Advanced** | Build sophisticated retry chains with circuit breakers, fallbacks, and complex failure patterns for production-grade reliability. |

## Domain Modeling
Model business domains with branded types and services

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Create Type-Safe Errors | 游릭 **Beginner** | Define domain-specific errors using Data.TaggedError for type-safe error handling. |
| Handle Missing Values with Option | 游릭 **Beginner** | Use Option to explicitly model values that might not exist, avoiding null/undefined bugs. |
| Your First Domain Model | 游릭 **Beginner** | Create a simple domain model using TypeScript interfaces and Effect to represent your business entities. |
| Accumulate Multiple Errors with Either | 游리 **Intermediate** | Use Either<E, A> to represent computations that can fail, allowing you to accumulate multiple errors instead of short-circuiting on the first one. |
| Avoid Long Chains of .andThen; Use Generators Instead | 游리 **Intermediate** | Prefer Effect.gen over long chains of .andThen for sequential logic to improve readability and maintainability. |
| Define Contracts Upfront with Schema | 游리 **Intermediate** | Use Schema to define the types for your data models and function signatures before writing the implementation, creating clear, type-safe contracts. |
| Define Type-Safe Errors with Data.TaggedError | 游리 **Intermediate** | Create custom, type-safe error classes by extending Data.TaggedError to make error handling robust, predictable, and self-documenting. |
| Distinguish 'Not Found' from Errors | 游리 **Intermediate** | Use Effect<Option<A>> to clearly distinguish between a recoverable 'not found' case (None) and a true failure (Fail). |
| Model Optional Values Safely with Option | 游리 **Intermediate** | Use Option<A> to explicitly represent a value that may or may not exist, eliminating null and undefined errors. |
| Model Validated Domain Types with Brand | 游리 **Intermediate** | Use Brand to turn primitive types like string or number into specific, validated domain types like Email or PositiveInt, making illegal states unrepresentable. |
| Modeling Validated Domain Types with Brand | 游리 **Intermediate** | Use Brand to create domain-specific types from primitives, making illegal states unrepresentable and preventing accidental misuse. |
| Parse and Validate Data with Schema.decode | 游리 **Intermediate** | Use Schema.decode(schema) to create an Effect that parses and validates unknown data, which integrates seamlessly with Effect's error handling. |
| Transform Data During Validation with Schema | 游리 **Intermediate** | Use Schema.transform to safely convert data from one type to another during the parsing phase, such as from a string to a Date. |
| Use Effect.gen for Business Logic | 游리 **Intermediate** | Encapsulate sequential business logic, control flow, and dependency access within Effect.gen for improved readability and maintainability. |
| Validating and Parsing Branded Types | 游리 **Intermediate** | Use Schema and Brand together to validate and parse branded types at runtime, ensuring only valid values are constructed. |

## Building APIs
Build HTTP APIs and services

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Create a Basic HTTP Server | 游릭 **Beginner** | Launch a simple, effect-native HTTP server to respond to incoming requests. |
| Extract Path Parameters | 游릭 **Beginner** | Capture and use dynamic segments from a request URL, such as a resource ID. |
| Handle a GET Request | 游릭 **Beginner** | Define a route that responds to a specific HTTP GET request path. |
| Send a JSON Response | 游릭 **Beginner** | Create and send a structured JSON response with the correct headers and status code. |
| Add Rate Limiting to APIs | 游리 **Intermediate** | Protect your API from abuse by limiting request rates per client. |
| Compose API Middleware | 游리 **Intermediate** | Build reusable middleware for logging, authentication, validation, and more. |
| Configure CORS for APIs | 游리 **Intermediate** | Enable Cross-Origin Resource Sharing to allow browser clients from different domains. |
| Handle API Errors | 游리 **Intermediate** | Translate application-specific errors from the Effect failure channel into meaningful HTTP error responses. |
| Implement API Authentication | 游리 **Intermediate** | Add JWT or session-based authentication to protect your API endpoints. |
| Make an Outgoing HTTP Client Request | 游리 **Intermediate** | Use the built-in Effect HTTP client to make safe and composable requests to external services from within your API. |
| Provide Dependencies to Routes | 游리 **Intermediate** | Inject services like database connections into HTTP route handlers using Layer and Effect.Service. |
| Validate Request Body | 游리 **Intermediate** | Safely parse and validate an incoming JSON request body against a predefined Schema. |
| Generate OpenAPI Documentation | 游 **Advanced** | Auto-generate OpenAPI/Swagger documentation from your Effect HTTP API definitions. |

## Building Data Pipelines
Process and transform data at scale

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Collect All Results into a List | 游릭 **Beginner** | Run a pipeline and gather all of its results into an in-memory array. |
| Create a Stream from a List | 游릭 **Beginner** | Turn a simple in-memory array or list into a foundational data pipeline using Stream. |
| Run a Pipeline for its Side Effects | 游릭 **Beginner** | Execute a pipeline for its effects without collecting the results, saving memory. |
| Automatically Retry Failed Operations | 游리 **Intermediate** | Build a self-healing pipeline that can automatically retry failed processing steps using a configurable backoff strategy. |
| Merge Multiple Streams | 游리 **Intermediate** | Combine data from multiple streams into a single unified stream. |
| Process a Large File with Constant Memory | 游리 **Intermediate** | Create a data pipeline from a file on disk, processing it line-by-line without loading the entire file into memory. |
| Process collections of data asynchronously | 游리 **Intermediate** | Process collections of data asynchronously in a lazy, composable, and resource-safe manner using Effect's Stream. |
| Process Items Concurrently | 游리 **Intermediate** | Perform an asynchronous action for each item in a stream with controlled parallelism to dramatically improve performance. |
| Process Items in Batches | 游리 **Intermediate** | Group items into chunks for efficient bulk operations, like database inserts or batch API calls. |
| Turn a Paginated API into a Single Stream | 游리 **Intermediate** | Convert a paginated API into a continuous, easy-to-use stream, abstracting away the complexity of fetching page by page. |
| Fan Out to Multiple Consumers | 游 **Advanced** | Distribute stream data to multiple parallel consumers for processing. |
| Implement Backpressure in Pipelines | 游 **Advanced** | Control data flow rates to prevent overwhelming slow consumers. |
| Implement Dead Letter Queues | 游 **Advanced** | Route failed items to a separate queue for later analysis and reprocessing. |
| Manage Resources Safely in a Pipeline | 游 **Advanced** | Ensure resources like file handles or connections are safely acquired at the start of a pipeline and always released at the end, even on failure. |

## Making HTTP Requests
HTTP client patterns with Effect

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Parse JSON Responses Safely | 游릭 **Beginner** | Use Effect Schema to validate and parse HTTP JSON responses with type safety. |
| Your First HTTP Request | 游릭 **Beginner** | Learn how to make HTTP requests using Effect's HttpClient with proper error handling. |
| Add Timeouts to HTTP Requests | 游리 **Intermediate** | Set timeouts on HTTP requests to prevent hanging operations. |
| Cache HTTP Responses | 游리 **Intermediate** | Implement response caching to reduce API calls and improve performance. |
| Create a Testable HTTP Client Service | 游리 **Intermediate** | Define an HttpClient service with separate 'Live' and 'Test' layers to enable robust, testable interactions with external APIs. |
| Handle Rate Limiting Responses | 游리 **Intermediate** | Gracefully handle 429 responses and respect API rate limits. |
| Log HTTP Requests and Responses | 游리 **Intermediate** | Add request/response logging for debugging and observability. |
| Model Dependencies as Services | 游리 **Intermediate** | Abstract external dependencies and capabilities into swappable, testable services using Effect's dependency injection system. |
| Retry HTTP Requests with Backoff | 游리 **Intermediate** | Implement robust retry logic for HTTP requests with exponential backoff. |
| Build a Basic HTTP Server | 游 **Advanced** | Combine Layer, Runtime, and Effect to create a simple, robust HTTP server using Node.js's built-in http module. |

## Testing
Test Effect applications

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Test Effects with Services | 游릭 **Beginner** | Learn how to test Effect programs that depend on services by providing test implementations. |
| Your First Effect Test | 游릭 **Beginner** | Write your first test for an Effect program using Vitest and Effect's testing utilities. |
| Accessing the Current Time with Clock | 游리 **Intermediate** | Use the Clock service to access the current time in a testable, deterministic way, avoiding direct calls to Date.now(). |
| Mocking Dependencies in Tests | 游리 **Intermediate** | Use a test-specific Layer to provide mock implementations of services your code depends on, enabling isolated and deterministic unit tests. |
| Use the Auto-Generated .Default Layer in Tests | 游리 **Intermediate** | When testing, always use the MyService.Default layer that is automatically generated by the Effect.Service class for dependency injection. |
| Write Tests That Adapt to Application Code | 游리 **Intermediate** | A cardinal rule of testing: Tests must adapt to the application's interface, not the other way around. Never modify application code solely to make a test pass. |
| Organize Layers into Composable Modules | 游 **Advanced** | Structure a large application by grouping related services into 'module' layers, which are then composed together with a shared base layer. |
| Property-Based Testing with Effect | 游 **Advanced** | Use fast-check with Effect for property-based testing of pure functions and effects. |
| Test Concurrent Code | 游 **Advanced** | Test race conditions, parallelism, and concurrent behavior in Effect programs. |
| Test Streaming Effects | 游 **Advanced** | Write tests for Stream operations, transformations, and error handling. |

## Observability
Logging, tracing, and metrics

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Debug Effect Programs | 游릭 **Beginner** | Learn techniques for debugging Effect programs using logging, tap, and cause inspection. |
| Your First Logs | 游릭 **Beginner** | Learn the basics of logging in Effect using the built-in structured logging system. |
| Add Custom Metrics to Your Application | 游리 **Intermediate** | Use Effect's Metric module to instrument your code with counters, gauges, and histograms to track key business and performance indicators. |
| Add Custom Metrics to Your Application | 游리 **Intermediate** | Use Effect's Metric module to instrument your code with counters, gauges, and histograms to track key business and performance indicators. |
| Instrument and Observe Function Calls with Effect.fn | 游리 **Intermediate** | Use Effect.fn to wrap, instrument, and observe function calls, enabling composable logging, metrics, and tracing at function boundaries. |
| Leverage Effect's Built-in Structured Logging | 游리 **Intermediate** | Use Effect's built-in logging functions for structured, configurable, and context-aware logging. |
| Trace Operations Across Services with Spans | 游리 **Intermediate** | Use Effect.withSpan to create custom tracing spans, providing detailed visibility into the performance and flow of your application's operations. |
| Trace Operations Across Services with Spans | 游리 **Intermediate** | Use Effect.withSpan to create custom tracing spans, providing detailed visibility into the performance and flow of your application's operations. |
| Create Observability Dashboards | 游 **Advanced** | Design effective dashboards to visualize your Effect application metrics. |
| Export Metrics to Prometheus | 游 **Advanced** | Expose application metrics in Prometheus format for monitoring and alerting. |
| Implement Distributed Tracing | 游 **Advanced** | Set up end-to-end distributed tracing across services with trace context propagation. |
| Integrate Effect Tracing with OpenTelemetry | 游 **Advanced** | Connect Effect's tracing spans to OpenTelemetry for end-to-end distributed tracing and visualization. |
| Set Up Alerting | 游 **Advanced** | Configure alerts to notify you when your Effect application has problems. |

## Tooling and Debugging
Debug and profile Effect applications

| Pattern | Skill Level | Summary |
| :--- | :--- | :--- |
| Read Effect Type Errors | 游릭 **Beginner** | Learn how to read and understand Effect's TypeScript error messages. |
| Set Up Your Effect Development Environment | 游릭 **Beginner** | Configure your editor and tools for the best Effect development experience. |
| Configure Linting for Effect | 游리 **Intermediate** | Set up Biome or ESLint with Effect-specific rules for code quality. |
| Set Up CI/CD for Effect Projects | 游리 **Intermediate** | Configure GitHub Actions to build, test, and deploy Effect applications. |
| Supercharge Your Editor with the Effect LSP | 游리 **Intermediate** | Install the Effect Language Server (LSP) extension for your editor to get rich, inline type information and enhanced error checking for your Effect code. |
| Use Effect DevTools | 游리 **Intermediate** | Debug Effect applications with specialized developer tools. |
| Profile Effect Applications | 游 **Advanced** | Measure and optimize performance of Effect applications. |
| Teach your AI Agents Effect with the MCP Server | 游 **Advanced** | Use the Effect MCP server to provide live, contextual information about your application's structure directly to AI coding agents. |

