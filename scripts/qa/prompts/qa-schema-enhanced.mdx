---
title: Enhanced QA Validation Schema
description: Comprehensive schema for validating Effect pattern quality with semantic checks
outputFormat: json
---

# Enhanced QA Validation Schema

This prompt defines the JSON schema for validating Effect patterns with enhanced semantic validation. The response must be a valid JSON object with the following structure:

## Required JSON Structure

```json
{
  "passed": boolean,
  "errors": ["string"],
  "warnings": ["string"],
  "suggestions": ["string"],
  "semantic_checks": {
    "memory_behavior": "pass" | "fail" | "unknown",
    "concurrency_claims": "pass" | "fail" | "unknown",
    "effect_idioms": "pass" | "fail" | "unknown",
    "api_modernization": "pass" | "fail" | "unknown"
  },
  "tokens": number,
  "cost": number
}
```

## Validation Criteria

### 1. Technical Correctness ‚öôÔ∏è

**Code Quality:**
- Code examples compile and run without errors
- Imports are correct and complete
- Exports are properly defined
- TypeScript types are accurate and specific
- Effect patterns are implemented correctly

**API Usage:**
- Uses modern Effect APIs (no deprecated APIs)
- Correct Effect version compatibility
- Proper error types (no generic `Error`)
- Type-safe throughout

### 2. Documentation Quality üìö

**Clarity:**
- Clear explanations of concepts
- Complete coverage of the pattern
- Accurate descriptions
- Consistent terminology
- Appropriate examples

**Structure:**
- Has "Good Example" section
- Has "Anti-Pattern" section  
- Has "Explanation" or "Rationale" section
- Code examples are complete and runnable
- Examples show real-world usage

### 3. Pattern Adherence üéØ

**Effect Best Practices:**
- Follows Effect.TS conventions
- Uses modern Effect patterns
- Avoids anti-patterns
- Proper service layer usage
- Correct dependency injection

**Code Style:**
- Idiomatic Effect code
- Prefer `pipe` for composition
- Use `Effect.gen` for sequential logic
- Proper error handling with typed errors
- Resource management with `Scope`

### 4. Examples Quality üí°

**Completeness:**
- Code is runnable as-is
- Demonstrates the pattern effectively
- Has clear "before" and "after" comparisons
- Shows practical use cases
- Includes expected outputs or behavior

**Clarity:**
- Examples are easy to understand
- Variable names are descriptive
- Comments explain non-obvious parts (sparingly)
- Code is well-formatted

### 5. Metadata ‚ÑπÔ∏è

**Frontmatter:**
- ID is unique and descriptive (kebab-case)
- Title is clear and accurate
- Skill level is appropriate (beginner/intermediate/advanced)
- Tags are relevant
- Use cases are practical and specific

---

## üîç SEMANTIC VALIDATION CHECKS (NEW!)

### Semantic Check 1: Memory Behavior üíæ

**For streaming patterns** (filename contains "stream", title mentions "streaming"):

**CRITICAL CHECKS:**
1. Does the code actually stream, or does it load everything into memory first?
   - ‚ùå BAD: `fs.readFileString(path)` then `Stream.fromIterable(content.split('\n'))`
   - ‚úÖ GOOD: `fs.readFile(path).pipe(Stream.decodeText('utf-8'), Stream.splitLines)`

2. Does it use `Stream.runCollect` which loads the entire stream?
   - ‚ö†Ô∏è WARNING: Only acceptable if the dataset is known to be small
   - ‚úÖ BETTER: Use `Stream.run` or process in chunks

3. Does the description claim "constant memory" or "streaming"?
   - ‚úÖ VERIFY: The code actually uses constant memory
   - ‚ùå FAIL: Claims streaming but loads everything first

**Set `semantic_checks.memory_behavior` to:**
- `"pass"` - Truly streams with constant memory
- `"fail"` - Claims streaming but loads into memory
- `"unknown"` - Not a streaming pattern

---

### Semantic Check 2: Concurrency Claims üîÄ

**For parallel/concurrent patterns** (filename contains "parallel", "concurrent", "all", title mentions these):

**CRITICAL CHECKS:**
1. Does `Effect.all` have an explicit `concurrency` option?
   - ‚ùå FAIL: `Effect.all(effects)` - sequential by default!
   - ‚úÖ PASS: `Effect.all(effects, { concurrency: "unbounded" })`
   - ‚úÖ PASS: `Effect.all(effects, { concurrency: 5 })`

2. Does the description claim "parallel" or "concurrent"?
   - ‚úÖ VERIFY: Code actually runs in parallel
   - ‚ùå FAIL: Claims parallel but is sequential

3. Are there timing examples that match the claims?
   - If claiming "parallel is faster", check if it actually would be
   - Sequential: delays add up (3 x 500ms = 1500ms)
   - Parallel: delays overlap (3 x 500ms = ~500ms)

**Set `semantic_checks.concurrency_claims` to:**
- `"pass"` - Correctly parallel with explicit concurrency
- `"fail"` - Claims parallel but sequential, or missing concurrency option
- `"unknown"` - Not a concurrency pattern

---

### Semantic Check 3: Effect Idioms üé®

**Check for non-idiomatic Effect code:**

**ANTI-PATTERNS TO FLAG:**
1. Using `Effect.catchAll + Effect.gen` just for logging:
   ```typescript
   // ‚ùå BAD
   .pipe(Effect.catchAll((e) => Effect.gen(function* () {
     yield* Effect.log(`Error: ${e}`)
   })))
   
   // ‚úÖ GOOD
   .pipe(
     Effect.tapError((e) => Effect.log(`Error: ${e}`)),
     Effect.catchAll(() => Effect.succeed(default))
   )
   ```

2. Using deprecated APIs:
   - `Effect.fromOption` ‚Üí Use `Option.match`
   - `Effect.fromEither` ‚Üí Use `Either.match`
   - `Option.zip` ‚Üí Use `Option.all`
   - `Either.zip` ‚Üí Use `Either.all`
   - `Effect.matchTag` ‚Üí Use `Effect.catchTags`

3. Generic `Error` instead of typed errors:
   ```typescript
   // ‚ùå BAD
   Effect<string, Error>
   Effect.fail(new Error("Failed"))
   
   // ‚úÖ GOOD
   class ParseError extends Data.TaggedError("ParseError")<{...}> {}
   Effect<string, ParseError>
   Effect.fail(new ParseError({...}))
   ```

4. Long method chains without `pipe`:
   ```typescript
   // ‚ùå BAD
   value.map(f1).map(f2).map(f3).map(f4)
   
   // ‚úÖ GOOD
   pipe(value, map(f1), map(f2), map(f3), map(f4))
   ```

**Set `semantic_checks.effect_idioms` to:**
- `"pass"` - Uses idiomatic Effect patterns
- `"fail"` - Uses anti-patterns or non-idiomatic code
- `"unknown"` - Unable to determine

---

### Semantic Check 4: API Modernization üîÑ

**Check for outdated or deprecated API usage:**

**DEPRECATED APIS (flag as errors):**
- `Effect.fromOption` (use `Option.match` with `Effect.succeed`/`fail`)
- `Effect.fromEither` (use `Either.match` with `Effect.succeed`/`fail`)
- `Option.zip` (use `Option.all`)
- `Either.zip` (use `Either.all`)
- `Option.cond` (use ternary with `Option.some`/`none`)
- `Either.cond` (use ternary with `Either.right`/`left`)
- `Effect.matchTag` (use `Effect.catchTags`)
- `Schema.string` (use `Schema.String` - capitalized)
- `Brand.Branded<T, "X">` (use `T & Brand.Brand<"X">`)
- `Brand.schema()` (use `Schema.brand()`)

**MODERN PATTERNS (encourage):**
- Use `Effect.Service` for services (not `Context.Tag`)
- Use `pipe` for composition
- Use `Effect.gen` for sequential logic
- Use typed errors with `Data.TaggedError`
- Use `Layer` for dependency injection

**Set `semantic_checks.api_modernization` to:**
- `"pass"` - Uses modern APIs throughout
- `"fail"` - Uses deprecated APIs
- `"unknown"` - Unable to determine

---

## Response Format

When analyzing a pattern, provide specific feedback:

- **errors**: Critical issues that must be fixed (syntax errors, deprecated APIs, broken code)
- **warnings**: Issues that should be addressed (non-idiomatic, unclear, incomplete)
- **suggestions**: Improvements that would enhance quality (better examples, more detail)

## Example Response

```json
{
  "passed": false,
  "errors": [
    "Uses deprecated Effect.fromOption - use Option.match instead",
    "Claims 'parallel execution' but Effect.all has no concurrency option (sequential by default)",
    "Streaming pattern loads entire file with fs.readFileString instead of actual streaming"
  ],
  "warnings": [
    "Uses Effect.catchAll + Effect.gen just for logging - use Effect.tapError instead",
    "Generic Error type instead of typed error (Data.TaggedError)",
    "Example output doesn't match actual behavior (sequential vs parallel timing)"
  ],
  "suggestions": [
    "Add timing example showing actual parallel speedup",
    "Show memory usage comparison for streaming vs loading",
    "Add anti-pattern section showing what NOT to do"
  ],
  "semantic_checks": {
    "memory_behavior": "fail",
    "concurrency_claims": "fail",
    "effect_idioms": "fail",
    "api_modernization": "fail"
  },
  "tokens": 1500,
  "cost": 0.003
}
```

## Validation Priority

**Priority 1 - Must Pass (errors):**
1. Code compiles and runs
2. No deprecated APIs
3. Concurrency claims match implementation
4. Streaming patterns actually stream

**Priority 2 - Should Pass (warnings):**
1. Uses idiomatic Effect patterns
2. Typed errors instead of generic Error
3. Clear and complete examples
4. Accurate descriptions

**Priority 3 - Nice to Have (suggestions):**
1. More comprehensive examples
2. Performance considerations
3. Edge case handling
4. Additional context

---

## Important Notes

1. **Be thorough**: Check both the "Good Example" AND "Anti-Pattern" sections
2. **Verify claims**: If it says "parallel", check for concurrency options
3. **Check semantics**: Not just "does it compile" but "does it do what it claims"
4. **Consider context**: Streaming patterns need different validation than utility patterns
5. **Be constructive**: Provide actionable feedback with specific suggestions

Remember: The goal is to catch bugs that would slip through syntax checking and runtime tests. Focus on semantic correctness, behavior, and idioms.

