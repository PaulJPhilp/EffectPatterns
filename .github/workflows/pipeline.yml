name: Pipeline Integrity Check

on:
  pull_request:
    paths:
      - 'content/new/**'
      - 'scripts/publish/**'
      - '.git/hooks/**'
      - 'PIPELINE.md'
      - 'PIPELINE-REVIEW.md'
  push:
    branches:
      - main
    paths:
      - 'content/new/**'
      - 'scripts/publish/**'
      - '.git/hooks/**'

jobs:
  pipeline-validation:
    name: Validate Pipeline Integrity
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
      
      - name: Check forbidden directories don't exist
        run: |
          echo "üîç Checking for forbidden directories..."
          FORBIDDEN=("patterns/" "rules/" ".claude/skills/" ".gemini/" ".openai/")
          for dir in "${FORBIDDEN[@]}"; do
            if [ -d "$dir" ]; then
              echo "‚ùå ERROR: $dir exists in repo root (pipeline-generated only)"
              echo "This directory should only exist in content/published/"
              exit 1
            fi
          done
          echo "‚úÖ No forbidden directories found"
      
      - name: Install dependencies
        run: bun install
      
      - name: Type check TypeScript examples
        run: |
          echo "üîç Type checking patterns..."
          bun run scripts/publish/test-improved.ts || exit 1
          echo "‚úÖ Type check passed"
      
      - name: Run full pipeline
        run: |
          echo "üîç Running publishing pipeline..."
          bun run pipeline || exit 1
          echo "‚úÖ Pipeline completed successfully"
      
      - name: Verify README structure
        run: |
          echo "üîç Verifying README structure..."
          if [ ! -f README.md ]; then
            echo "‚ùå ERROR: README.md not generated"
            exit 1
          fi
          
          grep -q "## Table of Contents" README.md || (echo "‚ùå Missing Table of Contents"; exit 1)
          grep -q "### Core Effect Patterns" README.md || (echo "‚ùå Missing Core section"; exit 1)
          grep -q "### Schema Patterns" README.md || (echo "‚ùå Missing Schema section"; exit 1)
          
          # Verify core categories (12 expected)
          CORE_CATEGORIES=("resource-management" "concurrency" "core-concepts" "testing" "domain-modeling" "building-apis" "error-management" "building-data-pipelines" "making-http-requests" "tooling-and-debugging" "observability" "project-setup--execution")
          for category in "${CORE_CATEGORIES[@]}"; do
            grep -q "^## $category" README.md || (echo "‚ùå Missing core category: $category"; exit 1)
          done
          
          # Verify schema categories (14 expected)
          SCHEMA_CATEGORIES=("Composition" "Transformations" "Unions" "Recursive" "Error Handling" "Async Validation" "Validating Api Responses" "Parsing Ai Responses" "Defining Ai Output Schemas" "Web Standards Validation" "Form Validation" "Json File Validation" "Json Db Validation" "Environment Config")
          for category in "${SCHEMA_CATEGORIES[@]}"; do
            grep -q "^## $category" README.md || (echo "‚ùå Missing schema category: $category"; exit 1)
          done
          
          echo "‚úÖ README structure verified (12 core + 14 schema categories)"
      
      - name: Verify pattern counts
        run: |
          echo "üîç Verifying pattern counts..."
          TOTAL=$(find content/published/patterns -name "*.mdx" | wc -l)
          if [ "$TOTAL" -lt 190 ]; then
            echo "‚ùå Pattern count too low: $TOTAL (expected 195)"
            exit 1
          fi
          
          CORE=$(find content/published/patterns/core -name "*.mdx" | wc -l)
          SCHEMA=$(find content/published/patterns/schema -name "*.mdx" | wc -l)
          echo "‚úÖ Pattern count verified: $TOTAL total ($CORE core + $SCHEMA schema)"
      
      - name: Verify rules generation
        run: |
          echo "üîç Verifying rules generation..."
          [ -f content/published/rules/rules.md ] || (echo "‚ùå rules.md not generated"; exit 1)
          [ -f content/published/rules/rules.json ] || (echo "‚ùå rules.json not generated"; exit 1)
          [ -f content/published/rules/rules-compact.md ] || (echo "‚ùå rules-compact.md not generated"; exit 1)
          [ -d content/published/rules/by-use-case ] || (echo "‚ùå by-use-case directory not generated"; exit 1)
          echo "‚úÖ Rules generation verified (6 formats)"
      
      - name: Verify skills generation
        run: |
          echo "üîç Verifying skills generation..."
          [ -d content/published/skills/claude ] || (echo "‚ùå Claude skills not generated"; exit 1)
          [ -d content/published/skills/gemini ] || (echo "‚ùå Gemini skills not generated"; exit 1)
          [ -d content/published/skills/openai ] || (echo "‚ùå OpenAI skills not generated"; exit 1)
          
          CLAUDE_COUNT=$(find content/published/skills/claude -name "*.md" | wc -l)
          GEMINI_COUNT=$(find content/published/skills/gemini -name "*.json" | wc -l)
          OPENAI_COUNT=$(find content/published/skills/openai -name "*.md" | wc -l)
          
          echo "‚úÖ Skills generation verified (Claude: $CLAUDE_COUNT, Gemini: $GEMINI_COUNT, OpenAI: $OPENAI_COUNT)"
      
      - name: Ensure no generated files in git staging
        run: |
          echo "üîç Checking for accidentally staged generated files..."
          
          # Check if any forbidden paths appear in git diff
          if git diff --cached --name-only | grep -E "^(patterns/|rules/|\.claude/skills/|\.gemini/|\.openai/)" > /dev/null; then
            echo "‚ùå ERROR: Generated files appear in git staging area"
            echo "These should never be committed:"
            git diff --cached --name-only | grep -E "^(patterns/|rules/|\.claude/skills/|\.gemini/|\.openai/)"
            exit 1
          fi
          
          echo "‚úÖ No generated files in staging area"
      
      - name: Validate pattern frontmatter
        run: |
          echo "üîç Validating pattern frontmatter..."
          
          INVALID_COUNT=0
          for file in content/published/patterns/**/*.mdx; do
            if [ -f "$file" ]; then
              # Check for required frontmatter fields
              if ! grep -q "^title:" "$file"; then
                echo "‚ùå Missing title in $file"
                ((INVALID_COUNT++))
              fi
              if ! grep -q "^skillLevel:\|^skill:" "$file"; then
                echo "‚ùå Missing skillLevel/skill in $file"
                ((INVALID_COUNT++))
              fi
              if ! grep -q "^summary:" "$file"; then
                echo "‚ùå Missing summary in $file"
                ((INVALID_COUNT++))
              fi
            fi
          done
          
          if [ "$INVALID_COUNT" -gt 0 ]; then
            echo "‚ùå Found $INVALID_COUNT patterns with invalid frontmatter"
            exit 1
          fi
          
          echo "‚úÖ All patterns have valid frontmatter"
      
      - name: Check git hooks exist
        run: |
          echo "üîç Checking git hooks..."
          [ -f .git/hooks/pre-commit ] || (echo "‚ùå pre-commit hook missing"; exit 1)
          [ -x .git/hooks/pre-commit ] || (echo "‚ùå pre-commit hook not executable"; exit 1)
          echo "‚úÖ Git hooks verified"
      
      - name: Pipeline integrity check passed
        run: |
          echo ""
          echo "‚úÖ =========================================="
          echo "‚úÖ PIPELINE INTEGRITY CHECK PASSED"
          echo "‚úÖ =========================================="
          echo ""
          echo "Summary:"
          echo "  ‚úÖ No forbidden directories in repo"
          echo "  ‚úÖ Type checking passed"
          echo "  ‚úÖ Pipeline executed successfully"
          echo "  ‚úÖ README structure valid (12 core + 14 schema)"
          echo "  ‚úÖ Pattern counts verified (195 total)"
          echo "  ‚úÖ Rules generated correctly (6 formats)"
          echo "  ‚úÖ Skills generated correctly (3 platforms)"
          echo "  ‚úÖ Frontmatter validated"
          echo "  ‚úÖ Git hooks present"
          echo "  ‚úÖ No generated files accidentally staged"
          echo ""
