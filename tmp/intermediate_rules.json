[
  {
    "path": "rules/cursor/access-configuration-from-the-context.mdc",
    "description": "Access configuration from the Effect context.",
    "content": "# Access Configuration from the Context\n**Rule:** Access configuration from the Effect context.\n\n### Example\n```typescript\nimport { Config, Effect, Layer } from \"effect\";\n\n// Define config service\nclass AppConfig extends Effect.Service<AppConfig>()(\n  \"AppConfig\",\n  {\n    sync: () => ({\n      host: \"localhost\",\n      port: 3000\n    })\n  }\n) {}\n\n// Create program that uses config\nconst program = Effect.gen(function* () {\n  const config = yield* AppConfig;\n  yield* Effect.log(`Starting server on http://${config.host}:${config.port}`);\n});\n\n// Run the program with default config\nEffect.runPromise(\n  Effect.provide(program, AppConfig.Default)\n);\n```\n\n**Explanation:**  \nBy yielding the config object, you make your dependency explicit and leverage Effect's context system for testability and modularity."
  },
  {
    "path": "rules/cursor/accessing-the-current-time-with-clock.mdc",
    "description": "Use the Clock service to get the current time, enabling deterministic testing with TestClock.",
    "content": "# Accessing the Current Time with Clock\n**Rule:** Use the Clock service to get the current time, enabling deterministic testing with TestClock.\n\n### Example\nThis example shows a function that checks if a token is expired. Its logic depends on `Clock`, making it fully testable.\n\n```typescript\nimport { Effect, Clock, Duration } from \"effect\";\n\ninterface Token {\n  readonly value: string;\n  readonly expiresAt: number; // UTC milliseconds\n}\n\n// This function is pure and testable because it depends on Clock\nconst isTokenExpired = (token: Token): Effect.Effect<boolean, never, Clock.Clock> =>\n  Clock.currentTimeMillis.pipe(\n    Effect.map((now) => now > token.expiresAt),\n    Effect.tap((expired) => Effect.log(`Token expired? ${expired} (current time: ${new Date().toISOString()})`))\n  );\n\n// Create a test clock service that advances time\nconst makeTestClock = (timeMs: number): Clock.Clock => ({\n  currentTimeMillis: Effect.succeed(timeMs),\n  currentTimeNanos: Effect.succeed(BigInt(timeMs * 1_000_000)),\n  sleep: (duration: Duration.Duration) => Effect.succeed(void 0),\n  unsafeCurrentTimeMillis: () => timeMs,\n  unsafeCurrentTimeNanos: () => BigInt(timeMs * 1_000_000),\n  [Clock.ClockTypeId]: Clock.ClockTypeId,\n});\n\n// Create a token that expires in 1 second\nconst token = { value: \"abc\", expiresAt: Date.now() + 1000 };\n\n// Check token expiry with different clocks\nconst program = Effect.gen(function* () {\n  // Check with current time\n  yield* Effect.log(\"Checking with current time...\");\n  yield* isTokenExpired(token);\n\n  // Check with past time\n  yield* Effect.log(\"\\nChecking with past time (1 minute ago)...\");\n  const pastClock = makeTestClock(Date.now() - 60_000);\n  yield* isTokenExpired(token).pipe(\n    Effect.provideService(Clock.Clock, pastClock)\n  );\n\n  // Check with future time\n  yield* Effect.log(\"\\nChecking with future time (1 hour ahead)...\");\n  const futureClock = makeTestClock(Date.now() + 3600_000);\n  yield* isTokenExpired(token).pipe(\n    Effect.provideService(Clock.Clock, futureClock)\n  );\n});\n\n// Run the program with default clock\nEffect.runPromise(\n  program.pipe(\n    Effect.provideService(Clock.Clock, makeTestClock(Date.now()))\n  )\n);\n```\n\n---"
  },
  {
    "path": "rules/cursor/accumulate-multiple-errors-with-either.mdc",
    "description": "Use Either to accumulate multiple validation errors instead of failing on the first one.",
    "content": "# Accumulate Multiple Errors with Either\n**Rule:** Use Either to accumulate multiple validation errors instead of failing on the first one.\n\n### Example\nUsing `Schema.decode` with the `allErrors: true` option demonstrates this pattern perfectly. The underlying mechanism uses `Either` to collect all parsing errors into an array instead of stopping at the first one.\n\n````typescript\nimport { Effect, Schema, Data } from \"effect\";\n\n// Define validation error type\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly field: string;\n  readonly message: string;\n}> {}\n\n// Define user type\ntype User = {\n  name: string;\n  email: string;\n};\n\n// Define schema with custom validation\nconst UserSchema = Schema.Struct({\n  name: Schema.String.pipe(\n    Schema.minLength(3),\n    Schema.filter((name) => /^[A-Za-z\\s]+$/.test(name), {\n      message: () => \"name must contain only letters and spaces\"\n    })\n  ),\n  email: Schema.String.pipe(\n    Schema.pattern(/@/),\n    Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/, {\n      message: () => \"email must be a valid email address\"\n    })\n  ),\n});\n\n// Example inputs\nconst invalidInputs: User[] = [\n  {\n    name: \"Al\", // Too short\n    email: \"bob-no-at-sign.com\", // Invalid pattern\n  },\n  {\n    name: \"John123\", // Contains numbers\n    email: \"john@incomplete\", // Invalid email\n  },\n  {\n    name: \"Alice Smith\", // Valid\n    email: \"alice@example.com\", // Valid\n  }\n];\n\n// Validate a single user\nconst validateUser = (input: User) =>\n  Effect.gen(function* () {\n    const result = yield* Schema.decode(UserSchema)(input, { errors: \"all\" });\n    return result;\n  });\n\n// Process multiple users and accumulate all errors\nconst program = Effect.gen(function* () {\n  console.log(\"Validating users...\\n\");\n  \n  for (const input of invalidInputs) {\n    const result = yield* Effect.either(validateUser(input));\n    \n    console.log(`Validating user: ${input.name} <${input.email}>`);\n    \n    yield* Effect.match(result, {\n      onFailure: (error) => Effect.sync(() => {\n        console.log(\"\u274c Validation failed:\");\n        console.log(error.message);\n        console.log(); // Empty line for readability\n      }),\n      onSuccess: (user) => Effect.sync(() => {\n        console.log(\"\u2705 User is valid:\", user);\n        console.log(); // Empty line for readability\n      })\n    });\n  }\n});\n\n// Run the program\nEffect.runSync(program);\n````\n\n---"
  },
  {
    "path": "rules/cursor/add-custom-metrics-to-your-application.mdc",
    "description": "Use Metric.counter, Metric.gauge, and Metric.histogram to instrument code for monitoring.",
    "content": "# Add Custom Metrics to Your Application\n**Rule:** Use Metric.counter, Metric.gauge, and Metric.histogram to instrument code for monitoring.\n\n### Example\nThis example creates a counter to track how many times a user is created and a histogram to track the duration of the database operation.\n\n```typescript\nimport { Effect, Metric, Duration } from \"effect\";  // We don't need MetricBoundaries anymore\n\n// 1. Define your metrics\nconst userRegisteredCounter = Metric.counter(\"users_registered_total\", {\n  description: \"A counter for how many users have been registered.\",\n});\n\nconst dbDurationTimer = Metric.timer(\n  \"db_operation_duration\",\n  \"A timer for DB operation durations\"\n);\n\n// 2. Simulated database call\nconst saveUserToDb = Effect.succeed(\"user saved\").pipe(\n  Effect.delay(Duration.millis(Math.random() * 100)),\n);\n\n// 3. Instrument the business logic\nconst createUser = Effect.gen(function* () {\n  // Time the operation\n  yield* saveUserToDb.pipe(Metric.trackDuration(dbDurationTimer));\n\n  // Increment the counter\n  yield* Metric.increment(userRegisteredCounter);\n\n  return { status: \"success\" };\n});\n\n// Run the Effect\nEffect.runPromise(createUser).then(console.log);\n```\n\n---"
  },
  {
    "path": "rules/cursor/automatically-retry-failed-operations.mdc",
    "description": "Compose a Stream with the .retry(Schedule) operator to automatically recover from transient failures.",
    "content": "# Automatically Retry Failed Operations\n**Rule:** Compose a Stream with the .retry(Schedule) operator to automatically recover from transient failures.\n\n### Example\nThis example simulates an API that fails the first two times it's called. The stream processes a list of IDs, and the `retry` operator ensures that the failing operation for `id: 2` is automatically retried until it succeeds.\n\n````typescript\nimport { Effect, Stream, Schedule } from \"effect\";\n\n// A mock function that simulates a flaky API call\nconst processItem = (id: number): Effect.Effect<string, Error> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`Attempting to process item ${id}...`);\n\n    // Item 2 fails on first attempt but succeeds on retry\n    if (id === 2) {\n      const random = Math.random();\n      if (random < 0.5) {\n        // 50% chance of failure for demonstration\n        yield* Effect.log(`Item ${id} failed, will retry...`);\n        return yield* Effect.fail(new Error(\"API is temporarily down\"));\n      }\n    }\n\n    yield* Effect.log(`\u2705 Successfully processed item ${id}`);\n    return `Processed item ${id}`;\n  });\n\nconst ids = [1, 2, 3];\n\n// Define a retry policy: 3 attempts with a fixed 100ms delay\nconst retryPolicy = Schedule.recurs(3).pipe(\n  Schedule.addDelay(() => \"100 millis\")\n);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Stream Retry on Failure Demo ===\");\n  yield* Effect.log(\n    \"Processing items with retry policy (3 attempts, 100ms delay)\"\n  );\n\n  // Process each item individually with retry\n  const results = yield* Effect.forEach(\n    ids,\n    (id) =>\n      processItem(id).pipe(\n        Effect.retry(retryPolicy),\n        Effect.catchAll((error) =>\n          Effect.gen(function* () {\n            yield* Effect.log(\n              `\u274c Item ${id} failed after all retries: ${error.message}`\n            );\n            return `Failed: item ${id}`;\n          })\n        )\n      ),\n    { concurrency: 1 }\n  );\n\n  yield* Effect.log(\"=== Results ===\");\n  results.forEach((result, index) => {\n    console.log(`Item ${ids[index]}: ${result}`);\n  });\n\n  yield* Effect.log(\"\u2705 Stream processing completed\");\n});\n\nEffect.runPromise(program).catch((error) => {\n  console.error(\"Unexpected error:\", error);\n});\n/*\nOutput:\n... level=INFO msg=\"Attempting to process item 1...\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Item 2 failed, attempt 1.\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Item 2 failed, attempt 2.\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Attempting to process item 3...\"\n*/\n\n````"
  },
  {
    "path": "rules/cursor/avoid-long-chains-of-andthen-use-generators-instead.mdc",
    "description": "Prefer generators over long chains of .andThen.",
    "content": "# Avoid Long Chains of .andThen; Use Generators Instead\n**Rule:** Prefer generators over long chains of .andThen.\n\n### Example\n```typescript\nimport { Effect } from \"effect\";\n\n// Define our steps with logging\nconst step1 = (): Effect.Effect<number> =>\n  Effect.succeed(42).pipe(\n    Effect.tap(n => Effect.log(`Step 1: ${n}`))\n  );\n\nconst step2 = (a: number): Effect.Effect<string> =>\n  Effect.succeed(`Result: ${a * 2}`).pipe(\n    Effect.tap(s => Effect.log(`Step 2: ${s}`))\n  );\n\n// Using Effect.gen for better readability\nconst program = Effect.gen(function* () {\n  const a = yield* step1();\n  const b = yield* step2(a);\n  return b;\n});\n\n// Run the program\nEffect.runPromise(program).then(\n  result => Effect.runSync(Effect.log(`Final result: ${result}`))\n);\n```\n\n**Explanation:**  \nGenerators keep sequential logic readable and easy to maintain."
  },
  {
    "path": "rules/cursor/beyond-the-date-type-real-world-dates-times-and-timezones.mdc",
    "description": "Use the Clock service for testable time-based logic and immutable primitives for timestamps.",
    "content": "# Beyond the Date Type - Real World Dates, Times, and Timezones\n**Rule:** Use the Clock service for testable time-based logic and immutable primitives for timestamps.\n\n### Example\nThis example shows a function that creates a timestamped event. It depends on the `Clock` service, making it fully testable.\n\n```typescript\nimport { Effect, Clock } from \"effect\";\nimport type * as Types from \"effect/Clock\";\n\ninterface Event {\n  readonly message: string;\n  readonly timestamp: number; // Store as a primitive number (UTC millis)\n}\n\n// This function is pure and testable because it depends on Clock\nconst createEvent = (message: string): Effect.Effect<Event, never, Types.Clock> =>\n  Effect.gen(function* () {\n    const timestamp = yield* Clock.currentTimeMillis;\n    return { message, timestamp };\n  });\n\n// Create and log some events\nconst program = Effect.gen(function* () {\n  const loginEvent = yield* createEvent(\"User logged in\");\n  console.log(\"Login event:\", loginEvent);\n\n  const logoutEvent = yield* createEvent(\"User logged out\");\n  console.log(\"Logout event:\", logoutEvent);\n});\n\n// Run the program\nEffect.runPromise(program.pipe(Effect.provideService(Clock.Clock, Clock.make()))).catch(console.error);\n```\n\n---"
  },
  {
    "path": "rules/cursor/compose-resource-lifecycles-with-layer-merge.mdc",
    "description": "Compose multiple scoped layers using `Layer.merge` or by providing one layer to another.",
    "content": "# Compose Resource Lifecycles with `Layer.merge`\n**Rule:** Compose multiple scoped layers using `Layer.merge` or by providing one layer to another.\n\n### Example\n```typescript\nimport { Effect, Layer, Console } from \"effect\";\n\n// --- Service 1: Database ---\ninterface DatabaseOps {\n  query: (sql: string) => Effect.Effect<string, never, never>;\n}\n\nclass Database extends Effect.Service<DatabaseOps>()(\n  \"Database\",\n  {\n    sync: () => ({\n      query: (sql: string): Effect.Effect<string, never, never> =>\n        Effect.sync(() => `db says: ${sql}`)\n    })\n  }\n) {}\n\n// --- Service 2: API Client ---\ninterface ApiClientOps {\n  fetch: (path: string) => Effect.Effect<string, never, never>;\n}\n\nclass ApiClient extends Effect.Service<ApiClientOps>()(\n  \"ApiClient\",\n  {\n    sync: () => ({\n      fetch: (path: string): Effect.Effect<string, never, never> =>\n        Effect.sync(() => `api says: ${path}`)\n    })\n  }\n) {}\n\n// --- Application Layer ---\n// We merge the two independent layers into one.\nconst AppLayer = Layer.merge(Database.Default, ApiClient.Default);\n\n// This program uses both services, unaware of their implementation details.\nconst program = Effect.gen(function* () {\n  const db = yield* Database;\n  const api = yield* ApiClient;\n\n  const dbResult = yield* db.query(\"SELECT *\");\n  const apiResult = yield* api.fetch(\"/users\");\n\n  yield* Console.log(dbResult);\n  yield* Console.log(apiResult);\n});\n\n// Provide the combined layer to the program.\nEffect.runPromise(Effect.provide(program, AppLayer));\n\n/*\nOutput (note the LIFO release order):\nDatabase pool opened\nAPI client session started\ndb says: SELECT *\napi says: /users\nAPI client session ended\nDatabase pool closed\n*/\n```\n\n**Explanation:**\nWe define two completely independent services, `Database` and `ApiClient`, each with its own resource lifecycle. By combining them with `Layer.merge`, we create a single `AppLayer`. When `program` runs, Effect acquires the resources for both layers. When `program` finishes, Effect closes the application's scope, releasing the resources in the reverse order they were acquired (`ApiClient` then `Database`), ensuring a clean and predictable shutdown."
  },
  {
    "path": "rules/cursor/conditionally-branching-workflows.mdc",
    "description": "Use predicate-based operators like Effect.filter and Effect.if to declaratively control workflow branching.",
    "content": "# Conditionally Branching Workflows\n**Rule:** Use predicate-based operators like Effect.filter and Effect.if to declaratively control workflow branching.\n\n### Example\nHere, we use `Effect.filter` with named predicates to validate a user before proceeding. The intent is crystal clear, and the business rules (`isActive`, `isAdmin`) are reusable.\n\n```typescript\nimport { Effect } from \"effect\";\n\ninterface User {\n  id: number;\n  status: \"active\" | \"inactive\";\n  roles: string[];\n}\n\ntype UserError = \"DbError\" | \"UserIsInactive\" | \"UserIsNotAdmin\";\n\nconst findUser = (id: number): Effect.Effect<User, \"DbError\"> =>\n  Effect.succeed({ id, status: \"active\", roles: [\"admin\"] });\n\n// Reusable, testable predicates that document business rules.\nconst isActive = (user: User): Effect.Effect<boolean> =>\n  Effect.succeed(user.status === \"active\");\n\nconst isAdmin = (user: User): Effect.Effect<boolean> =>\n  Effect.succeed(user.roles.includes(\"admin\"));\n\nconst program = (id: number): Effect.Effect<string, UserError> =>\n  Effect.gen(function* () {\n    // Find the user\n    const user = yield* findUser(id);\n\n    // Check if user is active\n    const active = yield* isActive(user);\n    if (!active) {\n      return yield* Effect.fail(\"UserIsInactive\" as const);\n    }\n\n    // Check if user is admin\n    const admin = yield* isAdmin(user);\n    if (!admin) {\n      return yield* Effect.fail(\"UserIsNotAdmin\" as const);\n    }\n\n    // Success case\n    return `Welcome, admin user #${user.id}!`;\n  });\n\n// We can then handle the specific failures in a type-safe way.\nconst handled = program(123).pipe(\n  Effect.match({\n    onFailure: (error) => {\n      switch (error) {\n        case \"UserIsNotAdmin\":\n          return \"Access denied: requires admin role.\";\n        case \"UserIsInactive\":\n          return \"Access denied: user is not active.\";\n        case \"DbError\":\n          return \"Error: could not find user.\";\n        default:\n          return `Unknown error: ${error}`;\n      }\n    },\n    onSuccess: (result) => result\n  })\n);\n\n// Run the program\nEffect.runPromise(handled).then(console.log);\n```\n\n---"
  },
  {
    "path": "rules/cursor/control-flow-with-conditional-combinators.mdc",
    "description": "Use conditional combinators for control flow.",
    "content": "# Control Flow with Conditional Combinators\n**Rule:** Use conditional combinators for control flow.\n\n### Example\n```typescript\nimport { Effect } from \"effect\"\n\nconst attemptAdminAction = (user: { isAdmin: boolean }) =>\n  Effect.if(user.isAdmin, {\n    onTrue: () => Effect.succeed(\"Admin action completed.\"),\n    onFalse: () => Effect.fail(\"Permission denied.\")\n  })\n\nconst program = Effect.gen(function* () {\n  // Try with admin user\n  yield* Effect.logInfo(\"\\nTrying with admin user...\")\n  const adminResult = yield* Effect.either(attemptAdminAction({ isAdmin: true }))\n  yield* Effect.logInfo(`Admin result: ${adminResult._tag === 'Right' ? adminResult.right : adminResult.left}`)\n\n  // Try with non-admin user\n  yield* Effect.logInfo(\"\\nTrying with non-admin user...\")\n  const userResult = yield* Effect.either(attemptAdminAction({ isAdmin: false }))\n  yield* Effect.logInfo(`User result: ${userResult._tag === 'Right' ? userResult.right : userResult.left}`)\n})\n\nEffect.runPromise(program)\n```\n\n**Explanation:**  \n`Effect.if` and related combinators allow you to branch logic without leaving\nthe Effect world or breaking the flow of composition."
  },
  {
    "path": "rules/cursor/control-repetition-with-schedule.mdc",
    "description": "Use Schedule to create composable policies for controlling the repetition and retrying of effects.",
    "content": "# Control Repetition with Schedule\n**Rule:** Use Schedule to create composable policies for controlling the repetition and retrying of effects.\n\n### Example\nThis example demonstrates composition by creating a common, robust retry policy: exponential backoff with jitter, limited to 5 attempts.\n\n```typescript\nimport { Effect, Schedule, Duration } from \"effect\"\n\n// A simple effect that can fail\nconst flakyEffect = Effect.try({\n  try: () => {\n    if (Math.random() > 0.2) {\n      throw new Error(\"Transient error\")\n    }\n    return \"Operation succeeded!\"\n  },\n  catch: (error: unknown) => {\n    Effect.logInfo(\"Operation failed, retrying...\")\n    return error\n  }\n})\n\n// --- Building a Composable Schedule ---\n\n// 1. Start with a base exponential backoff (100ms, 200ms, 400ms...)\nconst exponentialBackoff = Schedule.exponential(\"100 millis\")\n\n// 2. Add random jitter to avoid thundering herd problems\nconst withJitter = Schedule.jittered(exponentialBackoff)\n\n// 3. Limit the schedule to a maximum of 5 repetitions\nconst limitedWithJitter = Schedule.compose(\n  withJitter,\n  Schedule.recurs(5)\n)\n\n// --- Using the Schedule ---\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting operation...\")\n  const result = yield* Effect.retry(flakyEffect, limitedWithJitter)\n  yield* Effect.logInfo(`Final result: ${result}`)\n})\n\n// Run the program\nEffect.runPromise(program)\n```\n\n---"
  },
  {
    "path": "rules/cursor/create-a-service-layer-from-a-managed-resource.mdc",
    "description": "Provide a managed resource to the application context using `Layer.scoped`.",
    "content": "# Create a Service Layer from a Managed Resource\n**Rule:** Provide a managed resource to the application context using `Layer.scoped`.\n\n### Example\n```typescript\nimport { Effect, Console } from \"effect\";\n\n// 1. Define the service interface\ninterface DatabaseService {\n  readonly query: (sql: string) => Effect.Effect<string[], never, never>\n}\n\n// 2. Define the service implementation with scoped resource management\nclass Database extends Effect.Service<DatabaseService>()(\n  \"Database\",\n  {\n    // The scoped property manages the resource lifecycle\n    scoped: Effect.gen(function* () {\n      const id = Math.floor(Math.random() * 1000);\n      \n      // Acquire the connection\n      yield* Console.log(`[Pool ${id}] Acquired`);\n      \n      // Setup cleanup to run when scope closes\n      yield* Effect.addFinalizer(() => \n        Console.log(`[Pool ${id}] Released`)\n      );\n      \n      // Return the service implementation\n      return {\n        query: (sql: string) => Effect.sync(() => \n          [`Result for '${sql}' from pool ${id}`]\n        )\n      };\n    })\n  }\n) {}\n\n// 3. Use the service in your program\nconst program = Effect.gen(function* () {\n  const db = yield* Database;\n  const users = yield* db.query(\"SELECT * FROM users\");\n  yield* Console.log(`Query successful: ${users[0]}`);\n});\n\n// 4. Run the program with scoped resource management\nEffect.runPromise(\n  Effect.scoped(program).pipe(\n    Effect.provide(Database.Default)\n  )\n);\n\n/*\nOutput:\n[Pool 458] Acquired\nQuery successful: Result for 'SELECT * FROM users' from pool 458\n[Pool 458] Released\n*/\n```\n\n**Explanation:**\nThe `Effect.Service` helper creates the `Database` class with a `scoped` implementation. When `program` asks for the `Database` service, the Effect runtime creates a new connection pool, logs the acquisition, and automatically releases it when the scope closes. The `scoped` implementation ensures proper resource lifecycle management - the pool is acquired when first needed and released when the scope ends."
  },
  {
    "path": "rules/cursor/create-a-testable-http-client-service.mdc",
    "description": "Define an HttpClient service with distinct Live and Test layers to enable testable API interactions.",
    "content": "# Create a Testable HTTP Client Service\n**Rule:** Define an HttpClient service with distinct Live and Test layers to enable testable API interactions.\n\n### Example\n### 1. Define the Service\n\n```typescript\nimport { Effect, Data, Layer } from \"effect\"\n\ninterface HttpErrorType {\n  readonly _tag: \"HttpError\"\n  readonly error: unknown\n}\n\nconst HttpError = Data.tagged<HttpErrorType>(\"HttpError\")\n\ninterface HttpClientType {\n  readonly get: <T>(url: string) => Effect.Effect<T, HttpErrorType>\n}\n\nclass HttpClient extends Effect.Service<HttpClientType>()(\n  \"HttpClient\",\n  {\n    sync: () => ({\n      get: <T>(url: string): Effect.Effect<T, HttpErrorType> =>\n        Effect.tryPromise({\n          try: () => fetch(url).then((res) => res.json()),\n          catch: (error) => HttpError({ error })\n        })\n    })\n  }\n) {}\n\n// Test implementation\nconst TestLayer = Layer.succeed(\n  HttpClient,\n  HttpClient.of({\n    get: <T>(_url: string) => Effect.succeed({ title: \"Mock Data\" } as T)\n  })\n)\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const client = yield* HttpClient\n  yield* Effect.logInfo(\"Fetching data...\")\n  const data = yield* client.get<{ title: string }>(\"https://api.example.com/data\")\n  yield* Effect.logInfo(`Received data: ${JSON.stringify(data)}`)\n})\n\n// Run with test implementation\nEffect.runPromise(\n  Effect.provide(program, TestLayer)\n)\n```\n\n### 2. Create the Live Implementation\n\n```typescript\nimport { Effect, Data, Layer } from \"effect\"\n\ninterface HttpErrorType {\n  readonly _tag: \"HttpError\"\n  readonly error: unknown\n}\n\nconst HttpError = Data.tagged<HttpErrorType>(\"HttpError\")\n\ninterface HttpClientType {\n  readonly get: <T>(url: string) => Effect.Effect<T, HttpErrorType>\n}\n\nclass HttpClient extends Effect.Service<HttpClientType>()(\n  \"HttpClient\",\n  {\n    sync: () => ({\n      get: <T>(url: string): Effect.Effect<T, HttpErrorType> =>\n        Effect.tryPromise({\n          try: () => fetch(url).then((res) => res.json()),\n          catch: (error) => HttpError({ error })\n        })\n    })\n  }\n) {}\n\n// Test implementation\nconst TestLayer = Layer.succeed(\n  HttpClient,\n  HttpClient.of({\n    get: <T>(_url: string) => Effect.succeed({ title: \"Mock Data\" } as T)\n  })\n)\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const client = yield* HttpClient\n  yield* Effect.logInfo(\"Fetching data...\")\n  const data = yield* client.get<{ title: string }>(\"https://api.example.com/data\")\n  yield* Effect.logInfo(`Received data: ${JSON.stringify(data)}`)\n})\n\n// Run with test implementation\nEffect.runPromise(\n  Effect.provide(program, TestLayer)\n)\n```\n\n### 3. Create the Test Implementation\n\n```typescript\n// src/services/HttpClientTest.ts\nimport { Effect, Layer } from \"effect\";\nimport { HttpClient } from \"./HttpClient\";\n\nexport const HttpClientTest = Layer.succeed(\n  HttpClient,\n  HttpClient.of({\n    get: (url) => Effect.succeed({ mock: \"data\", url }),\n  }),\n);\n```\n\n### 4. Usage in Business Logic\n\nYour business logic is now clean and only depends on the abstract `HttpClient`.\n\n```typescript\n// src/features/User/UserService.ts\nimport { Effect } from \"effect\";\nimport { HttpClient } from \"../../services/HttpClient\";\n\nexport const getUserFromApi = (id: number) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient;\n    const data = yield* client.get(`https://api.example.com/users/${id}`);\n    // ... logic to parse and return user\n    return data;\n  });\n```\n\n---"
  },
  {
    "path": "rules/cursor/define-a-type-safe-configuration-schema.mdc",
    "description": "Define a type-safe configuration schema.",
    "content": "# Define a Type-Safe Configuration Schema\n**Rule:** Define a type-safe configuration schema.\n\n### Example\n```typescript\nimport { Config, Effect, ConfigProvider, Layer } from \"effect\"\n\nconst ServerConfig = Config.nested(\"SERVER\")(\n  Config.all({\n    host: Config.string(\"HOST\"),\n    port: Config.number(\"PORT\"),\n  })\n)\n\n// Example program that uses the config\nconst program = Effect.gen(function* () {\n  const config = yield* ServerConfig\n  yield* Effect.logInfo(`Server config loaded: ${JSON.stringify(config)}`)\n})\n\n// Create a config provider with test values\nconst TestConfig = ConfigProvider.fromMap(\n  new Map([\n    [\"SERVER.HOST\", \"localhost\"],\n    [\"SERVER.PORT\", \"3000\"]\n  ])\n)\n\n// Run with test config\nEffect.runPromise(\n  Effect.provide(\n    program,\n    Layer.setConfigProvider(TestConfig)\n  )\n)\n```\n\n**Explanation:**  \nThis schema ensures that both `host` and `port` are present and properly typed, and that their source is clearly defined."
  },
  {
    "path": "rules/cursor/define-contracts-upfront-with-schema.mdc",
    "description": "Define contracts upfront with schema.",
    "content": "# Define Contracts Upfront with Schema\n**Rule:** Define contracts upfront with schema.\n\n### Example\n```typescript\nimport { Schema, Effect, Data } from \"effect\"\n\n// Define User schema and type\nconst UserSchema = Schema.Struct({\n  id: Schema.Number,\n  name: Schema.String\n})\n\ntype User = Schema.Schema.Type<typeof UserSchema>\n\n// Define error type\nclass UserNotFound extends Data.TaggedError(\"UserNotFound\")<{\n  readonly id: number\n}> {}\n\n// Create database service implementation\nexport class Database extends Effect.Service<Database>()(\n  \"Database\",\n  {\n    sync: () => ({\n      getUser: (id: number) =>\n        id === 1\n          ? Effect.succeed({ id: 1, name: \"John\" })\n          : Effect.fail(new UserNotFound({ id }))\n    })\n  }\n) {}\n\n// Create a program that demonstrates schema and error handling\nconst program = Effect.gen(function* () {\n  const db = yield* Database\n  \n  // Try to get an existing user\n  yield* Effect.logInfo(\"Looking up user 1...\")\n  const user1 = yield* db.getUser(1)\n  yield* Effect.logInfo(`Found user: ${JSON.stringify(user1)}`)\n  \n  // Try to get a non-existent user\n  yield* Effect.logInfo(\"\\nLooking up user 999...\")\n  yield* Effect.logInfo(\"Attempting to get user 999...\")\n  yield* Effect.gen(function* () {\n    const user = yield* db.getUser(999)\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchAll((error) => {\n      if (error instanceof UserNotFound) {\n        return Effect.logInfo(`Error: User with id ${error.id} not found`)\n      }\n      return Effect.logInfo(`Unexpected error: ${error}`)\n    })\n  )\n\n  // Try to decode invalid data\n  yield* Effect.logInfo(\"\\nTrying to decode invalid user data...\")\n  const invalidUser = { id: \"not-a-number\", name: 123 } as any\n  yield* Effect.gen(function* () {\n    const user = yield* Schema.decode(UserSchema)(invalidUser)\n    yield* Effect.logInfo(`Decoded user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.logInfo(`Validation failed:\\n${JSON.stringify(error, null, 2)}`)\n    )\n  )\n})\n\n// Run the program\nEffect.runPromise(\n  Effect.provide(program, Database.Default)\n)\n```\n\n**Explanation:**  \nDefining schemas upfront clarifies your contracts and ensures both type safety\nand runtime validation."
  },
  {
    "path": "rules/cursor/define-type-safe-errors-with-data-taggederror.mdc",
    "description": "Define type-safe errors with Data.TaggedError.",
    "content": "# Define Type-Safe Errors with Data.TaggedError\n**Rule:** Define type-safe errors with Data.TaggedError.\n\n### Example\n```typescript\nimport { Data, Effect } from \"effect\"\n\n// Define our tagged error type\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\")<{\n  readonly cause: unknown\n}> {}\n\n// Function that simulates a database error\nconst findUser = (id: number): Effect.Effect<{ id: number; name: string }, DatabaseError> =>\n  Effect.gen(function* () {\n    if (id < 0) {\n      return yield* Effect.fail(new DatabaseError({ cause: \"Invalid ID\" }))\n    }\n    return { id, name: `User ${id}` }\n  })\n\n// Create a program that demonstrates error handling\nconst program = Effect.gen(function* () {\n  // Try to find a valid user\n  yield* Effect.logInfo(\"Looking up user 1...\")\n  yield* Effect.gen(function* () {\n    const user = yield* findUser(1)\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.logInfo(`Error finding user: ${error._tag} - ${error.cause}`)\n    )\n  )\n\n  // Try to find an invalid user\n  yield* Effect.logInfo(\"\\nLooking up user -1...\")\n  yield* Effect.gen(function* () {\n    const user = yield* findUser(-1)\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`)\n  }).pipe(\n    Effect.catchTag(\"DatabaseError\", (error) =>\n      Effect.logInfo(`Database error: ${error._tag} - ${error.cause}`)\n    )\n  )\n})\n\n// Run the program\nEffect.runPromise(program)\n```\n\n**Explanation:**  \nTagged errors allow you to handle errors in a type-safe, self-documenting way."
  },
  {
    "path": "rules/cursor/distinguish-not-found-from-errors.mdc",
    "description": "Use Effect<Option<A>> to distinguish between recoverable 'not found' cases and actual failures.",
    "content": "# Distinguish 'Not Found' from Errors\n**Rule:** Use Effect<Option<A>> to distinguish between recoverable 'not found' cases and actual failures.\n\n### Example\nThis function to find a user can fail if the database is down, or it can succeed but find no user. The return type ``Effect.Effect<Option.Option<User>, DatabaseError>`` makes this contract perfectly clear.\n\n````typescript\nimport { Effect, Option, Data } from \"effect\"\n\ninterface User {\n  id: number\n  name: string\n}\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\") {}\n\n// This signature is extremely honest about its possible outcomes.\nconst findUserInDb = (\n  id: number\n): Effect.Effect<Option.Option<User>, DatabaseError> =>\n  Effect.gen(function* () {\n    // This could fail with a DatabaseError\n    const dbResult = yield* Effect.try({\n      try: () => (id === 1 ? { id: 1, name: \"Paul\" } : null),\n      catch: () => new DatabaseError()\n    })\n\n    // We wrap the potentially null result in an Option\n    return Option.fromNullable(dbResult)\n  })\n\n// The caller can now handle all three cases explicitly.\nconst program = (id: number) =>\n  findUserInDb(id).pipe(\n    Effect.flatMap((maybeUser) =>\n      Option.match(maybeUser, {\n        onNone: () =>\n          Effect.logInfo(`Result: User with ID ${id} was not found.`),\n        onSome: (user) =>\n          Effect.logInfo(`Result: Found user ${user.name}.`)\n      })\n    ),\n    Effect.catchAll((error) =>\n      Effect.logInfo(\"Error: Could not connect to the database.\")\n    )\n  )\n\n// Run the program with different IDs\nEffect.runPromise(\n  Effect.gen(function* () {\n    // Try with existing user\n    yield* Effect.logInfo(\"Looking for user with ID 1...\")\n    yield* program(1)\n\n    // Try with non-existent user\n    yield* Effect.logInfo(\"\\nLooking for user with ID 2...\")\n    yield* program(2)\n  })\n)\n````"
  },
  {
    "path": "rules/cursor/handle-api-errors.mdc",
    "description": "Model application errors as typed classes and use Http.server.serveOptions to map them to specific HTTP responses.",
    "content": "# Handle API Errors\n**Rule:** Model application errors as typed classes and use Http.server.serveOptions to map them to specific HTTP responses.\n\n### Example\nThis example defines two custom error types, `UserNotFoundError` and `InvalidIdError`. The route logic can fail with either. The `unhandledErrorResponse` function inspects the error and returns a `404` or `400` response accordingly, with a generic `500` for any other unexpected errors.\n\n```typescript\nimport { Cause, Data, Effect } from 'effect';\n\n// Define our domain types\nexport interface User {\n  readonly id: string;\n  readonly name: string;\n  readonly email: string;\n  readonly role: 'admin' | 'user';\n}\n\n// Define specific, typed errors for our domain\nexport class UserNotFoundError extends Data.TaggedError('UserNotFoundError')<{\n  readonly id: string;\n}> { }\n\nexport class InvalidIdError extends Data.TaggedError('InvalidIdError')<{\n  readonly id: string;\n  readonly reason: string;\n}> { }\n\nexport class UnauthorizedError extends Data.TaggedError('UnauthorizedError')<{\n  readonly action: string;\n  readonly role: string;\n}> { }\n\n// Define error handler service\nexport class ErrorHandlerService extends Effect.Service<ErrorHandlerService>()(\n  'ErrorHandlerService',\n  {\n    sync: () => ({\n      // Handle API errors with proper logging\n      handleApiError: <E>(error: E): Effect.Effect<ApiResponse, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logError(`API Error: ${JSON.stringify(error)}`);\n\n          if (error instanceof UserNotFoundError) {\n            return { error: 'Not Found', message: `User ${error.id} not found` };\n          }\n          if (error instanceof InvalidIdError) {\n            return { error: 'Bad Request', message: error.reason };\n          }\n          if (error instanceof UnauthorizedError) {\n            return { error: 'Unauthorized', message: `${error.role} cannot ${error.action}` };\n          }\n\n          return { error: 'Internal Server Error', message: 'An unexpected error occurred' };\n        }),\n\n      // Handle unexpected errors\n      handleUnexpectedError: (cause: Cause.Cause<unknown>): Effect.Effect<void, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logError('Unexpected error occurred');\n\n          if (Cause.isDie(cause)) {\n            const defect = Cause.failureOption(cause);\n            if (defect._tag === 'Some') {\n              const error = defect.value as Error;\n              yield* Effect.logError(`Defect: ${error.message}`);\n              yield* Effect.logError(`Stack: ${error.stack?.split('\\n')[1]?.trim() ?? 'N/A'}`);\n            }\n          }\n\n          return Effect.succeed(void 0);\n        })\n    })\n  }\n) { }\n\n// Define UserRepository service\nexport class UserRepository extends Effect.Service<UserRepository>()(\n  'UserRepository',\n  {\n    sync: () => {\n      const users = new Map<string, User>([\n        ['user_123', { id: 'user_123', name: 'Paul', email: 'paul@example.com', role: 'admin' }],\n        ['user_456', { id: 'user_456', name: 'Alice', email: 'alice@example.com', role: 'user' }]\n      ]);\n\n      return {\n        // Get user by ID with proper error handling\n        getUser: (id: string): Effect.Effect<User, UserNotFoundError | InvalidIdError> =>\n          Effect.gen(function* () {\n            yield* Effect.logInfo(`Attempting to get user with id: ${id}`);\n\n            // Validate ID format\n            if (!id.match(/^user_\\d+$/)) {\n              yield* Effect.logWarning(`Invalid user ID format: ${id}`);\n              return yield* Effect.fail(new InvalidIdError({\n                id,\n                reason: 'ID must be in format user_<number>'\n              }));\n            }\n\n            const user = users.get(id);\n            if (user === undefined) {\n              yield* Effect.logWarning(`User not found with id: ${id}`);\n              return yield* Effect.fail(new UserNotFoundError({ id }));\n            }\n\n            yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n            return user;\n          }),\n\n        // Check if user has required role\n        checkRole: (user: User, requiredRole: 'admin' | 'user'): Effect.Effect<void, UnauthorizedError> =>\n          Effect.gen(function* () {\n            yield* Effect.logInfo(`Checking if user ${user.id} has role: ${requiredRole}`);\n\n            if (user.role !== requiredRole && user.role !== 'admin') {\n              yield* Effect.logWarning(`User ${user.id} with role ${user.role} cannot access ${requiredRole} resources`);\n              return yield* Effect.fail(new UnauthorizedError({\n                action: 'access_user',\n                role: user.role\n              }));\n            }\n\n            yield* Effect.logInfo(`User ${user.id} has required role: ${user.role}`);\n            return Effect.succeed(void 0);\n          })\n      };\n    }\n  }\n) { }\n\ninterface ApiResponse {\n  readonly error?: string;\n  readonly message?: string;\n  readonly data?: User;\n}\n\n// Create routes with proper error handling\nconst createRoutes = () => Effect.gen(function* () {\n  const repo = yield* UserRepository;\n  const errorHandler = yield* ErrorHandlerService;\n\n  yield* Effect.logInfo('=== Processing API request ===');\n\n  // Test different scenarios\n  for (const userId of ['user_123', 'user_456', 'invalid_id', 'user_789']) {\n    yield* Effect.logInfo(`\\n--- Testing user ID: ${userId} ---`);\n\n    const response = yield* repo.getUser(userId).pipe(\n      Effect.map(user => ({\n        data: {\n          ...user,\n          email: user.role === 'admin' ? user.email : '[hidden]'\n        }\n      })),\n      Effect.catchAll(error => errorHandler.handleApiError(error))\n    );\n\n    yield* Effect.logInfo(`Response: ${JSON.stringify(response)}`);\n  }\n\n  // Test role checking\n  const adminUser = yield* repo.getUser('user_123');\n  const regularUser = yield* repo.getUser('user_456');\n\n  yield* Effect.logInfo('\\n=== Testing role checks ===');\n\n  yield* repo.checkRole(adminUser, 'admin').pipe(\n    Effect.tap(() => Effect.logInfo('Admin access successful')),\n    Effect.catchAll(error => errorHandler.handleApiError(error))\n  );\n\n  yield* repo.checkRole(regularUser, 'admin').pipe(\n    Effect.tap(() => Effect.logInfo('User admin access successful')),\n    Effect.catchAll(error => errorHandler.handleApiError(error))\n  );\n\n  return { message: 'Tests completed successfully' };\n});\n\n// Run the program with all services\nEffect.runPromise(\n  Effect.provide(\n    Effect.provide(\n      createRoutes(),\n      ErrorHandlerService.Default\n    ),\n    UserRepository.Default\n  )\n);\n```"
  },
  {
    "path": "rules/cursor/handle-errors-with-catchtag-catchtags-and-catchall.mdc",
    "description": "Handle errors with catchTag, catchTags, and catchAll.",
    "content": "# Handle Errors with catchTag, catchTags, and catchAll\n**Rule:** Handle errors with catchTag, catchTags, and catchAll.\n\n### Example\n```typescript\nimport { Data, Effect } from \"effect\";\n\n// Define domain types\ninterface User {\n  readonly id: string;\n  readonly name: string;\n}\n\n// Define specific error types\nclass NetworkError extends Data.TaggedError(\"NetworkError\")<{\n  readonly url: string;\n  readonly code: number;\n}> { }\n\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly field: string;\n  readonly message: string;\n}> { }\n\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{\n  readonly id: string;\n}> { }\n\n// Define UserService\nclass UserService extends Effect.Service<UserService>()(\"UserService\", {\n  sync: () => ({\n    // Fetch user data\n    fetchUser: (\n      id: string\n    ): Effect.Effect<User, NetworkError | NotFoundError> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Fetching user with id: ${id}`);\n\n        if (id === \"invalid\") {\n          const url = \"/api/users/\" + id;\n          yield* Effect.logWarning(`Network error accessing: ${url}`);\n          return yield* Effect.fail(new NetworkError({ url, code: 500 }));\n        }\n\n        if (id === \"missing\") {\n          yield* Effect.logWarning(`User not found: ${id}`);\n          return yield* Effect.fail(new NotFoundError({ id }));\n        }\n\n        const user = { id, name: \"John Doe\" };\n        yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n        return user;\n      }),\n\n    // Validate user data\n    validateUser: (user: User): Effect.Effect<string, ValidationError> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Validating user: ${JSON.stringify(user)}`);\n\n        if (user.name.length < 3) {\n          yield* Effect.logWarning(\n            `Validation failed: name too short for user ${user.id}`\n          );\n          return yield* Effect.fail(\n            new ValidationError({ field: \"name\", message: \"Name too short\" })\n          );\n        }\n\n        const message = `User ${user.name} is valid`;\n        yield* Effect.logInfo(message);\n        return message;\n      }),\n  }),\n}) { }\n\n// Compose operations with error handling using catchTags\nconst processUser = (\n  userId: string\n): Effect.Effect<string, never, UserService> =>\n  Effect.gen(function* () {\n    const userService = yield* UserService;\n\n    yield* Effect.logInfo(`=== Processing user ID: ${userId} ===`);\n\n    const result = yield* userService.fetchUser(userId).pipe(\n      Effect.flatMap(userService.validateUser),\n      // Handle different error types with specific recovery logic\n      Effect.catchTags({\n        NetworkError: (e) =>\n          Effect.gen(function* () {\n            const message = `Network error: ${e.code} for ${e.url}`;\n            yield* Effect.logError(message);\n            return message;\n          }),\n        NotFoundError: (e) =>\n          Effect.gen(function* () {\n            const message = `User ${e.id} not found`;\n            yield* Effect.logWarning(message);\n            return message;\n          }),\n        ValidationError: (e) =>\n          Effect.gen(function* () {\n            const message = `Invalid ${e.field}: ${e.message}`;\n            yield* Effect.logWarning(message);\n            return message;\n          }),\n      })\n    );\n\n    yield* Effect.logInfo(`Result: ${result}`);\n    return result;\n  });\n\n// Test with different scenarios\nconst runTests = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Starting User Processing Tests ===\");\n\n  const testCases = [\"valid\", \"invalid\", \"missing\"];\n  const results = yield* Effect.forEach(testCases, (id) => processUser(id));\n\n  yield* Effect.logInfo(\"=== User Processing Tests Complete ===\");\n  return results;\n});\n\n// Run the program\nEffect.runPromise(Effect.provide(runTests, UserService.Default));\n\n```\n\n**Explanation:**  \nUse `catchTag` to handle specific error types in a type-safe, composable way."
  },
  {
    "path": "rules/cursor/handle-flaky-operations-with-retries-and-timeouts.mdc",
    "description": "Use Effect.retry and Effect.timeout to build resilience against slow or intermittently failing effects.",
    "content": "# Handle Flaky Operations with Retries and Timeouts\n**Rule:** Use Effect.retry and Effect.timeout to build resilience against slow or intermittently failing effects.\n\n### Example\nThis program attempts to fetch data from a flaky API. It will retry the request up to 3 times with increasing delays if it fails. It will also give up entirely if any single attempt takes longer than 2 seconds.\n\n```typescript\nimport { Data, Duration, Effect, Schedule } from \"effect\";\n\n// Define domain types\ninterface ApiResponse {\n  readonly data: string;\n}\n\n// Define error types\nclass ApiError extends Data.TaggedError(\"ApiError\")<{\n  readonly message: string;\n  readonly attempt: number;\n}> { }\n\nclass TimeoutError extends Data.TaggedError(\"TimeoutError\")<{\n  readonly duration: string;\n  readonly attempt: number;\n}> { }\n\n// Define API service\nclass ApiService extends Effect.Service<ApiService>()(\n  \"ApiService\",\n  {\n    sync: () => ({\n      // Flaky API call that might fail or be slow\n      fetchData: (): Effect.Effect<ApiResponse, ApiError | TimeoutError> =>\n        Effect.gen(function* () {\n          const attempt = Math.floor(Math.random() * 5) + 1;\n          yield* Effect.logInfo(`Attempt ${attempt}: Making API call...`);\n\n          if (Math.random() > 0.3) {\n            yield* Effect.logWarning(`Attempt ${attempt}: API call failed`);\n            return yield* Effect.fail(new ApiError({\n              message: \"API Error\",\n              attempt\n            }));\n          }\n\n          const delay = Math.random() * 3000;\n          yield* Effect.logInfo(`Attempt ${attempt}: API call will take ${delay.toFixed(0)}ms`);\n\n          yield* Effect.sleep(Duration.millis(delay));\n\n          const response = { data: \"some important data\" };\n          yield* Effect.logInfo(`Attempt ${attempt}: API call succeeded with data: ${JSON.stringify(response)}`);\n          return response;\n        })\n    })\n  }\n) { }\n\n// Define retry policy: exponential backoff, up to 3 retries\nconst retryPolicy = Schedule.exponential(Duration.millis(100)).pipe(\n  Schedule.compose(Schedule.recurs(3)),\n  Schedule.tapInput((error: ApiError | TimeoutError) =>\n    Effect.logWarning(`Retrying after error: ${error._tag} (Attempt ${error.attempt})`)\n  )\n);\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const api = yield* ApiService;\n\n  yield* Effect.logInfo(\"=== Starting API calls with retry and timeout ===\");\n\n  // Make multiple test calls\n  for (let i = 1; i <= 3; i++) {\n    yield* Effect.logInfo(`\\n--- Test Call ${i} ---`);\n\n    const result = yield* api.fetchData().pipe(\n      Effect.timeout(Duration.seconds(2)),\n      Effect.catchTag(\"TimeoutException\", () =>\n        Effect.fail(new TimeoutError({ duration: \"2 seconds\", attempt: i }))\n      ),\n      Effect.retry(retryPolicy),\n      Effect.catchTags({\n        ApiError: (error) =>\n          Effect.gen(function* () {\n            yield* Effect.logError(`All retries failed: ${error.message} (Last attempt: ${error.attempt})`);\n            return { data: \"fallback data due to API error\" } as ApiResponse;\n          }),\n        TimeoutError: (error) =>\n          Effect.gen(function* () {\n            yield* Effect.logError(`All retries timed out after ${error.duration} (Last attempt: ${error.attempt})`);\n            return { data: \"fallback data due to timeout\" } as ApiResponse;\n          })\n      })\n    );\n\n    yield* Effect.logInfo(`Result: ${JSON.stringify(result)}`);\n  }\n\n  yield* Effect.logInfo(\"\\n=== API calls complete ===\");\n});\n\n// Run the program\nEffect.runPromise(\n  Effect.provide(program, ApiService.Default)\n);\n```\n\n---"
  },
  {
    "path": "rules/cursor/leverage-effect-s-built-in-structured-logging.mdc",
    "description": "Leverage Effect's built-in structured logging.",
    "content": "# Leverage Effect's Built-in Structured Logging\n**Rule:** Leverage Effect's built-in structured logging.\n\n### Example\n```typescript\nimport { Effect } from \"effect\";\n\nconst program = Effect.logDebug(\"Processing user\", { userId: 123 });\n\n// Run the program with debug logging enabled\nEffect.runSync(\n  program.pipe(\n    Effect.tap(() => Effect.log(\"Debug logging enabled\"))\n  )\n);\n```\n\n**Explanation:**  \nUsing Effect's logging system ensures your logs are structured, filterable,\nand context-aware."
  },
  {
    "path": "rules/cursor/make-an-outgoing-http-client-request.mdc",
    "description": "Use the Http.client module to make outgoing requests to keep the entire operation within the Effect ecosystem.",
    "content": "# Make an Outgoing HTTP Client Request\n**Rule:** Use the Http.client module to make outgoing requests to keep the entire operation within the Effect ecosystem.\n\n### Example\nThis example creates a proxy endpoint. A request to `/proxy/posts/1` on our server will trigger an outgoing request to the JSONPlaceholder API. The response is then parsed and relayed back to the original client.\n\n```typescript\nimport { NodeHttpServer, NodeRuntime } from \"@effect/platform-node\";\nimport * as HttpRouter from \"@effect/platform/HttpRouter\";\nimport * as HttpServer from \"@effect/platform/HttpServer\";\nimport * as HttpResponse from \"@effect/platform/HttpServerResponse\";\nimport { Console, Data, Duration, Effect, Fiber, Layer } from \"effect\";\n\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\")<{\n  id: string;\n}> { }\n\nexport class Database extends Effect.Service<Database>()(\"Database\", {\n  sync: () => ({\n    getUser: (id: string) =>\n      id === \"123\"\n        ? Effect.succeed({ name: \"Paul\" })\n        : Effect.fail(new UserNotFoundError({ id })),\n  }),\n}) { }\n\nconst userHandler = Effect.flatMap(HttpRouter.params, (p) =>\n  Effect.flatMap(Database, (db) => db.getUser(p[\"userId\"] ?? \"\")).pipe(\n    Effect.flatMap(HttpResponse.json)\n  )\n);\n\nconst app = HttpRouter.empty.pipe(\n  HttpRouter.get(\"/users/:userId\", userHandler)\n);\n\nconst server = NodeHttpServer.layer(() => require(\"node:http\").createServer(), {\n  port: 3457,\n});\n\nconst serverLayer = HttpServer.serve(app);\n\nconst mainLayer = Layer.merge(Database.Default, server);\n\nconst program = Effect.gen(function* () {\n  yield* Console.log(\"Server started on http://localhost:3457\");\n  const layer = Layer.provide(serverLayer, mainLayer);\n\n  // Launch server and run for a short duration to demonstrate\n  const serverFiber = yield* Layer.launch(layer).pipe(Effect.fork);\n\n  // Wait a moment for server to start\n  yield* Effect.sleep(Duration.seconds(1));\n\n  // Simulate some server activity\n  yield* Console.log(\"Server is running and ready to handle requests\");\n  yield* Effect.sleep(Duration.seconds(2));\n\n  // Shutdown gracefully\n  yield* Fiber.interrupt(serverFiber);\n  yield* Console.log(\"Server shutdown complete\");\n});\n\nNodeRuntime.runMain(\n  Effect.provide(program, Layer.provide(serverLayer, Layer.merge(Database.Default, server))) as Effect.Effect<void, unknown, never>\n);\n\n```"
  },
  {
    "path": "rules/cursor/manage-shared-state-safely-with-ref.mdc",
    "description": "Use Ref to manage shared, mutable state concurrently, ensuring atomicity.",
    "content": "# Manage Shared State Safely with Ref\n**Rule:** Use Ref to manage shared, mutable state concurrently, ensuring atomicity.\n\n### Example\nThis program simulates 1,000 concurrent fibers all trying to increment a shared counter. Because we use `Ref.update`, every single increment is applied atomically, and the final result is always correct.\n\n```typescript\nimport { Effect, Ref } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  // Create a new Ref with an initial value of 0\n  const ref = yield* Ref.make(0);\n\n  // Define an effect that increments the counter by 1\n  const increment = Ref.update(ref, (n) => n + 1);\n\n  // Create an array of 1,000 increment effects\n  const tasks = Array.from({ length: 1000 }, () => increment);\n\n  // Run all 1,000 effects concurrently\n  yield* Effect.all(tasks, { concurrency: \"unbounded\" });\n\n  // Get the final value of the counter\n  return yield* Ref.get(ref);\n});\n\n// The result will always be 1000\nEffect.runPromise(program).then(console.log);\n\n```\n\n---"
  },
  {
    "path": "rules/cursor/mapping-errors-to-fit-your-domain.mdc",
    "description": "Use Effect.mapError to transform errors and create clean architectural boundaries between layers.",
    "content": "# Mapping Errors to Fit Your Domain\n**Rule:** Use Effect.mapError to transform errors and create clean architectural boundaries between layers.\n\n### Example\nA `UserRepository` uses a `Database` service. The `Database` can fail with specific errors, but the `UserRepository` maps them to a single, generic `RepositoryError` before they are exposed to the rest of the application.\n\n```typescript\nimport { Effect, Data } from \"effect\";\n\n// Low-level, specific errors from the database layer\nclass ConnectionError extends Data.TaggedError(\"ConnectionError\") {}\nclass QueryError extends Data.TaggedError(\"QueryError\") {}\n\n// A generic error for the repository layer\nclass RepositoryError extends Data.TaggedError(\"RepositoryError\")<{\n  readonly cause: unknown;\n}> {}\n\n// The inner service\nconst dbQuery = (): Effect.Effect<\n  { name: string },\n  ConnectionError | QueryError\n> => Effect.fail(new ConnectionError());\n\n// The outer service uses `mapError` to create a clean boundary.\n// Its public signature only exposes `RepositoryError`.\nconst findUser = (): Effect.Effect<{ name: string }, RepositoryError> =>\n  dbQuery().pipe(\n    Effect.mapError((error) => new RepositoryError({ cause: error }))\n  );\n\n// Demonstrate the error mapping\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Attempting to find user...\");\n\n  try {\n    const user = yield* findUser();\n    yield* Effect.logInfo(`Found user: ${user.name}`);\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      if (error instanceof RepositoryError) {\n        yield* Effect.logInfo(`Repository error occurred: ${error._tag}`);\n        if (error.cause instanceof ConnectionError || error.cause instanceof QueryError) {\n          yield* Effect.logInfo(`Original cause: ${error.cause._tag}`);\n        }\n      } else {\n        yield* Effect.logInfo(`Unexpected error: ${error}`);\n      }\n    })\n  )\n);\n\nEffect.runPromise(program);\n\n```\n\n---"
  },
  {
    "path": "rules/cursor/mocking-dependencies-in-tests.mdc",
    "description": "Provide mock service implementations via a test-specific Layer to isolate the unit under test.",
    "content": "# Mocking Dependencies in Tests\n**Rule:** Provide mock service implementations via a test-specific Layer to isolate the unit under test.\n\n### Example\nWe want to test a `Notifier` service that uses an `EmailClient` to send emails. In our test, we provide a mock `EmailClient` that doesn't actually send emails but just returns a success value.\n\n```typescript\nimport { Effect, Layer } from \"effect\";\n\n// --- The Services ---\ninterface EmailClientService {\n  send: (address: string, body: string) => Effect.Effect<void>\n}\n\nclass EmailClient extends Effect.Service<EmailClientService>()(\n  \"EmailClient\",\n  {\n    sync: () => ({\n      send: (address: string, body: string) => \n        Effect.sync(() => Effect.log(`Sending email to ${address}: ${body}`))\n    })\n  }\n) {}\n\ninterface NotifierService {\n  notifyUser: (userId: number, message: string) => Effect.Effect<void>\n}\n\nclass Notifier extends Effect.Service<NotifierService>()(\n  \"Notifier\",\n  {\n    effect: Effect.gen(function* () {\n      const emailClient = yield* EmailClient;\n      return {\n        notifyUser: (userId: number, message: string) =>\n          emailClient.send(`user-${userId}@example.com`, message)\n      };\n    }),\n    dependencies: [EmailClient.Default]\n  }\n) {}\n\n// Create a program that uses the Notifier service\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Using default EmailClient implementation...\");\n  const notifier = yield* Notifier;\n  yield* notifier.notifyUser(123, \"Your invoice is ready.\");\n\n  // Create mock EmailClient that logs differently\n  yield* Effect.log(\"\\nUsing mock EmailClient implementation...\");\n  const mockEmailClient = Layer.succeed(\n    EmailClient,\n    {\n      send: (address: string, body: string) =>\n        Effect.sync(() => \n          Effect.log(`MOCK: Would send to ${address} with body: ${body}`)\n        )\n    } as EmailClientService\n  );\n\n  // Run the same notification with mock client\n  yield* Effect.gen(function* () {\n    const notifier = yield* Notifier;\n    yield* notifier.notifyUser(123, \"Your invoice is ready.\");\n  }).pipe(\n    Effect.provide(mockEmailClient)\n  );\n});\n\n// Run the program\nEffect.runPromise(\n  Effect.provide(program, Notifier.Default)\n);\n```\n\n---"
  },
  {
    "path": "rules/cursor/model-dependencies-as-services.mdc",
    "description": "Model dependencies as services.",
    "content": "# Model Dependencies as Services\n**Rule:** Model dependencies as services.\n\n### Example\n```typescript\nimport { Effect } from \"effect\";\n\n// Define Random service with production implementation as default\nexport class Random extends Effect.Service<Random>()(\n  \"Random\",\n  {\n    // Default production implementation\n    sync: () => ({\n      next: Effect.sync(() => Math.random())\n    })\n  }\n) {}\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const random = yield* Random;\n  const value = yield* random.next;\n  return value;\n});\n\n// Run with default implementation\nEffect.runPromise(\n  Effect.provide(\n    program,\n    Random.Default\n  )\n).then(value => console.log('Random value:', value));\n```\n\n**Explanation:**  \nBy modeling dependencies as services, you can easily substitute mocked or deterministic implementations for testing, leading to more reliable and predictable tests."
  },
  {
    "path": "rules/cursor/model-optional-values-safely-with-option.mdc",
    "description": "Use Option<A> to explicitly model values that may be absent, avoiding null or undefined.",
    "content": "# Model Optional Values Safely with Option\n**Rule:** Use Option<A> to explicitly model values that may be absent, avoiding null or undefined.\n\n### Example\nA function that looks for a user in a database is a classic use case. It might find a user, or it might not. Returning an `Option<User>` makes this contract explicit and safe.\n\n```typescript\nimport { Option } from \"effect\";\n\ninterface User {\n  id: number;\n  name: string;\n}\n\nconst users: User[] = [\n  { id: 1, name: \"Paul\" },\n  { id: 2, name: \"Alex\" },\n];\n\n// This function safely returns an Option, not a User or null.\nconst findUserById = (id: number): Option.Option<User> => {\n  const user = users.find((u) => u.id === id);\n  return Option.fromNullable(user); // A useful helper for existing APIs\n};\n\n// The caller MUST handle both cases.\nconst greeting = (id: number): string =>\n  findUserById(id).pipe(\n    Option.match({\n      onNone: () => \"User not found.\",\n      onSome: (user) => `Welcome, ${user.name}!`,\n    }),\n  );\n\nconsole.log(greeting(1)); // \"Welcome, Paul!\"\nconsole.log(greeting(3)); // \"User not found.\"\n```"
  },
  {
    "path": "rules/cursor/model-validated-domain-types-with-brand.mdc",
    "description": "Model validated domain types with Brand.",
    "content": "# Model Validated Domain Types with Brand\n**Rule:** Model validated domain types with Brand.\n\n### Example\n```typescript\nimport { Brand, Option } from \"effect\";\n\ntype Email = string & Brand.Brand<\"Email\">;\n\nconst makeEmail = (s: string): Option.Option<Email> =>\n  s.includes(\"@\") ? Option.some(s as Email) : Option.none();\n\n// A function can now trust that its input is a valid email.\nconst sendEmail = (email: Email, body: string) => { /* ... */ };\n```\n\n**Explanation:**  \nBranding ensures that only validated values are used, reducing bugs and\nrepetitive checks."
  },
  {
    "path": "rules/cursor/parse-and-validate-data-with-schema-decode.mdc",
    "description": "Parse and validate data with Schema.decode.",
    "content": "# Parse and Validate Data with Schema.decode\n**Rule:** Parse and validate data with Schema.decode.\n\n### Example\n```typescript\nimport { Effect, Schema } from \"effect\";\n\ninterface User {\n  name: string;\n}\n\nconst UserSchema = Schema.Struct({\n  name: Schema.String,\n}) as Schema.Schema<User>;\n\nconst processUserInput = (input: unknown) =>\n  Effect.gen(function* () {\n    const user = yield* Schema.decodeUnknown(UserSchema)(input);\n    return `Welcome, ${user.name}!`;\n  }).pipe(\n    Effect.catchTag(\"ParseError\", () => Effect.succeed(\"Invalid user data.\"))\n  );\n\n// Demonstrate the schema parsing\nconst program = Effect.gen(function* () {\n  // Test with valid input\n  const validInput = { name: \"Paul\" };\n  const validResult = yield* processUserInput(validInput);\n  yield* Effect.logInfo(`Valid input result: ${validResult}`);\n\n  // Test with invalid input\n  const invalidInput = { age: 25 }; // Missing 'name' field\n  const invalidResult = yield* processUserInput(invalidInput);\n  yield* Effect.logInfo(`Invalid input result: ${invalidResult}`);\n\n  // Test with completely invalid input\n  const badInput = \"not an object\";\n  const badResult = yield* processUserInput(badInput);\n  yield* Effect.logInfo(`Bad input result: ${badResult}`);\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \n`Schema.decode` integrates parsing and validation into the Effect workflow,\nmaking error handling composable and type-safe."
  },
  {
    "path": "rules/cursor/process-a-collection-in-parallel-with-effect-foreach.mdc",
    "description": "Use Effect.forEach with the `concurrency` option to process a collection in parallel with a fixed limit.",
    "content": "# Process a Collection in Parallel with Effect.forEach\n**Rule:** Use Effect.forEach with the `concurrency` option to process a collection in parallel with a fixed limit.\n\n### Example\nImagine you have a list of 100 user IDs and you need to fetch the data for each one. `Effect.forEach` with a concurrency of 10 will process them in controlled parallel batches.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Mock function to simulate fetching a user by ID\nconst fetchUserById = (id: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching user ${id}...`);\n    yield* Effect.sleep(\"1 second\"); // Simulate network delay\n    return { id, name: `User ${id}`, email: `user${id}@example.com` };\n  });\n\nconst userIds = Array.from({ length: 10 }, (_, i) => i + 1);\n\n// Process the entire array, but only run 5 fetches at a time.\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting parallel processing...\");\n\n  const startTime = Date.now();\n  const users = yield* Effect.forEach(userIds, fetchUserById, {\n    concurrency: 5, // Limit to 5 concurrent operations\n  });\n  const endTime = Date.now();\n\n  yield* Effect.logInfo(\n    `Processed ${users.length} users in ${endTime - startTime}ms`\n  );\n  yield* Effect.logInfo(\n    `First few users: ${JSON.stringify(users.slice(0, 3), null, 2)}`\n  );\n\n  return users;\n});\n\n// The result will be an array of all user objects.\n// The total time will be much less than running them sequentially.\nEffect.runPromise(program);\n\n```\n\n---"
  },
  {
    "path": "rules/cursor/process-a-large-file-with-constant-memory.mdc",
    "description": "Use Stream.fromReadable with a Node.js Readable stream to process files efficiently.",
    "content": "# Process a Large File with Constant Memory\n**Rule:** Use Stream.fromReadable with a Node.js Readable stream to process files efficiently.\n\n### Example\nThis example demonstrates reading a text file, splitting it into individual lines, and processing each line. The combination of `Stream.fromReadable`, `Stream.decodeText`, and `Stream.splitLines` is a powerful and common pattern for handling text-based files.\n\n```typescript\nimport { FileSystem } from '@effect/platform';\nimport { NodeFileSystem } from '@effect/platform-node';\nimport type { PlatformError } from '@effect/platform/Error';\nimport { Effect, Stream } from 'effect';\nimport * as path from 'node:path';\n\nconst processFile = (\n  filePath: string,\n  content: string\n): Effect.Effect<void, PlatformError, FileSystem.FileSystem> =>\n  Effect.gen(function* () {\n    const fs = yield* FileSystem.FileSystem;\n\n    // Write content to file\n    yield* fs.writeFileString(filePath, content);\n\n    // Create a stream from file content\n    const fileStream = Stream.fromEffect(fs.readFileString(filePath))\n      .pipe(\n        // Split content into lines\n        Stream.map((content: string) => content.split('\\n')),\n        Stream.flatMap(Stream.fromIterable),\n        // Process each line\n        Stream.tap((line) => Effect.log(`Processing: ${line}`))\n      );\n\n    // Run the stream to completion\n    yield* Stream.runDrain(fileStream);\n\n    // Clean up file\n    yield* fs.remove(filePath);\n  });\n\nconst program = Effect.gen(function* () {\n  const filePath = path.join(__dirname, 'large-file.txt');\n\n  yield* processFile(\n    filePath,\n    'line 1\\nline 2\\nline 3'\n  ).pipe(\n    Effect.catchAll((error: PlatformError) =>\n      Effect.logError(`Error processing file: ${error.message}`)\n    )\n  );\n});\n\nEffect.runPromise(\n  program.pipe(\n    Effect.provide(NodeFileSystem.layer)\n  )\n).catch(console.error);\n/*\nOutput:\n... level=INFO msg=\"Processing: line 1\"\n... level=INFO msg=\"Processing: line 2\"\n... level=INFO msg=\"Processing: line 3\"\n*/\n```"
  },
  {
    "path": "rules/cursor/process-collections-of-data-asynchronously.mdc",
    "description": "Leverage Stream to process collections effectfully with built-in concurrency control and resource safety.",
    "content": "# Process collections of data asynchronously\n**Rule:** Leverage Stream to process collections effectfully with built-in concurrency control and resource safety.\n\n### Example\nThis example processes a list of IDs by fetching user data for each one. `Stream.mapEffect` is used to apply an effectful function (`getUserById`) to each element, with concurrency limited to 2 simultaneous requests.\n\n```typescript\nimport { Effect, Stream, Chunk } from 'effect';\n\n// A mock function that simulates fetching a user from a database\nconst getUserById = (id: number): Effect.Effect<{ id: number; name: string }, Error> =>\n  Effect.succeed({ id, name: `User ${id}` }).pipe(\n    Effect.delay('100 millis'),\n    Effect.tap(() => Effect.log(`Fetched user ${id}`))\n  );\n\n// The stream-based program\nconst program = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(\n  // Process each item with an Effect, limiting concurrency to 2\n  Stream.mapEffect(getUserById, { concurrency: 2 }),\n  // Run the stream and collect all results into a Chunk\n  Stream.runCollect\n);\n\nEffect.runPromise(program).then((users) => {\n  console.log('All users fetched:', Chunk.toArray(users));\n});\n```"
  },
  {
    "path": "rules/cursor/process-items-concurrently.mdc",
    "description": "Use Stream.mapEffect with the `concurrency` option to process stream items in parallel.",
    "content": "# Process Items Concurrently\n**Rule:** Use Stream.mapEffect with the `concurrency` option to process stream items in parallel.\n\n### Example\nThis example processes four items, each taking one second. By setting `concurrency: 2`, the total runtime is approximately two seconds instead of four, because items are processed in parallel pairs.\n\n```typescript\nimport { Effect, Stream } from 'effect';\n\n// A mock function that simulates a slow I/O operation\nconst processItem = (id: number): Effect.Effect<string, Error> =>\n  Effect.log(`Starting item ${id}...`).pipe(\n    Effect.delay('1 second'),\n    Effect.map(() => `Finished item ${id}`),\n    Effect.tap(Effect.log)\n  );\n\nconst ids = [1, 2, 3, 4];\n\nconst program = Stream.fromIterable(ids).pipe(\n  // Process up to 2 items concurrently\n  Stream.mapEffect(processItem, { concurrency: 2 }),\n  Stream.runDrain\n);\n\n// Measure the total time taken\nconst timedProgram = Effect.timed(program);\n\nEffect.runPromise(timedProgram).then(([duration, _]) => {\n  const durationMs = Number(duration);\n  console.log(`\\nTotal time: ${Math.round(durationMs / 1000)} seconds`);\n}).catch(console.error);\n/*\nOutput:\n... level=INFO msg=\"Starting item 1...\"\n... level=INFO msg=\"Starting item 2...\"\n... level=INFO msg=\"Finished item 1\"\n... level=INFO msg=\"Starting item 3...\"\n... level=INFO msg=\"Finished item 2\"\n... level=INFO msg=\"Starting item 4...\"\n... level=INFO msg=\"Finished item 3\"\n... level=INFO msg=\"Finished item 4\"\n\nTotal time: 2 seconds\n*/\n```"
  },
  {
    "path": "rules/cursor/process-items-in-batches.mdc",
    "description": "Use Stream.grouped(n) to transform a stream of items into a stream of batched chunks.",
    "content": "# Process Items in Batches\n**Rule:** Use Stream.grouped(n) to transform a stream of items into a stream of batched chunks.\n\n### Example\nThis example processes 10 users. By using `Stream.grouped(5)`, it transforms the stream of 10 individual users into a stream of two chunks (each a batch of 5). The `saveUsersInBulk` function is then called only twice, once for each batch.\n\n```typescript\nimport { Effect, Stream, Chunk } from 'effect';\n\n// A mock function that simulates a bulk database insert\nconst saveUsersInBulk = (\n  userBatch: Chunk.Chunk<{ id: number }>\n): Effect.Effect<void, Error> =>\n  Effect.log(\n    `Saving batch of ${userBatch.length} users: ${Chunk.toArray(userBatch)\n      .map((u) => u.id)\n      .join(', ')}`\n  );\n\nconst userIds = Array.from({ length: 10 }, (_, i) => ({ id: i + 1 }));\n\nconst program = Stream.fromIterable(userIds).pipe(\n  // Group the stream of users into batches of 5\n  Stream.grouped(5),\n  // Process each batch with our bulk save function\n  Stream.mapEffect(saveUsersInBulk, { concurrency: 1 }),\n  Stream.runDrain\n);\n\nEffect.runPromise(program);\n/*\nOutput:\n... level=INFO msg=\"Saving batch of 5 users: 1, 2, 3, 4, 5\"\n... level=INFO msg=\"Saving batch of 5 users: 6, 7, 8, 9, 10\"\n*/\n```"
  },
  {
    "path": "rules/cursor/process-streaming-data-with-stream.mdc",
    "description": "Use Stream to model and process data that arrives over time in a composable, efficient way.",
    "content": "# Process Streaming Data with Stream\n**Rule:** Use Stream to model and process data that arrives over time in a composable, efficient way.\n\n### Example\nThis example demonstrates creating a `Stream` from a paginated API. The `Stream` will make API calls as needed, processing one page of users at a time without ever holding the entire user list in memory.\n\n```typescript\nimport { Effect, Stream, Option } from \"effect\";\n\ninterface User {\n  id: number;\n  name: string;\n}\ninterface PaginatedResponse {\n  users: User[];\n  nextPage: number | null;\n}\n\n// A mock API call that returns a page of users\nconst fetchUserPage = (\n  page: number,\n): Effect.Effect<PaginatedResponse, \"ApiError\"> =>\n  Effect.succeed(\n    page < 3\n      ? {\n          users: [\n            { id: page * 2 + 1, name: `User ${page * 2 + 1}` },\n            { id: page * 2 + 2, name: `User ${page * 2 + 2}` },\n          ],\n          nextPage: page + 1,\n        }\n      : { users: [], nextPage: null },\n  ).pipe(Effect.delay(\"50 millis\"));\n\n// Stream.paginateEffect creates a stream from a paginated source\nconst userStream: Stream.Stream<User, \"ApiError\"> = Stream.paginateEffect(0, (page) =>\n  fetchUserPage(page).pipe(\n    Effect.map((response) => [\n      response.users,\n      Option.fromNullable(response.nextPage)\n    ] as const),\n  ),\n).pipe(\n  // Flatten the stream of user arrays into a stream of individual users\n  Stream.flatMap((users) => Stream.fromIterable(users)),\n);\n\n// We can now process the stream of users.\n// Stream.runForEach will pull from the stream until it's exhausted.\nconst program = Stream.runForEach(userStream, (user: User) =>\n  Effect.log(`Processing user: ${user.name}`),\n);\n\nEffect.runPromise(program).catch(console.error);\n```\n\n---"
  },
  {
    "path": "rules/cursor/provide-configuration-to-your-app-via-a-layer.mdc",
    "description": "Provide configuration to your app via a Layer.",
    "content": "# Provide Configuration to Your App via a Layer\n**Rule:** Provide configuration to your app via a Layer.\n\n### Example\n````typescript\nimport { Effect, Layer } from \"effect\";\n\nclass ServerConfig extends Effect.Service<ServerConfig>()(\n  \"ServerConfig\",\n  {\n    sync: () => ({\n      port: process.env.PORT ? parseInt(process.env.PORT) : 8080\n    })\n  }\n) {}\n\nconst program = Effect.gen(function* () {\n  const config = yield* ServerConfig;\n  yield* Effect.log(`Starting application on port ${config.port}...`);\n});\n\nEffect.runPromise(\n  Effect.provide(program, ServerConfig.Default)\n).catch(console.error);\n````\n\n**Explanation:**  \nThis approach makes configuration available contextually, supporting better testing and modularity."
  },
  {
    "path": "rules/cursor/provide-dependencies-to-routes.mdc",
    "description": "Define dependencies with Effect.Service and provide them to your HTTP server using a Layer.",
    "content": "# Provide Dependencies to Routes\n**Rule:** Define dependencies with Effect.Service and provide them to your HTTP server using a Layer.\n\n### Example\nThis example defines a `Database` service. The route handler for `/users/:userId` requires this service to fetch a user. We then provide a \"live\" implementation of the `Database` to the entire server using a `Layer`.\n\n```typescript\nimport * as HttpRouter from \"@effect/platform/HttpRouter\";\nimport * as HttpResponse from \"@effect/platform/HttpServerResponse\";\nimport * as HttpServer from \"@effect/platform/HttpServer\";\nimport { NodeHttpServer, NodeRuntime } from \"@effect/platform-node\";\nimport { Effect, Duration, Fiber } from \"effect/index\";\nimport { Data } from \"effect\";\n\n// 1. Define the service interface using Effect.Service\nexport class Database extends Effect.Service<Database>()(\"Database\", {\n  sync: () => ({\n    getUser: (id: string) =>\n      id === \"123\"\n        ? Effect.succeed({ name: \"Paul\" })\n        : Effect.fail(new UserNotFoundError({ id })),\n  }),\n}) {}\n\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\")<{\n  id: string;\n}> {}\n\n// handler producing a `HttpServerResponse`\nconst userHandler = Effect.flatMap(HttpRouter.params, (p) =>\n  Effect.flatMap(Database, (db) => db.getUser(p[\"userId\"] ?? \"\")).pipe(\n    Effect.flatMap(HttpResponse.json)\n  )\n);\n\n// assemble router & server\nconst app = HttpRouter.empty.pipe(\n  HttpRouter.get(\"/users/:userId\", userHandler)\n);\n\n// Create the server effect with all dependencies\nconst serverEffect = HttpServer.serveEffect(app).pipe(\n  Effect.provide(Database.Default),\n  Effect.provide(\n    NodeHttpServer.layer(\n      () => require(\"node:http\").createServer(),\n      { port: 3458 }\n    )\n  )\n);\n\n// Create program that manages server lifecycle\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting server on port 3458...\");\n\n  const serverFiber = yield* Effect.scoped(serverEffect).pipe(Effect.fork);\n\n  yield* Effect.logInfo(\"Server started successfully on http://localhost:3458\");\n  yield* Effect.logInfo(\"Try: curl http://localhost:3458/users/123\");\n  yield* Effect.logInfo(\"Try: curl http://localhost:3458/users/456\");\n\n  // Run for a short time to demonstrate\n  yield* Effect.sleep(Duration.seconds(3));\n\n  yield* Effect.logInfo(\"Shutting down server...\");\n  yield* Fiber.interrupt(serverFiber);\n  yield* Effect.logInfo(\"Server shutdown complete\");\n});\n\n// Run the program\nNodeRuntime.runMain(program);\n\n```"
  },
  {
    "path": "rules/cursor/race-concurrent-effects-for-the-fastest-result.mdc",
    "description": "Use Effect.race to get the result from the first of several effects to succeed, automatically interrupting the losers.",
    "content": "# Race Concurrent Effects for the Fastest Result\n**Rule:** Use Effect.race to get the result from the first of several effects to succeed, automatically interrupting the losers.\n\n### Example\nA classic use case is checking a fast cache before falling back to a slower database. We can race the cache lookup against the database query.\n\n```typescript\nimport { Effect, Option } from \"effect\";\n\ntype User = { id: number; name: string };\n\n// Simulate a slower cache lookup that might find nothing (None)\nconst checkCache: Effect.Effect<Option.Option<User>> = Effect.succeed(\n  Option.none()\n).pipe(\n  Effect.delay(\"200 millis\") // Made slower so database wins\n);\n\n// Simulate a faster database query that will always find the data\nconst queryDatabase: Effect.Effect<Option.Option<User>> = Effect.succeed(\n  Option.some({ id: 1, name: \"Paul\" })\n).pipe(\n  Effect.delay(\"50 millis\") // Made faster so it wins the race\n);\n\n// Race them. The database should win and return the user data.\nconst program = Effect.race(checkCache, queryDatabase).pipe(\n  // The result of the race is an Option, so we can handle it.\n  Effect.flatMap((result: Option.Option<User>) =>\n    Option.match(result, {\n      onNone: () => Effect.fail(\"User not found anywhere.\"),\n      onSome: (user) => Effect.succeed(user),\n    })\n  )\n);\n\n// In this case, the database wins the race.\nEffect.runPromise(program)\n  .then((user) => {\n    console.log(\"User found:\", user);\n  })\n  .catch((error) => {\n    console.log(\"Error:\", error);\n  });\n\n// Also demonstrate with logging\nconst programWithLogging = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting race between cache and database...\");\n\n  try {\n    const user = yield* program;\n    yield* Effect.logInfo(\n      `Success: Found user ${user.name} with ID ${user.id}`\n    );\n    return user;\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n    return null;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logInfo(`Handled error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithLogging);\n\n```\n\n---"
  },
  {
    "path": "rules/cursor/representing-time-spans-with-duration.mdc",
    "description": "Use the Duration data type to represent time intervals instead of raw numbers.",
    "content": "# Representing Time Spans with Duration\n**Rule:** Use the Duration data type to represent time intervals instead of raw numbers.\n\n### Example\nThis example shows how to create and use `Duration` to make time-based operations clear and unambiguous.\n\n```typescript\nimport { Effect, Duration } from \"effect\";\n\n// Create durations with clear, explicit units\nconst fiveSeconds = Duration.seconds(5);\nconst oneHundredMillis = Duration.millis(100);\n\n// Use them in Effect operators\nconst program = Effect.log(\"Starting...\").pipe(\n  Effect.delay(oneHundredMillis),\n  Effect.flatMap(() => Effect.log(\"Running after 100ms\")),\n  Effect.timeout(fiveSeconds) // This whole operation must complete within 5 seconds\n);\n\n// Durations can also be compared\nconst isLonger = Duration.greaterThan(fiveSeconds, oneHundredMillis); // true\n\n// Demonstrate the duration functionality\nconst demonstration = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Duration Demonstration ===\");\n\n  // Show duration values\n  yield* Effect.logInfo(`Five seconds: ${Duration.toMillis(fiveSeconds)}ms`);\n  yield* Effect.logInfo(\n    `One hundred millis: ${Duration.toMillis(oneHundredMillis)}ms`\n  );\n\n  // Show comparison\n  yield* Effect.logInfo(`Is 5 seconds longer than 100ms? ${isLonger}`);\n\n  // Run the timed program\n  yield* Effect.logInfo(\"Running timed program...\");\n  yield* program;\n\n  // Show more duration operations\n  const combined = Duration.sum(fiveSeconds, oneHundredMillis);\n  yield* Effect.logInfo(`Combined duration: ${Duration.toMillis(combined)}ms`);\n\n  // Show different duration units\n  const oneMinute = Duration.minutes(1);\n  yield* Effect.logInfo(`One minute: ${Duration.toMillis(oneMinute)}ms`);\n\n  const isMinuteLonger = Duration.greaterThan(oneMinute, fiveSeconds);\n  yield* Effect.logInfo(`Is 1 minute longer than 5 seconds? ${isMinuteLonger}`);\n});\n\nEffect.runPromise(demonstration);\n\n```\n\n---"
  },
  {
    "path": "rules/cursor/retry-operations-based-on-specific-errors.mdc",
    "description": "Use predicate-based retry policies to retry an operation only for specific, recoverable errors.",
    "content": "# Retry Operations Based on Specific Errors\n**Rule:** Use predicate-based retry policies to retry an operation only for specific, recoverable errors.\n\n### Example\nThis example simulates an API client that can fail with different, specific error types. The retry policy is configured to *only* retry on `ServerBusyError` and give up immediately on `NotFoundError`.\n\n```typescript\nimport { Effect, Data, Schedule, Duration } from \"effect\";\n\n// Define specific, tagged errors for our API client\nclass ServerBusyError extends Data.TaggedError(\"ServerBusyError\") {}\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\") {}\n\nlet attemptCount = 0;\n\n// A flaky API call that can fail in different ways\nconst flakyApiCall = Effect.try({\n  try: () => {\n    attemptCount++;\n    const random = Math.random();\n\n    if (attemptCount <= 2) {\n      // First two attempts fail with ServerBusyError (retryable)\n      console.log(\n        `Attempt ${attemptCount}: API call failed - Server is busy. Retrying...`\n      );\n      throw new ServerBusyError();\n    }\n\n    // Third attempt succeeds\n    console.log(`Attempt ${attemptCount}: API call succeeded!`);\n    return { data: \"success\", attempt: attemptCount };\n  },\n  catch: (e) => e as ServerBusyError | NotFoundError,\n});\n\n// A predicate that returns true only for the error we want to retry\nconst isRetryableError = (e: ServerBusyError | NotFoundError) =>\n  e._tag === \"ServerBusyError\";\n\n// A policy that retries 3 times, but only if the error is retryable\nconst selectiveRetryPolicy = Schedule.recurs(3).pipe(\n  Schedule.whileInput(isRetryableError),\n  Schedule.addDelay(() => \"100 millis\")\n);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Retry Based on Specific Errors Demo ===\");\n\n  try {\n    const result = yield* flakyApiCall.pipe(Effect.retry(selectiveRetryPolicy));\n    yield* Effect.logInfo(`Success: ${JSON.stringify(result)}`);\n    return result;\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n    return null;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      if (error instanceof NotFoundError) {\n        yield* Effect.logInfo(\"Failed with NotFoundError - not retrying\");\n      } else if (error instanceof ServerBusyError) {\n        yield* Effect.logInfo(\"Failed with ServerBusyError after all retries\");\n      } else {\n        yield* Effect.logInfo(`Failed with unexpected error: ${error}`);\n      }\n      return null;\n    })\n  )\n);\n\n// Also demonstrate a case where NotFoundError is not retried\nconst demonstrateNotFound = Effect.gen(function* () {\n  yield* Effect.logInfo(\"\\n=== Demonstrating Non-Retryable Error ===\");\n\n  const alwaysNotFound = Effect.fail(new NotFoundError());\n\n  const result = yield* alwaysNotFound.pipe(\n    Effect.retry(selectiveRetryPolicy),\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`NotFoundError was not retried: ${error._tag}`);\n        return null;\n      })\n    )\n  );\n\n  return result;\n});\n\nEffect.runPromise(program.pipe(Effect.flatMap(() => demonstrateNotFound)));\n\n```\n\n---"
  },
  {
    "path": "rules/cursor/run-independent-effects-in-parallel-with-effect-all.mdc",
    "description": "Use Effect.all to execute a collection of independent effects concurrently.",
    "content": "# Run Independent Effects in Parallel with Effect.all\n**Rule:** Use Effect.all to execute a collection of independent effects concurrently.\n\n### Example\nImagine fetching a user's profile and their latest posts from two different API endpoints. These are independent operations and can be run in parallel to save time.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Simulate fetching a user, takes 1 second\nconst fetchUser = Effect.succeed({ id: 1, name: \"Paul\" }).pipe(\n  Effect.delay(\"1 second\"),\n);\n\n// Simulate fetching posts, takes 1.5 seconds\nconst fetchPosts = Effect.succeed([{ title: \"Effect is great\" }]).pipe(\n  Effect.delay(\"1.5 seconds\"),\n);\n\n// Run both effects concurrently\nconst program = Effect.all([fetchUser, fetchPosts]);\n\n// The resulting effect will succeed with a tuple: [{id, name}, [{title}]]\n// Total execution time will be ~1.5 seconds (the duration of the longest task).\nEffect.runPromise(program).then(console.log);\n```\n\n---"
  },
  {
    "path": "rules/cursor/supercharge-your-editor-with-the-effect-lsp.mdc",
    "description": "Install and use the Effect LSP extension for enhanced type information and error checking in your editor.",
    "content": "# Supercharge Your Editor with the Effect LSP\n**Rule:** Install and use the Effect LSP extension for enhanced type information and error checking in your editor.\n\n### Example\nImagine you have the following code. Without the LSP, hovering over `program` might show a complex, hard-to-read inferred type.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Define Logger service using Effect.Service pattern\nclass Logger extends Effect.Service<Logger>()(\n  \"Logger\",\n  {\n    sync: () => ({\n      log: (msg: string) => Effect.sync(() => console.log(`LOG: ${msg}`))\n    })\n  }\n) {}\n\nconst program = Effect.succeed(42).pipe(\n  Effect.map((n) => n.toString()),\n  Effect.flatMap((s) => Effect.log(s)),\n  Effect.provide(Logger.Default)\n);\n\n// Run the program\nEffect.runPromise(program);\n```\n\nWith the Effect LSP installed, your editor would display a clear, readable overlay right above the `program` variable, looking something like this:\n\n```\n// (LSP Inlay Hint)\n// program: Effect<void, never, never>\n```\n\nThis immediately tells you that the final program returns nothing (`void`), has no expected failures (`never`), and has no remaining requirements (`never`), so it's ready to be run.\n\n---"
  },
  {
    "path": "rules/cursor/trace-operations-across-services-with-spans.mdc",
    "description": "Use Effect.withSpan to create custom tracing spans for important operations.",
    "content": "# Trace Operations Across Services with Spans\n**Rule:** Use Effect.withSpan to create custom tracing spans for important operations.\n\n### Example\nThis example shows a multi-step operation. Each step, and the overall operation, is wrapped in a span. This creates a parent-child hierarchy in the trace that is easy to visualize.\n\n```typescript\nimport { Effect, Duration } from \"effect\";\n\nconst validateInput = (input: unknown) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"Starting input validation...\");\n    yield* Effect.sleep(Duration.millis(10));\n    const result = { email: \"paul@example.com\" };\n    yield* Effect.logInfo(`\u2705 Input validated: ${result.email}`);\n    return result;\n  }).pipe(\n    // This creates a child span\n    Effect.withSpan(\"validateInput\")\n  );\n\nconst saveToDatabase = (user: { email: string }) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Saving user to database: ${user.email}`);\n    yield* Effect.sleep(Duration.millis(50));\n    const result = { id: 123, ...user };\n    yield* Effect.logInfo(`\u2705 User saved with ID: ${result.id}`);\n    return result;\n  }).pipe(\n    // This span includes useful attributes\n    Effect.withSpan(\"saveToDatabase\", {\n      attributes: { \"db.system\": \"postgresql\", \"db.user.email\": user.email },\n    })\n  );\n\nconst createUser = (input: unknown) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"=== Creating User with Tracing ===\");\n    yield* Effect.logInfo(\n      \"This demonstrates how spans trace operations through the call stack\"\n    );\n\n    const validated = yield* validateInput(input);\n    const user = yield* saveToDatabase(validated);\n\n    yield* Effect.logInfo(\n      `\u2705 User creation completed: ${JSON.stringify(user)}`\n    );\n    yield* Effect.logInfo(\n      \"Note: In production, spans would be sent to a tracing system like Jaeger or Zipkin\"\n    );\n\n    return user;\n  }).pipe(\n    // This is the parent span for the entire operation\n    Effect.withSpan(\"createUserOperation\")\n  );\n\n// Demonstrate the tracing functionality\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Trace Operations with Spans Demo ===\");\n\n  // Create multiple users to show tracing in action\n  const user1 = yield* createUser({ email: \"user1@example.com\" });\n\n  yield* Effect.logInfo(\"\\n--- Creating second user ---\");\n  const user2 = yield* createUser({ email: \"user2@example.com\" });\n\n  yield* Effect.logInfo(\"\\n=== Summary ===\");\n  yield* Effect.logInfo(\"Created users with tracing spans:\");\n  yield* Effect.logInfo(`User 1: ID ${user1.id}, Email: ${user1.email}`);\n  yield* Effect.logInfo(`User 2: ID ${user2.id}, Email: ${user2.email}`);\n});\n\n// When run with a tracing SDK, this will produce traces with root spans\n// \"createUserOperation\" and child spans: \"validateInput\" and \"saveToDatabase\".\nEffect.runPromise(program);\n\n```\n\n---"
  },
  {
    "path": "rules/cursor/transform-data-during-validation-with-schema.mdc",
    "description": "Use Schema.transform to safely convert data types during the validation and parsing process.",
    "content": "# Transform Data During Validation with Schema\n**Rule:** Use Schema.transform to safely convert data types during the validation and parsing process.\n\n### Example\nThis schema parses a string but produces a `Date` object, making the final data structure much more useful.\n\n```typescript\nimport { Schema, Effect } from \"effect\";\n\n// Define types for better type safety\ntype RawEvent = {\n  name: string;\n  timestamp: string;\n};\n\ntype ParsedEvent = {\n  name: string;\n  timestamp: Date;\n};\n\n// Define the schema for our event\nconst ApiEventSchema = Schema.Struct({\n  name: Schema.String,\n  timestamp: Schema.String\n});\n\n// Example input\nconst rawInput: RawEvent = {\n  name: \"User Login\",\n  timestamp: \"2025-06-22T20:08:42.000Z\"\n};\n\n// Parse and transform\nconst program = Effect.gen(function* () {\n  const parsed = yield* Schema.decode(ApiEventSchema)(rawInput);\n  return {\n    name: parsed.name,\n    timestamp: new Date(parsed.timestamp)\n  } as ParsedEvent;\n});\n\nEffect.runPromise(program).then(\n  (event) => {\n    console.log('Event year:', event.timestamp.getFullYear());\n    console.log('Full event:', event);\n  },\n  (error) => {\n    console.error('Failed to parse event:', error);\n  }\n);\n```\n\n\n`transformOrFail` is perfect for creating branded types, as the validation can fail.\n\n```typescript\nimport { Schema, Effect, Brand, Either } from \"effect\";\n\ntype Email = string & Brand.Brand<\"Email\">;\nconst Email = Schema.string.pipe(\n  Schema.transformOrFail(\n    Schema.brand<Email>(\"Email\"),\n    (s, _, ast) =>\n      s.includes(\"@\")\n        ? Either.right(s as Email)\n        : Either.left(Schema.ParseError.create(ast, \"Invalid email format\")),\n    (email) => Either.right(email),\n  ),\n);\n\nconst result = Schema.decode(Email)(\"paul@example.com\"); // Succeeds\nconst errorResult = Schema.decode(Email)(\"invalid-email\"); // Fails\n```\n\n---"
  },
  {
    "path": "rules/cursor/turn-a-paginated-api-into-a-single-stream.mdc",
    "description": "Use Stream.paginateEffect to model a paginated data source as a single, continuous stream.",
    "content": "# Turn a Paginated API into a Single Stream\n**Rule:** Use Stream.paginateEffect to model a paginated data source as a single, continuous stream.\n\n### Example\nThis example simulates fetching users from a paginated API. The `fetchUsersPage` function gets one page of data and returns the next page number. `Stream.paginateEffect` uses this function to create a single stream of all users across all pages.\n\n```typescript\nimport { Effect, Stream, Chunk, Option } from 'effect';\n\n// --- Mock Paginated API ---\ninterface User {\n  id: number;\n  name: string;\n}\n\n// Define FetchError as a class with a literal type tag\nclass FetchError {\n  readonly _tag = 'FetchError' as const;\n  constructor(readonly message: string) {}\n}\n\n// Helper to create FetchError instances\nconst fetchError = (message: string): FetchError => new FetchError(message);\n\nconst allUsers: User[] = Array.from({ length: 25 }, (_, i) => ({\n  id: i + 1,\n  name: `User ${i + 1}`,\n}));\n\n// This function simulates fetching a page of users from an API.\nconst fetchUsersPage = (\n  page: number\n): Effect.Effect<[Chunk.Chunk<User>, Option.Option<number>], FetchError> =>\n  Effect.gen(function* () {\n    const pageSize = 10;\n    const offset = (page - 1) * pageSize;\n\n    // Simulate potential API errors\n    if (page < 1) {\n      return yield* Effect.fail(fetchError('Invalid page number'));\n    }\n\n    const users = Chunk.fromIterable(allUsers.slice(offset, offset + pageSize));\n\n    const nextPage =\n      Chunk.isNonEmpty(users) && allUsers.length > offset + pageSize\n        ? Option.some(page + 1)\n        : Option.none();\n\n    yield* Effect.log(`Fetched page ${page}`);\n    return [users, nextPage];\n  });\n\n// --- The Pattern ---\n// Use paginateEffect, providing an initial state (page 1) and the fetch function.\nconst userStream = Stream.paginateEffect(1, fetchUsersPage);\n\nconst program = userStream.pipe(\n  Stream.runCollect,\n  Effect.map((users) => users.length),\n  Effect.tap((totalUsers) => \n    Effect.log(`Total users fetched: ${totalUsers}`)\n  ),\n  Effect.catchTag('FetchError', (error) => \n    Effect.succeed(`Error fetching users: ${error.message}`)\n  )\n);\n\n// Run the program\nEffect.runPromise(program).then(console.log);\n\n/*\nOutput:\n... level=INFO msg=\"Fetched page 1\"\n... level=INFO msg=\"Fetched page 2\"\n... level=INFO msg=\"Fetched page 3\"\n... level=INFO msg=\"Total users fetched: 25\"\n25\n*/\n```"
  },
  {
    "path": "rules/cursor/understand-layers-for-dependency-injection.mdc",
    "description": "Understand that a Layer is a blueprint describing how to construct a service and its dependencies.",
    "content": "# Understand Layers for Dependency Injection\n**Rule:** Understand that a Layer is a blueprint describing how to construct a service and its dependencies.\n\n### Example\nHere, we define a `Notifier` service that requires a `Logger` to be built. The `NotifierLive` layer's type signature, `Layer<Logger, never, Notifier>`, clearly documents this dependency.\n\n```typescript\nimport { Effect } from \"effect\";\n\n// Define the Logger service with a default implementation\nexport class Logger extends Effect.Service<Logger>()(\n  \"Logger\",\n  {\n    // Provide a synchronous implementation\n    sync: () => ({\n      log: (msg: string) => Effect.sync(() => console.log(`LOG: ${msg}`))\n    })\n  }\n) {}\n\n// Define the Notifier service that depends on Logger\nexport class Notifier extends Effect.Service<Notifier>()(\n  \"Notifier\",\n  {\n    // Provide an implementation that requires Logger\n    effect: Effect.gen(function* () {\n      const logger = yield* Logger;\n      return {\n        notify: (msg: string) => logger.log(`Notifying: ${msg}`)\n      };\n    }),\n    // Specify dependencies\n    dependencies: [Logger.Default]\n  }\n) {}\n\n// Create a program that uses both services\nconst program = Effect.gen(function* () {\n  const notifier = yield* Notifier;\n  yield* notifier.notify(\"Hello, World!\");\n});\n\n// Run the program with the default implementations\nEffect.runPromise(\n  Effect.provide(\n    program,\n    Notifier.Default\n  )\n);\n```\n\n---"
  },
  {
    "path": "rules/cursor/use-chunk-for-high-performance-collections.mdc",
    "description": "Prefer Chunk over Array for immutable collection operations within data processing pipelines for better performance.",
    "content": "# Use Chunk for High-Performance Collections\n**Rule:** Prefer Chunk over Array for immutable collection operations within data processing pipelines for better performance.\n\n### Example\nThis example shows how to create and manipulate a `Chunk`. The API is very similar to `Array`, but the underlying performance characteristics for these immutable operations are superior.\n\n```typescript\nimport { Chunk } from \"effect\";\n\n// Create a Chunk from an array\nlet numbers = Chunk.fromIterable([1, 2, 3, 4, 5]);\n\n// Append a new element. This is much faster than [...arr, 6] on large collections.\nnumbers = Chunk.append(numbers, 6);\n\n// Prepend an element.\nnumbers = Chunk.prepend(numbers, 0);\n\n// Take the first 3 elements\nconst firstThree = Chunk.take(numbers, 3);\n\n// Convert back to an array when you need to interface with other libraries\nconst finalArray = Chunk.toReadonlyArray(firstThree);\n\nconsole.log(finalArray); // [0, 1, 2]\n```\n\n---"
  },
  {
    "path": "rules/cursor/use-effect-gen-for-business-logic.mdc",
    "description": "Use Effect.gen for business logic.",
    "content": "# Use Effect.gen for Business Logic\n**Rule:** Use Effect.gen for business logic.\n\n### Example\n```typescript\nimport { Effect } from \"effect\";\n\n// Concrete implementations for demonstration\nconst validateUser = (\n  data: any\n): Effect.Effect<{ email: string; password: string }, Error, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Validating user data: ${JSON.stringify(data)}`);\n\n    if (!data.email || !data.password) {\n      return yield* Effect.fail(new Error(\"Email and password are required\"));\n    }\n\n    if (data.password.length < 6) {\n      return yield* Effect.fail(\n        new Error(\"Password must be at least 6 characters\")\n      );\n    }\n\n    yield* Effect.logInfo(\"\u2705 User data validated successfully\");\n    return { email: data.email, password: data.password };\n  });\n\nconst hashPassword = (pw: string): Effect.Effect<string, never, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"Hashing password...\");\n    // Simulate password hashing\n    const hashed = `hashed_${pw}_${Date.now()}`;\n    yield* Effect.logInfo(\"\u2705 Password hashed successfully\");\n    return hashed;\n  });\n\nconst dbCreateUser = (data: {\n  email: string;\n  password: string;\n}): Effect.Effect<{ id: number; email: string }, never, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Creating user in database: ${data.email}`);\n    // Simulate database operation\n    const user = { id: Math.floor(Math.random() * 1000), email: data.email };\n    yield* Effect.logInfo(`\u2705 User created with ID: ${user.id}`);\n    return user;\n  });\n\nconst createUser = (userData: any): Effect.Effect<{ id: number; email: string }, Error, never> =>\n  Effect.gen(function* () {\n    const validated = yield* validateUser(userData);\n    const hashed = yield* hashPassword(validated.password);\n    return yield* dbCreateUser({ ...validated, password: hashed });\n  });\n\n// Demonstrate using Effect.gen for business logic\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Using Effect.gen for Business Logic Demo ===\");\n\n  // Example 1: Successful user creation\n  yield* Effect.logInfo(\"\\n1. Creating a valid user:\");\n  const validUser = yield* createUser({\n    email: \"paul@example.com\",\n    password: \"securepassword123\",\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to create user: ${error.message}`);\n        return { id: -1, email: \"error\" };\n      })\n    )\n  );\n  yield* Effect.logInfo(`Created user: ${JSON.stringify(validUser)}`);\n\n  // Example 2: Invalid user data\n  yield* Effect.logInfo(\"\\n2. Attempting to create user with invalid data:\");\n  const invalidUser = yield* createUser({\n    email: \"invalid@example.com\",\n    password: \"123\", // Too short\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to create user: ${error.message}`);\n        return { id: -1, email: \"error\" };\n      })\n    )\n  );\n  yield* Effect.logInfo(`Result: ${JSON.stringify(invalidUser)}`);\n\n  yield* Effect.logInfo(\"\\n\u2705 Business logic demonstration completed!\");\n});\n\nEffect.runPromise(program);\n\n```\n\n**Explanation:**  \n`Effect.gen` allows you to express business logic in a clear, sequential style,\nimproving maintainability."
  },
  {
    "path": "rules/cursor/use-the-auto-generated-default-layer-in-tests.mdc",
    "description": "Use the auto-generated .Default layer in tests.",
    "content": "# Use the Auto-Generated .Default Layer in Tests\n**Rule:** Use the auto-generated .Default layer in tests.\n\n### Example\n```typescript\nimport { Effect } from \"effect\";\n\n// Define MyService using Effect.Service pattern\nclass MyService extends Effect.Service<MyService>()(\n  \"MyService\",\n  {\n    sync: () => ({\n      doSomething: () => \n        Effect.succeed(\"done\").pipe(\n          Effect.tap(() => Effect.log(\"MyService did something!\"))\n        )\n    })\n  }\n) {}\n\n// Create a program that uses MyService\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Getting MyService...\");\n  const service = yield* MyService;\n  \n  yield* Effect.log(\"Calling doSomething()...\");\n  const result = yield* service.doSomething();\n  \n  yield* Effect.log(`Result: ${result}`);\n});\n\n// Run the program with default service implementation\nEffect.runPromise(\n  Effect.provide(program, MyService.Default)\n);\n```\n\n**Explanation:**  \nThis approach ensures your tests are idiomatic, maintainable, and take full advantage of Effect's dependency injection system."
  },
  {
    "path": "rules/cursor/validate-request-body.mdc",
    "description": "Use Http.request.schemaBodyJson with a Schema to automatically parse and validate request bodies.",
    "content": "# Validate Request Body\n**Rule:** Use Http.request.schemaBodyJson with a Schema to automatically parse and validate request bodies.\n\n### Example\nThis example defines a `POST` route to create a user. It uses a `CreateUser` schema to validate the request body. If validation passes, it returns a success message with the typed data. If it fails, the platform automatically sends a descriptive 400 error.\n\n```typescript\nimport { Duration, Effect } from \"effect\";\nimport * as S from \"effect/Schema\";\nimport { createServer, IncomingMessage, ServerResponse } from \"http\";\n\n// Define user schema\nconst UserSchema = S.Struct({\n  name: S.String,\n  email: S.String.pipe(S.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)),\n});\ntype User = S.Schema.Type<typeof UserSchema>;\n\n// Define user service interface\ninterface UserServiceInterface {\n  readonly validateUser: (data: unknown) => Effect.Effect<User, Error, never>;\n}\n\n// Define user service\nclass UserService extends Effect.Service<UserService>()(\"UserService\", {\n  sync: () => ({\n    validateUser: (data: unknown) => S.decodeUnknown(UserSchema)(data),\n  }),\n}) { }\n\n// Define HTTP server service interface\ninterface HttpServerInterface {\n  readonly handleRequest: (\n    request: IncomingMessage,\n    response: ServerResponse\n  ) => Effect.Effect<void, Error, never>;\n  readonly start: () => Effect.Effect<void, Error, never>;\n}\n\n// Define HTTP server service\nclass HttpServer extends Effect.Service<HttpServer>()(\"HttpServer\", {\n  // Define effect-based implementation that uses dependencies\n  effect: Effect.gen(function* () {\n    const userService = yield* UserService;\n\n    return {\n      handleRequest: (request: IncomingMessage, response: ServerResponse) =>\n        Effect.gen(function* () {\n          // Only handle POST /users\n          if (request.method !== \"POST\" || request.url !== \"/users\") {\n            response.writeHead(404, { \"Content-Type\": \"application/json\" });\n            response.end(JSON.stringify({ error: \"Not Found\" }));\n            return;\n          }\n\n          try {\n            // Read request body\n            const body = yield* Effect.async<unknown, Error>((resume) => {\n              let data = \"\";\n              request.on(\"data\", (chunk) => {\n                data += chunk;\n              });\n              request.on(\"end\", () => {\n                try {\n                  resume(Effect.succeed(JSON.parse(data)));\n                } catch (e) {\n                  resume(\n                    Effect.fail(e instanceof Error ? e : new Error(String(e)))\n                  );\n                }\n              });\n              request.on(\"error\", (e) =>\n                resume(\n                  Effect.fail(e instanceof Error ? e : new Error(String(e)))\n                )\n              );\n            });\n\n            // Validate body against schema\n            const user = yield* userService.validateUser(body);\n\n            response.writeHead(200, { \"Content-Type\": \"application/json\" });\n            response.end(\n              JSON.stringify({\n                message: `Successfully created user: ${user.name}`,\n              })\n            );\n          } catch (error) {\n            response.writeHead(400, { \"Content-Type\": \"application/json\" });\n            response.end(JSON.stringify({ error: String(error) }));\n          }\n        }),\n\n      start: function (this: HttpServer) {\n        const self = this;\n        return Effect.gen(function* () {\n          // Create HTTP server\n          const server = createServer((req, res) =>\n            Effect.runFork(self.handleRequest(req, res))\n          );\n\n          // Add cleanup finalizer\n          yield* Effect.addFinalizer(() =>\n            Effect.gen(function* () {\n              yield* Effect.sync(() => server.close());\n              yield* Effect.logInfo(\"Server shut down\");\n            })\n          );\n\n          // Start server\n          yield* Effect.async<void, Error>((resume) => {\n            server.on(\"error\", (error) => resume(Effect.fail(error)));\n            server.listen(3456, () => {\n              Effect.runFork(\n                Effect.logInfo(\"Server running at http://localhost:3456/\")\n              );\n              resume(Effect.succeed(void 0));\n            });\n          });\n\n          // Run for demonstration period\n          yield* Effect.sleep(Duration.seconds(3));\n          yield* Effect.logInfo(\"Demo completed - shutting down server\");\n        });\n      },\n    };\n  }),\n  // Specify dependencies\n  dependencies: [UserService.Default],\n}) { }\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const server = yield* HttpServer;\n\n  yield* Effect.logInfo(\"Starting HTTP server...\");\n\n  yield* server.start().pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Server error: ${error}`);\n        return yield* Effect.fail(error);\n      })\n    )\n  );\n}).pipe(\n  Effect.scoped // Ensure server is cleaned up\n);\n\n// Run the server\nEffect.runFork(Effect.provide(program, HttpServer.Default));\n\n/*\nTo test:\n- POST http://localhost:3456/users with body {\"name\": \"Paul\", \"email\": \"paul@effect.com\"}\n  -> Returns 200 OK with message \"Successfully created user: Paul\"\n\n- POST http://localhost:3456/users with body {\"name\": \"Paul\"}\n  -> Returns 400 Bad Request with error message about missing email field\n*/\n\n```"
  },
  {
    "path": "rules/cursor/write-tests-that-adapt-to-application-code.mdc",
    "description": "Write tests that adapt to application code.",
    "content": "# Write Tests That Adapt to Application Code\n**Rule:** Write tests that adapt to application code.\n\n### Example\n```typescript\nimport { Effect } from \"effect\";\n\n// Define our types\ninterface User {\n  id: number;\n  name: string;\n}\n\nclass NotFoundError extends Error {\n  readonly _tag = \"NotFoundError\";\n  constructor(readonly id: number) {\n    super(`User ${id} not found`);\n  }\n}\n\n// Define database service interface\ninterface DatabaseServiceApi {\n  getUserById: (id: number) => Effect.Effect<User, NotFoundError>;\n}\n\n// Implement the service with mock data\nclass DatabaseService extends Effect.Service<DatabaseService>()(\n  \"DatabaseService\",\n  {\n    sync: () => ({\n      getUserById: (id: number) => {\n        // Simulate database lookup\n        if (id === 404) {\n          return Effect.fail(new NotFoundError(id));\n        }\n        return Effect.succeed({ id, name: `User ${id}` });\n      },\n    }),\n  }\n) {}\n\n// Test service implementation for testing\nclass TestDatabaseService extends Effect.Service<TestDatabaseService>()(\n  \"TestDatabaseService\",\n  {\n    sync: () => ({\n      getUserById: (id: number) => {\n        // Test data with predictable responses\n        const testUsers = [\n          { id: 1, name: \"Test User 1\" },\n          { id: 2, name: \"Test User 2\" },\n          { id: 123, name: \"User 123\" },\n        ];\n\n        const user = testUsers.find((u) => u.id === id);\n        if (user) {\n          return Effect.succeed(user);\n        }\n        return Effect.fail(new NotFoundError(id));\n      },\n    }),\n  }\n) {}\n\n// Business logic that uses the database service\nconst getUserWithFallback = (id: number) =>\n  Effect.gen(function* () {\n    const db = yield* DatabaseService;\n    return yield* Effect.gen(function* () {\n      const user = yield* db.getUserById(id);\n      return user;\n    }).pipe(\n      Effect.catchAll((error) =>\n        Effect.gen(function* () {\n          if (error instanceof NotFoundError) {\n            yield* Effect.logInfo(`User ${id} not found, using fallback`);\n            return { id, name: `Fallback User ${id}` };\n          }\n          return yield* Effect.fail(error);\n        })\n      )\n    );\n  });\n\n// Create a program that demonstrates the service\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\n    \"=== Writing Tests that Adapt to Application Code Demo ===\"\n  );\n\n  const db = yield* DatabaseService;\n\n  // Example 1: Successful user lookup\n  yield* Effect.logInfo(\"\\n1. Looking up existing user 123...\");\n  const user = yield* Effect.gen(function* () {\n    try {\n      return yield* db.getUserById(123);\n    } catch (error) {\n      yield* Effect.logError(`Failed to get user: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return { id: -1, name: \"Error\" };\n    }\n  });\n  yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n\n  // Example 2: Handle non-existent user with proper error handling\n  yield* Effect.logInfo(\"\\n2. Looking up non-existent user 404...\");\n  const notFoundUser = yield* Effect.gen(function* () {\n    try {\n      return yield* db.getUserById(404);\n    } catch (error) {\n      if (error instanceof NotFoundError) {\n        yield* Effect.logInfo(\n          `\u2705 Properly handled NotFoundError: ${error.message}`\n        );\n        return { id: 404, name: \"Not Found\" };\n      }\n      yield* Effect.logError(`Unexpected error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return { id: -1, name: \"Error\" };\n    }\n  });\n  yield* Effect.logInfo(`Result: ${JSON.stringify(notFoundUser)}`);\n\n  // Example 3: Business logic with fallback\n  yield* Effect.logInfo(\"\\n3. Business logic with fallback for missing user:\");\n  const userWithFallback = yield* getUserWithFallback(999);\n  yield* Effect.logInfo(\n    `User with fallback: ${JSON.stringify(userWithFallback)}`\n  );\n\n  // Example 4: Testing with different service implementation\n  yield* Effect.logInfo(\"\\n4. Testing with test service implementation:\");\n  yield* Effect.provide(\n    Effect.gen(function* () {\n      const testDb = yield* TestDatabaseService;\n\n      // Test existing user\n      const testUser1 = yield* Effect.gen(function* () {\n        try {\n          return yield* testDb.getUserById(1);\n        } catch (error) {\n          yield* Effect.logError(`Test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n          return { id: -1, name: \"Test Error\" };\n        }\n      });\n      yield* Effect.logInfo(`Test user 1: ${JSON.stringify(testUser1)}`);\n\n      // Test non-existing user\n      const testUser404 = yield* Effect.gen(function* () {\n        try {\n          return yield* testDb.getUserById(404);\n        } catch (error) {\n          yield* Effect.logInfo(\n            `\u2705 Test service properly threw NotFoundError: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n          return { id: 404, name: \"Test Not Found\" };\n        }\n      });\n      yield* Effect.logInfo(`Test result: ${JSON.stringify(testUser404)}`);\n    }),\n    TestDatabaseService.Default\n  );\n\n  yield* Effect.logInfo(\n    \"\\n\u2705 Tests that adapt to application code demonstration completed!\"\n  );\n  yield* Effect.logInfo(\n    \"The same business logic works with different service implementations!\"\n  );\n});\n\n// Run the program with the default database service\nEffect.runPromise(\n  Effect.provide(program, DatabaseService.Default) as Effect.Effect<void, never, never>\n);\n\n```\n\n**Explanation:**  \nTests should reflect the real interface and behavior of your code, not force changes to it."
  }
]