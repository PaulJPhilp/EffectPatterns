{
    "effect_patterns": [
        {
            "id": "7dacd5f7-29aa-4027-8efe-e0f377ba8d91",
            "slug": "scoped-service-layer",
            "title": "Create a Service Layer from a Managed Resource",
            "summary": "Use `Layer.scoped` with `Effect.Service` to transform a managed resource into a shareable, application-wide service.",
            "skill_level": "intermediate",
            "category": "resource-management",
            "difficulty": "intermediate",
            "tags": [
                "resource",
                "layer",
                "scope",
                "service",
                "dependency-injection",
                "context",
                "acquire-release"
            ],
            "examples": [
                {
                    "code": "import { Effect, Console } from \"effect\";\n\n// 1. Define the service interface\ninterface DatabaseService {\n  readonly query: (sql: string) => Effect.Effect<string[], never, never>;\n}\n\n// 2. Define the service implementation with scoped resource management\nclass Database extends Effect.Service<DatabaseService>()(\"Database\", {\n  // The scoped property manages the resource lifecycle\n  scoped: Effect.gen(function* () {\n    const id = Math.floor(Math.random() * 1000);\n\n    // Acquire the connection\n    yield* Effect.log(`[Pool ${id}] Acquired`);\n\n    // Setup cleanup to run when scope closes\n    yield* Effect.addFinalizer(() => Effect.log(`[Pool ${id}] Released`));\n\n    // Return the service implementation\n    return {\n      query: (sql: string) =>\n        Effect.sync(() => [`Result for '${sql}' from pool ${id}`]),\n    };\n  }),\n}) {}\n\n// 3. Use the service in your program\nconst program = Effect.gen(function* () {\n  const db = yield* Database;\n  const users = yield* db.query(\"SELECT * FROM users\");\n  yield* Effect.log(`Query successful: ${users[0]}`);\n});\n\n// 4. Run the program with scoped resource management\nEffect.runPromise(\n  Effect.scoped(program).pipe(Effect.provide(Database.Default))\n);\n\n/*\nOutput:\n[Pool 458] Acquired\nQuery successful: Result for 'SELECT * FROM users' from pool 458\n[Pool 458] Released\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Provide a managed resource to the application context using `Layer.scoped`."
            },
            "created_at": "2026-02-15T21:22:18.505836",
            "updated_at": "2026-02-20T23:09:32.434679"
        },
        {
            "id": "276eed50-6907-480d-b193-50ed0b920290",
            "slug": "combinator-zip",
            "title": "Combining Values with zip",
            "summary": "Use zip to combine two computations, pairing their results together in Effect, Stream, Option, or Either.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "zip",
                "combinator",
                "pair",
                "effect",
                "stream",
                "option",
                "either"
            ],
            "examples": [
                {
                    "code": "import { Effect, Either, Option, Stream } from \"effect\";\n\n// Effect: Combine two effects and get both results\nconst effectA = Effect.succeed(1);\nconst effectB = Effect.succeed(\"hello\");\nconst zippedEffect = effectA.pipe(Effect.zip(effectB)); // Effect<[number, string]>\n\n// Option: Combine two options, only Some if both are Some\nconst optionA = Option.some(1);\nconst optionB = Option.some(\"hello\");\nconst zippedOption = Option.all([optionA, optionB]); // Option<[number, string]>\n\n// Either: Combine two eithers, only Right if both are Right\nconst eitherA = Either.right(1);\nconst eitherB = Either.right(\"hello\");\nconst zippedEither = Either.all([eitherA, eitherB]); // Either<never, [number, string]>\n\n// Stream: Pair up values from two streams\nconst streamA = Stream.fromIterable([1, 2, 3]);\nconst streamB = Stream.fromIterable([\"a\", \"b\", \"c\"]);\nconst zippedStream = streamA.pipe(Stream.zip(streamB)); // Stream<[number, string]>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use zip to run two computations and combine their results into a tuple, preserving error and context handling."
            },
            "created_at": "2026-02-15T21:22:13.034204",
            "updated_at": "2026-02-20T23:09:35.23547"
        },
        {
            "id": "051b45a6-7ee0-4cc6-abc1-b964a5688d19",
            "slug": "getting-started-hello-world",
            "title": "Hello World: Your First Effect",
            "summary": "Create and run your very first Effect program using Effect.succeed and Effect.runSync.",
            "skill_level": "beginner",
            "category": "getting-started",
            "difficulty": "beginner",
            "tags": [
                "getting-started",
                "hello-world",
                "beginner",
                "succeed",
                "first-program"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Step 1: Create an Effect that succeeds with a value\nconst helloWorld = Effect.succeed(\"Hello, Effect!\");\n\n// Step 2: Run the Effect and get the result\nconst result = Effect.runSync(helloWorld);\n\nconsole.log(result); // \"Hello, Effect!\"",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Create your first Effect program with Effect.succeed."
            },
            "created_at": "2026-02-15T21:22:12.432639",
            "updated_at": "2026-02-20T23:09:35.482763"
        },
        {
            "id": "43044573-7911-4bd9-a325-e4891632709f",
            "slug": "resource-timeouts",
            "title": "Handle Resource Timeouts",
            "summary": "Set timeouts on resource acquisition and usage to prevent hanging operations.",
            "skill_level": "intermediate",
            "category": "resource-management",
            "difficulty": "intermediate",
            "tags": [
                "resource-management",
                "timeouts",
                "resilience"
            ],
            "examples": [
                {
                    "code": "import { Effect, Duration, Scope } from \"effect\"\n\n// ============================================\n// 1. Define a resource with slow acquisition\n// ============================================\n\ninterface Connection {\n  readonly id: string\n  readonly query: (sql: string) => Effect.Effect<unknown>\n}\n\nconst acquireConnection = Effect.gen(function* () {\n  yield* Effect.log(\"Attempting to connect...\")\n  \n  // Simulate slow connection\n  yield* Effect.sleep(\"2 seconds\")\n  \n  const connection: Connection = {\n    id: crypto.randomUUID(),\n    query: (sql) => Effect.succeed({ rows: [] }),\n  }\n  \n  yield* Effect.log(`Connected: ${connection.id}`)\n  return connection\n})\n\nconst releaseConnection = (conn: Connection) =>\n  Effect.log(`Released: ${conn.id}`)\n\n// ============================================\n// 2. Timeout on acquisition\n// ============================================\n\nconst acquireWithTimeout = acquireConnection.pipe(\n  Effect.timeout(\"1 second\"),\n  Effect.catchTag(\"TimeoutException\", () =>\n    Effect.fail(new Error(\"Connection timeout - database unreachable\"))\n  )\n)\n\n// ============================================\n// 3. Timeout on usage\n// ============================================\n\nconst queryWithTimeout = (conn: Connection, sql: string) =>\n  conn.query(sql).pipe(\n    Effect.timeout(\"5 seconds\"),\n    Effect.catchTag(\"TimeoutException\", () =>\n      Effect.fail(new Error(`Query timeout: ${sql}`))\n    )\n  )\n\n// ============================================\n// 4. Full resource lifecycle with timeouts\n// ============================================\n\nconst useConnectionWithTimeouts = Effect.acquireRelease(\n  acquireWithTimeout,\n  releaseConnection\n).pipe(\n  Effect.flatMap((conn) =>\n    Effect.gen(function* () {\n      yield* Effect.log(\"Running queries...\")\n      \n      // Each query has its own timeout\n      const result1 = yield* queryWithTimeout(conn, \"SELECT 1\")\n      const result2 = yield* queryWithTimeout(conn, \"SELECT 2\")\n      \n      return [result1, result2]\n    })\n  ),\n  Effect.scoped\n)\n\n// ============================================\n// 5. Timeout on entire operation\n// ============================================\n\nconst entireOperationWithTimeout = useConnectionWithTimeouts.pipe(\n  Effect.timeout(\"10 seconds\"),\n  Effect.catchTag(\"TimeoutException\", () =>\n    Effect.fail(new Error(\"Entire operation timed out\"))\n  )\n)\n\n// ============================================\n// 6. Run with different scenarios\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Testing timeouts ===\")\n  \n  const result = yield* entireOperationWithTimeout.pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed: ${error.message}`)\n        return []\n      })\n    )\n  )\n  \n  yield* Effect.log(`Result: ${JSON.stringify(result)}`)\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Always set timeouts on resource acquisition to prevent indefinite waits."
            },
            "created_at": "2026-02-15T21:22:18.600219",
            "updated_at": "2026-02-20T23:09:32.239942"
        },
        {
            "id": "a49e582e-6414-480c-a7ad-c1daecbbb68a",
            "slug": "data-ref",
            "title": "Understand Ref for Atomic State",
            "summary": "Use Ref<A> to model shared, mutable state in a concurrent environment, ensuring all updates are atomic and free of race conditions.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "Ref",
                "state",
                "concurrency",
                "mutable",
                "data-type",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Effect, Ref } from \"effect\";\n\n// Create a Ref with an initial value\nconst makeCounter = Ref.make(0);\n\n// Increment the counter atomically\nconst increment = makeCounter.pipe(\n  Effect.flatMap((counter) => Ref.update(counter, (n) => n + 1))\n);\n\n// Read the current value\nconst getValue = makeCounter.pipe(\n  Effect.flatMap((counter) => Ref.get(counter))\n);\n\n// Use Ref in a workflow\nconst program = Effect.gen(function* () {\n  const counter = yield* Ref.make(0);\n  yield* Ref.update(counter, (n) => n + 1);\n  const value = yield* Ref.get(counter);\n  yield* Effect.log(`Counter value: ${value}`);\n});",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Ref to safely manage shared, mutable state in concurrent and effectful programs."
            },
            "created_at": "2026-02-15T21:22:15.522225",
            "updated_at": "2026-02-20T23:09:32.728432"
        },
        {
            "id": "d7160dc8-3b93-4c3a-b392-ff34ac57891e",
            "slug": "combinator-filter",
            "title": "Filtering Results with filter",
            "summary": "Use filter to keep or discard results based on a predicate, across Effect, Stream, Option, and Either.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "filter",
                "combinator",
                "predicate",
                "effect",
                "stream",
                "option",
                "either"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Only succeed if the value is even, fail otherwise\nconst effect = Effect.succeed(4).pipe(\n  Effect.filterOrFail(\n    (n): n is number => n % 2 === 0,\n    () => \"Number is not even\"\n  )\n); // Effect<number, string>\n\n// Option: Only keep the value if it is even\nconst option = Option.some(4).pipe(\n  Option.filter((n): n is number => n % 2 === 0)\n); // Option<number>\n\n// Either: Use map and flatMap to filter\nconst either = Either.right(4).pipe(\n  Either.flatMap((n) =>\n    n % 2 === 0 ? Either.right(n) : Either.left(\"Number is not even\")\n  )\n); // Either<string, number>\n\n// Stream: Only emit even numbers\nconst stream = Stream.fromIterable([1, 2, 3, 4]).pipe(\n  Stream.filter((n): n is number => n % 2 === 0)\n); // Stream<number>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use filter to declaratively express conditional logic, keeping only values that satisfy a predicate."
            },
            "created_at": "2026-02-15T21:22:13.725375",
            "updated_at": "2026-02-20T23:09:34.152518"
        },
        {
            "id": "b462b587-8e1b-4f38-8f9d-30004bfb04f6",
            "slug": "data-option",
            "title": "Understand the Option Data Type",
            "summary": "Use Option<A> to explicitly represent a value that may or may not exist, eliminating null and undefined errors.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "Option",
                "optional",
                "data-type",
                "domain",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Option } from \"effect\";\n\n// Create an Option from a value\nconst someValue = Option.some(42); // Option<number>\nconst noValue = Option.none(); // Option<never>\n\n// Safely convert a nullable value to Option\nconst fromNullable = Option.fromNullable(Math.random() > 0.5 ? \"hello\" : null); // Option<string>\n\n// Pattern match on Option\nconst result = someValue.pipe(\n  Option.match({\n    onNone: () => \"No value\",\n    onSome: (n) => `Value: ${n}`,\n  })\n); // string\n\n// Use Option in a workflow\nfunction findUser(id: number): Option.Option<{ id: number; name: string }> {\n  return id === 1 ? Option.some({ id, name: \"Alice\" }) : Option.none();\n}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Option to model values that may be present or absent, making absence explicit and type-safe."
            },
            "created_at": "2026-02-15T21:22:13.985304",
            "updated_at": "2026-02-20T23:09:35.139531"
        },
        {
            "id": "328f9740-1644-4be1-ac5e-bf223067a209",
            "slug": "compose-scoped-layers",
            "title": "Compose Resource Lifecycles with `Layer.merge`",
            "summary": "Combine multiple resource-managing layers, letting Effect automatically handle the acquisition and release order.",
            "skill_level": "intermediate",
            "category": "resource-management",
            "difficulty": "intermediate",
            "tags": [
                "resource",
                "layer",
                "scope",
                "compose",
                "merge",
                "dependency-graph",
                "architecture"
            ],
            "examples": [
                {
                    "code": "import { Effect, Layer, Console } from \"effect\";\n\n// --- Service 1: Database ---\ninterface DatabaseOps {\n  query: (sql: string) => Effect.Effect<string, never, never>;\n}\n\nclass Database extends Effect.Service<DatabaseOps>()(\"Database\", {\n  sync: () => ({\n    query: (sql: string): Effect.Effect<string, never, never> =>\n      Effect.sync(() => `db says: ${sql}`),\n  }),\n}) {}\n\n// --- Service 2: API Client ---\ninterface ApiClientOps {\n  fetch: (path: string) => Effect.Effect<string, never, never>;\n}\n\nclass ApiClient extends Effect.Service<ApiClientOps>()(\"ApiClient\", {\n  sync: () => ({\n    fetch: (path: string): Effect.Effect<string, never, never> =>\n      Effect.sync(() => `api says: ${path}`),\n  }),\n}) {}\n\n// --- Application Layer ---\n// We merge the two independent layers into one.\nconst AppLayer = Layer.merge(Database.Default, ApiClient.Default);\n\n// This program uses both services, unaware of their implementation details.\nconst program = Effect.gen(function* () {\n  const db = yield* Database;\n  const api = yield* ApiClient;\n\n  const dbResult = yield* db.query(\"SELECT *\");\n  const apiResult = yield* api.fetch(\"/users\");\n\n  yield* Effect.log(dbResult);\n  yield* Effect.log(apiResult);\n});\n\n// Provide the combined layer to the program.\nEffect.runPromise(Effect.provide(program, AppLayer));\n\n/*\nOutput (note the LIFO release order):\nDatabase pool opened\nAPI client session started\ndb says: SELECT *\napi says: /users\nAPI client session ended\nDatabase pool closed\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Compose multiple scoped layers using `Layer.merge` or by providing one layer to another."
            },
            "created_at": "2026-02-15T21:22:18.402471",
            "updated_at": "2026-02-20T23:09:32.383628"
        },
        {
            "id": "07cedd04-b3f7-4020-9b89-05a0870c217b",
            "slug": "wrap-synchronous-computations",
            "title": "Wrap Synchronous Computations with sync and try",
            "summary": "Use Effect.sync for non-throwing synchronous code and Effect.try for synchronous code that might throw an exception.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "sync",
                "try",
                "creation",
                "error-handling",
                "integration",
                "exceptions"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\nconst randomNumber = Effect.sync(() => Math.random());\n\nconst parseJson = (input: string) =>\n  Effect.try({\n    try: () => JSON.parse(input),\n    catch: (error) => new Error(`JSON parsing failed: ${error}`),\n  });\n\n// More examples of wrapping synchronous computations\nconst divide = (a: number, b: number) =>\n  Effect.try({\n    try: () => {\n      if (b === 0) throw new Error(\"Division by zero\");\n      return a / b;\n    },\n    catch: (error) => new Error(`Division failed: ${error}`),\n  });\n\nconst processString = (str: string) =>\n  Effect.gen(function* () {\n    yield* Effect.log(`Processing string: \"${str}\"`);\n    return str.toUpperCase().split(\"\").reverse().join(\"\");\n  });\n\n// Demonstrate wrapping synchronous computations\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Wrapping Synchronous Computations Demo ===\");\n\n  // Example 1: Basic sync computation\n  yield* Effect.log(\"\\n1. Basic sync computation (random number):\");\n  const random1 = yield* randomNumber;\n  const random2 = yield* randomNumber;\n  yield* Effect.log(\n    `Random numbers: ${random1.toFixed(4)}, ${random2.toFixed(4)}`\n  );\n\n  // Example 2: Successful JSON parsing\n  yield* Effect.log(\"\\n2. Successful JSON parsing:\");\n  const validJson = '{\"name\": \"Paul\", \"age\": 30}';\n  const parsed = yield* parseJson(validJson);\n  yield* Effect.log(\"Parsed JSON:\" + JSON.stringify(parsed));\n\n  // Example 3: Failed JSON parsing with error logging\n  yield* Effect.log(\"\\n3. Failed JSON parsing with error logging:\");\n  const invalidJson = '{\"name\": \"Paul\", \"age\":}';\n  yield* parseJson(invalidJson).pipe(\n    Effect.tapError((error) => Effect.log(`Parsing failed: ${error.message}`)),\n    Effect.catchAll(() => Effect.succeed({ name: \"default\", age: 0 }))\n  );\n  yield* Effect.log(\"Continued after error (with recovery)\");\n\n  // Example 4: Division with error logging and recovery\n  yield* Effect.log(\"\\n4. Division with error logging and recovery:\");\n  const division1 = yield* divide(10, 2);\n  yield* Effect.log(`10 / 2 = ${division1}`);\n\n  // Use tapError to log, then catchAll to recover\n  const division2 = yield* divide(10, 0).pipe(\n    Effect.tapError((error) => Effect.log(`Division error: ${error.message}`)),\n    Effect.catchAll(() => Effect.succeed(-1))\n  );\n  yield* Effect.log(`10 / 0 = ${division2} (error handled)`);\n\n  // Example 5: String processing\n  yield* Effect.log(\"\\n5. String processing:\");\n  const processed = yield* processString(\"Hello Effect\");\n  yield* Effect.log(`Processed result: \"${processed}\"`);\n\n  // Example 6: Combining multiple sync operations\n  yield* Effect.log(\"\\n6. Combining multiple sync operations:\");\n  const combined = yield* Effect.gen(function* () {\n    const num = yield* randomNumber;\n    const multiplied = yield* Effect.sync(() => num * 100);\n    const rounded = yield* Effect.sync(() => Math.round(multiplied));\n    return rounded;\n  });\n  yield* Effect.log(`Combined operations result: ${combined}`);\n\n  yield* Effect.log(\"\\n\u2705 Synchronous computations demonstration completed!\");\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Wrap synchronous computations with sync and try."
            },
            "created_at": "2026-02-15T21:22:14.824837",
            "updated_at": "2026-02-20T23:09:33.006372"
        },
        {
            "id": "1815d722-6acc-4ffb-88d7-2aaae8e816dd",
            "slug": "wrap-asynchronous-computations",
            "title": "Wrap Asynchronous Computations with tryPromise",
            "summary": "Use Effect.tryPromise to safely convert a function that returns a Promise into an Effect, capturing rejections in the error channel.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "promise",
                "async",
                "integration",
                "creation",
                "try"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data } from \"effect\";\n\n// Define error type using Data.TaggedError\nclass HttpError extends Data.TaggedError(\"HttpError\")<{\n  readonly message: string;\n}> {}\n\n// Define HTTP client service\nexport class HttpClient extends Effect.Service<HttpClient>()(\"HttpClient\", {\n  // Provide default implementation\n  sync: () => ({\n    getUrl: (url: string) =>\n      Effect.tryPromise({\n        try: () => fetch(url),\n        catch: (error) =>\n          new HttpError({ message: `Failed to fetch ${url}: ${error}` }),\n      }),\n  }),\n}) {}\n\n// Mock HTTP client for demonstration\nexport class MockHttpClient extends Effect.Service<MockHttpClient>()(\n  \"MockHttpClient\",\n  {\n    sync: () => ({\n      getUrl: (url: string) =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Fetching URL: ${url}`);\n\n          // Simulate different responses based on URL\n          if (url.includes(\"success\")) {\n            yield* Effect.logInfo(\"\u2705 Request successful\");\n            return new Response(JSON.stringify({ data: \"success\" }), {\n              status: 200,\n            });\n          } else if (url.includes(\"error\")) {\n            yield* Effect.logInfo(\"\u274c Request failed\");\n            return yield* Effect.fail(\n              new HttpError({ message: \"Server returned 500\" })\n            );\n          } else {\n            yield* Effect.logInfo(\"\u2705 Request completed\");\n            return new Response(JSON.stringify({ data: \"mock response\" }), {\n              status: 200,\n            });\n          }\n        }),\n    }),\n  }\n) {}\n\n// Demonstrate wrapping asynchronous computations\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Wrapping Asynchronous Computations Demo ===\");\n\n  const client = yield* MockHttpClient;\n\n  // Example 1: Successful request\n  yield* Effect.logInfo(\"\\n1. Successful request:\");\n  const response1 = yield* client\n    .getUrl(\"https://api.example.com/success\")\n    .pipe(\n      Effect.catchAll((error) =>\n        Effect.gen(function* () {\n          yield* Effect.logError(`Request failed: ${error.message}`);\n          return new Response(\"Error response\", { status: 500 });\n        })\n      )\n    );\n  yield* Effect.logInfo(`Response status: ${response1.status}`);\n\n  // Example 2: Failed request with error handling\n  yield* Effect.logInfo(\"\\n2. Failed request with error handling:\");\n  const response2 = yield* client.getUrl(\"https://api.example.com/error\").pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Request failed: ${error.message}`);\n        return new Response(\"Fallback response\", { status: 200 });\n      })\n    )\n  );\n  yield* Effect.logInfo(`Fallback response status: ${response2.status}`);\n\n  // Example 3: Multiple async operations\n  yield* Effect.logInfo(\"\\n3. Multiple async operations:\");\n  const results = yield* Effect.all(\n    [\n      client.getUrl(\"https://api.example.com/endpoint1\"),\n      client.getUrl(\"https://api.example.com/endpoint2\"),\n      client.getUrl(\"https://api.example.com/endpoint3\"),\n    ],\n    { concurrency: 2 }\n  ).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`One or more requests failed: ${error.message}`);\n        return [];\n      })\n    )\n  );\n  yield* Effect.logInfo(`Completed ${results.length} requests`);\n\n  yield* Effect.logInfo(\n    \"\\n\u2705 Asynchronous computations demonstration completed!\"\n  );\n});\n\n// Run with mock implementation\nEffect.runPromise(Effect.provide(program, MockHttpClient.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Wrap asynchronous computations with tryPromise."
            },
            "created_at": "2026-02-15T21:22:14.740545",
            "updated_at": "2026-02-20T23:09:33.927542"
        },
        {
            "id": "9aa22238-b9c7-4b46-a349-24356d7b24fd",
            "slug": "effects-are-lazy",
            "title": "Understand that Effects are Lazy Blueprints",
            "summary": "An Effect is a lazy, immutable blueprint describing a computation, which does nothing until it is explicitly executed by a runtime.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "laziness",
                "immutability",
                "blueprint",
                "execution",
                "runtime",
                "core-concept"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\nEffect.runSync(Effect.log(\"1. Defining the Effect blueprint...\"));\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"3. The blueprint is now being executed!\");\n  return 42;\n});\n\nconst demonstrationProgram = Effect.gen(function* () {\n  yield* Effect.log(\n    \"2. The blueprint has been defined. No work has been done yet.\"\n  );\n  yield* program;\n});\n\nEffect.runSync(demonstrationProgram);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Understand that effects are lazy blueprints."
            },
            "created_at": "2026-02-15T21:22:14.338133",
            "updated_at": "2026-02-20T23:09:34.484816"
        },
        {
            "id": "9276e943-9774-40f0-878e-785913da3b0b",
            "slug": "safely-bracket-resource-usage",
            "title": "Safely Bracket Resource Usage with `acquireRelease`",
            "summary": "Use `Effect.acquireRelease` to guarantee a resource's cleanup logic runs, even if errors or interruptions occur.",
            "skill_level": "beginner",
            "category": "resource-management",
            "difficulty": "beginner",
            "tags": [
                "resource",
                "scope",
                "acquire",
                "release",
                "bracket",
                "finalizer",
                "try-finally",
                "interruption"
            ],
            "examples": [
                {
                    "code": "import { Effect, Console } from \"effect\";\n\n// A mock resource that needs to be managed\nconst getDbConnection = Effect.sync(() => ({ id: Math.random() })).pipe(\n  Effect.tap(() => Effect.log(\"Connection Acquired\"))\n);\n\nconst closeDbConnection = (conn: {\n  id: number;\n}): Effect.Effect<void, never, never> =>\n  Effect.log(`Connection ${conn.id} Released`);\n\n// The program that uses the resource\nconst program = Effect.acquireRelease(\n  getDbConnection, // 1. acquire\n  (connection) => closeDbConnection(connection) // 2. cleanup\n).pipe(\n  Effect.tap((connection) =>\n    Effect.log(`Using connection ${connection.id} to run query...`)\n  )\n);\n\nEffect.runPromise(Effect.scoped(program));\n\n/*\nOutput:\nConnection Acquired\nUsing connection 0.12345... to run query...\nConnection 0.12345... Released\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Bracket the use of a resource between an `acquire` and a `release` effect."
            },
            "created_at": "2026-02-15T21:22:18.325783",
            "updated_at": "2026-02-20T23:09:32.683784"
        },
        {
            "id": "aefb18e7-e88d-49c1-8ee5-b0eca2a78ee7",
            "slug": "write-sequential-code-with-gen",
            "title": "Write Sequential Code with Effect.gen",
            "summary": "Use Effect.gen with yield* to write sequential, asynchronous code in a style that looks and feels like familiar async/await.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "generators",
                "gen",
                "sequential",
                "async-await",
                "readability"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Mock API functions for demonstration\nconst fetchUser = (id: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching user ${id}...`);\n    // Simulate API call\n    yield* Effect.sleep(\"100 millis\");\n    return { id, name: `User ${id}`, email: `user${id}@example.com` };\n  });\n\nconst fetchUserPosts = (userId: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching posts for user ${userId}...`);\n    // Simulate API call\n    yield* Effect.sleep(\"150 millis\");\n    return [\n      { id: 1, title: \"First Post\", userId },\n      { id: 2, title: \"Second Post\", userId },\n    ];\n  });\n\nconst fetchPostComments = (postId: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching comments for post ${postId}...`);\n    // Simulate API call\n    yield* Effect.sleep(\"75 millis\");\n    return [\n      { id: 1, text: \"Great post!\", postId },\n      { id: 2, text: \"Thanks for sharing\", postId },\n    ];\n  });\n\n// Example of sequential code with Effect.gen\nconst getUserDataWithGen = (userId: number) =>\n  Effect.gen(function* () {\n    // Step 1: Fetch user\n    const user = yield* fetchUser(userId);\n    yield* Effect.logInfo(`\u2705 Got user: ${user.name}`);\n\n    // Step 2: Fetch user's posts (depends on user data)\n    const posts = yield* fetchUserPosts(user.id);\n    yield* Effect.logInfo(`\u2705 Got ${posts.length} posts`);\n\n    // Step 3: Fetch comments for first post (depends on posts data)\n    const firstPost = posts[0];\n    const comments = yield* fetchPostComments(firstPost.id);\n    yield* Effect.logInfo(\n      `\u2705 Got ${comments.length} comments for \"${firstPost.title}\"`\n    );\n\n    // Step 4: Combine all data\n    const result = {\n      user,\n      posts,\n      featuredPost: {\n        ...firstPost,\n        comments,\n      },\n    };\n\n    yield* Effect.logInfo(\"\u2705 Successfully combined all user data\");\n    return result;\n  });\n\n// Example without Effect.gen (more complex)\nconst getUserDataWithoutGen = (userId: number) =>\n  fetchUser(userId).pipe(\n    Effect.flatMap((user) =>\n      fetchUserPosts(user.id).pipe(\n        Effect.flatMap((posts) =>\n          fetchPostComments(posts[0].id).pipe(\n            Effect.map((comments) => ({\n              user,\n              posts,\n              featuredPost: {\n                ...posts[0],\n                comments,\n              },\n            }))\n          )\n        )\n      )\n    )\n  );\n\n// Demonstrate writing sequential code with gen\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Writing Sequential Code with Effect.gen Demo ===\");\n\n  // Example 1: Sequential operations with Effect.gen\n  yield* Effect.logInfo(\"\\n1. Sequential operations with Effect.gen:\");\n  const userData = yield* getUserDataWithGen(123).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to get user data: ${error}`);\n        return null;\n      })\n    )\n  );\n\n  if (userData) {\n    yield* Effect.logInfo(\n      `Final result: User \"${userData.user.name}\" has ${userData.posts.length} posts`\n    );\n    yield* Effect.logInfo(\n      `Featured post: \"${userData.featuredPost.title}\" with ${userData.featuredPost.comments.length} comments`\n    );\n  }\n\n  // Example 2: Compare with traditional promise-like chaining\n  yield* Effect.logInfo(\"\\n2. Same logic without Effect.gen (for comparison):\");\n  const userData2 = yield* getUserDataWithoutGen(456).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to get user data: ${error}`);\n        return null;\n      })\n    )\n  );\n\n  if (userData2) {\n    yield* Effect.logInfo(\n      `Result from traditional approach: User \"${userData2.user.name}\"`\n    );\n  }\n\n  // Example 3: Error handling in sequential code\n  yield* Effect.logInfo(\"\\n3. Error handling in sequential operations:\");\n  const errorHandling = yield* Effect.gen(function* () {\n    try {\n      const user = yield* fetchUser(999);\n      const posts = yield* fetchUserPosts(user.id);\n      return { user, posts };\n    } catch (error) {\n      yield* Effect.logError(`Error in sequential operations: ${error}`);\n      return null;\n    }\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Caught error: ${error}`);\n        return { user: null, posts: [] };\n      })\n    )\n  );\n\n  yield* Effect.logInfo(\n    `Error handling result: ${errorHandling ? \"Success\" : \"Handled error\"}`\n  );\n\n  yield* Effect.logInfo(\"\\n\u2705 Sequential code demonstration completed!\");\n  yield* Effect.logInfo(\n    \"Effect.gen makes sequential async code look like synchronous code!\"\n  );\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Write sequential code with Effect.gen."
            },
            "created_at": "2026-02-15T21:22:14.999028",
            "updated_at": "2026-02-20T23:09:33.878977"
        },
        {
            "id": "ae2d0ee6-5f96-4209-a906-5dc76fbe8b49",
            "slug": "access-config-in-context",
            "title": "Access Configuration from the Context",
            "summary": "Access your type-safe configuration within an Effect.gen block by yielding the Config object you defined.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "configuration",
                "config",
                "context",
                "generators",
                "business-logic"
            ],
            "examples": [
                {
                    "code": "import { Config, Effect, Layer } from \"effect\";\n\n// Define config service\nclass AppConfig extends Effect.Service<AppConfig>()(\"AppConfig\", {\n  sync: () => ({\n    host: \"localhost\",\n    port: 3000,\n  }),\n}) {}\n\n// Create program that uses config\nconst program = Effect.gen(function* () {\n  const config = yield* AppConfig;\n  yield* Effect.log(`Starting server on http://${config.host}:${config.port}`);\n});\n\n// Run the program with default config\nEffect.runPromise(Effect.provide(program, AppConfig.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Access configuration from the Effect context."
            },
            "created_at": "2026-02-15T21:22:15.083594",
            "updated_at": "2026-02-20T23:09:34.794573"
        },
        {
            "id": "03470e04-a415-446b-b02d-94a20173c11e",
            "slug": "data-datetime",
            "title": "Work with Dates and Times using DateTime",
            "summary": "Use DateTime for immutable, time-zone-aware date and time values, enabling safe and precise time calculations.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "DateTime",
                "date",
                "time",
                "timezone",
                "data-type",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { DateTime } from \"effect\";\n\n// Create a DateTime for the current instant (returns an Effect)\nimport { Effect } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  const now = yield* DateTime.now; // DateTime.Utc\n\n  // Parse from ISO string\n  const parsed = DateTime.unsafeMakeZoned(\"2024-07-19T12:34:56Z\"); // DateTime.Zoned\n\n  // Add or subtract durations\n  const inOneHour = DateTime.add(now, { hours: 1 });\n  const oneHourAgo = DateTime.subtract(now, { hours: 1 });\n\n  // Format as ISO string\n  const iso = DateTime.formatIso(now); // e.g., \"2024-07-19T23:33:19.000Z\"\n\n  // Compare DateTimes\n  const isBefore = DateTime.lessThan(oneHourAgo, now); // true\n\n  return { now, inOneHour, oneHourAgo, iso, isBefore };\n});",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use DateTime to represent and manipulate dates and times in a type-safe, immutable, and time-zone-aware way."
            },
            "created_at": "2026-02-15T21:22:16.773432",
            "updated_at": "2026-02-20T23:09:32.803739"
        },
        {
            "id": "135bcb22-bc38-4a92-b725-650389a3374c",
            "slug": "understand-effect-channels",
            "title": "Understand the Three Effect Channels (A, E, R)",
            "summary": "Learn about the three generic parameters of an Effect: the success value (A), the failure error (E), and the context requirements (R).",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "effect",
                "type-parameters",
                "success",
                "error",
                "context",
                "requirements",
                "A",
                "E",
                "R",
                "core-concept"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data } from \"effect\";\n\n// Define the types for our channels\ninterface User {\n  readonly name: string;\n} // The 'A' type\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\") {} // The 'E' type\n\n// Define the Database service using Effect.Service\nexport class Database extends Effect.Service<Database>()(\"Database\", {\n  // Provide a default implementation\n  sync: () => ({\n    findUser: (id: number) =>\n      id === 1\n        ? Effect.succeed({ name: \"Paul\" })\n        : Effect.fail(new UserNotFoundError()),\n  }),\n}) {}\n\n// This function's signature shows all three channels\nconst getUser = (\n  id: number\n): Effect.Effect<User, UserNotFoundError, Database> =>\n  Effect.gen(function* () {\n    const db = yield* Database;\n    return yield* db.findUser(id);\n  });\n\n// The program will use the default implementation\nconst program = getUser(1);\n\n// Run the program with the default implementation\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* Effect.provide(program, Database.Default);\n  yield* Effect.log(`Result: ${JSON.stringify(result)}`); // { name: 'Paul' }\n  return result;\n});\n\nEffect.runPromise(programWithLogging);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Understand that an Effect<A, E, R> describes a computation with a success type (A), an error type (E), and a requirements type (R)."
            },
            "created_at": "2026-02-15T21:22:14.418424",
            "updated_at": "2026-02-20T23:09:32.882176"
        },
        {
            "id": "1ece10c7-525f-4e08-a69a-bf516fd4b887",
            "slug": "data-redacted",
            "title": "Redact and Handle Sensitive Data",
            "summary": "Use Redacted to securely handle sensitive data, ensuring secrets are not accidentally logged or exposed.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "Redacted",
                "security",
                "sensitive-data",
                "logging",
                "data-type",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Redacted } from \"effect\";\n\n// Wrap a sensitive value\nconst secret = Redacted.make(\"super-secret-password\");\n\n// Use the secret in your application logic\nfunction authenticate(user: string, password: Redacted.Redacted<string>) {\n  // ... authentication logic\n}\n\n// Logging or stringifying a Redacted value\nconsole.log(`Password: ${secret}`); // Output: Password: <redacted>\nconsole.log(String(secret)); // Output: <redacted>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Redacted to wrap sensitive values, preventing accidental exposure in logs or error messages."
            },
            "created_at": "2026-02-15T21:22:16.030119",
            "updated_at": "2026-02-20T23:09:34.744397"
        },
        {
            "id": "cd10a96c-4582-4cfd-8a06-24da9da394ee",
            "slug": "use-pipe-for-composition",
            "title": "Use .pipe for Composition",
            "summary": "Use the .pipe() method to chain multiple operations onto an Effect in a readable, top-to-bottom sequence.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "pipe",
                "composition",
                "chaining",
                "readability"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\nconst program = Effect.succeed(5).pipe(\n  Effect.map((n) => n * 2),\n  Effect.map((n) => `The result is ${n}`),\n  Effect.tap(Effect.log)\n);\n\n// Demonstrate various pipe composition patterns\nconst demo = Effect.gen(function* () {\n  yield* Effect.log(\"=== Using Pipe for Composition Demo ===\");\n\n  // 1. Basic pipe composition\n  yield* Effect.log(\"\\n1. Basic pipe composition:\");\n  yield* program;\n\n  // 2. Complex pipe composition with multiple transformations\n  yield* Effect.log(\"\\n2. Complex pipe composition:\");\n  const complexResult = yield* Effect.succeed(10).pipe(\n    Effect.map((n) => n + 5),\n    Effect.map((n) => n * 2),\n    Effect.tap((n) => Effect.log(`Intermediate result: ${n}`)),\n    Effect.map((n) => n.toString()),\n    Effect.map((s) => `Final: ${s}`)\n  );\n  yield* Effect.log(\"Complex result: \" + complexResult);\n\n  // 3. Pipe with flatMap for chaining effects\n  yield* Effect.log(\"\\n3. Pipe with flatMap for chaining effects:\");\n  const chainedResult = yield* Effect.succeed(\"hello\").pipe(\n    Effect.map((s) => s.toUpperCase()),\n    Effect.flatMap((s) => Effect.succeed(`${s} WORLD`)),\n    Effect.flatMap((s) => Effect.succeed(`${s}!`)),\n    Effect.tap((s) => Effect.log(`Chained: ${s}`))\n  );\n  yield* Effect.log(\"Chained result: \" + chainedResult);\n\n  // 4. Pipe with error handling\n  yield* Effect.log(\"\\n4. Pipe with error handling:\");\n  const errorHandledResult = yield* Effect.succeed(-1).pipe(\n    Effect.flatMap((n) =>\n      n > 0 ? Effect.succeed(n) : Effect.fail(new Error(\"Negative number\"))\n    ),\n    Effect.catchAll((error) =>\n      Effect.succeed(\"Handled error: \" + error.message)\n    ),\n    Effect.tap((result) => Effect.log(`Error handled: ${result}`))\n  );\n  yield* Effect.log(\"Error handled result: \" + errorHandledResult);\n\n  // 5. Pipe with multiple operations\n  yield* Effect.log(\"\\n5. Pipe with multiple operations:\");\n  const multiOpResult = yield* Effect.succeed([1, 2, 3, 4, 5]).pipe(\n    Effect.map((arr) => arr.filter((n) => n % 2 === 0)),\n    Effect.map((arr) => arr.map((n) => n * 2)),\n    Effect.map((arr) => arr.reduce((sum, n) => sum + n, 0)),\n    Effect.tap((sum) => Effect.log(`Sum of even numbers doubled: ${sum}`))\n  );\n  yield* Effect.log(\"Multi-operation result: \" + multiOpResult);\n\n  yield* Effect.log(\"\\n\u2705 Pipe composition demonstration completed!\");\n});\n\nEffect.runPromise(demo);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use .pipe for composition."
            },
            "created_at": "2026-02-15T21:22:14.502738",
            "updated_at": "2026-02-20T23:09:32.928227"
        },
        {
            "id": "815a32b8-2dbf-45cc-8b53-4c64cf17aad7",
            "slug": "define-config-schema",
            "title": "Define a Type-Safe Configuration Schema",
            "summary": "Use Effect.Config primitives to define a schema for your application's configuration, ensuring type-safety and separation from code.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "configuration",
                "config",
                "schema",
                "type-safety"
            ],
            "examples": [
                {
                    "code": "import { Config, Effect, ConfigProvider, Layer } from \"effect\";\n\nconst ServerConfig = Config.nested(\"SERVER\")(\n  Config.all({\n    host: Config.string(\"HOST\"),\n    port: Config.number(\"PORT\"),\n  })\n);\n\n// Example program that uses the config\nconst program = Effect.gen(function* () {\n  const config = yield* ServerConfig;\n  yield* Effect.logInfo(`Server config loaded: ${JSON.stringify(config)}`);\n});\n\n// Create a config provider with test values\nconst TestConfig = ConfigProvider.fromMap(\n  new Map([\n    [\"SERVER.HOST\", \"localhost\"],\n    [\"SERVER.PORT\", \"3000\"],\n  ])\n);\n\n// Run with test config\nEffect.runPromise(Effect.provide(program, Layer.setConfigProvider(TestConfig)));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Define a type-safe configuration schema."
            },
            "created_at": "2026-02-15T21:22:15.359846",
            "updated_at": "2026-02-20T23:09:33.473994"
        },
        {
            "id": "7e3bebcc-ae0f-49e9-855d-60ad6cfe1d66",
            "slug": "pattern-option-either-checks",
            "title": "Checking Option and Either Cases",
            "summary": "Use isSome, isNone, isLeft, and isRight to check Option and Either cases for simple, type-safe branching.",
            "skill_level": "beginner",
            "category": "error-management",
            "difficulty": "beginner",
            "tags": [
                "isSome",
                "isNone",
                "isLeft",
                "isRight",
                "pattern-matching",
                "option",
                "either",
                "checks"
            ],
            "examples": [
                {
                    "code": "import { Option, Either } from \"effect\";\n\n// Option: Check if value is Some or None\nconst option = Option.some(42);\n\nif (Option.isSome(option)) {\n  // option.value is available here\n  console.log(\"We have a value:\", option.value);\n} else if (Option.isNone(option)) {\n  console.log(\"No value present\");\n}\n\n// Either: Check if value is Right or Left\nconst either = Either.left(\"error\");\n\nif (Either.isRight(either)) {\n  // either.right is available here\n  console.log(\"Success:\", either.right);\n} else if (Either.isLeft(either)) {\n  // either.left is available here\n  console.log(\"Failure:\", either.left);\n}\n\n// Filtering a collection of Options\nconst options = [Option.some(1), Option.none(), Option.some(3)];\nconst presentValues = options.filter(Option.isSome).map((o) => o.value); // [1, 3]",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use isSome, isNone, isLeft, and isRight to check Option and Either cases for simple, type-safe conditional logic."
            },
            "created_at": "2026-02-15T21:22:17.026639",
            "updated_at": "2026-02-20T23:09:41.41202"
        },
        {
            "id": "89995f95-6e76-453a-b66f-f8c661045244",
            "slug": "pattern-option-either-match",
            "title": "Pattern Match on Option and Either",
            "summary": "Use declarative match() combinators to handle optional and error-prone values",
            "skill_level": "beginner",
            "category": "error-management",
            "difficulty": "beginner",
            "tags": [
                "option",
                "either",
                "pattern-matching",
                "match",
                "declarative"
            ],
            "examples": [
                {
                    "code": "import { Option } from \"effect\";\n\nconst getUserName = (id: number): Option.Option<string> => {\n  return id === 1 ? Option.some(\"Alice\") : Option.none();\n};\n\n// Using .match() for declarative pattern matching\nconst displayUser = (id: number): string =>\n  getUserName(id).pipe(\n    Option.match({\n      onNone: () => \"Guest User\",\n      onSome: (name) => `Hello, ${name}!`,\n    })\n  );\n\nconsole.log(displayUser(1));   // \"Hello, Alice!\"\nconsole.log(displayUser(999)); // \"Guest User\"",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Option.match() and Either.match() for declarative pattern matching on optional and error-prone values"
            },
            "created_at": "2026-02-15T21:22:17.196511",
            "updated_at": "2026-02-20T23:09:41.935033"
        },
        {
            "id": "4816949d-a950-4112-a5b1-9b90298f492f",
            "slug": "beyond-the-date-type",
            "title": "Beyond the Date Type - Real World Dates, Times, and Timezones",
            "summary": "Use the Clock service for testable access to the current time and prefer immutable primitives for storing and passing timestamps.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "time",
                "date",
                "clock",
                "test-clock",
                "testing",
                "timezone"
            ],
            "examples": [
                {
                    "code": "import { Effect, Clock } from \"effect\";\nimport type * as Types from \"effect/Clock\";\n\ninterface Event {\n  readonly message: string;\n  readonly timestamp: number; // Store as a primitive number (UTC millis)\n}\n\n// This function is pure and testable because it depends on Clock\nconst createEvent = (\n  message: string\n): Effect.Effect<Event, never, Types.Clock> =>\n  Effect.gen(function* () {\n    const timestamp = yield* Clock.currentTimeMillis;\n    return { message, timestamp };\n  });\n\n// Create and log some events\nconst program = Effect.gen(function* () {\n  const loginEvent = yield* createEvent(\"User logged in\");\n  yield* Effect.log(\"Login event:\", loginEvent);\n\n  const logoutEvent = yield* createEvent(\"User logged out\");\n  yield* Effect.log(\"Logout event:\", logoutEvent);\n});\n\n// Run the program\nconst programWithErrorHandling = program.pipe(\n  Effect.provideService(Clock.Clock, Clock.make()),\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use the Clock service for testable time-based logic and immutable primitives for timestamps."
            },
            "created_at": "2026-02-15T21:22:15.173965",
            "updated_at": "2026-02-20T23:09:33.097812"
        },
        {
            "id": "23cf3522-f41c-424d-87f9-37f4f4f6afd3",
            "slug": "pattern-matchtag",
            "title": "Matching Tagged Unions with matchTag and matchTags",
            "summary": "Use matchTag and matchTags to pattern match on specific tagged union cases, enabling precise and type-safe branching.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "matchTag",
                "matchTags",
                "pattern-matching",
                "tagged-union",
                "effect",
                "error-handling",
                "branching"
            ],
            "examples": [
                {
                    "code": "import { Data, Effect } from \"effect\";\n\n// Define a tagged error type\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{}> {}\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  message: string;\n}> {}\n\ntype MyError = NotFoundError | ValidationError;\n\n// Effect: Match on specific error tags\nconst effect: Effect.Effect<string, never, never> = Effect.fail(\n  new ValidationError({ message: \"Invalid input\" }) as MyError\n).pipe(\n  Effect.catchTags({\n    NotFoundError: () => Effect.succeed(\"Not found!\"),\n    ValidationError: (err) =>\n      Effect.succeed(`Validation failed: ${err.message}`),\n  })\n); // Effect<string>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use matchTag and matchTags to handle specific cases of tagged unions or custom error types in a declarative, type-safe way."
            },
            "created_at": "2026-02-15T21:22:18.032481",
            "updated_at": "2026-02-20T23:09:41.805485"
        },
        {
            "id": "afcaa492-cc90-4e7d-8ac3-d2a402d0cb60",
            "slug": "handle-unexpected-errors-with-cause",
            "title": "Handle Unexpected Errors by Inspecting the Cause",
            "summary": "Use Effect.catchAllCause or Effect.runFork to inspect the Cause of a failure, distinguishing between expected errors (Fail) and unexpected defects (Die).",
            "skill_level": "advanced",
            "category": "error-management",
            "difficulty": "advanced",
            "tags": [
                "error-handling",
                "cause",
                "exit",
                "defect",
                "die",
                "unexpected-error",
                "runtime"
            ],
            "examples": [
                {
                    "code": "import { Cause, Effect, Data, Schedule, Duration } from \"effect\";\n\n// Define domain types\ninterface DatabaseConfig {\n  readonly url: string;\n}\n\ninterface DatabaseConnection {\n  readonly success: true;\n}\n\ninterface UserData {\n  readonly id: string;\n  readonly name: string;\n}\n\n// Define error types\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\")<{\n  readonly operation: string;\n  readonly details: string;\n}> {}\n\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly field: string;\n  readonly message: string;\n}> {}\n\n// Define database service\nclass DatabaseService extends Effect.Service<DatabaseService>()(\n  \"DatabaseService\",\n  {\n    sync: () => ({\n      // Connect to database with proper error handling\n      connect: (\n        config: DatabaseConfig\n      ): Effect.Effect<DatabaseConnection, DatabaseError> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`Connecting to database: ${config.url}`);\n\n          if (!config.url) {\n            const error = new DatabaseError({\n              operation: \"connect\",\n              details: \"Missing URL\",\n            });\n            yield* Effect.logError(`Database error: ${JSON.stringify(error)}`);\n            return yield* Effect.fail(error);\n          }\n\n          // Simulate unexpected errors\n          if (config.url === \"invalid\") {\n            yield* Effect.logError(\"Invalid connection string\");\n            return yield* Effect.sync(() => {\n              throw new Error(\"Failed to parse connection string\");\n            });\n          }\n\n          if (config.url === \"timeout\") {\n            yield* Effect.logError(\"Connection timeout\");\n            return yield* Effect.sync(() => {\n              throw new Error(\"Connection timed out\");\n            });\n          }\n\n          yield* Effect.logInfo(\"Database connection successful\");\n          return { success: true };\n        }),\n    }),\n  }\n) {}\n\n// Define user service\nclass UserService extends Effect.Service<UserService>()(\"UserService\", {\n  sync: () => ({\n    // Parse user data with validation\n    parseUser: (input: unknown): Effect.Effect<UserData, ValidationError> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Parsing user data: ${JSON.stringify(input)}`);\n\n        try {\n          if (typeof input !== \"object\" || !input) {\n            const error = new ValidationError({\n              field: \"input\",\n              message: \"Invalid input type\",\n            });\n            yield* Effect.logWarning(\n              `Validation error: ${JSON.stringify(error)}`\n            );\n            throw error;\n          }\n\n          const data = input as Record<string, unknown>;\n\n          if (typeof data.id !== \"string\" || typeof data.name !== \"string\") {\n            const error = new ValidationError({\n              field: \"input\",\n              message: \"Missing required fields\",\n            });\n            yield* Effect.logWarning(\n              `Validation error: ${JSON.stringify(error)}`\n            );\n            throw error;\n          }\n\n          const user = { id: data.id, name: data.name };\n          yield* Effect.logInfo(\n            `Successfully parsed user: ${JSON.stringify(user)}`\n          );\n          return user;\n        } catch (e) {\n          if (e instanceof ValidationError) {\n            return yield* Effect.fail(e);\n          }\n          yield* Effect.logError(\n            `Unexpected error: ${e instanceof Error ? e.message : String(e)}`\n          );\n          throw e;\n        }\n      }),\n  }),\n}) {}\n\n// Define test service\nclass TestService extends Effect.Service<TestService>()(\"TestService\", {\n  sync: () => {\n    // Create instance methods\n    const printCause = (\n      prefix: string,\n      cause: Cause.Cause<unknown>\n    ): Effect.Effect<void, never, never> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`\\n=== ${prefix} ===`);\n\n        if (Cause.isDie(cause)) {\n          const defect = Cause.failureOption(cause);\n          if (defect._tag === \"Some\") {\n            const error = defect.value as Error;\n            yield* Effect.logError(\"Defect (unexpected error)\");\n            yield* Effect.logError(`Message: ${error.message}`);\n            yield* Effect.logError(\n              `Stack: ${error.stack?.split(\"\\n\")[1]?.trim() ?? \"N/A\"}`\n            );\n          }\n        } else if (Cause.isFailure(cause)) {\n          const error = Cause.failureOption(cause);\n          yield* Effect.logWarning(\"Expected failure\");\n          yield* Effect.logWarning(`Error: ${JSON.stringify(error)}`);\n        }\n\n        // Don't return an Effect inside Effect.gen, just return the value directly\n        return void 0;\n      });\n\n    const runScenario = <E, A extends { [key: string]: any }>(\n      name: string,\n      program: Effect.Effect<A, E>\n    ): Effect.Effect<void, never, never> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`\\n=== Testing: ${name} ===`);\n\n        type TestError = {\n          readonly _tag: \"error\";\n          readonly cause: Cause.Cause<E>;\n        };\n\n        const result = yield* Effect.catchAllCause(program, (cause) =>\n          Effect.succeed({ _tag: \"error\" as const, cause } as TestError)\n        );\n\n        if (\"cause\" in result) {\n          yield* printCause(\"Error details\", result.cause);\n        } else {\n          yield* Effect.logInfo(`Success: ${JSON.stringify(result)}`);\n        }\n\n        // Don't return an Effect inside Effect.gen, just return the value directly\n        return void 0;\n      });\n\n    // Return bound methods\n    return {\n      printCause,\n      runScenario,\n    };\n  },\n}) {}\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const db = yield* DatabaseService;\n  const users = yield* UserService;\n  const test = yield* TestService;\n\n  yield* Effect.logInfo(\"=== Starting Error Handling Tests ===\");\n\n  // Test expected database errors\n  yield* test.runScenario(\n    \"Expected database error\",\n    Effect.gen(function* () {\n      const result = yield* Effect.retry(\n        db.connect({ url: \"\" }),\n        Schedule.exponential(100)\n      ).pipe(\n        Effect.timeout(Duration.seconds(5)),\n        Effect.catchAll(() => Effect.fail(\"Connection timeout\"))\n      );\n      return result;\n    })\n  );\n\n  // Test unexpected connection errors\n  yield* test.runScenario(\n    \"Unexpected connection error\",\n    Effect.gen(function* () {\n      const result = yield* Effect.retry(\n        db.connect({ url: \"invalid\" }),\n        Schedule.recurs(3)\n      ).pipe(\n        Effect.catchAllCause((cause) =>\n          Effect.gen(function* () {\n            yield* Effect.logError(\"Failed after 3 retries\");\n            yield* Effect.logError(Cause.pretty(cause));\n            return yield* Effect.fail(\"Max retries exceeded\");\n          })\n        )\n      );\n      return result;\n    })\n  );\n\n  // Test user validation with recovery\n  yield* test.runScenario(\n    \"Valid user data\",\n    Effect.gen(function* () {\n      const result = yield* users\n        .parseUser({ id: \"1\", name: \"John\" })\n        .pipe(\n          Effect.orElse(() =>\n            Effect.succeed({ id: \"default\", name: \"Default User\" })\n          )\n        );\n      return result;\n    })\n  );\n\n  // Test concurrent error handling with timeout\n  yield* test.runScenario(\n    \"Concurrent operations\",\n    Effect.gen(function* () {\n      const results = yield* Effect.all(\n        [\n          db.connect({ url: \"\" }).pipe(\n            Effect.timeout(Duration.seconds(1)),\n            Effect.catchAll(() => Effect.succeed({ success: true }))\n          ),\n          users.parseUser({ id: \"invalid\" }).pipe(\n            Effect.timeout(Duration.seconds(1)),\n            Effect.catchAll(() =>\n              Effect.succeed({ id: \"timeout\", name: \"Timeout\" })\n            )\n          ),\n        ],\n        { concurrency: 2 }\n      );\n      return results;\n    })\n  );\n\n  yield* Effect.logInfo(\"\\n=== Error Handling Tests Complete ===\");\n\n  // Don't return an Effect inside Effect.gen, just return the value directly\n  return void 0;\n});\n\n// Run the program with all services\nEffect.runPromise(\n  Effect.provide(\n    Effect.provide(\n      Effect.provide(program, TestService.Default),\n      DatabaseService.Default\n    ),\n    UserService.Default\n  )\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Handle unexpected errors by inspecting the cause."
            },
            "created_at": "2026-02-15T21:22:18.226138",
            "updated_at": "2026-02-20T23:09:42.111809"
        },
        {
            "id": "d850e402-85db-4318-b8b8-be8ff4b77470",
            "slug": "handle-errors-with-catch",
            "title": "Handle Errors with catchTag, catchTags, and catchAll",
            "summary": "Use catchTag for type-safe recovery from specific tagged errors, and catchAll to recover from any possible failure.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "error-handling",
                "catch",
                "tagged-error",
                "recovery"
            ],
            "examples": [
                {
                    "code": "import { Data, Effect } from \"effect\";\n\n// Define domain types\ninterface User {\n  readonly id: string;\n  readonly name: string;\n}\n\n// Define specific error types\nclass NetworkError extends Data.TaggedError(\"NetworkError\")<{\n  readonly url: string;\n  readonly code: number;\n}> {}\n\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly field: string;\n  readonly message: string;\n}> {}\n\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{\n  readonly id: string;\n}> {}\n\n// Define UserService\nclass UserService extends Effect.Service<UserService>()(\"UserService\", {\n  sync: () => ({\n    // Fetch user data\n    fetchUser: (\n      id: string\n    ): Effect.Effect<User, NetworkError | NotFoundError> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Fetching user with id: ${id}`);\n\n        if (id === \"invalid\") {\n          const url = \"/api/users/\" + id;\n          yield* Effect.logWarning(`Network error accessing: ${url}`);\n          return yield* Effect.fail(new NetworkError({ url, code: 500 }));\n        }\n\n        if (id === \"missing\") {\n          yield* Effect.logWarning(`User not found: ${id}`);\n          return yield* Effect.fail(new NotFoundError({ id }));\n        }\n\n        const user = { id, name: \"John Doe\" };\n        yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n        return user;\n      }),\n\n    // Validate user data\n    validateUser: (user: User): Effect.Effect<string, ValidationError> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Validating user: ${JSON.stringify(user)}`);\n\n        if (user.name.length < 3) {\n          yield* Effect.logWarning(\n            `Validation failed: name too short for user ${user.id}`\n          );\n          return yield* Effect.fail(\n            new ValidationError({ field: \"name\", message: \"Name too short\" })\n          );\n        }\n\n        const message = `User ${user.name} is valid`;\n        yield* Effect.logInfo(message);\n        return message;\n      }),\n  }),\n}) {}\n\n// Compose operations with error handling using catchTags\nconst processUser = (\n  userId: string\n): Effect.Effect<string, never, UserService> =>\n  Effect.gen(function* () {\n    const userService = yield* UserService;\n\n    yield* Effect.logInfo(`=== Processing user ID: ${userId} ===`);\n\n    const result = yield* userService.fetchUser(userId).pipe(\n      Effect.flatMap(userService.validateUser),\n      // Handle different error types with specific recovery logic\n      Effect.catchTags({\n        NetworkError: (e) =>\n          Effect.gen(function* () {\n            const message = `Network error: ${e.code} for ${e.url}`;\n            yield* Effect.logError(message);\n            return message;\n          }),\n        NotFoundError: (e) =>\n          Effect.gen(function* () {\n            const message = `User ${e.id} not found`;\n            yield* Effect.logWarning(message);\n            return message;\n          }),\n        ValidationError: (e) =>\n          Effect.gen(function* () {\n            const message = `Invalid ${e.field}: ${e.message}`;\n            yield* Effect.logWarning(message);\n            return message;\n          }),\n      })\n    );\n\n    yield* Effect.logInfo(`Result: ${result}`);\n    return result;\n  });\n\n// Test with different scenarios\nconst runTests = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Starting User Processing Tests ===\");\n\n  const testCases = [\"valid\", \"invalid\", \"missing\"];\n  const results = yield* Effect.forEach(testCases, (id) => processUser(id));\n\n  yield* Effect.logInfo(\"=== User Processing Tests Complete ===\");\n  return results;\n});\n\n// Run the program\nEffect.runPromise(Effect.provide(runTests, UserService.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Handle errors with catchTag, catchTags, and catchAll."
            },
            "created_at": "2026-02-15T21:22:17.611638",
            "updated_at": "2026-02-20T23:09:42.155764"
        },
        {
            "id": "97829011-517e-4c61-862a-e9463398d61d",
            "slug": "resource-hierarchies",
            "title": "Manage Hierarchical Resources",
            "summary": "Manage parent-child resource relationships where children must be released before parents.",
            "skill_level": "advanced",
            "category": "resource-management",
            "difficulty": "advanced",
            "tags": [
                "resource-management",
                "hierarchy",
                "scope",
                "lifecycle"
            ],
            "examples": [
                {
                    "code": "import { Effect, Scope, Exit } from \"effect\"\n\n// ============================================\n// 1. Define hierarchical resources\n// ============================================\n\ninterface Database {\n  readonly name: string\n  readonly createConnection: () => Effect.Effect<Connection, never, Scope.Scope>\n}\n\ninterface Connection {\n  readonly id: string\n  readonly database: string\n  readonly beginTransaction: () => Effect.Effect<Transaction, never, Scope.Scope>\n}\n\ninterface Transaction {\n  readonly id: string\n  readonly connectionId: string\n  readonly execute: (sql: string) => Effect.Effect<void>\n}\n\n// ============================================\n// 2. Create resources with proper lifecycle\n// ============================================\n\nconst makeDatabase = (name: string): Effect.Effect<Database, never, Scope.Scope> =>\n  Effect.acquireRelease(\n    Effect.gen(function* () {\n      yield* Effect.log(`Opening database: ${name}`)\n      \n      const db: Database = {\n        name,\n        createConnection: () => makeConnection(name),\n      }\n      \n      return db\n    }),\n    (db) => Effect.log(`Closing database: ${db.name}`)\n  )\n\nconst makeConnection = (dbName: string): Effect.Effect<Connection, never, Scope.Scope> =>\n  Effect.acquireRelease(\n    Effect.gen(function* () {\n      const id = `conn-${crypto.randomUUID().slice(0, 8)}`\n      yield* Effect.log(`  Opening connection: ${id} to ${dbName}`)\n      \n      const conn: Connection = {\n        id,\n        database: dbName,\n        beginTransaction: () => makeTransaction(id),\n      }\n      \n      return conn\n    }),\n    (conn) => Effect.log(`  Closing connection: ${conn.id}`)\n  )\n\nconst makeTransaction = (connId: string): Effect.Effect<Transaction, never, Scope.Scope> =>\n  Effect.acquireRelease(\n    Effect.gen(function* () {\n      const id = `tx-${crypto.randomUUID().slice(0, 8)}`\n      yield* Effect.log(`    Beginning transaction: ${id}`)\n      \n      const tx: Transaction = {\n        id,\n        connectionId: connId,\n        execute: (sql) => Effect.log(`      [${id}] ${sql}`),\n      }\n      \n      return tx\n    }),\n    (tx) => Effect.log(`    Committing transaction: ${tx.id}`)\n  )\n\n// ============================================\n// 3. Use hierarchical resources\n// ============================================\n\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    yield* Effect.log(\"=== Starting hierarchical resource demo ===\\n\")\n    \n    // Level 1: Database\n    const db = yield* makeDatabase(\"myapp\")\n    \n    // Level 2: Connection (child of database)\n    const conn = yield* db.createConnection()\n    \n    // Level 3: Transaction (child of connection)\n    const tx = yield* conn.beginTransaction()\n    \n    // Use the transaction\n    yield* tx.execute(\"INSERT INTO users (name) VALUES ('Alice')\")\n    yield* tx.execute(\"INSERT INTO users (name) VALUES ('Bob')\")\n    \n    yield* Effect.log(\"\\n=== Work complete, releasing resources ===\\n\")\n    \n    // Resources released in reverse order:\n    // 1. Transaction committed\n    // 2. Connection closed\n    // 3. Database closed\n  })\n)\n\nEffect.runPromise(program)\n\n// ============================================\n// 4. Multiple children at same level\n// ============================================\n\nconst multipleConnections = Effect.scoped(\n  Effect.gen(function* () {\n    const db = yield* makeDatabase(\"myapp\")\n    \n    // Create multiple connections\n    const conn1 = yield* db.createConnection()\n    const conn2 = yield* db.createConnection()\n    \n    // Each connection can have transactions\n    const tx1 = yield* conn1.beginTransaction()\n    const tx2 = yield* conn2.beginTransaction()\n    \n    // Use both transactions\n    yield* Effect.all([\n      tx1.execute(\"UPDATE table1 SET x = 1\"),\n      tx2.execute(\"UPDATE table2 SET y = 2\"),\n    ])\n    \n    // All released in proper order\n  })\n)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use nested Scopes to manage resources with parent-child dependencies."
            },
            "created_at": "2026-02-15T21:22:18.865375",
            "updated_at": "2026-02-20T23:09:32.531331"
        },
        {
            "id": "957e7dac-2290-4cc9-947b-407cf5fac41a",
            "slug": "manual-scope-management",
            "title": "Manually Manage Lifecycles with `Scope`",
            "summary": "Use `Scope` directly to manage complex resource lifecycles or when building custom layers.",
            "skill_level": "advanced",
            "category": "resource-management",
            "difficulty": "advanced",
            "tags": [
                "resource",
                "scope",
                "finalizer",
                "layer",
                "advanced",
                "lifecycle"
            ],
            "examples": [
                {
                    "code": "import { Effect, Console } from \"effect\";\n\n// Mocking a complex file operation\nconst openFile = (path: string) =>\n  Effect.succeed({ path, handle: Math.random() }).pipe(\n    Effect.tap((f) => Effect.log(`Opened ${f.path}`))\n  );\nconst createTempFile = (path: string) =>\n  Effect.succeed({ path: `${path}.tmp`, handle: Math.random() }).pipe(\n    Effect.tap((f) => Effect.log(`Created temp file ${f.path}`))\n  );\nconst closeFile = (file: { path: string }) =>\n  Effect.sync(() => Effect.log(`Closed ${file.path}`));\nconst deleteFile = (file: { path: string }) =>\n  Effect.sync(() => Effect.log(`Deleted ${file.path}`));\n\n// This program acquires two resources (a file and a temp file)\n// and ensures both are cleaned up correctly using acquireRelease.\nconst program = Effect.gen(function* () {\n  const file = yield* Effect.acquireRelease(openFile(\"data.csv\"), (f) =>\n    closeFile(f)\n  );\n\n  const tempFile = yield* Effect.acquireRelease(\n    createTempFile(\"data.csv\"),\n    (f) => deleteFile(f)\n  );\n\n  yield* Effect.log(\"...writing data from temp file to main file...\");\n});\n\n// Run the program with a scope\nEffect.runPromise(Effect.scoped(program));\n\n/*\nOutput (note the LIFO cleanup order):\nOpened data.csv\nCreated temp file data.csv.tmp\n...writing data from temp file to main file...\nDeleted data.csv.tmp\nClosed data.csv\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use `Effect.scope` and `Scope.addFinalizer` for fine-grained control over resource cleanup."
            },
            "created_at": "2026-02-15T21:22:18.948725",
            "updated_at": "2026-02-20T23:09:32.64271"
        },
        {
            "id": "1b7f8bac-610b-4e96-9869-520e9d84a13e",
            "slug": "constructor-try-trypromise",
            "title": "Wrapping Synchronous and Asynchronous Computations",
            "summary": "Use try and tryPromise to safely wrap synchronous or asynchronous computations that may throw or reject, capturing errors in the Effect world.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "try",
                "tryPromise",
                "constructor",
                "effect",
                "error",
                "async",
                "interop"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Synchronous: Wrap code that may throw\nconst effectSync = Effect.try({\n  try: () => JSON.parse(\"{ invalid json }\"),\n  catch: (error) => `Parse error: ${String(error)}`,\n}); // Effect<string, never, never>\n\n// Asynchronous: Wrap a promise that may reject\nconst effectAsync = Effect.tryPromise({\n  try: () => fetch(\"https://api.example.com/data\").then((res) => res.json()),\n  catch: (error) => `Network error: ${String(error)}`,\n}); // Effect<string, any, never>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use try and tryPromise to lift code that may throw or reject into Effect, capturing errors in the failure channel."
            },
            "created_at": "2026-02-15T21:22:14.9087",
            "updated_at": "2026-02-20T23:09:33.519363"
        },
        {
            "id": "c0e544ab-0b6e-473a-82e5-89835c0dcdef",
            "slug": "concurrency-hello-world",
            "title": "Your First Parallel Operation",
            "summary": "Run multiple effects in parallel with Effect.all and understand when to use parallel vs sequential execution.",
            "skill_level": "beginner",
            "category": "concurrency",
            "difficulty": "beginner",
            "tags": [
                "concurrency",
                "parallel",
                "effect-all",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\"\n\n// Simulate async operations\nconst fetchUser = Effect.gen(function* () {\n  yield* Effect.sleep(\"100 millis\")\n  return { id: 1, name: \"Alice\" }\n})\n\nconst fetchProducts = Effect.gen(function* () {\n  yield* Effect.sleep(\"150 millis\")\n  return [{ id: 1, name: \"Widget\" }, { id: 2, name: \"Gadget\" }]\n})\n\nconst fetchCart = Effect.gen(function* () {\n  yield* Effect.sleep(\"80 millis\")\n  return { items: 3, total: 99.99 }\n})\n\n// ============================================\n// SEQUENTIAL: One after another (~330ms)\n// ============================================\n\nconst sequential = Effect.all([fetchUser, fetchProducts, fetchCart])\n\n// ============================================\n// PARALLEL: All at once (~150ms)\n// ============================================\n\nconst parallel = Effect.all(\n  [fetchUser, fetchProducts, fetchCart],\n  { concurrency: \"unbounded\" }\n)\n\n// ============================================\n// PARALLEL WITH LIMIT: Max 2 at a time\n// ============================================\n\nconst limited = Effect.all(\n  [fetchUser, fetchProducts, fetchCart],\n  { concurrency: 2 }\n)\n\n// ============================================\n// DEMO\n// ============================================\n\nconst demo = Effect.gen(function* () {\n  const start = Date.now()\n  \n  const [user, products, cart] = yield* parallel\n  \n  const elapsed = Date.now() - start\n  yield* Effect.log(`Fetched in ${elapsed}ms`)\n  yield* Effect.log(`User: ${user.name}`)\n  yield* Effect.log(`Products: ${products.length}`)\n  yield* Effect.log(`Cart total: $${cart.total}`)\n})\n\nEffect.runPromise(demo)\n// Output: Fetched in ~150ms (not ~330ms!)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.all with concurrency option to run independent effects in parallel."
            },
            "created_at": "2026-02-15T21:22:19.179722",
            "updated_at": "2026-02-20T23:09:37.15325"
        },
        {
            "id": "3a119a26-dba6-4b84-8bf9-65d077b4cc52",
            "slug": "data-case",
            "title": "Modeling Tagged Unions with Data.case",
            "summary": "Use Data.case to create tagged unions (algebraic data types) for robust, type-safe domain modeling and pattern matching.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "Data.case",
                "tagged-union",
                "ADT",
                "domain-modeling",
                "pattern-matching",
                "data-type",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Data } from \"effect\";\n\n// Define a tagged union for a simple state machine\ntype State = Data.TaggedEnum<{\n  Loading: {};\n  Success: { data: string };\n  Failure: { error: string };\n}>;\nconst { Loading, Success, Failure } = Data.taggedEnum<State>();\n\n// Create instances\nconst state1: State = Loading();\nconst state2: State = Success({ data: \"Hello\" });\nconst state3: State = Failure({ error: \"Oops\" });\n\n// Pattern match on the state\nfunction handleState(state: State): string {\n  switch (state._tag) {\n    case \"Loading\":\n      return \"Loading...\";\n    case \"Success\":\n      return `Data: ${state.data}`;\n    case \"Failure\":\n      return `Error: ${state.error}`;\n  }\n}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Data.case to define tagged unions (ADTs) for modeling domain-specific states and enabling exhaustive pattern matching."
            },
            "created_at": "2026-02-15T21:22:15.771221",
            "updated_at": "2026-02-20T23:09:33.145737"
        },
        {
            "id": "c7b7f11c-e940-499d-b31c-83f415d7488a",
            "slug": "data-class",
            "title": "Type Classes for Equality, Ordering, and Hashing with Data.Class",
            "summary": "Use Data.Class to derive and implement type classes for equality, ordering, and hashing, enabling composable and type-safe abstractions.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "Data.Class",
                "type-class",
                "equality",
                "ordering",
                "hashing",
                "data-type",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Data, Equal, HashSet } from \"effect\";\n\n// Define custom data types with structural equality\nconst user1 = Data.struct({ id: 1, name: \"Alice\" });\nconst user2 = Data.struct({ id: 1, name: \"Alice\" });\nconst user3 = Data.struct({ id: 2, name: \"Bob\" });\n\n// Data.struct provides automatic structural equality\nconsole.log(Equal.equals(user1, user2)); // true (same structure)\nconsole.log(Equal.equals(user1, user3)); // false (different values)\n\n// Use in a HashSet (works because Data.struct implements Equal)\nconst set = HashSet.make(user1);\nconsole.log(HashSet.has(set, user2)); // true (structural equality)\n\n// Create an array and use structural equality\nconst users = [user1, user3];\nconsole.log(users.some((u) => Equal.equals(u, user2))); // true",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Data.Class to define and derive type classes for your data types, supporting composable equality, ordering, and hashing."
            },
            "created_at": "2026-02-15T21:22:16.356644",
            "updated_at": "2026-02-20T23:09:33.585852"
        },
        {
            "id": "320d61d3-fb20-4da3-b4b3-67b26713ef91",
            "slug": "concurrency-pattern-coordinate-with-latch",
            "title": "Concurrency Pattern 3: Coordinate Multiple Fibers with Latch",
            "summary": "Use Latch to synchronize multiple fibers, enabling patterns like coordinating N async tasks, fan-out/fan-in, and barrier synchronization.",
            "skill_level": "intermediate",
            "category": "concurrency",
            "difficulty": "intermediate",
            "tags": [
                "concurrency",
                "latch",
                "synchronization",
                "fan-out-fan-in",
                "barrier",
                "multi-fiber"
            ],
            "examples": [
                {
                    "code": "import { Effect, Latch, Fiber, Ref } from \"effect\";\n\ninterface WorkResult {\n  readonly workerId: number;\n  readonly taskId: number;\n  readonly result: string;\n  readonly duration: number;\n}\n\n// Simulate a long-running task\nconst processTask = (\n  workerId: number,\n  taskId: number\n): Effect.Effect<WorkResult> =>\n  Effect.gen(function* () {\n    const startTime = Date.now();\n    const duration = 100 + Math.random() * 400; // 100-500ms\n\n    yield* Effect.log(\n      `[Worker ${workerId}] Starting task ${taskId} (duration: ${Math.round(duration)}ms)`\n    );\n\n    yield* Effect.sleep(`${Math.round(duration)} millis`);\n\n    const elapsed = Date.now() - startTime;\n\n    yield* Effect.log(\n      `[Worker ${workerId}] \u2713 Completed task ${taskId} in ${elapsed}ms`\n    );\n\n    return {\n      workerId,\n      taskId,\n      result: `Result from worker ${workerId} on task ${taskId}`,\n      duration: elapsed,\n    };\n  });\n\n// Fan-out/Fan-in with Latch\nconst fanOutFanIn = Effect.gen(function* () {\n  const numWorkers = 5;\n  const tasksPerWorker = 3;\n\n  // Create latch: will countdown from (numWorkers) when all workers complete\n  const workersCompleteLatch = yield* Latch.make(numWorkers);\n\n  // Track results from all workers\n  const results = yield* Ref.make<WorkResult[]>([]);\n\n  // Worker fiber that processes tasks sequentially\n  const createWorker = (workerId: number) =>\n    Effect.gen(function* () {\n      try {\n        yield* Effect.log(`[Worker ${workerId}] \u25b6 Starting`);\n\n        // Process multiple tasks\n        for (let i = 1; i <= tasksPerWorker; i++) {\n          const result = yield* processTask(workerId, i);\n          yield* Ref.update(results, (rs) => [...rs, result]);\n        }\n\n        yield* Effect.log(`[Worker ${workerId}] \u2713 All tasks completed`);\n      } finally {\n        // Signal completion to latch\n        yield* Latch.countDown(workersCompleteLatch);\n        yield* Effect.log(`[Worker ${workerId}] Signaled latch`);\n      }\n    });\n\n  // Spawn all workers as background fibers\n  console.log(`\\n[COORDINATOR] Spawning ${numWorkers} workers...\\n`);\n\n  const workerFibers = yield* Effect.all(\n    Array.from({ length: numWorkers }, (_, i) =>\n      createWorker(i + 1).pipe(Effect.fork)\n    )\n  );\n\n  // Wait for all workers to complete\n  console.log(`\\n[COORDINATOR] Waiting for all workers to finish...\\n`);\n\n  yield* Latch.await(workersCompleteLatch);\n\n  console.log(`\\n[COORDINATOR] All workers completed!\\n`);\n\n  // Join all fibers to ensure cleanup\n  yield* Effect.all(workerFibers.map((fiber) => Fiber.join(fiber)));\n\n  // Aggregate results\n  const allResults = yield* Ref.get(results);\n\n  console.log(`[SUMMARY]`);\n  console.log(`  Total workers: ${numWorkers}`);\n  console.log(`  Tasks per worker: ${tasksPerWorker}`);\n  console.log(`  Total tasks: ${allResults.length}`);\n  console.log(\n    `  Avg task duration: ${Math.round(\n      allResults.reduce((sum, r) => sum + r.duration, 0) / allResults.length\n    )}ms`\n  );\n});\n\nEffect.runPromise(fanOutFanIn);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Latch to coordinate multiple fibers awaiting a common completion signal, enabling fan-out/fan-in and barrier synchronization patterns."
            },
            "created_at": "2026-02-15T21:22:19.428167",
            "updated_at": "2026-02-20T23:09:36.55517"
        },
        {
            "id": "59223562-7ab2-4f26-9f15-e078778dabb2",
            "slug": "use-chunk-for-high-performance-collections",
            "title": "Use Chunk for High-Performance Collections",
            "summary": "Use Chunk<A> as a high-performance, immutable alternative to JavaScript's Array, especially for data processing pipelines.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "chunk",
                "collections",
                "performance",
                "immutable",
                "data"
            ],
            "examples": [
                {
                    "code": "import { Chunk, Effect } from \"effect\";\n\n// Create a Chunk from an array\nlet numbers = Chunk.fromIterable([1, 2, 3, 4, 5]);\n\n// Append a new element. This is much faster than [...arr, 6] on large collections.\nnumbers = Chunk.append(numbers, 6);\n\n// Prepend an element.\nnumbers = Chunk.prepend(numbers, 0);\n\n// Take the first 3 elements\nconst firstThree = Chunk.take(numbers, 3);\n\n// Convert back to an array when you need to interface with other libraries\nconst finalArray = Chunk.toReadonlyArray(firstThree);\n\nEffect.runSync(Effect.log(finalArray)); // [0, 1, 2]",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Prefer Chunk over Array for immutable collection operations within data processing pipelines for better performance."
            },
            "created_at": "2026-02-15T21:22:16.598509",
            "updated_at": "2026-02-20T23:09:33.283622"
        },
        {
            "id": "09aa281e-9846-49c1-8264-29e916d431c5",
            "slug": "run-background-tasks-with-fork",
            "title": "Run Background Tasks with Effect.fork",
            "summary": "Use Effect.fork to start a computation in a background fiber, allowing the parent fiber to continue its work without waiting.",
            "skill_level": "advanced",
            "category": "concurrency",
            "difficulty": "advanced",
            "tags": [
                "concurrency",
                "fork",
                "fiber",
                "background-process",
                "asynchronous"
            ],
            "examples": [
                {
                    "code": "import { Effect, Fiber } from \"effect\";\n\n// A long-running effect that logs a message every second, forever\n// Effect.forever creates an infinite loop that repeats the effect\n// This simulates a background service like a health check or monitoring task\nconst tickingClock = Effect.log(\"tick\").pipe(\n  Effect.delay(\"1 second\"), // Wait 1 second between ticks\n  Effect.forever // Repeat indefinitely - this creates an infinite effect\n);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Forking the ticking clock into the background.\");\n\n  // Start the clock, but don't wait for it.\n  // Effect.fork creates a new fiber that runs concurrently with the main program\n  // The main fiber continues immediately without waiting for the background task\n  // This is essential for non-blocking background operations\n  const clockFiber = yield* Effect.fork(tickingClock);\n\n  // At this point, we have two fibers running:\n  // 1. The main fiber (this program)\n  // 2. The background clock fiber (ticking every second)\n\n  yield* Effect.log(\"Main process is now doing other work for 5 seconds...\");\n\n  // Simulate the main application doing work\n  // While this sleep happens, the background clock continues ticking\n  // This demonstrates true concurrency - both fibers run simultaneously\n  yield* Effect.sleep(\"5 seconds\");\n\n  yield* Effect.log(\"Main process is done. Interrupting the clock fiber.\");\n\n  // Stop the background process.\n  // Fiber.interrupt sends an interruption signal to the fiber\n  // This allows the fiber to perform cleanup operations before terminating\n  // Without this, the background task would continue running indefinitely\n  yield* Fiber.interrupt(clockFiber);\n\n  // Important: Always clean up background fibers to prevent resource leaks\n  // In a real application, you might want to:\n  // 1. Use Fiber.join instead of interrupt to wait for graceful completion\n  // 2. Handle interruption signals within the background task\n  // 3. Implement proper shutdown procedures\n\n  yield* Effect.log(\"Program finished.\");\n\n  // Key concepts demonstrated:\n  // 1. Fork creates concurrent fibers without blocking\n  // 2. Background tasks run independently of the main program\n  // 3. Fiber interruption provides controlled shutdown\n  // 4. Multiple fibers can run simultaneously on the same thread pool\n});\n\n// This example shows how to:\n// - Run background tasks that don't block the main program\n// - Manage fiber lifecycles (create, run, interrupt)\n// - Coordinate between multiple concurrent operations\n// - Properly clean up resources when shutting down\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.fork to start a non-blocking background process and manage its lifecycle via its Fiber."
            },
            "created_at": "2026-02-15T21:22:20.644887",
            "updated_at": "2026-02-20T23:09:36.883165"
        },
        {
            "id": "b98f92e4-7a68-4c7d-a083-e9473f711660",
            "slug": "brand-validate-parse",
            "title": "Validating and Parsing Branded Types",
            "summary": "Use Schema and Brand together to validate and parse branded types at runtime, ensuring only valid values are constructed.",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "Brand",
                "Schema",
                "validation",
                "parsing",
                "domain",
                "type-safety",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Brand, Effect, Schema } from \"effect\";\n\n// Define a branded type for Email\ntype Email = string & Brand.Brand<\"Email\">;\n\n// Create a Schema for Email validation\nconst EmailSchema = Schema.String.pipe(\n  Schema.pattern(/^[^@]+@[^@]+\\.[^@]+$/), // Simple email regex\n  Schema.brand(\"Email\" as const) // Attach the brand\n);\n\n// Parse and validate an email at runtime\nconst parseEmail = (input: string) =>\n  Effect.try({\n    try: () => Schema.decodeSync(EmailSchema)(input),\n    catch: (err) => `Invalid email: ${String(err)}`,\n  });\n\n// Usage\nparseEmail(\"user@example.com\").pipe(\n  Effect.match({\n    onSuccess: (email) => console.log(\"Valid email:\", email),\n    onFailure: (err) => console.error(err),\n  })\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Combine Schema and Brand to validate and parse branded types, guaranteeing only valid domain values are created at runtime."
            },
            "created_at": "2026-02-15T21:22:24.944792",
            "updated_at": "2026-02-20T23:09:46.02789"
        },
        {
            "id": "9112e7af-0045-4b7c-a4c2-e5bbe5e54510",
            "slug": "solve-promise-problems-with-effect",
            "title": "Solve Promise Problems with Effect",
            "summary": "Understand how Effect solves the fundamental problems of native Promises, such as untyped errors, lack of dependency injection, and no built-in cancellation.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "promise",
                "motivation",
                "error-handling",
                "dependency-injection",
                "cancellation",
                "core-concept"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data } from \"effect\";\n\ninterface DbErrorType {\n  readonly _tag: \"DbError\";\n  readonly message: string;\n}\n\nconst DbError = Data.tagged<DbErrorType>(\"DbError\");\n\ninterface User {\n  name: string;\n}\n\nclass HttpClient extends Effect.Service<HttpClient>()(\"HttpClient\", {\n  sync: () => ({\n    findById: (id: number): Effect.Effect<User, DbErrorType> =>\n      Effect.try({\n        try: () => ({ name: `User ${id}` }),\n        catch: () => DbError({ message: \"Failed to find user\" }),\n      }),\n  }),\n}) {}\n\nconst findUser = (id: number) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient;\n    return yield* client.findById(id);\n  });\n\n// Demonstrate how Effect solves promise problems\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Solving Promise Problems with Effect ===\");\n\n  // Problem 1: Proper error handling (no more try/catch hell)\n  yield* Effect.logInfo(\"1. Demonstrating type-safe error handling:\");\n\n  const result1 = yield* findUser(123).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Handled error: ${error.message}`);\n        return { name: \"Default User\" };\n      })\n    )\n  );\n  yield* Effect.logInfo(`Found user: ${result1.name}`);\n\n  // Problem 2: Easy composition and chaining\n  yield* Effect.logInfo(\"\\n2. Demonstrating easy composition:\");\n\n  const composedOperation = Effect.gen(function* () {\n    const user1 = yield* findUser(1);\n    const user2 = yield* findUser(2);\n    yield* Effect.logInfo(`Composed result: ${user1.name} and ${user2.name}`);\n    return [user1, user2];\n  });\n\n  yield* composedOperation;\n\n  // Problem 3: Resource management and cleanup\n  yield* Effect.logInfo(\"\\n3. Demonstrating resource management:\");\n\n  const resourceOperation = Effect.gen(function* () {\n    yield* Effect.logInfo(\"Acquiring resource...\");\n    const resource = \"database-connection\";\n\n    yield* Effect.addFinalizer(() => Effect.logInfo(\"Cleaning up resource...\"));\n\n    const user = yield* findUser(456);\n    yield* Effect.logInfo(`Used resource to get: ${user.name}`);\n\n    return user;\n  }).pipe(Effect.scoped);\n\n  yield* resourceOperation;\n\n  yield* Effect.logInfo(\"\\n\u2705 All operations completed successfully!\");\n});\n\nEffect.runPromise(Effect.provide(program, HttpClient.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Recognize that Effect solves the core limitations of Promises: untyped errors, no dependency injection, and no cancellation."
            },
            "created_at": "2026-02-15T21:22:14.078081",
            "updated_at": "2026-02-20T23:09:33.39521"
        },
        {
            "id": "6a22d5b9-cd10-4adc-951c-53e77f6e995b",
            "slug": "constructor-from-nullable-option-either",
            "title": "Converting from Nullable, Option, or Either",
            "summary": "Use fromNullable, fromOption, and fromEither to convert nullable values, Option, or Either into Effects or Streams, enabling safe and composable interop.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "fromNullable",
                "fromOption",
                "fromEither",
                "constructor",
                "effect",
                "stream",
                "option",
                "either",
                "interop",
                "conversion"
            ],
            "examples": [
                {
                    "code": "import { Effect, Option, Either } from \"effect\";\n\n// Option: Convert a nullable value to an Option\nconst nullableValue: string | null = Math.random() > 0.5 ? \"hello\" : null;\nconst option = Option.fromNullable(nullableValue); // Option<string>\n\n// Effect: Convert an Option to an Effect that may fail\nconst someValue = Option.some(42);\nconst effectFromOption = Option.match(someValue, {\n  onNone: () => Effect.fail(\"No value\"),\n  onSome: (value) => Effect.succeed(value),\n}); // Effect<number, string, never>\n\n// Effect: Convert an Either to an Effect\nconst either = Either.right(\"success\");\nconst effectFromEither = Either.match(either, {\n  onLeft: (error) => Effect.fail(error),\n  onRight: (value) => Effect.succeed(value),\n}); // Effect<string, never, never>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use fromNullable, fromOption, and fromEither to lift nullable values, Option, or Either into Effects or Streams for safe, typeful interop."
            },
            "created_at": "2026-02-15T21:22:13.393104",
            "updated_at": "2026-02-20T23:09:33.701173"
        },
        {
            "id": "d96c190b-e1f6-4361-a3b1-0f69813aa0e8",
            "slug": "stream-pattern-map-filter-transformations",
            "title": "Stream Pattern 1: Transform Streams with Map and Filter",
            "summary": "Use Stream.map and Stream.filter to transform and select stream elements, enabling data pipelines that reshape and filter data in flight.",
            "skill_level": "beginner",
            "category": "streams",
            "difficulty": "beginner",
            "tags": [
                "streams",
                "transformations",
                "map",
                "filter",
                "data-pipeline",
                "functional-programming"
            ],
            "examples": [
                {
                    "code": "import { Stream, Effect, Chunk } from \"effect\";\n\ninterface RawLogEntry {\n  readonly timestamp: string;\n  readonly level: string;\n  readonly message: string;\n}\n\ninterface ProcessedLog {\n  readonly date: Date;\n  readonly severity: \"low\" | \"medium\" | \"high\";\n  readonly normalizedMessage: string;\n}\n\n// Create a stream of raw log entries\nconst createLogStream = (): Stream.Stream<RawLogEntry> =>\n  Stream.fromIterable([\n    { timestamp: \"2025-12-17T09:00:00Z\", level: \"DEBUG\", message: \"App starting\" },\n    { timestamp: \"2025-12-17T09:01:00Z\", level: \"INFO\", message: \"Connected to DB\" },\n    { timestamp: \"2025-12-17T09:02:00Z\", level: \"ERROR\", message: \"Query timeout\" },\n    { timestamp: \"2025-12-17T09:03:00Z\", level: \"DEBUG\", message: \"Retry initiated\" },\n    { timestamp: \"2025-12-17T09:04:00Z\", level: \"WARN\", message: \"Connection degraded\" },\n    { timestamp: \"2025-12-17T09:05:00Z\", level: \"INFO\", message: \"Recovered\" },\n  ]);\n\n// Transform: Parse timestamp\nconst parseTimestamp = (entry: RawLogEntry): RawLogEntry => ({\n  ...entry,\n  timestamp: entry.timestamp, // Already ISO, but could parse here\n});\n\n// Transform: Map log level to severity\nconst mapSeverity = (level: string): \"low\" | \"medium\" | \"high\" => {\n  if (level === \"DEBUG\" || level === \"INFO\") return \"low\";\n  if (level === \"WARN\") return \"medium\";\n  return \"high\";\n};\n\n// Transform: Normalize message\nconst normalizeMessage = (message: string): string =>\n  message.toLowerCase().trim();\n\n// Filter: Keep only important logs\nconst isImportant = (entry: RawLogEntry): boolean => {\n  return entry.level !== \"DEBUG\";\n};\n\n// Main pipeline\nconst program = Effect.gen(function* () {\n  console.log(`\\n[STREAM] Processing log stream with map/filter\\n`);\n\n  // Create and transform stream\n  const transformedStream = createLogStream().pipe(\n    // Filter: Keep only non-debug logs\n    Stream.filter((entry) => {\n      const important = isImportant(entry);\n      console.log(\n        `[FILTER] ${entry.level} \u2192 ${important ? \"\u2713 kept\" : \"\u2717 filtered out\"}`\n      );\n      return important;\n    }),\n\n    // Map: Extract date\n    Stream.map((entry) => {\n      const date = new Date(entry.timestamp);\n      console.log(`[MAP-1] Parsed date: ${date.toISOString()}`);\n      return { ...entry, parsedDate: date };\n    }),\n\n    // Map: Normalize and map severity\n    Stream.map((entry) => {\n      const processed: ProcessedLog = {\n        date: entry.parsedDate,\n        severity: mapSeverity(entry.level),\n        normalizedMessage: normalizeMessage(entry.message),\n      };\n      console.log(\n        `[MAP-2] Transformed: ${entry.level} \u2192 ${processed.severity}`\n      );\n      return processed;\n    })\n  );\n\n  // Collect all transformed logs\n  const results = yield* transformedStream.pipe(\n    Stream.runCollect\n  );\n\n  console.log(`\\n[RESULTS]`);\n  console.log(`  Total logs: ${results.length}`);\n\n  Chunk.forEach(results, (log) => {\n    console.log(\n      `  - [${log.severity.toUpperCase()}] ${log.date.toISOString()}: ${log.normalizedMessage}`\n    );\n  });\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use map and filter combinators to transform stream elements declaratively, creating pipelines that reshape data without materializing intermediate results."
            },
            "created_at": "2026-02-15T21:22:21.095268",
            "updated_at": "2026-02-20T23:09:44.190893"
        },
        {
            "id": "db52b6c0-a203-406a-aaec-942bb97aed52",
            "slug": "sink-pattern-write-stream-events-to-event-log",
            "title": "Sink Pattern 2: Write Stream Events to Event Log",
            "summary": "Use Sink to append stream events to an event log with metadata and causal ordering, enabling event sourcing and audit trail patterns.",
            "skill_level": "intermediate",
            "category": "streams",
            "difficulty": "intermediate",
            "tags": [
                "sink",
                "stream",
                "event-sourcing",
                "persistence",
                "append-only",
                "audit-log"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Sink, DateTime, Data } from \"effect\";\n\n// Event types\ntype AccountEvent =\n  | AccountCreated\n  | MoneyDeposited\n  | MoneyWithdrawn\n  | AccountClosed;\n\nclass AccountCreated extends Data.TaggedError(\"AccountCreated\")<{\n  readonly accountId: string;\n  readonly owner: string;\n  readonly initialBalance: number;\n}> {}\n\nclass MoneyDeposited extends Data.TaggedError(\"MoneyDeposited\")<{\n  readonly accountId: string;\n  readonly amount: number;\n}> {}\n\nclass MoneyWithdrawn extends Data.TaggedError(\"MoneyWithdrawn\")<{\n  readonly accountId: string;\n  readonly amount: number;\n}> {}\n\nclass AccountClosed extends Data.TaggedError(\"AccountClosed\")<{\n  readonly accountId: string;\n}> {}\n\n// Event envelope with metadata\ninterface StoredEvent {\n  readonly eventId: string; // Unique identifier per event\n  readonly eventType: string; // Type of event\n  readonly aggregateId: string; // What this event is about\n  readonly aggregateType: string; // What kind of thing (Account)\n  readonly data: any; // Event payload\n  readonly metadata: {\n    readonly timestamp: number;\n    readonly version: number; // Position in log\n    readonly causationId?: string; // What caused this\n  };\n}\n\n// Mock event log that appends events\nconst eventLog: StoredEvent[] = [];\nlet eventVersion = 0;\n\nconst appendToEventLog = (\n  event: AccountEvent,\n  aggregateId: string\n): Effect.Effect<StoredEvent> =>\n  Effect.gen(function* () {\n    const now = yield* DateTime.now;\n    const storedEvent: StoredEvent = {\n      eventId: `evt-${eventVersion}-${Date.now()}`,\n      eventType: event._tag,\n      aggregateId,\n      aggregateType: \"Account\",\n      data: event,\n      metadata: {\n        timestamp: now.toEpochMillis(),\n        version: ++eventVersion,\n      },\n    };\n\n    // Append to log (simulated)\n    eventLog.push(storedEvent);\n    console.log(\n      `[v${storedEvent.metadata.version}] ${storedEvent.eventType}: ${aggregateId}`\n    );\n\n    return storedEvent;\n  });\n\n// Simulate a stream of events from various account operations\nconst accountEvents: Stream.Stream<[string, AccountEvent]> = Stream.fromIterable([\n  [\n    \"acc-1\",\n    new AccountCreated({\n      accountId: \"acc-1\",\n      owner: \"Alice\",\n      initialBalance: 1000,\n    }),\n  ],\n  [\"acc-1\", new MoneyDeposited({ accountId: \"acc-1\", amount: 500 })],\n  [\"acc-1\", new MoneyWithdrawn({ accountId: \"acc-1\", amount: 200 })],\n  [\n    \"acc-2\",\n    new AccountCreated({\n      accountId: \"acc-2\",\n      owner: \"Bob\",\n      initialBalance: 2000,\n    }),\n  ],\n  [\"acc-2\", new MoneyDeposited({ accountId: \"acc-2\", amount: 1000 })],\n  [\"acc-1\", new AccountClosed({ accountId: \"acc-1\" })],\n]);\n\n// Sink that appends each event to the log\nconst eventLogSink: Sink.Sink<number, never, [string, AccountEvent]> = Sink.fold(\n  0,\n  (count, [aggregateId, event]) =>\n    appendToEventLog(event, aggregateId).pipe(\n      Effect.map(() => count + 1)\n    ),\n  (count) => Effect.succeed(count)\n);\n\n// Run the stream and append all events\nconst program = Effect.gen(function* () {\n  const totalEvents = yield* accountEvents.pipe(Stream.run(eventLogSink));\n\n  console.log(`\\nTotal events appended: ${totalEvents}`);\n  console.log(`\\nEvent log contents:`);\n  eventLog.forEach((event) => {\n    console.log(`  [v${event.metadata.version}] ${event.eventType}`);\n  });\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Append stream events to an event log with metadata to maintain a complete, ordered record of what happened."
            },
            "created_at": "2026-02-15T21:22:21.509939",
            "updated_at": "2026-02-20T23:09:44.923788"
        },
        {
            "id": "2da3e33a-4ac8-41bc-85eb-d61090cb9725",
            "slug": "sink-pattern-batch-insert-stream-records-into-database",
            "title": "Sink Pattern 1: Batch Insert Stream Records into Database",
            "summary": "Use Sink to batch stream records and insert them efficiently into a database in groups, rather than one-by-one, for better performance and resource usage.",
            "skill_level": "intermediate",
            "category": "streams",
            "difficulty": "intermediate",
            "tags": [
                "sink",
                "stream",
                "database",
                "persistence",
                "batching",
                "performance"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Sink, Chunk } from \"effect\";\n\ninterface User {\n  readonly id: number;\n  readonly name: string;\n  readonly email: string;\n}\n\ninterface PaginatedResponse {\n  readonly users: User[];\n  readonly nextPage: number | null;\n}\n\n// Mock API that returns paginated users\nconst fetchUserPage = (\n  page: number\n): Effect.Effect<PaginatedResponse> =>\n  Effect.succeed(\n    page < 10\n      ? {\n          users: Array.from({ length: 50 }, (_, i) => ({\n            id: page * 50 + i,\n            name: `User ${page * 50 + i}`,\n            email: `user${page * 50 + i}@example.com`,\n          })),\n          nextPage: page + 1,\n        }\n      : { users: [], nextPage: null }\n  ).pipe(Effect.delay(\"10 millis\"));\n\n// Mock database insert that takes a batch of users\nconst insertUserBatch = (\n  users: readonly User[]\n): Effect.Effect<number> =>\n  Effect.sync(() => {\n    console.log(`Inserting batch of ${users.length} users`);\n    return users.length;\n  }).pipe(Effect.delay(\"50 millis\"));\n\n// Create a stream of users from paginated API\nconst userStream: Stream.Stream<User> = Stream.paginateEffect(\n  0,\n  (page) =>\n    fetchUserPage(page).pipe(\n      Effect.map((response) => [\n        Chunk.fromIterable(response.users),\n        response.nextPage !== null ? Option.some(response.nextPage) : Option.none(),\n      ])\n    )\n);\n\n// Sink that batches users and inserts them\nconst batchInsertSink: Sink.Sink<number, never, User> = Sink.fold(\n  0,\n  (count, chunk: Chunk.Chunk<User>) =>\n    Effect.gen(function* () {\n      const users = Chunk.toArray(chunk);\n      const inserted = yield* insertUserBatch(users);\n      return count + inserted;\n    }),\n  (count) => Effect.succeed(count)\n).pipe(\n  // Batch into groups of 100 users\n  Sink.withChunking((chunk) =>\n    chunk.pipe(\n      Chunk.chunksOf(100),\n      Stream.fromIterable,\n      Stream.runCollect\n    )\n  )\n);\n\n// Run the stream with batching sink\nconst program = Effect.gen(function* () {\n  const totalInserted = yield* userStream.pipe(\n    Stream.run(batchInsertSink)\n  );\n  console.log(`Total users inserted: ${totalInserted}`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Batch stream records before database operations to improve throughput and reduce transaction overhead."
            },
            "created_at": "2026-02-15T21:22:21.430111",
            "updated_at": "2026-02-20T23:09:44.975188"
        },
        {
            "id": "f9cea3ef-9074-497f-811c-eb212075fb82",
            "slug": "combinator-flatmap",
            "title": "Chaining Computations with flatMap",
            "summary": "Use flatMap to chain together computations where each step may itself be effectful, optional, or error-prone.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "flatMap",
                "combinator",
                "monad",
                "effect",
                "stream",
                "option",
                "either"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Chain two effectful computations\nconst effect = Effect.succeed(2).pipe(\n  Effect.flatMap((n) => Effect.succeed(n * 10))\n); // Effect<number>\n\n// Option: Chain two optional computations\nconst option = Option.some(2).pipe(Option.flatMap((n) => Option.some(n * 10))); // Option<number>\n\n// Either: Chain two computations that may fail\nconst either = Either.right(2).pipe(\n  Either.flatMap((n) => Either.right(n * 10))\n); // Either<never, number>\n\n// Stream: Chain streams (flattening)\nconst stream = Stream.fromIterable([1, 2]).pipe(\n  Stream.flatMap((n) => Stream.fromIterable([n, n * 10]))\n); // Stream<number>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use flatMap to sequence computations, flattening nested structures and preserving error and context handling."
            },
            "created_at": "2026-02-15T21:22:12.949651",
            "updated_at": "2026-02-20T23:09:34.19505"
        },
        {
            "id": "e0dddf6f-23cb-405b-95d2-1e2d0e5aca2e",
            "slug": "write-tests-that-adapt-to-application-code",
            "title": "Write Tests That Adapt to Application Code",
            "summary": "A cardinal rule of testing: Tests must adapt to the application's interface, not the other way around. Never modify application code solely to make a test pass.",
            "skill_level": "intermediate",
            "category": "testing",
            "difficulty": "intermediate",
            "tags": [
                "testing",
                "philosophy",
                "best-practice",
                "architecture"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Define our types\ninterface User {\n  id: number;\n  name: string;\n}\n\nclass NotFoundError extends Error {\n  readonly _tag = \"NotFoundError\";\n  constructor(readonly id: number) {\n    super(`User ${id} not found`);\n  }\n}\n\n// Define database service interface\ninterface DatabaseServiceApi {\n  getUserById: (id: number) => Effect.Effect<User, NotFoundError>;\n}\n\n// Implement the service with mock data\nclass DatabaseService extends Effect.Service<DatabaseService>()(\n  \"DatabaseService\",\n  {\n    sync: () => ({\n      getUserById: (id: number) => {\n        // Simulate database lookup\n        if (id === 404) {\n          return Effect.fail(new NotFoundError(id));\n        }\n        return Effect.succeed({ id, name: `User ${id}` });\n      },\n    }),\n  }\n) {}\n\n// Test service implementation for testing\nclass TestDatabaseService extends Effect.Service<TestDatabaseService>()(\n  \"TestDatabaseService\",\n  {\n    sync: () => ({\n      getUserById: (id: number) => {\n        // Test data with predictable responses\n        const testUsers = [\n          { id: 1, name: \"Test User 1\" },\n          { id: 2, name: \"Test User 2\" },\n          { id: 123, name: \"User 123\" },\n        ];\n\n        const user = testUsers.find((u) => u.id === id);\n        if (user) {\n          return Effect.succeed(user);\n        }\n        return Effect.fail(new NotFoundError(id));\n      },\n    }),\n  }\n) {}\n\n// Business logic that uses the database service\nconst getUserWithFallback = (id: number) =>\n  Effect.gen(function* () {\n    const db = yield* DatabaseService;\n    return yield* Effect.gen(function* () {\n      const user = yield* db.getUserById(id);\n      return user;\n    }).pipe(\n      Effect.catchAll((error) =>\n        Effect.gen(function* () {\n          if (error instanceof NotFoundError) {\n            yield* Effect.logInfo(`User ${id} not found, using fallback`);\n            return { id, name: `Fallback User ${id}` };\n          }\n          return yield* Effect.fail(error);\n        })\n      )\n    );\n  });\n\n// Create a program that demonstrates the service\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\n    \"=== Writing Tests that Adapt to Application Code Demo ===\"\n  );\n\n  const db = yield* DatabaseService;\n\n  // Example 1: Successful user lookup\n  yield* Effect.logInfo(\"\\n1. Looking up existing user 123...\");\n  const user = yield* Effect.gen(function* () {\n    try {\n      return yield* db.getUserById(123);\n    } catch (error) {\n      yield* Effect.logError(\n        `Failed to get user: ${error instanceof Error ? error.message : \"Unknown error\"}`\n      );\n      return { id: -1, name: \"Error\" };\n    }\n  });\n  yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n\n  // Example 2: Handle non-existent user with proper error handling\n  yield* Effect.logInfo(\"\\n2. Looking up non-existent user 404...\");\n  const notFoundUser = yield* Effect.gen(function* () {\n    try {\n      return yield* db.getUserById(404);\n    } catch (error) {\n      if (error instanceof NotFoundError) {\n        yield* Effect.logInfo(\n          `\u2705 Properly handled NotFoundError: ${error.message}`\n        );\n        return { id: 404, name: \"Not Found\" };\n      }\n      yield* Effect.logError(\n        `Unexpected error: ${error instanceof Error ? error.message : \"Unknown error\"}`\n      );\n      return { id: -1, name: \"Error\" };\n    }\n  });\n  yield* Effect.logInfo(`Result: ${JSON.stringify(notFoundUser)}`);\n\n  // Example 3: Business logic with fallback\n  yield* Effect.logInfo(\"\\n3. Business logic with fallback for missing user:\");\n  const userWithFallback = yield* getUserWithFallback(999);\n  yield* Effect.logInfo(\n    `User with fallback: ${JSON.stringify(userWithFallback)}`\n  );\n\n  // Example 4: Testing with different service implementation\n  yield* Effect.logInfo(\"\\n4. Testing with test service implementation:\");\n  yield* Effect.provide(\n    Effect.gen(function* () {\n      const testDb = yield* TestDatabaseService;\n\n      // Test existing user\n      const testUser1 = yield* Effect.gen(function* () {\n        try {\n          return yield* testDb.getUserById(1);\n        } catch (error) {\n          yield* Effect.logError(\n            `Test failed: ${error instanceof Error ? error.message : \"Unknown error\"}`\n          );\n          return { id: -1, name: \"Test Error\" };\n        }\n      });\n      yield* Effect.logInfo(`Test user 1: ${JSON.stringify(testUser1)}`);\n\n      // Test non-existing user\n      const testUser404 = yield* Effect.gen(function* () {\n        try {\n          return yield* testDb.getUserById(404);\n        } catch (error) {\n          yield* Effect.logInfo(\n            `\u2705 Test service properly threw NotFoundError: ${error instanceof Error ? error.message : \"Unknown error\"}`\n          );\n          return { id: 404, name: \"Test Not Found\" };\n        }\n      });\n      yield* Effect.logInfo(`Test result: ${JSON.stringify(testUser404)}`);\n    }),\n    TestDatabaseService.Default\n  );\n\n  yield* Effect.logInfo(\n    \"\\n\u2705 Tests that adapt to application code demonstration completed!\"\n  );\n  yield* Effect.logInfo(\n    \"The same business logic works with different service implementations!\"\n  );\n});\n\n// Run the program with the default database service\nEffect.runPromise(\n  Effect.provide(program, DatabaseService.Default) as Effect.Effect<\n    void,\n    never,\n    never\n  >\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Write tests that adapt to application code."
            },
            "created_at": "2026-02-15T21:22:28.593331",
            "updated_at": "2026-02-20T23:09:41.071851"
        },
        {
            "id": "601003b4-9ece-4297-9026-732d48638d4b",
            "slug": "stream-pattern-error-handling",
            "title": "Stream Pattern 7: Error Handling in Streams",
            "summary": "Handle errors gracefully in streams with recovery strategies, resuming after failures, and maintaining stream integrity.",
            "skill_level": "advanced",
            "category": "streams",
            "difficulty": "advanced",
            "tags": [
                "streams",
                "error-handling",
                "recovery",
                "fault-tolerance",
                "error-propagation",
                "stream-resilience"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Ref } from \"effect\";\n\ninterface DataRecord {\n  id: string;\n  value: number;\n}\n\ninterface ProcessingResult {\n  successful: DataRecord[];\n  failed: Array<{ id: string; error: string }>;\n  retried: number;\n}\n\nconst program = Effect.gen(function* () {\n  console.log(`\\n[STREAM ERROR HANDLING] Resilient stream processing\\n`);\n\n  // Example 1: Continue on error (skip failed, process rest)\n  console.log(`[1] Continue processing despite errors:\\n`);\n\n  const processElement = (record: DataRecord): Effect.Effect<string> =>\n    Effect.gen(function* () {\n      if (record.value < 0) {\n        yield* Effect.fail(new Error(`Invalid value: ${record.value}`));\n      }\n\n      return `processed-${record.id}`;\n    });\n\n  const records = [\n    { id: \"rec1\", value: 10 },\n    { id: \"rec2\", value: -5 }, // Will fail\n    { id: \"rec3\", value: 20 },\n    { id: \"rec4\", value: -1 }, // Will fail\n    { id: \"rec5\", value: 30 },\n  ];\n\n  const successfulProcessing = yield* Stream.fromIterable(records).pipe(\n    Stream.mapEffect((record) =>\n      processElement(record).pipe(\n        Effect.map((result) => ({ success: true, result })),\n        Effect.catchAll((error) =>\n          Effect.gen(function* () {\n            yield* Effect.log(`[ERROR] Record ${record.id} failed`);\n\n            return { success: false, error };\n          })\n        )\n      )\n    ),\n    Stream.runCollect\n  );\n\n  yield* Effect.log(\n    `[RESULTS] ${successfulProcessing.filter((r) => r.success).length}/${records.length} succeeded\\n`\n  );\n\n  // Example 2: Recover with fallback value\n  console.log(`[2] Providing fallback on error:\\n`);\n\n  const getData = (id: string): Effect.Effect<number> =>\n    id.includes(\"fail\") ? Effect.fail(new Error(\"Data error\")) : Effect.succeed(42);\n\n  const recovered = yield* Stream.fromIterable([\"ok1\", \"fail1\", \"ok2\"]).pipe(\n    Stream.mapEffect((id) =>\n      getData(id).pipe(\n        Effect.catchAll(() =>\n          Effect.gen(function* () {\n            yield* Effect.log(`[FALLBACK] Using default for ${id}`);\n\n            return -1; // Fallback value\n          })\n        )\n      )\n    ),\n    Stream.runCollect\n  );\n\n  yield* Effect.log(`[VALUES] ${recovered.join(\", \")}\\n`);\n\n  // Example 3: Collect errors alongside successes\n  console.log(`[3] Collecting errors and successes:\\n`);\n\n  const results = yield* Ref.make<ProcessingResult>({\n    successful: [],\n    failed: [],\n    retried: 0,\n  });\n\n  yield* Stream.fromIterable(records).pipe(\n    Stream.mapEffect((record) =>\n      processElement(record).pipe(\n        Effect.tap((result) =>\n          Ref.modify(results, (r) => [\n            undefined,\n            {\n              ...r,\n              successful: [...r.successful, record],\n            },\n          ])\n        ),\n        Effect.catchAll((error) =>\n          Ref.modify(results, (r) => [\n            undefined,\n            {\n              ...r,\n              failed: [\n                ...r.failed,\n                { id: record.id, error: error.message },\n              ],\n            },\n          ])\n        )\n      )\n    ),\n    Stream.runDrain\n  );\n\n  const finalResults = yield* Ref.get(results);\n\n  yield* Effect.log(\n    `[AGGREGATE] ${finalResults.successful.length} succeeded, ${finalResults.failed.length} failed`\n  );\n\n  for (const failure of finalResults.failed) {\n    yield* Effect.log(`  - ${failure.id}: ${failure.error}`);\n  }\n\n  // Example 4: Retry on error with backoff\n  console.log(`\\n[4] Retry with exponential backoff:\\n`);\n\n  let attemptCount = 0;\n\n  const unreliableOperation = (id: string): Effect.Effect<string> =>\n    Effect.gen(function* () {\n      attemptCount++;\n\n      if (attemptCount <= 2) {\n        yield* Effect.log(`[ATTEMPT ${attemptCount}] Failing for ${id}`);\n\n        yield* Effect.fail(new Error(\"Temporary failure\"));\n      }\n\n      yield* Effect.log(`[SUCCESS] Succeeded on attempt ${attemptCount}`);\n\n      return `result-${id}`;\n    });\n\n  const retried = unreliableOperation(\"test\").pipe(\n    Effect.retry(\n      Schedule.exponential(\"10 millis\").pipe(\n        Schedule.upTo(\"100 millis\"),\n        Schedule.recurs(3)\n      )\n    ),\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[EXHAUSTED] All retries failed`);\n\n        return \"fallback\";\n      })\n    )\n  );\n\n  yield* retried;\n\n  // Example 5: Error context in streams\n  console.log(`\\n[5] Propagating error context:\\n`);\n\n  interface StreamContext {\n    batchId: string;\n    timestamp: Date;\n  }\n\n  const processWithContext = (context: StreamContext) =>\n    Stream.fromIterable([1, 2, -3, 4]).pipe(\n      Stream.mapEffect((value) =>\n        Effect.gen(function* () {\n          if (value < 0) {\n            yield* Effect.fail(\n              new Error(\n                `Negative value in batch ${context.batchId} at ${context.timestamp.toISOString()}`\n              )\n            );\n          }\n\n          return value * 2;\n        })\n      ),\n      Stream.catchAll((error) =>\n        Effect.gen(function* () {\n          yield* Effect.log(`[CONTEXT ERROR] ${error.message}`);\n\n          return Stream.empty;\n        })\n      )\n    );\n\n  const context: StreamContext = {\n    batchId: \"batch-001\",\n    timestamp: new Date(),\n  };\n\n  yield* processWithContext(context).pipe(Stream.runDrain);\n\n  // Example 6: Partial recovery (keep good data, log bad)\n  console.log(`\\n[6] Partial recovery strategy:\\n`);\n\n  const mixedQuality = [\n    { id: \"1\", data: \"good\" },\n    { id: \"2\", data: \"bad\" },\n    { id: \"3\", data: \"good\" },\n    { id: \"4\", data: \"bad\" },\n    { id: \"5\", data: \"good\" },\n  ];\n\n  const processQuality = (record: { id: string; data: string }) =>\n    record.data === \"good\"\n      ? Effect.succeed(`valid-${record.id}`)\n      : Effect.fail(new Error(`Invalid data for ${record.id}`));\n\n  const partialResults = yield* Stream.fromIterable(mixedQuality).pipe(\n    Stream.mapEffect((record) =>\n      processQuality(record).pipe(\n        Effect.catchAll((error) =>\n          Effect.gen(function* () {\n            yield* Effect.log(`[LOG] ${error.message}`);\n\n            return null; // Skip this record\n          })\n        )\n      )\n    ),\n    Stream.filter((result) => result !== null),\n    Stream.runCollect\n  );\n\n  yield* Effect.log(\n    `[PARTIAL] Kept ${partialResults.length}/${mixedQuality.length} valid records\\n`\n  );\n\n  // Example 7: Timeout handling in streams\n  console.log(`[7] Timeout handling per element:\\n`);\n\n  const slowOperation = (id: string): Effect.Effect<string> =>\n    Effect.gen(function* () {\n      // Simulate slow operations\n      if (id === \"slow\") {\n        yield* Effect.sleep(\"200 millis\");\n      } else {\n        yield* Effect.sleep(\"50 millis\");\n      }\n\n      return `done-${id}`;\n    });\n\n  const withTimeout = yield* Stream.fromIterable([\"fast1\", \"slow\", \"fast2\"]).pipe(\n    Stream.mapEffect((id) =>\n      slowOperation(id).pipe(\n        Effect.timeout(\"100 millis\"),\n        Effect.catchAll((error) =>\n          Effect.gen(function* () {\n            yield* Effect.log(`[TIMEOUT] Operation ${id} timed out`);\n\n            return \"timeout-fallback\";\n          })\n        )\n      )\n    ),\n    Stream.runCollect\n  );\n\n  yield* Effect.log(`[RESULTS] ${withTimeout.join(\", \")}\\n`);\n\n  // Example 8: Stream termination on critical error\n  console.log(`[8] Terminating stream on critical error:\\n`);\n\n  const isCritical = (error: Error): boolean =>\n    error.message.includes(\"CRITICAL\");\n\n  const terminateOnCritical = Stream.fromIterable([1, 2, 3]).pipe(\n    Stream.mapEffect((value) =>\n      value === 2\n        ? Effect.fail(new Error(\"CRITICAL: System failure\"))\n        : Effect.succeed(value)\n    ),\n    Stream.catchAll((error) =>\n      Effect.gen(function* () {\n        if (isCritical(error)) {\n          yield* Effect.log(`[CRITICAL] Terminating stream`);\n\n          return Stream.fail(error);\n        }\n\n        yield* Effect.log(`[WARNING] Continuing despite error`);\n\n        return Stream.empty;\n      })\n    )\n  );\n\n  yield* terminateOnCritical.pipe(\n    Stream.runCollect,\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[STOPPED] Stream stopped: ${error.message}`);\n\n        return [];\n      })\n    )\n  );\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream error handlers to recover from failures, retry operations, and maintain stream integrity even when individual elements fail."
            },
            "created_at": "2026-02-15T21:22:22.361104",
            "updated_at": "2026-02-20T23:09:44.394264"
        },
        {
            "id": "4e288906-cf8c-478c-8caf-25c2c1165e0e",
            "slug": "stream-pattern-resource-management",
            "title": "Stream Pattern 6: Resource Management in Streams",
            "summary": "Properly manage resources (connections, files, memory) in streams using acquire/release patterns and ensuring cleanup on error or completion.",
            "skill_level": "advanced",
            "category": "streams",
            "difficulty": "advanced",
            "tags": [
                "streams",
                "resource-management",
                "cleanup",
                "error-safety",
                "file-handling",
                "connection-pooling"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Resource, Scope, Ref } from \"effect\";\n\ninterface FileHandle {\n  readonly path: string;\n  readonly fd: number;\n}\n\ninterface Connection {\n  readonly id: string;\n  readonly isOpen: boolean;\n}\n\n// Simulate resource management\nconst program = Effect.gen(function* () {\n  console.log(`\\n[RESOURCE MANAGEMENT] Stream resource lifecycle\\n`);\n\n  // Example 1: Bracket pattern for file streams\n  console.log(`[1] Bracket pattern (acquire \u2192 use \u2192 release):\\n`);\n\n  let openHandles = 0;\n  let closedHandles = 0;\n\n  const openFile = (path: string) =>\n    Effect.gen(function* () {\n      openHandles++;\n      yield* Effect.log(`[OPEN] File \"${path}\" (total open: ${openHandles})`);\n\n      return { path, fd: 1000 + openHandles };\n    });\n\n  const closeFile = (handle: FileHandle) =>\n    Effect.gen(function* () {\n      closedHandles++;\n      yield* Effect.log(`[CLOSE] File \"${handle.path}\" (total closed: ${closedHandles})`);\n    });\n\n  const readFileWithBracket = (path: string) =>\n    Effect.gen(function* () {\n      let handle: FileHandle | null = null;\n\n      try {\n        handle = yield* openFile(path);\n\n        yield* Effect.log(\n          `[USE] Reading from fd ${handle.fd} (\"${handle.path}\")`\n        );\n\n        // Simulate reading\n        return \"file contents\";\n      } finally {\n        // Guaranteed to run even if error occurs above\n        if (handle) {\n          yield* closeFile(handle);\n        }\n      }\n    });\n\n  // Test with success\n  yield* Effect.log(`[TEST] Success case:`);\n\n  const content = yield* readFileWithBracket(\"/data/file.txt\");\n\n  yield* Effect.log(`[RESULT] Got: \"${content}\"\\n`);\n\n  // Test with failure (simulated)\n  yield* Effect.log(`[TEST] Error case:`);\n\n  const failCase = Effect.gen(function* () {\n    let handle: FileHandle | null = null;\n\n    try {\n      handle = yield* openFile(\"/data/missing.txt\");\n\n      // Simulate error mid-operation\n      yield* Effect.fail(new Error(\"Read failed\"));\n    } finally {\n      if (handle) {\n        yield* closeFile(handle);\n      }\n    }\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[ERROR] Caught: ${error.message}`);\n        yield* Effect.log(`[CHECK] Closed handles: ${closedHandles} (verifying cleanup)\\n`);\n      })\n    )\n  );\n\n  yield* failCase;\n\n  // Example 2: Connection pool management\n  console.log(`[2] Connection pooling:\\n`);\n\n  interface ConnectionPool {\n    acquire: () => Effect.Effect<Connection>;\n    release: (conn: Connection) => Effect.Effect<void>;\n  }\n\n  const createConnectionPool = (maxSize: number): Effect.Effect<ConnectionPool> =>\n    Effect.gen(function* () {\n      const available = yield* Ref.make<Connection[]>([]);\n      const inUse = yield* Ref.make<Set<string>>(new Set());\n      let idCounter = 0;\n\n      return {\n        acquire: Effect.gen(function* () {\n          const avail = yield* Ref.get(available);\n\n          if (avail.length > 0) {\n            yield* Effect.log(`[POOL] Reusing connection from pool`);\n\n            const conn = avail.pop()!;\n\n            yield* Ref.modify(inUse, (set) => [\n              undefined,\n              new Set(set).add(conn.id),\n            ]);\n\n            return conn;\n          }\n\n          const inUseCount = (yield* Ref.get(inUse)).size;\n\n          if (inUseCount >= maxSize) {\n            yield* Effect.fail(new Error(\"Pool exhausted\"));\n          }\n\n          const connId = `conn-${++idCounter}`;\n\n          yield* Effect.log(`[POOL] Creating new connection: ${connId}`);\n\n          const conn = { id: connId, isOpen: true };\n\n          yield* Ref.modify(inUse, (set) => [\n            undefined,\n            new Set(set).add(connId),\n          ]);\n\n          return conn;\n        }),\n\n        release: (conn: Connection) =>\n          Effect.gen(function* () {\n            yield* Ref.modify(inUse, (set) => {\n              const updated = new Set(set);\n              updated.delete(conn.id);\n              return [undefined, updated];\n            });\n\n            yield* Ref.modify(available, (avail) => [\n              undefined,\n              [...avail, conn],\n            ]);\n\n            yield* Effect.log(`[POOL] Returned connection: ${conn.id}`);\n          }),\n      };\n    });\n\n  const pool = yield* createConnectionPool(3);\n\n  // Acquire and release connections\n  const conn1 = yield* pool.acquire();\n  const conn2 = yield* pool.acquire();\n\n  yield* pool.release(conn1);\n\n  const conn3 = yield* pool.acquire(); // Reuses conn1\n\n  yield* Effect.log(`\\n`);\n\n  // Example 3: Scope-based resource safety\n  console.log(`[3] Scoped resources (hierarchical cleanup):\\n`);\n\n  let scopedCount = 0;\n\n  const withScoped = <R,>(create: () => Effect.Effect<R>) =>\n    Effect.gen(function* () {\n      scopedCount++;\n      const id = scopedCount;\n\n      yield* Effect.log(`[SCOPE] Enter scope ${id}`);\n\n      const resource = yield* create();\n\n      yield* Effect.log(`[SCOPE] Using resource in scope ${id}`);\n\n      // Cleanup is guaranteed via ensuring\n      yield* Effect.unit.pipe(\n        Effect.ensuring(\n          Effect.log(`[SCOPE] Cleanup guaranteed for scope ${id}`)\n        )\n      );\n\n      return resource;\n    });\n\n  // Nested scopes\n  const result = yield* withScoped(() =>\n    Effect.gen(function* () {\n      const innerData = yield* withScoped(() => Effect.succeed(\"inner data\"));\n      return { level: 1, data: innerData };\n    })\n  ).pipe(\n    Effect.catchAll(() => Effect.succeed({ level: 0, data: null }))\n  );\n\n  yield* Effect.log(`[SCOPES] Cleanup order: inner \u2192 outer\\n`);\n\n  // Example 4: Stream resource management\n  console.log(`[4] Stream with resource cleanup:\\n`);\n\n  let streamResourceCount = 0;\n\n  // Simulate stream that acquires resources\n  const streamWithResources = Stream.empty.pipe(\n    Stream.tap(() =>\n      Effect.gen(function* () {\n        streamResourceCount++;\n        yield* Effect.log(`[STREAM-RES] Acquired resource ${streamResourceCount}`);\n      })\n    ),\n    // Cleanup when stream ends\n    Stream.ensuring(\n      Effect.log(`[STREAM-RES] Cleaning up all ${streamResourceCount} resources`)\n    )\n  );\n\n  yield* Stream.runDrain(streamWithResources);\n\n  // Example 5: Error propagation with cleanup\n  console.log(`\\n[5] Error safety with cleanup:\\n`);\n\n  const safeRead = (retryCount: number) =>\n    Effect.gen(function* () {\n      let handle: FileHandle | null = null;\n\n      try {\n        handle = yield* openFile(`/data/file-${retryCount}.txt`);\n\n        if (retryCount < 2) {\n          yield* Effect.log(`[READ] Attempt ${retryCount}: failing intentionally`);\n          yield* Effect.fail(new Error(`Attempt ${retryCount} failed`));\n        }\n\n        yield* Effect.log(`[READ] Success on attempt ${retryCount}`);\n\n        return \"success\";\n      } finally {\n        if (handle) {\n          yield* closeFile(handle);\n        }\n      }\n    });\n\n  // Retry with guaranteed cleanup\n  const result2 = yield* safeRead(1).pipe(\n    Effect.retry(\n      Schedule.recurs(2).pipe(\n        Schedule.compose(Schedule.fixed(\"10 millis\"))\n      )\n    ),\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[FINAL] All retries failed: ${error.message}`);\n        return \"fallback\";\n      })\n    )\n  );\n\n  yield* Effect.log(`\\n[FINAL] Result: ${result2}`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream.bracket or effect scoping to guarantee resource cleanup, preventing leaks even when streams fail or are interrupted."
            },
            "created_at": "2026-02-15T21:22:22.275361",
            "updated_at": "2026-02-20T23:09:44.43855"
        },
        {
            "id": "acff52da-8ede-43f4-96b3-c63085cccd14",
            "slug": "stream-pattern-grouping-windowing",
            "title": "Stream Pattern 5: Grouping and Windowing Streams",
            "summary": "Use grouping and windowing to organize streams by key or time window, enabling batch operations and temporal aggregations.",
            "skill_level": "advanced",
            "category": "streams",
            "difficulty": "advanced",
            "tags": [
                "streams",
                "grouping",
                "windowing",
                "temporal-aggregation",
                "batching",
                "time-based-operations"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Ref, Duration, Schedule } from \"effect\";\n\ninterface Event {\n  readonly timestamp: Date;\n  readonly userId: string;\n  readonly action: string;\n  readonly duration: number; // milliseconds\n}\n\n// Simulate event stream\nconst generateEvents = (): Event[] => [\n  { timestamp: new Date(Date.now() - 5000), userId: \"user1\", action: \"click\", duration: 100 },\n  { timestamp: new Date(Date.now() - 4500), userId: \"user2\", action: \"view\", duration: 250 },\n  { timestamp: new Date(Date.now() - 4000), userId: \"user1\", action: \"scroll\", duration: 150 },\n  { timestamp: new Date(Date.now() - 3500), userId: \"user3\", action: \"click\", duration: 120 },\n  { timestamp: new Date(Date.now() - 3000), userId: \"user2\", action: \"click\", duration: 180 },\n  { timestamp: new Date(Date.now() - 2500), userId: \"user1\", action: \"view\", duration: 200 },\n  { timestamp: new Date(Date.now() - 2000), userId: \"user3\", action: \"view\", duration: 300 },\n  { timestamp: new Date(Date.now() - 1500), userId: \"user1\", action: \"submit\", duration: 500 },\n  { timestamp: new Date(Date.now() - 1000), userId: \"user2\", action: \"scroll\", duration: 100 },\n];\n\n// Main: windowing and grouping examples\nconst program = Effect.gen(function* () {\n  console.log(`\\n[WINDOWING & GROUPING] Stream organization patterns\\n`);\n\n  const events = generateEvents();\n\n  // Example 1: Tumbling window (fixed-size batches)\n  console.log(`[1] Tumbling window (2-event batches):\\n`);\n\n  const windowSize = 2;\n  let batchNumber = 1;\n\n  for (let i = 0; i < events.length; i += windowSize) {\n    const batch = events.slice(i, i + windowSize);\n\n    yield* Effect.log(`[WINDOW ${batchNumber}] (${batch.length} events)`);\n\n    let totalDuration = 0;\n\n    for (const event of batch) {\n      yield* Effect.log(\n        `  - ${event.userId}: ${event.action} (${event.duration}ms)`\n      );\n\n      totalDuration += event.duration;\n    }\n\n    yield* Effect.log(`[WINDOW ${batchNumber}] Total duration: ${totalDuration}ms\\n`);\n\n    batchNumber++;\n  }\n\n  // Example 2: Sliding window (overlapping)\n  console.log(`[2] Sliding window (last 3 events, slide by 1):\\n`);\n\n  const windowSizeSlide = 3;\n  const slideBy = 1;\n\n  for (let i = 0; i <= events.length - windowSizeSlide; i += slideBy) {\n    const window = events.slice(i, i + windowSizeSlide);\n\n    const avgDuration =\n      window.reduce((sum, e) => sum + e.duration, 0) / window.length;\n\n    yield* Effect.log(\n      `[SLIDE ${i / slideBy}] ${window.length} events, avg duration: ${avgDuration.toFixed(0)}ms`\n    );\n  }\n\n  // Example 3: Group by key\n  console.log(`\\n[3] Group by user:\\n`);\n\n  const byUser = new Map<string, Event[]>();\n\n  for (const event of events) {\n    if (!byUser.has(event.userId)) {\n      byUser.set(event.userId, []);\n    }\n\n    byUser.get(event.userId)!.push(event);\n  }\n\n  for (const [userId, userEvents] of byUser) {\n    const totalActions = userEvents.length;\n    const totalTime = userEvents.reduce((sum, e) => sum + e.duration, 0);\n    const avgTime = totalTime / totalActions;\n\n    yield* Effect.log(\n      `[USER ${userId}] ${totalActions} actions, ${totalTime}ms total, ${avgTime.toFixed(0)}ms avg`\n    );\n  }\n\n  // Example 4: Group + Window combination\n  console.log(`\\n[4] Group by user, window by action type:\\n`);\n\n  for (const [userId, userEvents] of byUser) {\n    const byAction = new Map<string, Event[]>();\n\n    for (const event of userEvents) {\n      if (!byAction.has(event.action)) {\n        byAction.set(event.action, []);\n      }\n\n      byAction.get(event.action)!.push(event);\n    }\n\n    yield* Effect.log(`[USER ${userId}] Action breakdown:`);\n\n    for (const [action, actionEvents] of byAction) {\n      const count = actionEvents.length;\n      const total = actionEvents.reduce((sum, e) => sum + e.duration, 0);\n\n      yield* Effect.log(`  ${action}: ${count}x (${total}ms total)`);\n    }\n  }\n\n  // Example 5: Session window (based on inactivity timeout)\n  console.log(`\\n[5] Session window (gap > 1000ms = new session):\\n`);\n\n  const sessionGapMs = 1000;\n  const sessions: Event[][] = [];\n  let currentSession: Event[] = [];\n  let lastTimestamp = events[0]?.timestamp.getTime() ?? 0;\n\n  for (const event of events) {\n    const currentTime = event.timestamp.getTime();\n    const timeSinceLastEvent = currentTime - lastTimestamp;\n\n    if (timeSinceLastEvent > sessionGapMs && currentSession.length > 0) {\n      sessions.push(currentSession);\n      yield* Effect.log(\n        `[SESSION] Closed (${currentSession.length} events, gap: ${timeSinceLastEvent}ms)`\n      );\n\n      currentSession = [];\n    }\n\n    currentSession.push(event);\n    lastTimestamp = currentTime;\n  }\n\n  if (currentSession.length > 0) {\n    sessions.push(currentSession);\n    yield* Effect.log(`[SESSION] Final (${currentSession.length} events)`);\n  }\n\n  // Example 6: Top-K aggregation in window\n  console.log(`\\n[6] Top 2 actions in last window:\\n`);\n\n  const lastWindow = events.slice(-3);\n\n  const actionCounts = new Map<string, number>();\n\n  for (const event of lastWindow) {\n    actionCounts.set(\n      event.action,\n      (actionCounts.get(event.action) ?? 0) + 1\n    );\n  }\n\n  const topActions = Array.from(actionCounts.entries())\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 2);\n\n  yield* Effect.log(`[TOP-K] In last window of 3 events:`);\n\n  for (const [action, count] of topActions) {\n    yield* Effect.log(`  ${action}: ${count}x`);\n  }\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use groupBy to partition streams by key and tumbling/sliding windows to aggregate streams over time windows."
            },
            "created_at": "2026-02-15T21:22:22.203042",
            "updated_at": "2026-02-20T23:09:44.482475"
        },
        {
            "id": "ed3cba36-3ed5-410d-baab-22fd1ee625a5",
            "slug": "sink-pattern-fall-back-to-alternative-sink-on-failure",
            "title": "Sink Pattern 5: Fall Back to Alternative Sink on Failure",
            "summary": "Use Sink to attempt writing to a primary destination, and automatically fall back to an alternative destination if the primary fails, enabling progressive degradation and high availability.",
            "skill_level": "intermediate",
            "category": "streams",
            "difficulty": "intermediate",
            "tags": [
                "sink",
                "stream",
                "error-handling",
                "fallback",
                "resilience",
                "degradation"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Sink, Chunk, Either, Data } from \"effect\";\n\ninterface Order {\n  readonly orderId: string;\n  readonly customerId: string;\n  readonly total: number;\n  readonly timestamp: number;\n}\n\nclass CacheSinkError extends Data.TaggedError(\"CacheSinkError\")<{\n  readonly reason: string;\n}> {}\n\nclass DatabaseSinkError extends Data.TaggedError(\"DatabaseSinkError\")<{\n  readonly reason: string;\n}> {}\n\n// Mock in-memory cache sink (fast but limited)\nconst createCacheSink = (): Sink.Sink<number, CacheSinkError, Order> => {\n  const cache: Order[] = [];\n  const MAX_CACHE_SIZE = 1000;\n\n  return Sink.fold(\n    0,\n    (count, order) =>\n      Effect.gen(function* () {\n        if (cache.length >= MAX_CACHE_SIZE) {\n          yield* Effect.fail(\n            new CacheSinkError({\n              reason: `Cache full (${cache.length}/${MAX_CACHE_SIZE})`,\n            })\n          );\n        }\n\n        cache.push(order);\n        console.log(`[CACHE] Cached order ${order.orderId}`);\n        return count + 1;\n      }),\n    (count) =>\n      Effect.gen(function* () {\n        console.log(`[CACHE] Final: ${count} orders in cache`);\n        return count;\n      })\n  );\n};\n\n// Mock database sink (slower but reliable)\nconst createDatabaseSink = (): Sink.Sink<number, DatabaseSinkError, Order> => {\n  const orders: Order[] = [];\n\n  return Sink.fold(\n    0,\n    (count, order) =>\n      Effect.gen(function* () {\n        // Simulate occasional database failures\n        if (Math.random() < 0.1) {\n          yield* Effect.fail(\n            new DatabaseSinkError({\n              reason: \"Connection timeout\",\n            })\n          );\n        }\n\n        orders.push(order);\n        console.log(`[DATABASE] Persisted order ${order.orderId}`);\n        return count + 1;\n      }),\n    (count) =>\n      Effect.gen(function* () {\n        console.log(`[DATABASE] Final: ${count} orders in database`);\n        return count;\n      })\n  );\n};\n\n// Mock file sink (always works but slow)\nconst createDeadLetterSink = (): Sink.Sink<number, never, Order> => {\n  const deadLetters: Order[] = [];\n\n  return Sink.fold(\n    0,\n    (count, order) =>\n      Effect.gen(function* () {\n        deadLetters.push(order);\n        console.log(\n          `[DEAD-LETTER] Wrote order ${order.orderId} to dead letter file`\n        );\n        return count + 1;\n      }),\n    (count) =>\n      Effect.gen(function* () {\n        console.log(\n          `[DEAD-LETTER] Final: ${count} orders in dead letter file`\n        );\n        return count;\n      })\n  );\n};\n\n// Create a fallback sink that tries cache -> database -> file\nconst createFallbackSink = (): Sink.Sink<\n  { readonly cached: number; readonly persisted: number; readonly deadLetters: number },\n  never,\n  Order\n> =>\n  Sink.fold(\n    { cached: 0, persisted: 0, deadLetters: 0 },\n    (state, order) =>\n      Effect.gen(function* () {\n        // Try cache first\n        const cacheResult = yield* createCacheSink()\n          .pipe(Sink.feed(Chunk.of(order)))\n          .pipe(Effect.either);\n\n        if (Either.isRight(cacheResult)) {\n          return {\n            ...state,\n            cached: state.cached + cacheResult.right,\n          };\n        }\n\n        console.log(\n          `[FALLBACK] Cache failed (${cacheResult.left.reason}), trying database`\n        );\n\n        // Cache failed, try database\n        const dbResult = yield* createDatabaseSink()\n          .pipe(Sink.feed(Chunk.of(order)))\n          .pipe(Effect.either);\n\n        if (Either.isRight(dbResult)) {\n          return {\n            ...state,\n            persisted: state.persisted + dbResult.right,\n          };\n        }\n\n        console.log(\n          `[FALLBACK] Database failed (${dbResult.left.reason}), falling back to dead letter`\n        );\n\n        // Database failed, use dead letter\n        const dlResult = yield* createDeadLetterSink()\n          .pipe(Sink.feed(Chunk.of(order)));\n\n        return {\n          ...state,\n          deadLetters: state.deadLetters + dlResult,\n        };\n      }),\n    (state) =>\n      Effect.gen(function* () {\n        console.log(`\\n[SUMMARY]`);\n        console.log(`  Cached:      ${state.cached}`);\n        console.log(`  Persisted:   ${state.persisted}`);\n        console.log(`  Dead Letter: ${state.deadLetters}`);\n        return state;\n      })\n  );\n\n// Simulate a stream of orders\nconst orderStream: Stream.Stream<Order> = Stream.fromIterable([\n  {\n    orderId: \"order-1\",\n    customerId: \"cust-1\",\n    total: 99.99,\n    timestamp: Date.now(),\n  },\n  {\n    orderId: \"order-2\",\n    customerId: \"cust-2\",\n    total: 149.99,\n    timestamp: Date.now() + 100,\n  },\n  {\n    orderId: \"order-3\",\n    customerId: \"cust-1\",\n    total: 49.99,\n    timestamp: Date.now() + 200,\n  },\n  {\n    orderId: \"order-4\",\n    customerId: \"cust-3\",\n    total: 199.99,\n    timestamp: Date.now() + 300,\n  },\n  {\n    orderId: \"order-5\",\n    customerId: \"cust-2\",\n    total: 89.99,\n    timestamp: Date.now() + 400,\n  },\n]);\n\n// Run the stream with fallback sink\nconst program = Effect.gen(function* () {\n  const result = yield* orderStream.pipe(Stream.run(createFallbackSink()));\n  console.log(`\\nTotal orders processed: ${result.cached + result.persisted + result.deadLetters}`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Implement fallback sinks to handle failures gracefully and ensure data is persisted even when the primary destination is unavailable."
            },
            "created_at": "2026-02-15T21:22:21.767399",
            "updated_at": "2026-02-20T23:09:44.839263"
        },
        {
            "id": "6b2d9226-7476-4745-bfe2-3d0085948d7d",
            "slug": "data-bigdecimal",
            "title": "Work with Arbitrary-Precision Numbers using BigDecimal",
            "summary": "Use BigDecimal for arbitrary-precision decimal arithmetic, avoiding rounding errors and loss of precision in financial or scientific calculations.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "BigDecimal",
                "numeric",
                "precision",
                "decimal",
                "data-type",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { BigDecimal } from \"effect\";\n\n// Create BigDecimal values\nconst a = BigDecimal.fromNumber(0.1);\nconst b = BigDecimal.fromNumber(0.2);\n\n// Add, subtract, multiply, divide\nconst sum = BigDecimal.sum(a, b); // BigDecimal(0.3)\nconst product = BigDecimal.multiply(a, b); // BigDecimal(0.02)\n\n// Compare values\nconst isEqual = BigDecimal.equals(sum, BigDecimal.fromNumber(0.3)); // true\n\n// Convert to string or number\nconst asString = BigDecimal.format(BigDecimal.normalize(sum)); // \"0.3\"\nconst asNumber = BigDecimal.unsafeToNumber(sum); // 0.3",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use BigDecimal to represent and compute with decimal numbers that require arbitrary precision, such as in finance or scientific domains."
            },
            "created_at": "2026-02-15T21:22:16.68712",
            "updated_at": "2026-02-20T23:09:34.523875"
        },
        {
            "id": "811dcc34-e29d-4586-b563-ec93e947f6d6",
            "slug": "platform-filesystem-operations",
            "title": "Platform Pattern 2: Filesystem Operations",
            "summary": "Use FileSystem module to read, write, list, and manage files with proper resource cleanup and error handling.",
            "skill_level": "beginner",
            "category": "platform",
            "difficulty": "beginner",
            "tags": [
                "platform",
                "filesystem",
                "file-io",
                "io-operations",
                "resource-management",
                "file-handling"
            ],
            "examples": [
                {
                    "code": "import { FileSystem, Effect, Stream } from \"@effect/platform\";\nimport * as fs from \"fs/promises\";\n\nconst program = Effect.gen(function* () {\n  console.log(`\\n[FILESYSTEM] Demonstrating file operations\\n`);\n\n  // Example 1: Write a file\n  console.log(`[1] Writing file:\\n`);\n\n  const content = `Hello, Effect-TS!\\nThis is a test file.\\nCreated at ${new Date().toISOString()}`;\n\n  yield* FileSystem.writeFileUtf8(\"test.txt\", content);\n\n  yield* Effect.log(`\u2713 File written: test.txt`);\n\n  // Example 2: Read the file\n  console.log(`\\n[2] Reading file:\\n`);\n\n  const readContent = yield* FileSystem.readFileUtf8(\"test.txt\");\n\n  console.log(readContent);\n\n  // Example 3: Get file stats\n  console.log(`\\n[3] File stats:\\n`);\n\n  const stats = yield* FileSystem.stat(\"test.txt\").pipe(\n    Effect.flatMap((stat) =>\n      Effect.succeed({\n        size: stat.size,\n        isFile: stat.isFile(),\n        modified: stat.mtimeMs,\n      })\n    )\n  );\n\n  console.log(`  Size: ${stats.size} bytes`);\n  console.log(`  Is file: ${stats.isFile}`);\n  console.log(`  Modified: ${new Date(stats.modified).toISOString()}`);\n\n  // Example 4: Create directory and write multiple files\n  console.log(`\\n[4] Creating directory and files:\\n`);\n\n  yield* FileSystem.mkdir(\"test-dir\");\n\n  yield* Effect.all(\n    Array.from({ length: 3 }, (_, i) =>\n      FileSystem.writeFileUtf8(\n        `test-dir/file-${i + 1}.txt`,\n        `Content of file ${i + 1}`\n      )\n    )\n  );\n\n  yield* Effect.log(`\u2713 Created directory with 3 files`);\n\n  // Example 5: List directory contents\n  console.log(`\\n[5] Listing directory:\\n`);\n\n  const entries = yield* FileSystem.readDirectory(\"test-dir\");\n\n  entries.forEach((entry) => {\n    console.log(`  - ${entry}`);\n  });\n\n  // Example 6: Append to file\n  console.log(`\\n[6] Appending to file:\\n`);\n\n  const appendContent = `\\nAppended line at ${new Date().toISOString()}`;\n\n  yield* FileSystem.appendFileUtf8(\"test.txt\", appendContent);\n\n  const finalContent = yield* FileSystem.readFileUtf8(\"test.txt\");\n\n  console.log(`File now has ${finalContent.split(\"\\n\").length} lines`);\n\n  // Example 7: Clean up\n  console.log(`\\n[7] Cleaning up:\\n`);\n\n  yield* Effect.all(\n    Array.from({ length: 3 }, (_, i) =>\n      FileSystem.remove(`test-dir/file-${i + 1}.txt`)\n    )\n  );\n\n  yield* FileSystem.remove(\"test-dir\");\n  yield* FileSystem.remove(\"test.txt\");\n\n  yield* Effect.log(`\u2713 Cleanup complete`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use FileSystem module for safe, resource-managed file operations with proper error handling and cleanup."
            },
            "created_at": "2026-02-15T21:22:22.607261",
            "updated_at": "2026-02-20T23:09:43.890653"
        },
        {
            "id": "c580afce-5b8c-4659-9320-de4587da97f9",
            "slug": "platform-keyvaluestore-persistence",
            "title": "Platform Pattern 3: Persistent Key-Value Storage",
            "summary": "Use KeyValueStore for simple persistent key-value storage, enabling caching, session management, and lightweight data persistence.",
            "skill_level": "intermediate",
            "category": "platform",
            "difficulty": "intermediate",
            "tags": [
                "platform",
                "persistence",
                "storage",
                "keyvalue",
                "cache",
                "state-management"
            ],
            "examples": [
                {
                    "code": "import { KeyValueStore, Effect } from \"@effect/platform\";\n\ninterface UserSession {\n  readonly userId: string;\n  readonly token: string;\n  readonly expiresAt: number;\n}\n\nconst program = Effect.gen(function* () {\n  console.log(`\\n[KEYVALUESTORE] Persistent storage example\\n`);\n\n  const store = yield* KeyValueStore.KeyValueStore;\n\n  // Example 1: Store session data\n  console.log(`[1] Storing session:\\n`);\n\n  const session: UserSession = {\n    userId: \"user-123\",\n    token: \"token-abc-def\",\n    expiresAt: Date.now() + 3600000, // 1 hour\n  };\n\n  yield* store.set(\"session:user-123\", JSON.stringify(session));\n\n  yield* Effect.log(`\u2713 Session stored`);\n\n  // Example 2: Retrieve stored data\n  console.log(`\\n[2] Retrieving session:\\n`);\n\n  const stored = yield* store.get(\"session:user-123\");\n\n  if (stored._tag === \"Some\") {\n    const retrievedSession = JSON.parse(stored.value) as UserSession;\n\n    console.log(`  User ID: ${retrievedSession.userId}`);\n    console.log(`  Token: ${retrievedSession.token}`);\n    console.log(\n      `  Expires: ${new Date(retrievedSession.expiresAt).toISOString()}`\n    );\n  }\n\n  // Example 3: Check if key exists\n  console.log(`\\n[3] Checking keys:\\n`);\n\n  const hasSession = yield* store.has(\"session:user-123\");\n  const hasOther = yield* store.has(\"session:user-999\");\n\n  console.log(`  Has session:user-123: ${hasSession}`);\n  console.log(`  Has session:user-999: ${hasOther}`);\n\n  // Example 4: Store multiple cache entries\n  console.log(`\\n[4] Caching API responses:\\n`);\n\n  const apiResponses = [\n    { endpoint: \"/api/users\", data: [{ id: 1, name: \"Alice\" }] },\n    { endpoint: \"/api/posts\", data: [{ id: 1, title: \"First Post\" }] },\n    { endpoint: \"/api/comments\", data: [] },\n  ];\n\n  yield* Effect.all(\n    apiResponses.map((item) =>\n      store.set(\n        `cache:${item.endpoint}`,\n        JSON.stringify(item.data)\n      )\n    )\n  );\n\n  yield* Effect.log(`\u2713 Cached ${apiResponses.length} endpoints`);\n\n  // Example 5: Retrieve cache with expiration\n  console.log(`\\n[5] Checking cached data:\\n`);\n\n  for (const item of apiResponses) {\n    const cached = yield* store.get(`cache:${item.endpoint}`);\n\n    if (cached._tag === \"Some\") {\n      const data = JSON.parse(cached.value);\n\n      console.log(\n        `  ${item.endpoint}: ${Array.isArray(data) ? data.length : 1} items`\n      );\n    }\n  }\n\n  // Example 6: Remove specific entry\n  console.log(`\\n[6] Removing entry:\\n`);\n\n  yield* store.remove(\"cache:/api/comments\");\n\n  const removed = yield* store.has(\"cache:/api/comments\");\n\n  console.log(`  Exists after removal: ${removed}`);\n\n  // Example 7: Iterate and count entries\n  console.log(`\\n[7] Counting entries:\\n`);\n\n  const allKeys = yield* store.entries.pipe(\n    Effect.map((entries) => entries.length)\n  );\n\n  console.log(`  Total entries: ${allKeys}`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use KeyValueStore for simple persistent storage of key-value pairs, enabling lightweight caching and session management."
            },
            "created_at": "2026-02-15T21:22:22.928379",
            "updated_at": "2026-02-20T23:09:44.013774"
        },
        {
            "id": "ae427330-c8ca-4639-b7f6-4aa8fa9eafb9",
            "slug": "platform-hello-world",
            "title": "Your First Platform Operation",
            "summary": "Get started with Effect Platform by reading a file and understanding how Platform differs from Node.js APIs.",
            "skill_level": "beginner",
            "category": "platform",
            "difficulty": "beginner",
            "tags": [
                "platform",
                "getting-started",
                "filesystem",
                "introduction"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\"\nimport { FileSystem } from \"@effect/platform\"\nimport { NodeContext, NodeRuntime } from \"@effect/platform-node\"\n\n// Read a file - returns Effect<string, PlatformError>\nconst readConfig = Effect.gen(function* () {\n  const fs = yield* FileSystem.FileSystem\n  \n  // Read file as UTF-8 string\n  const content = yield* fs.readFileString(\"./config.json\")\n  \n  return JSON.parse(content)\n})\n\n// Write a file\nconst writeLog = Effect.gen(function* () {\n  const fs = yield* FileSystem.FileSystem\n  \n  yield* fs.writeFileString(\n    \"./app.log\",\n    `Started at ${new Date().toISOString()}\\n`\n  )\n})\n\n// Combine operations\nconst program = Effect.gen(function* () {\n  const config = yield* readConfig\n  yield* Effect.log(`Loaded config: ${config.appName}`)\n  \n  yield* writeLog\n  yield* Effect.log(\"Log file created\")\n})\n\n// Run with Node.js platform\nprogram.pipe(\n  Effect.provide(NodeContext.layer),\n  NodeRuntime.runMain\n)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use @effect/platform for cross-platform system operations with Effect integration."
            },
            "created_at": "2026-02-15T21:22:22.764246",
            "updated_at": "2026-02-20T23:09:44.102671"
        },
        {
            "id": "4bf1ea51-d6fd-44ab-83b5-b8da5612ba3a",
            "slug": "create-pre-resolved-effect",
            "title": "Create Pre-resolved Effects with succeed and fail",
            "summary": "Use Effect.succeed(value) to create an Effect that immediately succeeds with a value, and Effect.fail(error) for an Effect that immediately fails.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "creation",
                "succeed",
                "fail",
                "sync"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data } from \"effect\";\n\n// Create a custom error type\nclass MyError extends Data.TaggedError(\"MyError\") {}\n\n// Create a program that demonstrates pre-resolved effects\nconst program = Effect.gen(function* () {\n  // Success effect\n  yield* Effect.logInfo(\"Running success effect...\");\n  yield* Effect.gen(function* () {\n    const value = yield* Effect.succeed(42);\n    yield* Effect.logInfo(`Success value: ${value}`);\n  });\n\n  // Failure effect\n  yield* Effect.logInfo(\"\\nRunning failure effect...\");\n  yield* Effect.gen(function* () {\n    // Use return yield* for effects that never succeed\n    return yield* Effect.fail(new MyError());\n  }).pipe(\n    Effect.catchTag(\"MyError\", (error) =>\n      Effect.logInfo(`Error occurred: ${error._tag}`)\n    )\n  );\n});\n\n// Run the program\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Create pre-resolved effects with succeed and fail."
            },
            "created_at": "2026-02-15T21:22:13.478748",
            "updated_at": "2026-02-20T23:09:33.655567"
        },
        {
            "id": "08bf7d08-eea0-4775-8112-a5caf3e5ddad",
            "slug": "scheduling-pattern-debounce-throttle",
            "title": "Scheduling Pattern 4: Debounce and Throttle Execution",
            "summary": "Use debouncing and throttling to limit how often effects execute, preventing runaway operations and handling rapid event sequences.",
            "skill_level": "intermediate",
            "category": "scheduling",
            "difficulty": "intermediate",
            "tags": [
                "scheduling",
                "debounce",
                "throttle",
                "rate-limiting",
                "event-handling",
                "deduplication"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule, Ref } from \"effect\";\n\ninterface SearchQuery {\n  readonly query: string;\n  readonly timestamp: Date;\n}\n\n// Simulate API search\nconst performSearch = (query: string): Effect.Effect<string[]> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`[API] Searching for: \"${query}\"`);\n\n    yield* Effect.sleep(\"100 millis\"); // Simulate API delay\n\n    return [\n      `Result 1 for ${query}`,\n      `Result 2 for ${query}`,\n      `Result 3 for ${query}`,\n    ];\n  });\n\n// Main: demonstrate debounce and throttle\nconst program = Effect.gen(function* () {\n  console.log(`\\n[DEBOUNCE/THROTTLE] Handling rapid events\\n`);\n\n  // Example 1: Debounce search input\n  console.log(`[1] Debounced search (wait for silence):\\n`);\n\n  const searchQueries = [\"h\", \"he\", \"hel\", \"hell\", \"hello\"];\n\n  const debouncedSearches = yield* Ref.make<Effect.Effect<string[]>[]>([]);\n\n  for (const query of searchQueries) {\n    yield* Effect.log(`[INPUT] User typed: \"${query}\"`);\n\n    // In real app, this would be debounced\n    yield* Effect.sleep(\"150 millis\"); // User typing\n  }\n\n  // After user stops, execute search\n  yield* Effect.log(`[DEBOUNCE] User silent for 200ms, executing search`);\n\n  const searchResults = yield* performSearch(\"hello\");\n\n  yield* Effect.log(`[RESULTS] ${searchResults.length} results found\\n`);\n\n  // Example 2: Throttle scroll events\n  console.log(`[2] Throttled scroll handler (max 10/sec):\\n`);\n\n  const scrollEventCount = yield* Ref.make(0);\n  const updateCount = yield* Ref.make(0);\n\n  // Simulate 100 rapid scroll events\n  for (let i = 0; i < 100; i++) {\n    yield* Ref.update(scrollEventCount, (c) => c + 1);\n\n    // In real app, scroll handler would be throttled\n    if (i % 10 === 0) {\n      // Simulate throttled update (max 10 per second)\n      yield* Ref.update(updateCount, (c) => c + 1);\n    }\n  }\n\n  const events = yield* Ref.get(scrollEventCount);\n  const updates = yield* Ref.get(updateCount);\n\n  yield* Effect.log(\n    `[THROTTLE] ${events} scroll events \u2192 ${updates} updates (${(updates / events * 100).toFixed(1)}% update rate)\\n`\n  );\n\n  // Example 3: Deduplication\n  console.log(`[3] Deduplicating rapid events:\\n`);\n\n  const userClicks = [\"click\", \"click\", \"click\", \"dblclick\", \"click\"];\n\n  const lastClick = yield* Ref.make<string | null>(null);\n  const clickCount = yield* Ref.make(0);\n\n  for (const click of userClicks) {\n    const prev = yield* Ref.get(lastClick);\n\n    if (click !== prev) {\n      yield* Effect.log(`[CLICK] Processing: ${click}`);\n      yield* Ref.update(clickCount, (c) => c + 1);\n      yield* Ref.set(lastClick, click);\n    } else {\n      yield* Effect.log(`[CLICK] Duplicate: ${click} (skipped)`);\n    }\n  }\n\n  const processed = yield* Ref.get(clickCount);\n\n  yield* Effect.log(\n    `\\n[DEDUPE] ${userClicks.length} clicks \u2192 ${processed} processed\\n`\n  );\n\n  // Example 4: Exponential backoff on repeated errors\n  console.log(`[4] Throttled retry on errors:\\n`);\n\n  let retryCount = 0;\n\n  const operation = Effect.gen(function* () {\n    retryCount++;\n\n    if (retryCount < 3) {\n      yield* Effect.fail(new Error(\"Still failing\"));\n    }\n\n    yield* Effect.log(`[SUCCESS] Succeeded on attempt ${retryCount}`);\n\n    return \"done\";\n  }).pipe(\n    Effect.retry(\n      Schedule.exponential(\"100 millis\").pipe(\n        Schedule.upTo(\"1 second\"),\n        Schedule.recurs(5)\n      )\n    )\n  );\n\n  yield* operation;\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use debounce to wait for silence before executing, and throttle to limit execution frequency, both critical for handling rapid events."
            },
            "created_at": "2026-02-15T21:22:23.529965",
            "updated_at": "2026-02-20T23:09:45.274387"
        },
        {
            "id": "b13537b5-e3b5-4c5e-8aed-a8b9453ed8b1",
            "slug": "scheduling-pattern-advanced-retry-chains",
            "title": "Scheduling Pattern 5: Advanced Retry Chains and Circuit Breakers",
            "summary": "Build sophisticated retry chains with circuit breakers, fallbacks, and complex failure patterns for production-grade reliability.",
            "skill_level": "advanced",
            "category": "scheduling",
            "difficulty": "advanced",
            "tags": [
                "scheduling",
                "retry",
                "circuit-breaker",
                "fault-tolerance",
                "error-recovery",
                "resilience"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule, Ref, Data } from \"effect\";\n\n// Error classification\nclass RetryableError extends Data.TaggedError(\"RetryableError\")<{\n  message: string;\n  code: string;\n}> {}\n\nclass NonRetryableError extends Data.TaggedError(\"NonRetryableError\")<{\n  message: string;\n  code: string;\n}> {}\n\nclass CircuitBreakerOpenError extends Data.TaggedError(\"CircuitBreakerOpenError\")<{\n  message: string;\n}> {}\n\n// Circuit breaker state\ninterface CircuitBreakerState {\n  status: \"closed\" | \"open\" | \"half-open\";\n  failureCount: number;\n  lastFailureTime: Date | null;\n  successCount: number;\n}\n\n// Create circuit breaker\nconst createCircuitBreaker = (config: {\n  failureThreshold: number;\n  resetTimeoutMs: number;\n  halfOpenRequests: number;\n}) =>\n  Effect.gen(function* () {\n    const state = yield* Ref.make<CircuitBreakerState>({\n      status: \"closed\",\n      failureCount: 0,\n      lastFailureTime: null,\n      successCount: 0,\n    });\n\n    const recordSuccess = Effect.gen(function* () {\n      yield* Ref.modify(state, (s) => {\n        if (s.status === \"half-open\") {\n          return [\n            undefined,\n            {\n              ...s,\n              successCount: s.successCount + 1,\n              status: s.successCount + 1 >= config.halfOpenRequests\n                ? \"closed\"\n                : \"half-open\",\n              failureCount: 0,\n            },\n          ];\n        }\n        return [undefined, s];\n      });\n    });\n\n    const recordFailure = Effect.gen(function* () {\n      yield* Ref.modify(state, (s) => {\n        const newFailureCount = s.failureCount + 1;\n        const newStatus = newFailureCount >= config.failureThreshold\n          ? \"open\"\n          : s.status;\n\n        return [\n          undefined,\n          {\n            ...s,\n            failureCount: newFailureCount,\n            lastFailureTime: new Date(),\n            status: newStatus,\n          },\n        ];\n      });\n    });\n\n    const canExecute = Effect.gen(function* () {\n      const current = yield* Ref.get(state);\n\n      if (current.status === \"closed\") {\n        return true;\n      }\n\n      if (current.status === \"open\") {\n        const timeSinceFailure = Date.now() - (current.lastFailureTime?.getTime() ?? 0);\n\n        if (timeSinceFailure > config.resetTimeoutMs) {\n          yield* Ref.modify(state, (s) => [\n            undefined,\n            {\n              ...s,\n              status: \"half-open\",\n              failureCount: 0,\n              successCount: 0,\n            },\n          ]);\n          return true;\n        }\n\n        return false;\n      }\n\n      // half-open: allow limited requests\n      return true;\n    });\n\n    return { recordSuccess, recordFailure, canExecute, state };\n  });\n\n// Main example\nconst program = Effect.gen(function* () {\n  console.log(`\\n[ADVANCED RETRY] Circuit breaker and fallback chains\\n`);\n\n  // Create circuit breaker\n  const cb = yield* createCircuitBreaker({\n    failureThreshold: 3,\n    resetTimeoutMs: 1000,\n    halfOpenRequests: 2,\n  });\n\n  // Example 1: Circuit breaker in action\n  console.log(`[1] Circuit breaker state transitions:\\n`);\n\n  let requestCount = 0;\n\n  const callWithCircuitBreaker = (shouldFail: boolean) =>\n    Effect.gen(function* () {\n      const canExecute = yield* cb.canExecute;\n\n      if (!canExecute) {\n        yield* Effect.fail(\n          new CircuitBreakerOpenError({\n            message: \"Circuit breaker is open\",\n          })\n        );\n      }\n\n      requestCount++;\n\n      if (shouldFail) {\n        yield* cb.recordFailure;\n        yield* Effect.log(\n          `[REQUEST ${requestCount}] FAILED (Circuit: ${(yield* Ref.get(cb.state)).status})`\n        );\n        yield* Effect.fail(\n          new RetryableError({\n            message: \"Service error\",\n            code: \"500\",\n          })\n        );\n      } else {\n        yield* cb.recordSuccess;\n        yield* Effect.log(\n          `[REQUEST ${requestCount}] SUCCESS (Circuit: ${(yield* Ref.get(cb.state)).status})`\n        );\n        return \"success\";\n      }\n    });\n\n  // Simulate failures then recovery\n  const failSequence = [true, true, true, false, false, false];\n\n  for (const shouldFail of failSequence) {\n    yield* callWithCircuitBreaker(shouldFail).pipe(\n      Effect.catchAll((error) =>\n        Effect.gen(function* () {\n          if (error._tag === \"CircuitBreakerOpenError\") {\n            yield* Effect.log(\n              `[REQUEST ${requestCount + 1}] REJECTED (Circuit open)`\n            );\n          } else {\n            yield* Effect.log(\n              `[REQUEST ${requestCount + 1}] ERROR caught`\n            );\n          }\n        })\n      )\n    );\n\n    // Add delay between requests\n    yield* Effect.sleep(\"100 millis\");\n  }\n\n  // Example 2: Fallback chain\n  console.log(`\\n[2] Fallback chain (primary \u2192 secondary \u2192 cache):\\n`);\n\n  const endpoints = {\n    primary: \"https://api.primary.com/data\",\n    secondary: \"https://api.secondary.com/data\",\n    cache: \"cached-data\",\n  };\n\n  const callEndpoint = (name: string, shouldFail: boolean) =>\n    Effect.gen(function* () {\n      yield* Effect.log(`[CALL] Trying ${name}`);\n\n      if (shouldFail) {\n        yield* Effect.sleep(\"50 millis\");\n        yield* Effect.fail(\n          new RetryableError({\n            message: `${name} failed`,\n            code: \"500\",\n          })\n        );\n      }\n\n      yield* Effect.sleep(\"50 millis\");\n      return `data-from-${name}`;\n    });\n\n  const fallbackChain = callEndpoint(\"primary\", true).pipe(\n    Effect.orElse(() => callEndpoint(\"secondary\", false)),\n    Effect.orElse(() =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[FALLBACK] Using cached data`);\n        return endpoints.cache;\n      })\n    )\n  );\n\n  const result = yield* fallbackChain;\n\n  yield* Effect.log(`[RESULT] Got: ${result}\\n`);\n\n  // Example 3: Error-specific retry strategy\n  console.log(`[3] Error classification and adaptive retry:\\n`);\n\n  const classifyError = (code: string) => {\n    if ([\"502\", \"503\", \"504\"].includes(code)) {\n      return \"retryable-service-error\";\n    }\n    if ([\"408\", \"429\"].includes(code)) {\n      return \"retryable-rate-limit\";\n    }\n    if ([\"404\", \"401\", \"403\"].includes(code)) {\n      return \"non-retryable\";\n    }\n    if (code === \"timeout\") {\n      return \"retryable-network\";\n    }\n    return \"unknown\";\n  };\n\n  const errorCodes = [\"500\", \"404\", \"429\", \"503\", \"timeout\"];\n\n  for (const code of errorCodes) {\n    const classification = classifyError(code);\n    const shouldRetry = !classification.startsWith(\"non-retryable\");\n\n    yield* Effect.log(\n      `[ERROR ${code}] \u2192 ${classification} (Retry: ${shouldRetry})`\n    );\n  }\n\n  // Example 4: Bulkhead pattern\n  console.log(`\\n[4] Bulkhead isolation (limit concurrency per endpoint):\\n`);\n\n  const bulkheads = {\n    \"primary-api\": { maxConcurrent: 5, currentCount: 0 },\n    \"secondary-api\": { maxConcurrent: 3, currentCount: 0 },\n  };\n\n  const acquirePermit = (endpoint: string) =>\n    Effect.gen(function* () {\n      const bulkhead = bulkheads[endpoint as keyof typeof bulkheads];\n\n      if (!bulkhead) {\n        return false;\n      }\n\n      if (bulkhead.currentCount < bulkhead.maxConcurrent) {\n        bulkhead.currentCount++;\n        return true;\n      }\n\n      yield* Effect.log(\n        `[BULKHEAD] ${endpoint} at capacity (${bulkhead.currentCount}/${bulkhead.maxConcurrent})`\n      );\n\n      return false;\n    });\n\n  // Simulate requests\n  for (let i = 0; i < 10; i++) {\n    const endpoint = i < 6 ? \"primary-api\" : \"secondary-api\";\n    const acquired = yield* acquirePermit(endpoint);\n\n    if (acquired) {\n      yield* Effect.log(\n        `[REQUEST] Acquired permit for ${endpoint}`\n      );\n    }\n  }\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use retry chains with circuit breakers to handle complex failure scenarios, detect cascade failures early, and prevent resource exhaustion."
            },
            "created_at": "2026-02-15T21:22:23.611666",
            "updated_at": "2026-02-20T23:09:45.323481"
        },
        {
            "id": "e456ee01-f384-46db-b4dc-45523e60b33f",
            "slug": "accumulate-multiple-errors-with-either",
            "title": "Accumulate Multiple Errors with Either",
            "summary": "Use Either<E, A> to represent computations that can fail, allowing you to accumulate multiple errors instead of short-circuiting on the first one.",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "either",
                "validation",
                "error-accumulation",
                "schema",
                "data"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema, Data, Either } from \"effect\";\n\n// Define validation error type\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly field: string;\n  readonly message: string;\n}> {}\n\n// Define user type\ntype User = {\n  name: string;\n  email: string;\n};\n\n// Define schema with custom validation\nconst UserSchema = Schema.Struct({\n  name: Schema.String.pipe(\n    Schema.minLength(3),\n    Schema.filter((name) => /^[A-Za-z\\s]+$/.test(name), {\n      message: () => \"name must contain only letters and spaces\",\n    })\n  ),\n  email: Schema.String.pipe(\n    Schema.pattern(/@/),\n    Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/, {\n      message: () => \"email must be a valid email address\",\n    })\n  ),\n});\n\n// Example inputs\nconst invalidInputs: User[] = [\n  {\n    name: \"Al\", // Too short\n    email: \"bob-no-at-sign.com\", // Invalid pattern\n  },\n  {\n    name: \"John123\", // Contains numbers\n    email: \"john@incomplete\", // Invalid email\n  },\n  {\n    name: \"Alice Smith\", // Valid\n    email: \"alice@example.com\", // Valid\n  },\n];\n\n// Validate a single user\nconst validateUser = (input: User) =>\n  Effect.gen(function* () {\n    const result = yield* Schema.decode(UserSchema)(input, { errors: \"all\" });\n    return result;\n  });\n\n// Process multiple users and accumulate all errors\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Validating users...\\n\");\n\n  for (const input of invalidInputs) {\n    const result = yield* Effect.either(validateUser(input));\n\n    yield* Effect.log(`Validating user: ${input.name} <${input.email}>`);\n\n    // Handle success and failure cases separately for clarity\n    // Using Either.match which is the idiomatic way to handle Either values\n    yield* Either.match(result, {\n      onLeft: (error) =>\n        Effect.gen(function* () {\n          yield* Effect.log(\"\u274c Validation failed:\");\n          yield* Effect.log(error.message);\n          yield* Effect.log(\"\"); // Empty line for readability\n        }),\n      onRight: (user) =>\n        Effect.gen(function* () {\n          yield* Effect.log(`\u2705 User is valid: ${JSON.stringify(user)}`);\n          yield* Effect.log(\"\"); // Empty line for readability\n        }),\n    });\n  }\n});\n\n// Run the program\nEffect.runSync(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Either to accumulate multiple validation errors instead of failing on the first one."
            },
            "created_at": "2026-02-15T21:22:23.94439",
            "updated_at": "2026-02-20T23:09:45.858301"
        },
        {
            "id": "6bc91e29-c9f0-4354-ba6d-4ec605e0987a",
            "slug": "domain-modeling-option-basics",
            "title": "Handle Missing Values with Option",
            "summary": "Use Option to explicitly model values that might not exist, avoiding null/undefined bugs.",
            "skill_level": "beginner",
            "category": "domain-modeling",
            "difficulty": "beginner",
            "tags": [
                "domain-modeling",
                "option",
                "null-safety",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Option, Effect } from \"effect\"\n\n// ============================================\n// 1. Creating Options\n// ============================================\n\n// Some - a value is present\nconst hasValue = Option.some(42)\n\n// None - no value\nconst noValue = Option.none<number>()\n\n// From nullable - null/undefined becomes None\nconst fromNull = Option.fromNullable(null)        // None\nconst fromValue = Option.fromNullable(\"hello\")    // Some(\"hello\")\n\n// ============================================\n// 2. Checking and extracting values\n// ============================================\n\nconst maybeUser = Option.some({ name: \"Alice\", age: 30 })\n\n// Check if value exists\nif (Option.isSome(maybeUser)) {\n  console.log(`User: ${maybeUser.value.name}`)\n}\n\n// Get with default\nconst name = Option.getOrElse(\n  Option.map(maybeUser, u => u.name),\n  () => \"Anonymous\"\n)\n\n// ============================================\n// 3. Transforming Options\n// ============================================\n\nconst maybeNumber = Option.some(5)\n\n// Map - transform the value if present\nconst doubled = Option.map(maybeNumber, n => n * 2)  // Some(10)\n\n// FlatMap - chain operations that return Option\nconst safeDivide = (a: number, b: number): Option.Option<number> =>\n  b === 0 ? Option.none() : Option.some(a / b)\n\nconst result = Option.flatMap(maybeNumber, n => safeDivide(10, n))  // Some(2)\n\n// ============================================\n// 4. Domain modeling example\n// ============================================\n\ninterface User {\n  readonly id: string\n  readonly name: string\n  readonly email: Option.Option<string>  // Email is optional\n  readonly phone: Option.Option<string>  // Phone is optional\n}\n\nconst createUser = (name: string): User => ({\n  id: crypto.randomUUID(),\n  name,\n  email: Option.none(),\n  phone: Option.none(),\n})\n\nconst addEmail = (user: User, email: string): User => ({\n  ...user,\n  email: Option.some(email),\n})\n\nconst getContactInfo = (user: User): string => {\n  const email = Option.getOrElse(user.email, () => \"no email\")\n  const phone = Option.getOrElse(user.phone, () => \"no phone\")\n  return `${user.name}: ${email}, ${phone}`\n}\n\n// ============================================\n// 5. Use in Effects\n// ============================================\n\nconst findUser = (id: string): Effect.Effect<Option.Option<User>> =>\n  Effect.succeed(\n    id === \"123\"\n      ? Option.some({ id, name: \"Alice\", email: Option.none(), phone: Option.none() })\n      : Option.none()\n  )\n\nconst program = Effect.gen(function* () {\n  const maybeUser = yield* findUser(\"123\")\n\n  if (Option.isSome(maybeUser)) {\n    yield* Effect.log(`Found: ${maybeUser.value.name}`)\n  } else {\n    yield* Effect.log(\"User not found\")\n  }\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Option instead of null/undefined to make missing values explicit and type-safe."
            },
            "created_at": "2026-02-15T21:22:23.773795",
            "updated_at": "2026-02-20T23:09:46.208279"
        },
        {
            "id": "ee629210-b4d1-45cc-b4ca-b1864824b7ea",
            "slug": "transform-effect-values",
            "title": "Transform Effect Values with map and flatMap",
            "summary": "Use Effect.map for synchronous transformations and Effect.flatMap to chain operations that return another Effect.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "map",
                "flatMap",
                "composition",
                "transformation",
                "chaining"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\nconst getUser = (id: number): Effect.Effect<{ id: number; name: string }> =>\n  Effect.succeed({ id, name: \"Paul\" });\n\nconst getPosts = (userId: number): Effect.Effect<{ title: string }[]> =>\n  Effect.succeed([{ title: \"My First Post\" }, { title: \"Second Post\" }]);\n\nconst userPosts = getUser(123).pipe(\n  Effect.flatMap((user) => getPosts(user.id))\n);\n\n// Demonstrate transforming Effect values\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Transform Effect Values Demo ===\");\n\n  // 1. Basic transformation with map\n  yield* Effect.log(\"\\n1. Transform with map:\");\n  const userWithUpperName = yield* getUser(123).pipe(\n    Effect.map((user) => ({ ...user, name: user.name.toUpperCase() }))\n  );\n  yield* Effect.log(\"Transformed user:\", userWithUpperName);\n\n  // 2. Chain effects with flatMap\n  yield* Effect.log(\"\\n2. Chain effects with flatMap:\");\n  const posts = yield* userPosts;\n  yield* Effect.log(\"User posts:\", posts);\n\n  // 3. Transform and combine multiple effects\n  yield* Effect.log(\"\\n3. Transform and combine multiple effects:\");\n  const userWithPosts = yield* getUser(456).pipe(\n    Effect.flatMap((user) =>\n      getPosts(user.id).pipe(\n        Effect.map((posts) => ({\n          user: user.name,\n          postCount: posts.length,\n          titles: posts.map((p) => p.title),\n        }))\n      )\n    )\n  );\n  yield* Effect.log(\"User with posts:\", userWithPosts);\n\n  // 4. Transform with tap for side effects\n  yield* Effect.log(\"\\n4. Transform with tap for side effects:\");\n  const result = yield* getUser(789).pipe(\n    Effect.tap((user) => Effect.log(`Processing user: ${user.name}`)),\n    Effect.map((user) => `Hello, ${user.name}!`)\n  );\n  yield* Effect.log(\"Final result:\", result);\n\n  yield* Effect.log(\"\\n\u2705 All transformations completed successfully!\");\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Transform Effect values with map and flatMap."
            },
            "created_at": "2026-02-15T21:22:14.168182",
            "updated_at": "2026-02-20T23:09:33.829856"
        },
        {
            "id": "17a162cc-925c-4fa8-9b30-17f90f8959f8",
            "slug": "data-exit",
            "title": "Modeling Effect Results with Exit",
            "summary": "Use Exit<E, A> to represent the result of running an Effect, capturing both success and failure (including defects) in a type-safe way.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "Exit",
                "effect",
                "result",
                "error-handling",
                "concurrency",
                "data-type"
            ],
            "examples": [
                {
                    "code": "import { Effect, Exit } from \"effect\";\n\n// Run an Effect and capture its Exit value\nconst program = Effect.succeed(42);\n\nconst runAndCapture = Effect.runPromiseExit(program); // Promise<Exit<never, number>>\n\n// Pattern match on Exit\nrunAndCapture.then((exit) => {\n  if (Exit.isSuccess(exit)) {\n    console.log(\"Success:\", exit.value);\n  } else if (Exit.isFailure(exit)) {\n    console.error(\"Failure:\", exit.cause);\n  }\n});",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Exit to capture the outcome of an Effect, including success, failure, and defects, for robust error handling and coordination."
            },
            "created_at": "2026-02-15T21:22:15.69365",
            "updated_at": "2026-02-20T23:09:34.566982"
        },
        {
            "id": "b159a698-c0a3-47c9-a787-7b747b214ee0",
            "slug": "define-contracts-with-schema",
            "title": "Define Contracts Upfront with Schema",
            "summary": "Use Schema to define the types for your data models and function signatures before writing the implementation, creating clear, type-safe contracts.",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "design",
                "architecture",
                "type-safety",
                "contract-first",
                "data-modeling"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect, Data } from \"effect\";\n\n// Define User schema and type\nconst UserSchema = Schema.Struct({\n  id: Schema.Number,\n  name: Schema.String,\n});\n\ntype User = Schema.Schema.Type<typeof UserSchema>;\n\n// Define error type\nclass UserNotFound extends Data.TaggedError(\"UserNotFound\")<{\n  readonly id: number;\n}> {}\n\n// Create database service implementation\nexport class Database extends Effect.Service<Database>()(\"Database\", {\n  sync: () => ({\n    getUser: (id: number) =>\n      id === 1\n        ? Effect.succeed({ id: 1, name: \"John\" })\n        : Effect.fail(new UserNotFound({ id })),\n  }),\n}) {}\n\n// Create a program that demonstrates schema and error handling\nconst program = Effect.gen(function* () {\n  const db = yield* Database;\n\n  // Try to get an existing user\n  yield* Effect.logInfo(\"Looking up user 1...\");\n  const user1 = yield* db.getUser(1);\n  yield* Effect.logInfo(`Found user: ${JSON.stringify(user1)}`);\n\n  // Try to get a non-existent user\n  yield* Effect.logInfo(\"\\nLooking up user 999...\");\n  yield* Effect.logInfo(\"Attempting to get user 999...\");\n  yield* Effect.gen(function* () {\n    const user = yield* db.getUser(999);\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n  }).pipe(\n    Effect.catchAll((error) => {\n      if (error instanceof UserNotFound) {\n        return Effect.logInfo(`Error: User with id ${error.id} not found`);\n      }\n      return Effect.logInfo(`Unexpected error: ${error}`);\n    })\n  );\n\n  // Try to decode invalid data\n  yield* Effect.logInfo(\"\\nTrying to decode invalid user data...\");\n  const invalidUser = { id: \"not-a-number\", name: 123 } as any;\n  yield* Effect.gen(function* () {\n    const user = yield* Schema.decode(UserSchema)(invalidUser);\n    yield* Effect.logInfo(`Decoded user: ${JSON.stringify(user)}`);\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.logInfo(`Validation failed:\\n${JSON.stringify(error, null, 2)}`)\n    )\n  );\n});\n\n// Run the program\nEffect.runPromise(Effect.provide(program, Database.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Define contracts upfront with schema."
            },
            "created_at": "2026-02-15T21:22:24.106318",
            "updated_at": "2026-02-20T23:09:46.251404"
        },
        {
            "id": "b19245e9-bd20-41d8-8fc2-a0fe0c9a2de6",
            "slug": "transform-data-with-schema",
            "title": "Transform Data During Validation with Schema",
            "summary": "Use Schema.transform to safely convert data from one type to another during the parsing phase, such as from a string to a Date.",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "transform",
                "validation",
                "parsing",
                "data-modeling",
                "coercion"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\";\n\n// Define types for better type safety\ntype RawEvent = {\n  name: string;\n  timestamp: string;\n};\n\ntype ParsedEvent = {\n  name: string;\n  timestamp: Date;\n};\n\n// Define the schema for our event\nconst ApiEventSchema = Schema.Struct({\n  name: Schema.String,\n  timestamp: Schema.String,\n});\n\n// Example input\nconst rawInput: RawEvent = {\n  name: \"User Login\",\n  timestamp: \"2025-06-22T20:08:42.000Z\",\n};\n\n// Parse and transform\nconst program = Effect.gen(function* () {\n  const parsed = yield* Schema.decode(ApiEventSchema)(rawInput);\n  return {\n    name: parsed.name,\n    timestamp: new Date(parsed.timestamp),\n  } as ParsedEvent;\n});\n\nconst programWithLogging = Effect.gen(function* () {\n  try {\n    const event = yield* program;\n    yield* Effect.log(`Event year: ${event.timestamp.getFullYear()}`);\n    yield* Effect.log(`Full event: ${JSON.stringify(event, null, 2)}`);\n    return event;\n  } catch (error) {\n    yield* Effect.logError(`Failed to parse event: ${error}`);\n    throw error;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithLogging);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Schema.transform to safely convert data types during the validation and parsing process."
            },
            "created_at": "2026-02-15T21:22:24.769148",
            "updated_at": "2026-02-20T23:09:46.337555"
        },
        {
            "id": "1843d4c7-c3d8-44a4-8813-58c84fef8fd0",
            "slug": "use-gen-for-business-logic",
            "title": "Use Effect.gen for Business Logic",
            "summary": "Encapsulate sequential business logic, control flow, and dependency access within Effect.gen for improved readability and maintainability.",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "generators",
                "business-logic",
                "control-flow",
                "readability"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Concrete implementations for demonstration\nconst validateUser = (\n  data: any\n): Effect.Effect<{ email: string; password: string }, Error, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Validating user data: ${JSON.stringify(data)}`);\n\n    if (!data.email || !data.password) {\n      return yield* Effect.fail(new Error(\"Email and password are required\"));\n    }\n\n    if (data.password.length < 6) {\n      return yield* Effect.fail(\n        new Error(\"Password must be at least 6 characters\")\n      );\n    }\n\n    yield* Effect.logInfo(\"\u2705 User data validated successfully\");\n    return { email: data.email, password: data.password };\n  });\n\nconst hashPassword = (pw: string): Effect.Effect<string, never, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"Hashing password...\");\n    // Simulate password hashing\n    const timestamp = yield* Effect.sync(() => Date.now());\n    const hashed = `hashed_${pw}_${timestamp}`;\n    yield* Effect.logInfo(\"\u2705 Password hashed successfully\");\n    return hashed;\n  });\n\nconst dbCreateUser = (data: {\n  email: string;\n  password: string;\n}): Effect.Effect<{ id: number; email: string }, never, never> =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Creating user in database: ${data.email}`);\n    // Simulate database operation\n    const user = { id: Math.floor(Math.random() * 1000), email: data.email };\n    yield* Effect.logInfo(`\u2705 User created with ID: ${user.id}`);\n    return user;\n  });\n\nconst createUser = (\n  userData: any\n): Effect.Effect<{ id: number; email: string }, Error, never> =>\n  Effect.gen(function* () {\n    const validated = yield* validateUser(userData);\n    const hashed = yield* hashPassword(validated.password);\n    return yield* dbCreateUser({ ...validated, password: hashed });\n  });\n\n// Demonstrate using Effect.gen for business logic\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Using Effect.gen for Business Logic Demo ===\");\n\n  // Example 1: Successful user creation\n  yield* Effect.logInfo(\"\\n1. Creating a valid user:\");\n  const validUser = yield* createUser({\n    email: \"paul@example.com\",\n    password: \"securepassword123\",\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to create user: ${error.message}`);\n        return { id: -1, email: \"error\" };\n      })\n    )\n  );\n  yield* Effect.logInfo(`Created user: ${JSON.stringify(validUser)}`);\n\n  // Example 2: Invalid user data\n  yield* Effect.logInfo(\"\\n2. Attempting to create user with invalid data:\");\n  const invalidUser = yield* createUser({\n    email: \"invalid@example.com\",\n    password: \"123\", // Too short\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Failed to create user: ${error.message}`);\n        return { id: -1, email: \"error\" };\n      })\n    )\n  );\n  yield* Effect.logInfo(`Result: ${JSON.stringify(invalidUser)}`);\n\n  yield* Effect.logInfo(\"\\n\u2705 Business logic demonstration completed!\");\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.gen for business logic."
            },
            "created_at": "2026-02-15T21:22:24.861671",
            "updated_at": "2026-02-20T23:09:46.374738"
        },
        {
            "id": "4b1f884e-87d2-4891-962d-7b1cf523a3cf",
            "slug": "execute-with-runsync",
            "title": "Execute Synchronous Effects with Effect.runSync",
            "summary": "Use Effect.runSync at the 'end of the world' to execute a purely synchronous Effect and get its value directly.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "execution",
                "runtime",
                "sync",
                "end-of-world"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Simple synchronous program\nconst program1 = Effect.gen(function* () {\n  const n = 10;\n  const result = n * 2;\n  yield* Effect.log(`Simple program result: ${result}`);\n  return result;\n});\n\n// Run simple program\nEffect.runSync(program1);\n\n// Program with logging\nconst program2 = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting calculation...\");\n  const n = yield* Effect.sync(() => 10);\n  yield* Effect.logInfo(`Got number: ${n}`);\n  const result = yield* Effect.sync(() => n * 2);\n  yield* Effect.logInfo(`Result: ${result}`);\n  return result;\n});\n\n// Run with logging\nEffect.runSync(program2);\n\n// Program with error handling\nconst program3 = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting division...\");\n  const n = yield* Effect.sync(() => 10);\n  const divisor = yield* Effect.sync(() => 0);\n\n  yield* Effect.logInfo(`Attempting to divide ${n} by ${divisor}...`);\n  return yield* Effect.try({\n    try: () => {\n      if (divisor === 0) throw new Error(\"Cannot divide by zero\");\n      return n / divisor;\n    },\n    catch: (error) => {\n      if (error instanceof Error) {\n        return error;\n      }\n      return new Error(\"Unknown error occurred\");\n    },\n  });\n}).pipe(\n  Effect.catchAll((error) => Effect.logInfo(`Error occurred: ${error.message}`))\n);\n\n// Run with error handling\nEffect.runSync(program3);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Execute synchronous effects with Effect.runSync."
            },
            "created_at": "2026-02-16T21:38:55.562113",
            "updated_at": "2026-02-20T23:09:34.701998"
        },
        {
            "id": "ac04b02e-3c59-44df-bd06-34a8df22c7b7",
            "slug": "api-openapi",
            "title": "Generate OpenAPI Documentation",
            "summary": "Auto-generate OpenAPI/Swagger documentation from your Effect HTTP API definitions.",
            "skill_level": "advanced",
            "category": "building-apis",
            "difficulty": "advanced",
            "tags": [
                "building-apis",
                "openapi",
                "documentation",
                "swagger"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema } from \"effect\"\nimport {\n  HttpApi,\n  HttpApiBuilder,\n  HttpApiEndpoint,\n  HttpApiGroup,\n  HttpApiSwagger,\n  OpenApi,\n} from \"@effect/platform\"\n\n// ============================================\n// 1. Define schemas for request/response\n// ============================================\n\nconst UserSchema = Schema.Struct({\n  id: Schema.String,\n  email: Schema.String.pipe(Schema.pattern(/@/)),\n  name: Schema.String,\n  createdAt: Schema.DateFromString,\n})\n\nconst CreateUserSchema = Schema.Struct({\n  email: Schema.String.pipe(Schema.pattern(/@/)),\n  name: Schema.String,\n})\n\nconst UserListSchema = Schema.Array(UserSchema)\n\nconst ErrorSchema = Schema.Struct({\n  error: Schema.String,\n  code: Schema.String,\n})\n\n// ============================================\n// 2. Define API endpoints with schemas\n// ============================================\n\nconst usersApi = HttpApiGroup.make(\"users\")\n  .pipe(\n    HttpApiGroup.add(\n      HttpApiEndpoint.get(\"getUsers\", \"/users\")\n        .pipe(\n          HttpApiEndpoint.setSuccess(UserListSchema),\n          HttpApiEndpoint.addError(ErrorSchema, { status: 500 })\n        )\n    ),\n    HttpApiGroup.add(\n      HttpApiEndpoint.get(\"getUser\", \"/users/:id\")\n        .pipe(\n          HttpApiEndpoint.setPath(Schema.Struct({\n            id: Schema.String,\n          })),\n          HttpApiEndpoint.setSuccess(UserSchema),\n          HttpApiEndpoint.addError(ErrorSchema, { status: 404 }),\n          HttpApiEndpoint.addError(ErrorSchema, { status: 500 })\n        )\n    ),\n    HttpApiGroup.add(\n      HttpApiEndpoint.post(\"createUser\", \"/users\")\n        .pipe(\n          HttpApiEndpoint.setPayload(CreateUserSchema),\n          HttpApiEndpoint.setSuccess(UserSchema, { status: 201 }),\n          HttpApiEndpoint.addError(ErrorSchema, { status: 400 }),\n          HttpApiEndpoint.addError(ErrorSchema, { status: 500 })\n        )\n    ),\n    HttpApiGroup.add(\n      HttpApiEndpoint.del(\"deleteUser\", \"/users/:id\")\n        .pipe(\n          HttpApiEndpoint.setPath(Schema.Struct({\n            id: Schema.String,\n          })),\n          HttpApiEndpoint.setSuccess(Schema.Void, { status: 204 }),\n          HttpApiEndpoint.addError(ErrorSchema, { status: 404 }),\n          HttpApiEndpoint.addError(ErrorSchema, { status: 500 })\n        )\n    )\n  )\n\n// ============================================\n// 3. Create the API definition\n// ============================================\n\nconst api = HttpApi.make(\"My API\")\n  .pipe(\n    HttpApi.addGroup(usersApi),\n    OpenApi.annotate({\n      title: \"My Effect API\",\n      version: \"1.0.0\",\n      description: \"A sample API built with Effect\",\n    })\n  )\n\n// ============================================\n// 4. Implement the handlers\n// ============================================\n\nconst usersHandlers = HttpApiBuilder.group(api, \"users\", (handlers) =>\n  handlers\n    .pipe(\n      HttpApiBuilder.handle(\"getUsers\", () =>\n        Effect.succeed([\n          {\n            id: \"1\",\n            email: \"alice@example.com\",\n            name: \"Alice\",\n            createdAt: new Date(),\n          },\n        ])\n      ),\n      HttpApiBuilder.handle(\"getUser\", ({ path }) =>\n        Effect.gen(function* () {\n          if (path.id === \"not-found\") {\n            return yield* Effect.fail({ error: \"User not found\", code: \"NOT_FOUND\" })\n          }\n          return {\n            id: path.id,\n            email: \"user@example.com\",\n            name: \"User\",\n            createdAt: new Date(),\n          }\n        })\n      ),\n      HttpApiBuilder.handle(\"createUser\", ({ payload }) =>\n        Effect.succeed({\n          id: crypto.randomUUID(),\n          email: payload.email,\n          name: payload.name,\n          createdAt: new Date(),\n        })\n      ),\n      HttpApiBuilder.handle(\"deleteUser\", ({ path }) =>\n        Effect.gen(function* () {\n          if (path.id === \"not-found\") {\n            return yield* Effect.fail({ error: \"User not found\", code: \"NOT_FOUND\" })\n          }\n          yield* Effect.log(`Deleted user ${path.id}`)\n        })\n      )\n    )\n)\n\n// ============================================\n// 5. Build the server with Swagger UI\n// ============================================\n\nconst MyApiLive = HttpApiBuilder.api(api).pipe(\n  Layer.provide(usersHandlers)\n)\n\nconst ServerLive = HttpApiBuilder.serve().pipe(\n  // Add Swagger UI at /docs\n  Layer.provide(HttpApiSwagger.layer({ path: \"/docs\" })),\n  Layer.provide(MyApiLive),\n  Layer.provide(NodeHttpServer.layer({ port: 3000 }))\n)\n\n// ============================================\n// 6. Export OpenAPI spec as JSON\n// ============================================\n\nconst openApiSpec = OpenApi.fromApi(api)\n\n// Save to file for external tools\nimport { NodeFileSystem } from \"@effect/platform-node\"\n\nconst saveSpec = Effect.gen(function* () {\n  const fs = yield* FileSystem.FileSystem\n  yield* fs.writeFileString(\n    \"openapi.json\",\n    JSON.stringify(openApiSpec, null, 2)\n  )\n  yield* Effect.log(\"OpenAPI spec saved to openapi.json\")\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Schema definitions to automatically generate OpenAPI documentation for your API."
            },
            "created_at": "2026-02-15T21:22:26.087558",
            "updated_at": "2026-02-20T23:09:35.800142"
        },
        {
            "id": "902efac6-70d0-472a-baca-d0259b2c8e7f",
            "slug": "api-middleware",
            "title": "Compose API Middleware",
            "summary": "Build reusable middleware for logging, authentication, validation, and more.",
            "skill_level": "intermediate",
            "category": "building-apis",
            "difficulty": "intermediate",
            "tags": [
                "building-apis",
                "middleware",
                "composition"
            ],
            "examples": [
                {
                    "code": "import { Effect, Context, Layer, Duration } from \"effect\"\nimport { HttpServerRequest, HttpServerResponse } from \"@effect/platform\"\n\n// ============================================\n// 1. Define middleware type\n// ============================================\n\ntype Handler<E, R> = Effect.Effect<HttpServerResponse.HttpServerResponse, E, R>\n\ntype Middleware<E1, R1, E2 = E1, R2 = R1> = <E extends E1, R extends R1>(\n  handler: Handler<E, R>\n) => Handler<E | E2, R | R2>\n\n// ============================================\n// 2. Logging middleware\n// ============================================\n\nconst withLogging: Middleware<never, HttpServerRequest.HttpServerRequest> =\n  (handler) =>\n    Effect.gen(function* () {\n      const request = yield* HttpServerRequest.HttpServerRequest\n      const startTime = Date.now()\n\n      yield* Effect.log(`\u2192 ${request.method} ${request.url}`)\n\n      const response = yield* handler\n\n      const duration = Date.now() - startTime\n      yield* Effect.log(`\u2190 ${response.status} (${duration}ms)`)\n\n      return response\n    })\n\n// ============================================\n// 3. Timing middleware (adds header)\n// ============================================\n\nconst withTiming: Middleware<never, never> = (handler) =>\n  Effect.gen(function* () {\n    const startTime = Date.now()\n    const response = yield* handler\n    const duration = Date.now() - startTime\n\n    return HttpServerResponse.setHeader(\n      response,\n      \"X-Response-Time\",\n      `${duration}ms`\n    )\n  })\n\n// ============================================\n// 4. Error handling middleware\n// ============================================\n\nconst withErrorHandling: Middleware<unknown, never, never> = (handler) =>\n  handler.pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Unhandled error: ${error}`)\n\n        return HttpServerResponse.json(\n          { error: \"Internal Server Error\" },\n          { status: 500 }\n        )\n      })\n    )\n  )\n\n// ============================================\n// 5. Request ID middleware\n// ============================================\n\nclass RequestId extends Context.Tag(\"RequestId\")<RequestId, string>() {}\n\nconst withRequestId: Middleware<never, never, never, RequestId> = (handler) =>\n  Effect.gen(function* () {\n    const requestId = crypto.randomUUID()\n\n    const response = yield* handler.pipe(\n      Effect.provideService(RequestId, requestId)\n    )\n\n    return HttpServerResponse.setHeader(response, \"X-Request-Id\", requestId)\n  })\n\n// ============================================\n// 6. Timeout middleware\n// ============================================\n\nconst withTimeout = (duration: Duration.DurationInput): Middleware<never, never> =>\n  (handler) =>\n    handler.pipe(\n      Effect.timeout(duration),\n      Effect.catchTag(\"TimeoutException\", () =>\n        Effect.succeed(\n          HttpServerResponse.json(\n            { error: \"Request timeout\" },\n            { status: 504 }\n          )\n        )\n      )\n    )\n\n// ============================================\n// 7. CORS middleware (see separate pattern)\n// ============================================\n\nconst withCORS = (origin: string): Middleware<never, never> => (handler) =>\n  Effect.gen(function* () {\n    const response = yield* handler\n\n    return response.pipe(\n      HttpServerResponse.setHeader(\"Access-Control-Allow-Origin\", origin),\n      HttpServerResponse.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\"),\n      HttpServerResponse.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n    )\n  })\n\n// ============================================\n// 8. Compose middleware\n// ============================================\n\nconst applyMiddleware = <E, R>(handler: Handler<E, R>) =>\n  handler.pipe(\n    withLogging,\n    withTiming,\n    withRequestId,\n    withTimeout(\"30 seconds\"),\n    withCORS(\"*\"),\n    withErrorHandling\n  )\n\n// ============================================\n// 9. Usage\n// ============================================\n\nconst myHandler = Effect.gen(function* () {\n  const requestId = yield* RequestId\n  yield* Effect.log(`Processing request ${requestId}`)\n\n  return HttpServerResponse.json({ message: \"Hello!\" })\n})\n\nconst protectedHandler = applyMiddleware(myHandler)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect composition to build a middleware pipeline that processes requests."
            },
            "created_at": "2026-02-15T21:22:25.454544",
            "updated_at": "2026-02-20T23:09:35.900177"
        },
        {
            "id": "0ce3f56d-ec70-4998-abf5-0175fae93069",
            "slug": "handle-api-errors",
            "title": "Handle API Errors",
            "summary": "Translate application-specific errors from the Effect failure channel into meaningful HTTP error responses.",
            "skill_level": "intermediate",
            "category": "building-apis",
            "difficulty": "intermediate",
            "tags": [
                "http",
                "server",
                "error-handling",
                "api",
                "data"
            ],
            "examples": [
                {
                    "code": "import { Cause, Data, Effect } from \"effect\";\n\n// Define our domain types\nexport interface User {\n  readonly id: string;\n  readonly name: string;\n  readonly email: string;\n  readonly role: \"admin\" | \"user\";\n}\n\n// Define specific, typed errors for our domain\nexport class UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\")<{\n  readonly id: string;\n}> {}\n\nexport class InvalidIdError extends Data.TaggedError(\"InvalidIdError\")<{\n  readonly id: string;\n  readonly reason: string;\n}> {}\n\nexport class UnauthorizedError extends Data.TaggedError(\"UnauthorizedError\")<{\n  readonly action: string;\n  readonly role: string;\n}> {}\n\n// Define error handler service\nexport class ErrorHandlerService extends Effect.Service<ErrorHandlerService>()(\n  \"ErrorHandlerService\",\n  {\n    sync: () => ({\n      // Handle API errors with proper logging\n      handleApiError: <E>(error: E): Effect.Effect<ApiResponse, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logError(`API Error: ${JSON.stringify(error)}`);\n\n          if (error instanceof UserNotFoundError) {\n            return {\n              error: \"Not Found\",\n              message: `User ${error.id} not found`,\n            };\n          }\n          if (error instanceof InvalidIdError) {\n            return { error: \"Bad Request\", message: error.reason };\n          }\n          if (error instanceof UnauthorizedError) {\n            return {\n              error: \"Unauthorized\",\n              message: `${error.role} cannot ${error.action}`,\n            };\n          }\n\n          return {\n            error: \"Internal Server Error\",\n            message: \"An unexpected error occurred\",\n          };\n        }),\n\n      // Handle unexpected errors\n      handleUnexpectedError: (\n        cause: Cause.Cause<unknown>\n      ): Effect.Effect<void, never, never> =>\n        Effect.gen(function* () {\n          yield* Effect.logError(\"Unexpected error occurred\");\n\n          if (Cause.isDie(cause)) {\n            const defect = Cause.failureOption(cause);\n            if (defect._tag === \"Some\") {\n              const error = defect.value as Error;\n              yield* Effect.logError(`Defect: ${error.message}`);\n              yield* Effect.logError(\n                `Stack: ${error.stack?.split(\"\\n\")[1]?.trim() ?? \"N/A\"}`\n              );\n            }\n          }\n\n          return Effect.succeed(void 0);\n        }),\n    }),\n  }\n) {}\n\n// Define UserRepository service\nexport class UserRepository extends Effect.Service<UserRepository>()(\n  \"UserRepository\",\n  {\n    sync: () => {\n      const users = new Map<string, User>([\n        [\n          \"user_123\",\n          {\n            id: \"user_123\",\n            name: \"Paul\",\n            email: \"paul@example.com\",\n            role: \"admin\",\n          },\n        ],\n        [\n          \"user_456\",\n          {\n            id: \"user_456\",\n            name: \"Alice\",\n            email: \"alice@example.com\",\n            role: \"user\",\n          },\n        ],\n      ]);\n\n      return {\n        // Get user by ID with proper error handling\n        getUser: (\n          id: string\n        ): Effect.Effect<User, UserNotFoundError | InvalidIdError> =>\n          Effect.gen(function* () {\n            yield* Effect.logInfo(`Attempting to get user with id: ${id}`);\n\n            // Validate ID format\n            if (!id.match(/^user_\\d+$/)) {\n              yield* Effect.logWarning(`Invalid user ID format: ${id}`);\n              return yield* Effect.fail(\n                new InvalidIdError({\n                  id,\n                  reason: \"ID must be in format user_<number>\",\n                })\n              );\n            }\n\n            const user = users.get(id);\n            if (user === undefined) {\n              yield* Effect.logWarning(`User not found with id: ${id}`);\n              return yield* Effect.fail(new UserNotFoundError({ id }));\n            }\n\n            yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n            return user;\n          }),\n\n        // Check if user has required role\n        checkRole: (\n          user: User,\n          requiredRole: \"admin\" | \"user\"\n        ): Effect.Effect<void, UnauthorizedError> =>\n          Effect.gen(function* () {\n            yield* Effect.logInfo(\n              `Checking if user ${user.id} has role: ${requiredRole}`\n            );\n\n            if (user.role !== requiredRole && user.role !== \"admin\") {\n              yield* Effect.logWarning(\n                `User ${user.id} with role ${user.role} cannot access ${requiredRole} resources`\n              );\n              return yield* Effect.fail(\n                new UnauthorizedError({\n                  action: \"access_user\",\n                  role: user.role,\n                })\n              );\n            }\n\n            yield* Effect.logInfo(\n              `User ${user.id} has required role: ${user.role}`\n            );\n            return Effect.succeed(void 0);\n          }),\n      };\n    },\n  }\n) {}\n\ninterface ApiResponse {\n  readonly error?: string;\n  readonly message?: string;\n  readonly data?: User;\n}\n\n// Create routes with proper error handling\nconst createRoutes = () =>\n  Effect.gen(function* () {\n    const repo = yield* UserRepository;\n    const errorHandler = yield* ErrorHandlerService;\n\n    yield* Effect.logInfo(\"=== Processing API request ===\");\n\n    // Test different scenarios\n    for (const userId of [\"user_123\", \"user_456\", \"invalid_id\", \"user_789\"]) {\n      yield* Effect.logInfo(`\\n--- Testing user ID: ${userId} ---`);\n\n      const response = yield* repo.getUser(userId).pipe(\n        Effect.map((user) => ({\n          data: {\n            ...user,\n            email: user.role === \"admin\" ? user.email : \"[hidden]\",\n          },\n        })),\n        Effect.catchAll((error) => errorHandler.handleApiError(error))\n      );\n\n      yield* Effect.logInfo(`Response: ${JSON.stringify(response)}`);\n    }\n\n    // Test role checking\n    const adminUser = yield* repo.getUser(\"user_123\");\n    const regularUser = yield* repo.getUser(\"user_456\");\n\n    yield* Effect.logInfo(\"\\n=== Testing role checks ===\");\n\n    yield* repo.checkRole(adminUser, \"admin\").pipe(\n      Effect.tap(() => Effect.logInfo(\"Admin access successful\")),\n      Effect.catchAll((error) => errorHandler.handleApiError(error))\n    );\n\n    yield* repo.checkRole(regularUser, \"admin\").pipe(\n      Effect.tap(() => Effect.logInfo(\"User admin access successful\")),\n      Effect.catchAll((error) => errorHandler.handleApiError(error))\n    );\n\n    return { message: \"Tests completed successfully\" };\n  });\n\n// Run the program with all services\nEffect.runPromise(\n  Effect.provide(\n    Effect.provide(createRoutes(), ErrorHandlerService.Default),\n    UserRepository.Default\n  )\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Model application errors as typed classes and use Http.server.serveOptions to map them to specific HTTP responses."
            },
            "created_at": "2026-02-15T21:22:25.650051",
            "updated_at": "2026-02-20T23:09:35.968798"
        },
        {
            "id": "bba8e688-d415-40be-81f9-1000711f61e0",
            "slug": "send-json-response",
            "title": "Send a JSON Response",
            "summary": "Create and send a structured JSON response with the correct headers and status code.",
            "skill_level": "beginner",
            "category": "building-apis",
            "difficulty": "beginner",
            "tags": [
                "http",
                "server",
                "response",
                "json",
                "api"
            ],
            "examples": [
                {
                    "code": "import { Effect, Context, Duration, Layer } from \"effect\";\nimport { NodeContext, NodeHttpServer } from \"@effect/platform-node\";\nimport { createServer } from \"node:http\";\n\nconst PORT = 3459; // Changed port to avoid conflicts\n\n// Define HTTP Server service\nclass JsonServer extends Effect.Service<JsonServer>()(\"JsonServer\", {\n  sync: () => ({\n    handleRequest: () =>\n      Effect.succeed({\n        status: 200,\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          message: \"Hello, JSON!\",\n          timestamp: new Date().toISOString(),\n        }),\n      }),\n  }),\n}) {}\n\n// Create and run the server\nconst program = Effect.gen(function* () {\n  const jsonServer = yield* JsonServer;\n\n  // Create and start HTTP server\n  const server = createServer((req, res) => {\n    const requestHandler = Effect.gen(function* () {\n      try {\n        const response = yield* jsonServer.handleRequest();\n        res.writeHead(response.status, response.headers);\n        res.end(response.body);\n        // Log the response for demonstration\n        yield* Effect.logInfo(`Sent JSON response: ${response.body}`);\n      } catch (error: any) {\n        res.writeHead(500, { \"Content-Type\": \"application/json\" });\n        res.end(JSON.stringify({ error: \"Internal Server Error\" }));\n        yield* Effect.logError(`Request error: ${error.message}`);\n      }\n    });\n\n    Effect.runPromise(requestHandler);\n  });\n\n  // Start server with error handling\n  yield* Effect.async<void, Error>((resume) => {\n    server.on(\"error\", (error: NodeJS.ErrnoException) => {\n      if (error.code === \"EADDRINUSE\") {\n        resume(Effect.fail(new Error(`Port ${PORT} is already in use`)));\n      } else {\n        resume(Effect.fail(error));\n      }\n    });\n\n    server.listen(PORT, () => {\n      resume(Effect.succeed(void 0));\n    });\n  });\n\n  yield* Effect.logInfo(`Server running at http://localhost:${PORT}`);\n  yield* Effect.logInfo(\"Try: curl http://localhost:3459\");\n\n  // Run for a short time to demonstrate\n  yield* Effect.sleep(Duration.seconds(3));\n\n  // Shutdown gracefully\n  yield* Effect.sync(() => server.close());\n  yield* Effect.logInfo(\"Server shutdown complete\");\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Server error: ${error.message}`);\n      return error;\n    })\n  ),\n  // Merge layers and provide them in a single call to ensure proper lifecycle management\n  Effect.provide(Layer.merge(JsonServer.Default, NodeContext.layer))\n);\n\n// Run the program\n// Use Effect.runFork for server applications that shouldn't resolve the promise\nEffect.runPromise(\n  program.pipe(\n    // Ensure the Effect has no remaining context requirements for runPromise\n    Effect.map(() => undefined)\n  )\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Http.response.json to automatically serialize data structures into a JSON response."
            },
            "created_at": "2026-02-15T21:22:25.285356",
            "updated_at": "2026-02-20T23:09:36.015182"
        },
        {
            "id": "7c0df20d-3b75-44a2-9190-99f0d9c1273a",
            "slug": "validate-request-body",
            "title": "Validate Request Body",
            "summary": "Safely parse and validate an incoming JSON request body against a predefined Schema.",
            "skill_level": "intermediate",
            "category": "building-apis",
            "difficulty": "intermediate",
            "tags": [
                "http",
                "server",
                "schema",
                "validation",
                "api",
                "post",
                "body"
            ],
            "examples": [
                {
                    "code": "import { Duration, Effect } from \"effect\";\nimport * as S from \"effect/Schema\";\nimport { createServer, IncomingMessage, ServerResponse } from \"http\";\n\n// Define user schema\nconst UserSchema = S.Struct({\n  name: S.String,\n  email: S.String.pipe(S.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)),\n});\ntype User = S.Schema.Type<typeof UserSchema>;\n\n// Define user service interface\ninterface UserServiceInterface {\n  readonly validateUser: (data: unknown) => Effect.Effect<User, Error, never>;\n}\n\n// Define user service\nclass UserService extends Effect.Service<UserService>()(\"UserService\", {\n  sync: () => ({\n    validateUser: (data: unknown) => S.decodeUnknown(UserSchema)(data),\n  }),\n}) {}\n\n// Define HTTP server service interface\ninterface HttpServerInterface {\n  readonly handleRequest: (\n    request: IncomingMessage,\n    response: ServerResponse\n  ) => Effect.Effect<void, Error, never>;\n  readonly start: () => Effect.Effect<void, Error, never>;\n}\n\n// Define HTTP server service\nclass HttpServer extends Effect.Service<HttpServer>()(\"HttpServer\", {\n  // Define effect-based implementation that uses dependencies\n  effect: Effect.gen(function* () {\n    const userService = yield* UserService;\n\n    return {\n      handleRequest: (request: IncomingMessage, response: ServerResponse) =>\n        Effect.gen(function* () {\n          // Only handle POST /users\n          if (request.method !== \"POST\" || request.url !== \"/users\") {\n            response.writeHead(404, { \"Content-Type\": \"application/json\" });\n            response.end(JSON.stringify({ error: \"Not Found\" }));\n            return;\n          }\n\n          try {\n            // Read request body\n            const body = yield* Effect.async<unknown, Error>((resume) => {\n              let data = \"\";\n              request.on(\"data\", (chunk) => {\n                data += chunk;\n              });\n              request.on(\"end\", () => {\n                try {\n                  resume(Effect.succeed(JSON.parse(data)));\n                } catch (e) {\n                  resume(\n                    Effect.fail(e instanceof Error ? e : new Error(String(e)))\n                  );\n                }\n              });\n              request.on(\"error\", (e) =>\n                resume(\n                  Effect.fail(e instanceof Error ? e : new Error(String(e)))\n                )\n              );\n            });\n\n            // Validate body against schema\n            const user = yield* userService.validateUser(body);\n\n            response.writeHead(200, { \"Content-Type\": \"application/json\" });\n            response.end(\n              JSON.stringify({\n                message: `Successfully created user: ${user.name}`,\n              })\n            );\n          } catch (error) {\n            response.writeHead(400, { \"Content-Type\": \"application/json\" });\n            response.end(JSON.stringify({ error: String(error) }));\n          }\n        }),\n\n      start: function (this: HttpServer) {\n        const self = this;\n        return Effect.gen(function* () {\n          // Create HTTP server\n          const server = createServer((req, res) =>\n            Effect.runFork(self.handleRequest(req, res))\n          );\n\n          // Add cleanup finalizer\n          yield* Effect.addFinalizer(() =>\n            Effect.gen(function* () {\n              yield* Effect.sync(() => server.close());\n              yield* Effect.logInfo(\"Server shut down\");\n            })\n          );\n\n          // Start server\n          yield* Effect.async<void, Error>((resume) => {\n            server.on(\"error\", (error) => resume(Effect.fail(error)));\n            server.listen(3456, () => {\n              Effect.runFork(\n                Effect.logInfo(\"Server running at http://localhost:3456/\")\n              );\n              resume(Effect.succeed(void 0));\n            });\n          });\n\n          // Run for demonstration period\n          yield* Effect.sleep(Duration.seconds(3));\n          yield* Effect.logInfo(\"Demo completed - shutting down server\");\n        });\n      },\n    };\n  }),\n  // Specify dependencies\n  dependencies: [UserService.Default],\n}) {}\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const server = yield* HttpServer;\n\n  yield* Effect.logInfo(\"Starting HTTP server...\");\n\n  yield* server.start().pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logError(`Server error: ${error}`);\n        return yield* Effect.fail(error);\n      })\n    )\n  );\n}).pipe(\n  Effect.scoped // Ensure server is cleaned up\n);\n\n// Run the server\nEffect.runFork(Effect.provide(program, HttpServer.Default));\n\n/*\nTo test:\n- POST http://localhost:3456/users with body {\"name\": \"Paul\", \"email\": \"paul@effect.com\"}\n  -> Returns 200 OK with message \"Successfully created user: Paul\"\n\n- POST http://localhost:3456/users with body {\"name\": \"Paul\"}\n  -> Returns 400 Bad Request with error message about missing email field\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Http.request.schemaBodyJson with a Schema to automatically parse and validate request bodies."
            },
            "created_at": "2026-02-15T21:22:26.002099",
            "updated_at": "2026-02-20T23:09:36.14454"
        },
        {
            "id": "ad0d9e23-44dd-4699-acf4-91495ec5cf8d",
            "slug": "api-rate-limiting",
            "title": "Add Rate Limiting to APIs",
            "summary": "Protect your API from abuse by limiting request rates per client.",
            "skill_level": "intermediate",
            "category": "building-apis",
            "difficulty": "intermediate",
            "tags": [
                "building-apis",
                "rate-limiting",
                "security",
                "performance"
            ],
            "examples": [
                {
                    "code": "import { Effect, Context, Layer, Ref, HashMap, Data, Duration } from \"effect\"\nimport { HttpServerRequest, HttpServerResponse } from \"@effect/platform\"\n\n// ============================================\n// 1. Define rate limit types\n// ============================================\n\ninterface RateLimitConfig {\n  readonly maxRequests: number\n  readonly windowMs: number\n}\n\ninterface RateLimitState {\n  readonly count: number\n  readonly resetAt: number\n}\n\nclass RateLimitExceededError extends Data.TaggedError(\"RateLimitExceededError\")<{\n  readonly retryAfter: number\n  readonly limit: number\n}> {}\n\n// ============================================\n// 2. Rate limiter service\n// ============================================\n\ninterface RateLimiter {\n  readonly check: (key: string) => Effect.Effect<void, RateLimitExceededError>\n  readonly getStatus: (key: string) => Effect.Effect<{\n    remaining: number\n    resetAt: number\n  }>\n}\n\nclass RateLimiterService extends Context.Tag(\"RateLimiter\")<\n  RateLimiterService,\n  RateLimiter\n>() {}\n\n// ============================================\n// 3. In-memory rate limiter implementation\n// ============================================\n\nconst makeRateLimiter = (config: RateLimitConfig) =>\n  Effect.gen(function* () {\n    const state = yield* Ref.make(HashMap.empty<string, RateLimitState>())\n\n    const getOrCreateState = (key: string, now: number) =>\n      Ref.modify(state, (map) => {\n        const existing = HashMap.get(map, key)\n\n        if (existing._tag === \"Some\") {\n          // Check if window expired\n          if (now >= existing.value.resetAt) {\n            // Start new window\n            const newState: RateLimitState = {\n              count: 0,\n              resetAt: now + config.windowMs,\n            }\n            return [newState, HashMap.set(map, key, newState)]\n          }\n          return [existing.value, map]\n        }\n\n        // Create new entry\n        const newState: RateLimitState = {\n          count: 0,\n          resetAt: now + config.windowMs,\n        }\n        return [newState, HashMap.set(map, key, newState)]\n      })\n\n    const incrementCount = (key: string) =>\n      Ref.modify(state, (map) => {\n        const existing = HashMap.get(map, key)\n        if (existing._tag === \"Some\") {\n          const updated = { ...existing.value, count: existing.value.count + 1 }\n          return [updated.count, HashMap.set(map, key, updated)]\n        }\n        return [1, map]\n      })\n\n    const limiter: RateLimiter = {\n      check: (key) =>\n        Effect.gen(function* () {\n          const now = Date.now()\n          const currentState = yield* getOrCreateState(key, now)\n\n          if (currentState.count >= config.maxRequests) {\n            const retryAfter = Math.ceil((currentState.resetAt - now) / 1000)\n            return yield* Effect.fail(\n              new RateLimitExceededError({\n                retryAfter,\n                limit: config.maxRequests,\n              })\n            )\n          }\n\n          yield* incrementCount(key)\n        }),\n\n      getStatus: (key) =>\n        Effect.gen(function* () {\n          const now = Date.now()\n          const currentState = yield* getOrCreateState(key, now)\n          return {\n            remaining: Math.max(0, config.maxRequests - currentState.count),\n            resetAt: currentState.resetAt,\n          }\n        }),\n    }\n\n    return limiter\n  })\n\n// ============================================\n// 4. Rate limit middleware\n// ============================================\n\nconst withRateLimit = <A, E, R>(\n  handler: Effect.Effect<A, E, R>\n): Effect.Effect<\n  A | HttpServerResponse.HttpServerResponse,\n  E,\n  R | RateLimiterService | HttpServerRequest.HttpServerRequest\n> =>\n  Effect.gen(function* () {\n    const request = yield* HttpServerRequest.HttpServerRequest\n    const rateLimiter = yield* RateLimiterService\n\n    // Use IP address as key (in production, might use user ID or API key)\n    const clientKey = request.headers[\"x-forwarded-for\"] || \"unknown\"\n\n    const result = yield* rateLimiter.check(clientKey).pipe(\n      Effect.matchEffect({\n        onFailure: (error) =>\n          Effect.succeed(\n            HttpServerResponse.json(\n              {\n                error: \"Rate limit exceeded\",\n                retryAfter: error.retryAfter,\n              },\n              {\n                status: 429,\n                headers: {\n                  \"Retry-After\": String(error.retryAfter),\n                  \"X-RateLimit-Limit\": String(error.limit),\n                  \"X-RateLimit-Remaining\": \"0\",\n                },\n              }\n            )\n          ),\n        onSuccess: () => handler,\n      })\n    )\n\n    return result\n  })\n\n// ============================================\n// 5. Usage example\n// ============================================\n\nconst RateLimiterLive = Layer.effect(\n  RateLimiterService,\n  makeRateLimiter({\n    maxRequests: 100,      // 100 requests\n    windowMs: 60 * 1000,   // per minute\n  })\n)\n\nconst apiEndpoint = withRateLimit(\n  Effect.gen(function* () {\n    // Your actual handler logic\n    return HttpServerResponse.json({ data: \"Success!\" })\n  })\n)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use a rate limiter service to enforce request quotas per client."
            },
            "created_at": "2026-02-15T21:22:25.369927",
            "updated_at": "2026-02-20T23:09:36.183803"
        },
        {
            "id": "7ffa93f4-e8f7-42aa-86dc-e4a288e00234",
            "slug": "understand-layers-for-dependency-injection",
            "title": "Understand Layers for Dependency Injection",
            "summary": "A Layer is a blueprint that describes how to build a service, detailing its own requirements and any potential errors during its construction.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "layer",
                "dependency-injection",
                "architecture",
                "service",
                "di"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Define the Logger service with a default implementation\nexport class Logger extends Effect.Service<Logger>()(\"Logger\", {\n  // Provide a synchronous implementation\n  sync: () => ({\n    log: (msg: string) => Effect.log(`LOG: ${msg}`),\n  }),\n}) {}\n\n// Define the Notifier service that depends on Logger\nexport class Notifier extends Effect.Service<Notifier>()(\"Notifier\", {\n  // Provide an implementation that requires Logger\n  effect: Effect.gen(function* () {\n    const logger = yield* Logger;\n    return {\n      notify: (msg: string) => logger.log(`Notifying: ${msg}`),\n    };\n  }),\n  // Specify dependencies\n  dependencies: [Logger.Default],\n}) {}\n\n// Create a program that uses both services\nconst program = Effect.gen(function* () {\n  const notifier = yield* Notifier;\n  yield* notifier.notify(\"Hello, World!\");\n});\n\n// Run the program with the default implementations\nEffect.runPromise(Effect.provide(program, Notifier.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Understand that a Layer is a blueprint describing how to construct a service and its dependencies."
            },
            "created_at": "2026-02-15T21:22:16.441262",
            "updated_at": "2026-02-20T23:09:34.067682"
        },
        {
            "id": "d29f16e7-a1be-47cc-aba5-b5e83a24dcff",
            "slug": "pipeline-backpressure",
            "title": "Implement Backpressure in Pipelines",
            "summary": "Control data flow rates to prevent overwhelming slow consumers.",
            "skill_level": "advanced",
            "category": "building-data-pipelines",
            "difficulty": "advanced",
            "tags": [
                "data-pipelines",
                "backpressure",
                "flow-control",
                "streams"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Schedule, Duration, Queue, Chunk } from \"effect\"\n\n// ============================================\n// 1. Stream with natural backpressure\n// ============================================\n\n// Streams have built-in backpressure - consumers pull data\nconst fastProducer = Stream.fromIterable(Array.from({ length: 1000 }, (_, i) => i))\n\nconst slowConsumer = fastProducer.pipe(\n  Stream.tap((n) =>\n    Effect.gen(function* () {\n      yield* Effect.sleep(\"10 millis\")  // Slow processing\n      yield* Effect.log(`Processed: ${n}`)\n    })\n  ),\n  Stream.runDrain\n)\n\n// Producer automatically slows down to match consumer\n\n// ============================================\n// 2. Explicit buffer with drop strategy\n// ============================================\n\nconst bufferedStream = (source: Stream.Stream<number>) =>\n  source.pipe(\n    // Buffer up to 100 items, drop oldest when full\n    Stream.buffer({ capacity: 100, strategy: \"dropping\" })\n  )\n\n// ============================================\n// 3. Throttling - limit rate\n// ============================================\n\nconst throttledStream = (source: Stream.Stream<number>) =>\n  source.pipe(\n    // Process at most 10 items per second\n    Stream.throttle({\n      cost: () => 1,\n      units: 10,\n      duration: \"1 second\",\n      strategy: \"enforce\",\n    })\n  )\n\n// ============================================\n// 4. Debounce - wait for quiet period\n// ============================================\n\nconst debouncedStream = (source: Stream.Stream<number>) =>\n  source.pipe(\n    // Wait 100ms of no new items before emitting\n    Stream.debounce(\"100 millis\")\n  )\n\n// ============================================\n// 5. Bounded queue for producer-consumer\n// ============================================\n\nconst boundedQueueExample = Effect.gen(function* () {\n  // Create bounded queue - blocks producer when full\n  const queue = yield* Queue.bounded<number>(10)\n\n  // Fast producer\n  const producer = Effect.gen(function* () {\n    for (let i = 0; i < 100; i++) {\n      yield* Queue.offer(queue, i)\n      yield* Effect.log(`Produced: ${i}`)\n    }\n    yield* Queue.shutdown(queue)\n  })\n\n  // Slow consumer\n  const consumer = Effect.gen(function* () {\n    let count = 0\n    while (true) {\n      const item = yield* Queue.take(queue).pipe(\n        Effect.catchTag(\"QueueShutdown\", () => Effect.fail(\"done\" as const))\n      )\n      if (item === \"done\") break\n      yield* Effect.sleep(\"50 millis\")  // Slow processing\n      yield* Effect.log(`Consumed: ${item}`)\n      count++\n    }\n    return count\n  }).pipe(Effect.catchAll(() => Effect.succeed(0)))\n\n  // Run both - producer will block when queue is full\n  yield* Effect.all([producer, consumer], { concurrency: 2 })\n})\n\n// ============================================\n// 6. Sliding window - keep most recent\n// ============================================\n\nconst slidingWindowStream = (source: Stream.Stream<number>) =>\n  source.pipe(\n    Stream.sliding(5),  // Keep last 5 items\n    Stream.map((window) => ({\n      items: window,\n      average: Chunk.reduce(window, 0, (a, b) => a + b) / Chunk.size(window),\n    }))\n  )\n\n// ============================================\n// 7. Run example\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Backpressure Demo ===\")\n\n  // Throttled stream\n  const throttled = Stream.fromIterable([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]).pipe(\n    Stream.tap((n) => Effect.log(`Emitting: ${n}`)),\n    Stream.throttle({\n      cost: () => 1,\n      units: 2,\n      duration: \"1 second\",\n      strategy: \"enforce\",\n    }),\n    Stream.tap((n) => Effect.log(`After throttle: ${n}`)),\n    Stream.runDrain\n  )\n\n  yield* throttled\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use buffering and throttling to handle producers faster than consumers."
            },
            "created_at": "2026-02-15T21:22:27.073455",
            "updated_at": "2026-02-20T23:09:43.262627"
        },
        {
            "id": "072f38f8-058c-4baf-b500-bb81f3214b35",
            "slug": "pipeline-merge",
            "title": "Merge Multiple Streams",
            "summary": "Combine data from multiple streams into a single unified stream.",
            "skill_level": "intermediate",
            "category": "building-data-pipelines",
            "difficulty": "intermediate",
            "tags": [
                "data-pipelines",
                "merge",
                "streams",
                "combine"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Duration, Chunk } from \"effect\"\n\n// ============================================\n// 1. Merge - interleave as items arrive\n// ============================================\n\nconst mergeExample = Effect.gen(function* () {\n  // Two streams producing at different rates\n  const fast = Stream.fromIterable([\"A1\", \"A2\", \"A3\"]).pipe(\n    Stream.tap(() => Effect.sleep(\"100 millis\"))\n  )\n\n  const slow = Stream.fromIterable([\"B1\", \"B2\", \"B3\"]).pipe(\n    Stream.tap(() => Effect.sleep(\"200 millis\"))\n  )\n\n  // Merge interleaves based on arrival time\n  const merged = Stream.merge(fast, slow)\n\n  yield* merged.pipe(\n    Stream.tap((item) => Effect.log(`Received: ${item}`)),\n    Stream.runDrain\n  )\n  // Output order depends on timing: A1, B1, A2, A3, B2, B3 (approximately)\n})\n\n// ============================================\n// 2. Merge all - combine many streams\n// ============================================\n\nconst mergeAllExample = Effect.gen(function* () {\n  const streams = [\n    Stream.fromIterable([1, 2, 3]),\n    Stream.fromIterable([10, 20, 30]),\n    Stream.fromIterable([100, 200, 300]),\n  ]\n\n  const merged = Stream.mergeAll(streams, { concurrency: 3 })\n\n  const results = yield* merged.pipe(Stream.runCollect)\n  yield* Effect.log(`Merged: ${Chunk.toReadonlyArray(results)}`)\n})\n\n// ============================================\n// 3. Concat - sequence streams\n// ============================================\n\nconst concatExample = Effect.gen(function* () {\n  const first = Stream.fromIterable([1, 2, 3])\n  const second = Stream.fromIterable([4, 5, 6])\n  const third = Stream.fromIterable([7, 8, 9])\n\n  // Concat waits for each stream to complete\n  const sequential = Stream.concat(Stream.concat(first, second), third)\n\n  const results = yield* sequential.pipe(Stream.runCollect)\n  yield* Effect.log(`Concatenated: ${Chunk.toReadonlyArray(results)}`)\n  // Always: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n})\n\n// ============================================\n// 4. Zip - pair items from streams\n// ============================================\n\nconst zipExample = Effect.gen(function* () {\n  const names = Stream.fromIterable([\"Alice\", \"Bob\", \"Charlie\"])\n  const ages = Stream.fromIterable([30, 25, 35])\n\n  // Zip pairs items by position\n  const zipped = Stream.zip(names, ages)\n\n  yield* zipped.pipe(\n    Stream.tap(([name, age]) => Effect.log(`${name} is ${age} years old`)),\n    Stream.runDrain\n  )\n})\n\n// ============================================\n// 5. ZipWith - pair and transform\n// ============================================\n\nconst zipWithExample = Effect.gen(function* () {\n  const prices = Stream.fromIterable([100, 200, 150])\n  const quantities = Stream.fromIterable([2, 1, 3])\n\n  // Zip and calculate total\n  const totals = Stream.zipWith(prices, quantities, (price, qty) => ({\n    price,\n    quantity: qty,\n    total: price * qty,\n  }))\n\n  yield* totals.pipe(\n    Stream.tap((item) => Effect.log(`${item.quantity}x @ $${item.price} = $${item.total}`)),\n    Stream.runDrain\n  )\n})\n\n// ============================================\n// 6. ZipLatest - combine with latest values\n// ============================================\n\nconst zipLatestExample = Effect.gen(function* () {\n  // Simulate different update rates\n  const temperature = Stream.fromIterable([20, 21, 22, 23]).pipe(\n    Stream.tap(() => Effect.sleep(\"100 millis\"))\n  )\n\n  const humidity = Stream.fromIterable([50, 55, 60]).pipe(\n    Stream.tap(() => Effect.sleep(\"150 millis\"))\n  )\n\n  // ZipLatest always uses the latest value from each stream\n  const combined = Stream.zipLatest(temperature, humidity)\n\n  yield* combined.pipe(\n    Stream.tap(([temp, hum]) => Effect.log(`Temp: ${temp}\u00b0C, Humidity: ${hum}%`)),\n    Stream.runDrain\n  )\n})\n\n// ============================================\n// 7. Practical example: Merge event sources\n// ============================================\n\ninterface Event {\n  source: string\n  type: string\n  data: unknown\n}\n\nconst mergeEventSources = Effect.gen(function* () {\n  // Simulate multiple event sources\n  const mouseEvents = Stream.fromIterable([\n    { source: \"mouse\", type: \"click\", data: { x: 100, y: 200 } },\n    { source: \"mouse\", type: \"move\", data: { x: 150, y: 250 } },\n  ] as Event[])\n\n  const keyboardEvents = Stream.fromIterable([\n    { source: \"keyboard\", type: \"keydown\", data: { key: \"Enter\" } },\n    { source: \"keyboard\", type: \"keyup\", data: { key: \"Enter\" } },\n  ] as Event[])\n\n  const networkEvents = Stream.fromIterable([\n    { source: \"network\", type: \"response\", data: { status: 200 } },\n  ] as Event[])\n\n  // Merge all event sources\n  const allEvents = Stream.mergeAll([mouseEvents, keyboardEvents, networkEvents])\n\n  yield* allEvents.pipe(\n    Stream.tap((event) =>\n      Effect.log(`[${event.source}] ${event.type}: ${JSON.stringify(event.data)}`)\n    ),\n    Stream.runDrain\n  )\n})\n\n// ============================================\n// 8. Run examples\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Merge Example ===\")\n  yield* mergeExample\n\n  yield* Effect.log(\"\\n=== Concat Example ===\")\n  yield* concatExample\n\n  yield* Effect.log(\"\\n=== Zip Example ===\")\n  yield* zipExample\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use merge, concat, or zip to combine multiple streams based on your requirements."
            },
            "created_at": "2026-02-15T21:22:26.481657",
            "updated_at": "2026-02-20T23:09:43.528408"
        },
        {
            "id": "69524ecd-338c-44af-ac79-1fa140e3d4ec",
            "slug": "pipeline-fan-out",
            "title": "Fan Out to Multiple Consumers",
            "summary": "Distribute stream data to multiple parallel consumers for processing.",
            "skill_level": "advanced",
            "category": "building-data-pipelines",
            "difficulty": "advanced",
            "tags": [
                "data-pipelines",
                "fan-out",
                "broadcast",
                "parallel"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Queue, Fiber, Chunk } from \"effect\"\n\n// ============================================\n// 1. Broadcast to all consumers\n// ============================================\n\nconst broadcastExample = Effect.scoped(\n  Effect.gen(function* () {\n    const source = Stream.fromIterable([1, 2, 3, 4, 5])\n\n    // Broadcast to 3 consumers - each gets all items\n    const [stream1, stream2, stream3] = yield* Stream.broadcast(source, 3)\n\n    // Consumer 1: Log items\n    const consumer1 = stream1.pipe(\n      Stream.tap((n) => Effect.log(`Consumer 1: ${n}`)),\n      Stream.runDrain\n    )\n\n    // Consumer 2: Sum items\n    const consumer2 = stream2.pipe(\n      Stream.runFold(0, (acc, n) => acc + n),\n      Effect.tap((sum) => Effect.log(`Consumer 2 sum: ${sum}`))\n    )\n\n    // Consumer 3: Collect to array\n    const consumer3 = stream3.pipe(\n      Stream.runCollect,\n      Effect.tap((items) => Effect.log(`Consumer 3 collected: ${Chunk.toReadonlyArray(items)}`))\n    )\n\n    // Run all consumers in parallel\n    yield* Effect.all([consumer1, consumer2, consumer3], { concurrency: 3 })\n  })\n)\n\n// ============================================\n// 2. Partition by predicate\n// ============================================\n\nconst partitionExample = Effect.gen(function* () {\n  const numbers = Stream.fromIterable([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n  // Partition into even and odd\n  const [evens, odds] = yield* Stream.partition(\n    numbers,\n    (n) => n % 2 === 0\n  )\n\n  const processEvens = evens.pipe(\n    Stream.tap((n) => Effect.log(`Even: ${n}`)),\n    Stream.runDrain\n  )\n\n  const processOdds = odds.pipe(\n    Stream.tap((n) => Effect.log(`Odd: ${n}`)),\n    Stream.runDrain\n  )\n\n  yield* Effect.all([processEvens, processOdds], { concurrency: 2 })\n})\n\n// ============================================\n// 3. Partition into multiple buckets\n// ============================================\n\ninterface Event {\n  type: \"click\" | \"scroll\" | \"submit\"\n  data: unknown\n}\n\nconst multiPartitionExample = Effect.gen(function* () {\n  const events: Event[] = [\n    { type: \"click\", data: { x: 100 } },\n    { type: \"scroll\", data: { y: 200 } },\n    { type: \"submit\", data: { form: \"login\" } },\n    { type: \"click\", data: { x: 150 } },\n    { type: \"scroll\", data: { y: 300 } },\n  ]\n\n  const source = Stream.fromIterable(events)\n\n  // Group by type using groupByKey\n  const grouped = source.pipe(\n    Stream.groupByKey((event) => event.type, {\n      bufferSize: 16,\n    })\n  )\n\n  // Process each group\n  yield* grouped.pipe(\n    Stream.flatMap(([key, stream]) =>\n      stream.pipe(\n        Stream.tap((event) => Effect.log(`[${key}] Processing: ${JSON.stringify(event.data)}`)),\n        Stream.runDrain,\n        Stream.fromEffect\n      )\n    ),\n    Stream.runDrain\n  )\n})\n\n// ============================================\n// 4. Fan-out with queues (manual control)\n// ============================================\n\nconst queueFanOut = Effect.gen(function* () {\n  const source = Stream.fromIterable([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n  // Create queues for each consumer\n  const queue1 = yield* Queue.unbounded<number>()\n  const queue2 = yield* Queue.unbounded<number>()\n  const queue3 = yield* Queue.unbounded<number>()\n\n  // Distribute items round-robin\n  const distributor = source.pipe(\n    Stream.zipWithIndex,\n    Stream.tap(([item, index]) => {\n      const queue = index % 3 === 0 ? queue1 : index % 3 === 1 ? queue2 : queue3\n      return Queue.offer(queue, item)\n    }),\n    Stream.runDrain,\n    Effect.tap(() => Effect.all([\n      Queue.shutdown(queue1),\n      Queue.shutdown(queue2),\n      Queue.shutdown(queue3),\n    ]))\n  )\n\n  // Consumers\n  const makeConsumer = (name: string, queue: Queue.Queue<number>) =>\n    Stream.fromQueue(queue).pipe(\n      Stream.tap((n) => Effect.log(`${name}: ${n}`)),\n      Stream.runDrain\n    )\n\n  yield* Effect.all([\n    distributor,\n    makeConsumer(\"Worker 1\", queue1),\n    makeConsumer(\"Worker 2\", queue2),\n    makeConsumer(\"Worker 3\", queue3),\n  ], { concurrency: 4 })\n})\n\n// ============================================\n// 5. Run examples\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Broadcast Example ===\")\n  yield* broadcastExample\n\n  yield* Effect.log(\"\\n=== Partition Example ===\")\n  yield* partitionExample\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use broadcast or partition to send stream data to multiple consumers."
            },
            "created_at": "2026-02-15T21:22:26.993252",
            "updated_at": "2026-02-20T23:09:43.646616"
        },
        {
            "id": "9e10ca8f-50bd-4c41-853e-62236b9c10ab",
            "slug": "stream-from-paginated-api",
            "title": "Turn a Paginated API into a Single Stream",
            "summary": "Convert a paginated API into a continuous, easy-to-use stream, abstracting away the complexity of fetching page by page.",
            "skill_level": "intermediate",
            "category": "building-data-pipelines",
            "difficulty": "intermediate",
            "tags": [
                "stream",
                "api",
                "pagination",
                "http",
                "client"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Chunk, Option } from \"effect\";\n\n// --- Mock Paginated API ---\ninterface User {\n  id: number;\n  name: string;\n}\n\n// Define FetchError as a class with a literal type tag\nclass FetchError {\n  readonly _tag = \"FetchError\" as const;\n  constructor(readonly message: string) {}\n}\n\n// Helper to create FetchError instances\nconst fetchError = (message: string): FetchError => new FetchError(message);\n\nconst allUsers: User[] = Array.from({ length: 25 }, (_, i) => ({\n  id: i + 1,\n  name: `User ${i + 1}`,\n}));\n\n// This function simulates fetching a page of users from an API.\nconst fetchUsersPage = (\n  page: number\n): Effect.Effect<[Chunk.Chunk<User>, Option.Option<number>], FetchError> =>\n  Effect.gen(function* () {\n    const pageSize = 10;\n    const offset = (page - 1) * pageSize;\n\n    // Simulate potential API errors\n    if (page < 1) {\n      return yield* Effect.fail(fetchError(\"Invalid page number\"));\n    }\n\n    const users = Chunk.fromIterable(allUsers.slice(offset, offset + pageSize));\n\n    const nextPage =\n      Chunk.isNonEmpty(users) && allUsers.length > offset + pageSize\n        ? Option.some(page + 1)\n        : Option.none();\n\n    yield* Effect.log(`Fetched page ${page}`);\n    return [users, nextPage];\n  });\n\n// --- The Pattern ---\n// Use paginateEffect, providing an initial state (page 1) and the fetch function.\nconst userStream = Stream.paginateEffect(1, fetchUsersPage);\n\nconst program = userStream.pipe(\n  Stream.runCollect,\n  Effect.map((users) => users.length),\n  Effect.tap((totalUsers) => Effect.log(`Total users fetched: ${totalUsers}`)),\n  Effect.catchTag(\"FetchError\", (error) =>\n    Effect.succeed(`Error fetching users: ${error.message}`)\n  )\n);\n\n// Run the program\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Program result: ${result}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);\n\n/*\nOutput:\n... level=INFO msg=\"Fetched page 1\"\n... level=INFO msg=\"Fetched page 2\"\n... level=INFO msg=\"Fetched page 3\"\n... level=INFO msg=\"Total users fetched: 25\"\n25\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream.paginateEffect to model a paginated data source as a single, continuous stream."
            },
            "created_at": "2026-02-15T21:22:26.907163",
            "updated_at": "2026-02-20T23:09:43.688486"
        },
        {
            "id": "306dc4f8-a896-4f21-bb89-61783747d2a0",
            "slug": "process-streaming-data-with-stream",
            "title": "Process Streaming Data with Stream",
            "summary": "Use Stream<A, E, R> to represent and process data that arrives over time, such as file reads, WebSocket messages, or paginated API results.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "stream",
                "streaming",
                "concurrency",
                "data-processing",
                "pagination"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Option } from \"effect\";\n\ninterface User {\n  id: number;\n  name: string;\n}\ninterface PaginatedResponse {\n  users: User[];\n  nextPage: number | null;\n}\n\n// A mock API call that returns a page of users\nconst fetchUserPage = (\n  page: number\n): Effect.Effect<PaginatedResponse, \"ApiError\"> =>\n  Effect.succeed(\n    page < 3\n      ? {\n          users: [\n            { id: page * 2 + 1, name: `User ${page * 2 + 1}` },\n            { id: page * 2 + 2, name: `User ${page * 2 + 2}` },\n          ],\n          nextPage: page + 1,\n        }\n      : { users: [], nextPage: null }\n  ).pipe(Effect.delay(\"50 millis\"));\n\n// Stream.paginateEffect creates a stream from a paginated source\nconst userStream: Stream.Stream<User, \"ApiError\"> = Stream.paginateEffect(\n  0,\n  (page) =>\n    fetchUserPage(page).pipe(\n      Effect.map(\n        (response) =>\n          [response.users, Option.fromNullable(response.nextPage)] as const\n      )\n    )\n).pipe(\n  // Flatten the stream of user arrays into a stream of individual users\n  Stream.flatMap((users) => Stream.fromIterable(users))\n);\n\n// We can now process the stream of users.\n// Stream.runForEach will pull from the stream until it's exhausted.\nconst program = Stream.runForEach(userStream, (user: User) =>\n  Effect.log(`Processing user: ${user.name}`)\n);\n\nconst programWithErrorHandling = program.pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Stream processing error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream to model and process data that arrives over time in a composable, efficient way."
            },
            "created_at": "2026-02-15T21:22:15.869634",
            "updated_at": "2026-02-20T23:09:34.262685"
        },
        {
            "id": "63703550-f3ed-4716-8df9-96793ad9eff0",
            "slug": "model-dependencies-as-services",
            "title": "Model Dependencies as Services",
            "summary": "Abstract external dependencies and capabilities into swappable, testable services using Effect's dependency injection system.",
            "skill_level": "intermediate",
            "category": "making-http-requests",
            "difficulty": "intermediate",
            "tags": [
                "service",
                "architecture",
                "dependency-injection",
                "layers",
                "testing",
                "decoupling"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Define Random service with production implementation as default\nexport class Random extends Effect.Service<Random>()(\"Random\", {\n  // Default production implementation\n  sync: () => ({\n    next: Effect.sync(() => Math.random()),\n  }),\n}) {}\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const random = yield* Random;\n  const value = yield* random.next;\n  return value;\n});\n\n// Run with default implementation\nconst programWithLogging = Effect.gen(function* () {\n  const value = yield* Effect.provide(program, Random.Default);\n  yield* Effect.log(`Random value: ${value}`);\n  return value;\n});\n\nEffect.runPromise(programWithLogging);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Model dependencies as services."
            },
            "created_at": "2026-02-15T21:22:27.905708",
            "updated_at": "2026-02-20T23:09:45.505526"
        },
        {
            "id": "6b5a4773-bd20-48f0-a862-a9ffd873e01d",
            "slug": "http-timeouts",
            "title": "Add Timeouts to HTTP Requests",
            "summary": "Set timeouts on HTTP requests to prevent hanging operations.",
            "skill_level": "intermediate",
            "category": "making-http-requests",
            "difficulty": "intermediate",
            "tags": [
                "http",
                "timeouts",
                "resilience"
            ],
            "examples": [
                {
                    "code": "import { Effect, Duration, Data } from \"effect\"\nimport { HttpClient, HttpClientRequest, HttpClientResponse } from \"@effect/platform\"\n\n// ============================================\n// 1. Basic request timeout\n// ============================================\n\nconst fetchWithTimeout = (url: string, timeout: Duration.DurationInput) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    return yield* client.get(url).pipe(\n      Effect.flatMap((r) => HttpClientResponse.json(r)),\n      Effect.timeout(timeout)\n    )\n    // Returns Option<A> - None if timed out\n  })\n\n// ============================================\n// 2. Timeout with custom error\n// ============================================\n\nclass RequestTimeoutError extends Data.TaggedError(\"RequestTimeoutError\")<{\n  readonly url: string\n  readonly timeout: Duration.Duration\n}> {}\n\nconst fetchWithTimeoutError = (url: string, timeout: Duration.DurationInput) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    return yield* client.get(url).pipe(\n      Effect.flatMap((r) => HttpClientResponse.json(r)),\n      Effect.timeoutFail({\n        duration: timeout,\n        onTimeout: () => new RequestTimeoutError({\n          url,\n          timeout: Duration.decode(timeout),\n        }),\n      })\n    )\n  })\n\n// ============================================\n// 3. Different timeouts for different phases\n// ============================================\n\nconst fetchWithPhasedTimeouts = (url: string) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    // Connection timeout (initial)\n    const response = yield* client.get(url).pipe(\n      Effect.timeout(\"5 seconds\"),\n      Effect.flatten,\n      Effect.mapError(() => new Error(\"Connection timeout\"))\n    )\n\n    // Read timeout (body)\n    const body = yield* HttpClientResponse.text(response).pipe(\n      Effect.timeout(\"30 seconds\"),\n      Effect.flatten,\n      Effect.mapError(() => new Error(\"Read timeout\"))\n    )\n\n    return body\n  })\n\n// ============================================\n// 4. Timeout with fallback\n// ============================================\n\ninterface ApiResponse {\n  data: unknown\n  cached: boolean\n}\n\nconst fetchWithFallback = (url: string): Effect.Effect<ApiResponse> =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    return yield* client.get(url).pipe(\n      Effect.flatMap((r) => HttpClientResponse.json(r)),\n      Effect.map((data) => ({ data, cached: false })),\n      Effect.timeout(\"5 seconds\"),\n      Effect.flatMap((result) =>\n        result._tag === \"Some\"\n          ? Effect.succeed(result.value)\n          : Effect.succeed({ data: null, cached: true })  // Fallback\n      )\n    )\n  })\n\n// ============================================\n// 5. Timeout with interrupt\n// ============================================\n\nconst fetchWithInterrupt = (url: string) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    return yield* client.get(url).pipe(\n      Effect.flatMap((r) => HttpClientResponse.json(r)),\n      Effect.interruptible,\n      Effect.timeout(\"10 seconds\")\n    )\n    // Fiber is interrupted if timeout, freeing resources\n  })\n\n// ============================================\n// 6. Configurable timeout wrapper\n// ============================================\n\ninterface TimeoutConfig {\n  readonly connect: Duration.DurationInput\n  readonly read: Duration.DurationInput\n  readonly total: Duration.DurationInput\n}\n\nconst defaultTimeouts: TimeoutConfig = {\n  connect: \"5 seconds\",\n  read: \"30 seconds\",\n  total: \"60 seconds\",\n}\n\nconst createHttpClient = (config: TimeoutConfig = defaultTimeouts) =>\n  Effect.gen(function* () {\n    const baseClient = yield* HttpClient.HttpClient\n\n    return {\n      get: (url: string) =>\n        baseClient.get(url).pipe(\n          Effect.timeout(config.connect),\n          Effect.flatten,\n          Effect.flatMap((r) =>\n            HttpClientResponse.json(r).pipe(\n              Effect.timeout(config.read),\n              Effect.flatten\n            )\n          ),\n          Effect.timeout(config.total),\n          Effect.flatten\n        ),\n    }\n  })\n\n// ============================================\n// 7. Usage\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Fetching with timeout...\")\n\n  const result = yield* fetchWithTimeoutError(\n    \"https://api.example.com/slow\",\n    \"5 seconds\"\n  ).pipe(\n    Effect.catchTag(\"RequestTimeoutError\", (error) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`Request to ${error.url} timed out`)\n        return { error: \"timeout\" }\n      })\n    )\n  )\n\n  yield* Effect.log(`Result: ${JSON.stringify(result)}`)\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Always set timeouts on HTTP requests to ensure your application doesn't hang."
            },
            "created_at": "2026-02-15T21:22:27.485021",
            "updated_at": "2026-02-20T23:09:45.621468"
        },
        {
            "id": "b0a56a95-fc40-43df-9b4c-65efc7d50848",
            "slug": "http-caching",
            "title": "Cache HTTP Responses",
            "summary": "Implement response caching to reduce API calls and improve performance.",
            "skill_level": "intermediate",
            "category": "making-http-requests",
            "difficulty": "intermediate",
            "tags": [
                "http",
                "caching",
                "performance"
            ],
            "examples": [
                {
                    "code": "import { Effect, Ref, HashMap, Option, Duration } from \"effect\"\nimport { HttpClient, HttpClientResponse } from \"@effect/platform\"\n\n// ============================================\n// 1. Simple in-memory cache\n// ============================================\n\ninterface CacheEntry<T> {\n  readonly data: T\n  readonly timestamp: number\n  readonly ttl: number\n}\n\nconst makeCache = <T>() =>\n  Effect.gen(function* () {\n    const store = yield* Ref.make(HashMap.empty<string, CacheEntry<T>>())\n\n    const get = (key: string): Effect.Effect<Option.Option<T>> =>\n      Ref.get(store).pipe(\n        Effect.map((map) => {\n          const entry = HashMap.get(map, key)\n          if (entry._tag === \"None\") return Option.none()\n\n          const now = Date.now()\n          if (now > entry.value.timestamp + entry.value.ttl) {\n            return Option.none()  // Expired\n          }\n          return Option.some(entry.value.data)\n        })\n      )\n\n    const set = (key: string, data: T, ttl: number): Effect.Effect<void> =>\n      Ref.update(store, (map) =>\n        HashMap.set(map, key, {\n          data,\n          timestamp: Date.now(),\n          ttl,\n        })\n      )\n\n    const invalidate = (key: string): Effect.Effect<void> =>\n      Ref.update(store, (map) => HashMap.remove(map, key))\n\n    const clear = (): Effect.Effect<void> =>\n      Ref.set(store, HashMap.empty())\n\n    return { get, set, invalidate, clear }\n  })\n\n// ============================================\n// 2. Cached HTTP client\n// ============================================\n\ninterface CachedHttpClient {\n  readonly get: <T>(\n    url: string,\n    options?: { ttl?: Duration.DurationInput }\n  ) => Effect.Effect<T, Error>\n  readonly invalidate: (url: string) => Effect.Effect<void>\n}\n\nconst makeCachedHttpClient = Effect.gen(function* () {\n  const httpClient = yield* HttpClient.HttpClient\n  const cache = yield* makeCache<unknown>()\n\n  const client: CachedHttpClient = {\n    get: <T>(url: string, options?: { ttl?: Duration.DurationInput }) => {\n      const ttl = options?.ttl ? Duration.toMillis(Duration.decode(options.ttl)) : 60000\n\n      return Effect.gen(function* () {\n        // Check cache first\n        const cached = yield* cache.get(url)\n        if (Option.isSome(cached)) {\n          yield* Effect.log(`Cache hit: ${url}`)\n          return cached.value as T\n        }\n\n        yield* Effect.log(`Cache miss: ${url}`)\n\n        // Fetch from network\n        const response = yield* httpClient.get(url)\n        const data = yield* HttpClientResponse.json(response) as Effect.Effect<T>\n\n        // Store in cache\n        yield* cache.set(url, data, ttl)\n\n        return data\n      })\n    },\n\n    invalidate: (url) => cache.invalidate(url),\n  }\n\n  return client\n})\n\n// ============================================\n// 3. Stale-while-revalidate pattern\n// ============================================\n\ninterface SWRCache<T> {\n  readonly data: T\n  readonly timestamp: number\n  readonly staleAfter: number\n  readonly expireAfter: number\n}\n\nconst makeSWRClient = Effect.gen(function* () {\n  const httpClient = yield* HttpClient.HttpClient\n  const cache = yield* Ref.make(HashMap.empty<string, SWRCache<unknown>>())\n\n  return {\n    get: <T>(\n      url: string,\n      options: {\n        staleAfter: Duration.DurationInput\n        expireAfter: Duration.DurationInput\n      }\n    ) =>\n      Effect.gen(function* () {\n        const now = Date.now()\n        const staleMs = Duration.toMillis(Duration.decode(options.staleAfter))\n        const expireMs = Duration.toMillis(Duration.decode(options.expireAfter))\n\n        const cached = yield* Ref.get(cache).pipe(\n          Effect.map((map) => HashMap.get(map, url))\n        )\n\n        if (cached._tag === \"Some\") {\n          const entry = cached.value\n          const age = now - entry.timestamp\n\n          if (age < staleMs) {\n            // Fresh - return immediately\n            return entry.data as T\n          }\n\n          if (age < expireMs) {\n            // Stale - return cached, revalidate in background\n            yield* Effect.fork(\n              httpClient.get(url).pipe(\n                Effect.flatMap((r) => HttpClientResponse.json(r)),\n                Effect.flatMap((data) =>\n                  Ref.update(cache, (map) =>\n                    HashMap.set(map, url, {\n                      data,\n                      timestamp: Date.now(),\n                      staleAfter: staleMs,\n                      expireAfter: expireMs,\n                    })\n                  )\n                ),\n                Effect.catchAll(() => Effect.void)  // Ignore errors\n              )\n            )\n            return entry.data as T\n          }\n        }\n\n        // Expired or missing - fetch fresh\n        const response = yield* httpClient.get(url)\n        const data = yield* HttpClientResponse.json(response) as Effect.Effect<T>\n\n        yield* Ref.update(cache, (map) =>\n          HashMap.set(map, url, {\n            data,\n            timestamp: now,\n            staleAfter: staleMs,\n            expireAfter: expireMs,\n          })\n        )\n\n        return data\n      }),\n  }\n})\n\n// ============================================\n// 4. Cache with request deduplication\n// ============================================\n\nconst makeDeduplicatedClient = Effect.gen(function* () {\n  const httpClient = yield* HttpClient.HttpClient\n  const inFlight = yield* Ref.make(HashMap.empty<string, Effect.Effect<unknown>>())\n  const cache = yield* makeCache<unknown>()\n\n  return {\n    get: <T>(url: string, ttl: number = 60000) =>\n      Effect.gen(function* () {\n        // Check cache\n        const cached = yield* cache.get(url)\n        if (Option.isSome(cached)) {\n          return cached.value as T\n        }\n\n        // Check if request already in flight\n        const pending = yield* Ref.get(inFlight).pipe(\n          Effect.map((map) => HashMap.get(map, url))\n        )\n\n        if (pending._tag === \"Some\") {\n          yield* Effect.log(`Deduplicating request: ${url}`)\n          return (yield* pending.value) as T\n        }\n\n        // Make the request\n        const request = httpClient.get(url).pipe(\n          Effect.flatMap((r) => HttpClientResponse.json(r)),\n          Effect.tap((data) => cache.set(url, data, ttl)),\n          Effect.ensuring(\n            Ref.update(inFlight, (map) => HashMap.remove(map, url))\n          )\n        )\n\n        // Store in-flight request\n        yield* Ref.update(inFlight, (map) => HashMap.set(map, url, request))\n\n        return (yield* request) as T\n      }),\n  }\n})\n\n// ============================================\n// 5. Usage\n// ============================================\n\nconst program = Effect.gen(function* () {\n  const client = yield* makeCachedHttpClient\n\n  // First call - cache miss\n  yield* client.get(\"https://api.example.com/users/1\", { ttl: \"5 minutes\" })\n\n  // Second call - cache hit\n  yield* client.get(\"https://api.example.com/users/1\")\n\n  // Invalidate when data changes\n  yield* client.invalidate(\"https://api.example.com/users/1\")\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use an in-memory or persistent cache to store HTTP responses."
            },
            "created_at": "2026-02-15T21:22:27.578497",
            "updated_at": "2026-02-20T23:09:45.717246"
        },
        {
            "id": "a13a1c39-bfec-40ce-89a8-86c58b08f96e",
            "slug": "http-logging",
            "title": "Log HTTP Requests and Responses",
            "summary": "Add request/response logging for debugging and observability.",
            "skill_level": "intermediate",
            "category": "making-http-requests",
            "difficulty": "intermediate",
            "tags": [
                "http",
                "logging",
                "debugging",
                "observability"
            ],
            "examples": [
                {
                    "code": "import { Effect, Duration } from \"effect\"\nimport { HttpClient, HttpClientRequest, HttpClientResponse } from \"@effect/platform\"\n\n// ============================================\n// 1. Simple request/response logging\n// ============================================\n\nconst withLogging = <A, E>(\n  request: Effect.Effect<A, E, HttpClient.HttpClient>\n): Effect.Effect<A, E, HttpClient.HttpClient> =>\n  Effect.gen(function* () {\n    const startTime = Date.now()\n    yield* Effect.log(\"\u2192 HTTP Request starting...\")\n\n    const result = yield* request\n\n    const duration = Date.now() - startTime\n    yield* Effect.log(`\u2190 HTTP Response received (${duration}ms)`)\n\n    return result\n  })\n\n// ============================================\n// 2. Detailed request logging\n// ============================================\n\ninterface RequestLog {\n  method: string\n  url: string\n  headers: Record<string, string>\n  body?: unknown\n}\n\ninterface ResponseLog {\n  status: number\n  headers: Record<string, string>\n  duration: number\n  size?: number\n}\n\nconst makeLoggingClient = Effect.gen(function* () {\n  const baseClient = yield* HttpClient.HttpClient\n\n  const logRequest = (method: string, url: string, headers: Record<string, string>) =>\n    Effect.log(\"HTTP Request\").pipe(\n      Effect.annotateLogs({\n        method,\n        url,\n        headers: JSON.stringify(headers),\n      })\n    )\n\n  const logResponse = (status: number, duration: number, headers: Record<string, string>) =>\n    Effect.log(\"HTTP Response\").pipe(\n      Effect.annotateLogs({\n        status: String(status),\n        duration: `${duration}ms`,\n        headers: JSON.stringify(headers),\n      })\n    )\n\n  return {\n    get: <T>(url: string, options?: { headers?: Record<string, string> }) =>\n      Effect.gen(function* () {\n        const headers = options?.headers ?? {}\n        yield* logRequest(\"GET\", url, headers)\n        const startTime = Date.now()\n\n        const response = yield* baseClient.get(url)\n\n        yield* logResponse(\n          response.status,\n          Date.now() - startTime,\n          response.headers\n        )\n\n        return yield* HttpClientResponse.json(response) as Effect.Effect<T>\n      }),\n\n    post: <T>(url: string, body: unknown, options?: { headers?: Record<string, string> }) =>\n      Effect.gen(function* () {\n        const headers = options?.headers ?? {}\n        yield* logRequest(\"POST\", url, headers).pipe(\n          Effect.annotateLogs(\"body\", JSON.stringify(body).slice(0, 200))\n        )\n        const startTime = Date.now()\n\n        const request = yield* HttpClientRequest.post(url).pipe(\n          HttpClientRequest.jsonBody(body)\n        )\n        const response = yield* baseClient.execute(request)\n\n        yield* logResponse(\n          response.status,\n          Date.now() - startTime,\n          response.headers\n        )\n\n        return yield* HttpClientResponse.json(response) as Effect.Effect<T>\n      }),\n  }\n})\n\n// ============================================\n// 3. Log with span for timing\n// ============================================\n\nconst fetchWithSpan = (url: string) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    return yield* client.get(url).pipe(\n      Effect.flatMap((r) => HttpClientResponse.json(r)),\n      Effect.withLogSpan(`HTTP GET ${url}`)\n    )\n  })\n\n// ============================================\n// 4. Conditional logging (debug mode)\n// ============================================\n\nconst makeConditionalLoggingClient = (debug: boolean) =>\n  Effect.gen(function* () {\n    const baseClient = yield* HttpClient.HttpClient\n\n    const maybeLog = (message: string, data?: Record<string, unknown>) =>\n      debug\n        ? Effect.log(message).pipe(\n            data ? Effect.annotateLogs(data) : (e) => e\n          )\n        : Effect.void\n\n    return {\n      get: <T>(url: string) =>\n        Effect.gen(function* () {\n          yield* maybeLog(\"HTTP Request\", { method: \"GET\", url })\n          const startTime = Date.now()\n\n          const response = yield* baseClient.get(url)\n\n          yield* maybeLog(\"HTTP Response\", {\n            status: String(response.status),\n            duration: `${Date.now() - startTime}ms`,\n          })\n\n          return yield* HttpClientResponse.json(response) as Effect.Effect<T>\n        }),\n    }\n  })\n\n// ============================================\n// 5. Request ID tracking\n// ============================================\n\nconst makeTrackedClient = Effect.gen(function* () {\n  const baseClient = yield* HttpClient.HttpClient\n\n  return {\n    get: <T>(url: string) =>\n      Effect.gen(function* () {\n        const requestId = crypto.randomUUID().slice(0, 8)\n\n        yield* Effect.log(\"HTTP Request\").pipe(\n          Effect.annotateLogs({\n            requestId,\n            method: \"GET\",\n            url,\n          })\n        )\n\n        const startTime = Date.now()\n        const response = yield* baseClient.get(url)\n\n        yield* Effect.log(\"HTTP Response\").pipe(\n          Effect.annotateLogs({\n            requestId,\n            status: String(response.status),\n            duration: `${Date.now() - startTime}ms`,\n          })\n        )\n\n        return yield* HttpClientResponse.json(response) as Effect.Effect<T>\n      })\n  }\n})\n\n// ============================================\n// 6. Error logging\n// ============================================\n\nconst fetchWithErrorLogging = (url: string) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    return yield* client.get(url).pipe(\n      Effect.flatMap((response) => {\n        if (response.status >= 400) {\n          return Effect.gen(function* () {\n            yield* Effect.logError(\"HTTP Error\").pipe(\n              Effect.annotateLogs({\n                url,\n                status: String(response.status),\n              })\n            )\n            return yield* Effect.fail(new Error(`HTTP ${response.status}`))\n          })\n        }\n        return Effect.succeed(response)\n      }),\n      Effect.flatMap((r) => HttpClientResponse.json(r)),\n      Effect.tapError((error) =>\n        Effect.logError(\"Request failed\").pipe(\n          Effect.annotateLogs({\n            url,\n            error: String(error),\n          })\n        )\n      )\n    )\n  })\n\n// ============================================\n// 7. Usage\n// ============================================\n\nconst program = Effect.gen(function* () {\n  const client = yield* makeLoggingClient\n\n  yield* Effect.log(\"Starting HTTP operations...\")\n\n  const data = yield* client.get(\"https://api.example.com/users\")\n\n  yield* Effect.log(\"Operations complete\")\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect's logging to trace HTTP requests for debugging and monitoring."
            },
            "created_at": "2026-02-15T21:22:27.818701",
            "updated_at": "2026-02-20T23:09:45.754818"
        },
        {
            "id": "f5bd7d08-530d-4115-9410-da946c407693",
            "slug": "http-retries",
            "title": "Retry HTTP Requests with Backoff",
            "summary": "Implement robust retry logic for HTTP requests with exponential backoff.",
            "skill_level": "intermediate",
            "category": "making-http-requests",
            "difficulty": "intermediate",
            "tags": [
                "http",
                "retries",
                "backoff",
                "resilience"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule, Duration, Data } from \"effect\"\nimport { HttpClient, HttpClientRequest, HttpClientResponse, HttpClientError } from \"@effect/platform\"\n\n// ============================================\n// 1. Basic retry with exponential backoff\n// ============================================\n\nconst fetchWithRetry = (url: string) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    return yield* client.get(url).pipe(\n      Effect.flatMap((response) => HttpClientResponse.json(response)),\n      Effect.retry(\n        Schedule.exponential(\"100 millis\", 2).pipe(\n          Schedule.intersect(Schedule.recurs(5)),     // Max 5 retries\n          Schedule.jittered                            // Add randomness\n        )\n      )\n    )\n  })\n\n// ============================================\n// 2. Retry only specific status codes\n// ============================================\n\nclass RetryableHttpError extends Data.TaggedError(\"RetryableHttpError\")<{\n  readonly status: number\n  readonly message: string\n}> {}\n\nclass NonRetryableHttpError extends Data.TaggedError(\"NonRetryableHttpError\")<{\n  readonly status: number\n  readonly message: string\n}> {}\n\nconst isRetryable = (status: number): boolean =>\n  status === 429 ||    // Rate limited\n  status === 503 ||    // Service unavailable\n  status === 502 ||    // Bad gateway\n  status === 504 ||    // Gateway timeout\n  status >= 500        // Server errors\n\nconst fetchWithSelectiveRetry = (url: string) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    const response = yield* client.get(url).pipe(\n      Effect.flatMap((response) => {\n        if (response.status >= 400) {\n          if (isRetryable(response.status)) {\n            return Effect.fail(new RetryableHttpError({\n              status: response.status,\n              message: `HTTP ${response.status}`,\n            }))\n          }\n          return Effect.fail(new NonRetryableHttpError({\n            status: response.status,\n            message: `HTTP ${response.status}`,\n          }))\n        }\n        return Effect.succeed(response)\n      }),\n      Effect.retry({\n        schedule: Schedule.exponential(\"200 millis\").pipe(\n          Schedule.intersect(Schedule.recurs(3))\n        ),\n        while: (error) => error._tag === \"RetryableHttpError\",\n      })\n    )\n\n    return yield* HttpClientResponse.json(response)\n  })\n\n// ============================================\n// 3. Retry with logging\n// ============================================\n\nconst fetchWithRetryLogging = (url: string) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    return yield* client.get(url).pipe(\n      Effect.flatMap((r) => HttpClientResponse.json(r)),\n      Effect.retry(\n        Schedule.exponential(\"100 millis\").pipe(\n          Schedule.intersect(Schedule.recurs(3)),\n          Schedule.tapOutput((_, output) =>\n            Effect.log(`Retry attempt, waiting ${Duration.toMillis(output)}ms`)\n          )\n        )\n      ),\n      Effect.tapError((error) => Effect.log(`Request failed: ${error}`))\n    )\n  })\n\n// ============================================\n// 4. Custom retry policy\n// ============================================\n\nconst customRetryPolicy = Schedule.exponential(\"500 millis\", 2).pipe(\n  Schedule.intersect(Schedule.recurs(5)),\n  Schedule.union(Schedule.spaced(\"30 seconds\")),  // Also retry after 30s\n  Schedule.whileOutput((duration) => Duration.lessThanOrEqualTo(duration, \"2 minutes\")),\n  Schedule.jittered\n)\n\n// ============================================\n// 5. Retry respecting Retry-After header\n// ============================================\n\nconst fetchWithRetryAfter = (url: string) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    const makeRequest = client.get(url).pipe(\n      Effect.flatMap((response) => {\n        if (response.status === 429) {\n          const retryAfter = response.headers[\"retry-after\"]\n          const delay = retryAfter ? parseInt(retryAfter, 10) * 1000 : 1000\n\n          return Effect.fail({\n            _tag: \"RateLimited\" as const,\n            delay,\n          })\n        }\n        return Effect.succeed(response)\n      })\n    )\n\n    return yield* makeRequest.pipe(\n      Effect.retry(\n        Schedule.recurWhile<{ _tag: \"RateLimited\"; delay: number }>(\n          (error) => error._tag === \"RateLimited\"\n        ).pipe(\n          Schedule.intersect(Schedule.recurs(3)),\n          Schedule.delayed((_, error) => Duration.millis(error.delay))\n        )\n      ),\n      Effect.flatMap((r) => HttpClientResponse.json(r))\n    )\n  })\n\n// ============================================\n// 6. Usage\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Fetching with retry...\")\n\n  const data = yield* fetchWithRetry(\"https://api.example.com/data\").pipe(\n    Effect.catchAll((error) => {\n      return Effect.succeed({ error: \"All retries exhausted\" })\n    })\n  )\n\n  yield* Effect.log(`Result: ${JSON.stringify(data)}`)\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Schedule to retry failed HTTP requests with configurable backoff strategies."
            },
            "created_at": "2026-02-15T21:22:27.987571",
            "updated_at": "2026-02-20T23:09:45.797893"
        },
        {
            "id": "b1a4adbb-1519-45ee-bb51-f7a0824539b6",
            "slug": "control-flow-with-combinators",
            "title": "Control Flow with Conditional Combinators",
            "summary": "Use combinators like Effect.if, Effect.when, and Effect.cond to handle conditional logic in a declarative, composable way.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "control-flow",
                "conditional",
                "if",
                "when",
                "cond",
                "declarative"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\nconst attemptAdminAction = (user: { isAdmin: boolean }) =>\n  Effect.if(user.isAdmin, {\n    onTrue: () => Effect.succeed(\"Admin action completed.\"),\n    onFalse: () => Effect.fail(\"Permission denied.\"),\n  });\n\nconst program = Effect.gen(function* () {\n  // Try with admin user\n  yield* Effect.logInfo(\"\\nTrying with admin user...\");\n  const adminResult = yield* Effect.either(\n    attemptAdminAction({ isAdmin: true })\n  );\n  yield* Effect.logInfo(\n    `Admin result: ${adminResult._tag === \"Right\" ? adminResult.right : adminResult.left}`\n  );\n\n  // Try with non-admin user\n  yield* Effect.logInfo(\"\\nTrying with non-admin user...\");\n  const userResult = yield* Effect.either(\n    attemptAdminAction({ isAdmin: false })\n  );\n  yield* Effect.logInfo(\n    `User result: ${userResult._tag === \"Right\" ? userResult.right : userResult.left}`\n  );\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use conditional combinators for control flow."
            },
            "created_at": "2026-02-15T21:22:15.269761",
            "updated_at": "2026-02-20T23:09:34.344134"
        },
        {
            "id": "edac6a03-e854-456b-8383-be29c75ea196",
            "slug": "combinator-conditional",
            "title": "Conditional Branching with if, when, and cond",
            "summary": "Use combinators like if, when, and cond to express conditional logic declaratively across Effect, Stream, Option, and Either.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "conditional",
                "if",
                "when",
                "cond",
                "combinator",
                "effect",
                "stream",
                "option",
                "either"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Branch based on a condition\nconst effect = Effect.if(true, {\n  onTrue: () => Effect.succeed(\"yes\"),\n  onFalse: () => Effect.succeed(\"no\"),\n}); // Effect<string>\n\n// Option: Conditionally create an Option\nconst option = true ? Option.some(\"yes\") : Option.none(); // Option<string> (Some(\"yes\"))\n\n// Either: Conditionally create an Either\nconst either = true ? Either.right(\"yes\") : Either.left(\"error\"); // Either<string, string> (Right(\"yes\"))\n\n// Stream: Conditionally emit a stream\nconst stream = false ? Stream.fromIterable([1, 2]) : Stream.empty; // Stream<number> (empty)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use combinators such as if, when, and cond to branch computations based on runtime conditions, without imperative if statements."
            },
            "created_at": "2026-02-15T21:22:13.310852",
            "updated_at": "2026-02-20T23:09:34.385595"
        },
        {
            "id": "a5dbc9ec-5868-44af-8d78-3117978da3fd",
            "slug": "testing-concurrent-code",
            "title": "Test Concurrent Code",
            "summary": "Test race conditions, parallelism, and concurrent behavior in Effect programs.",
            "skill_level": "advanced",
            "category": "testing",
            "difficulty": "advanced",
            "tags": [
                "testing",
                "concurrency",
                "fibers",
                "race-conditions"
            ],
            "examples": [
                {
                    "code": "import { describe, it, expect } from \"vitest\"\nimport { Effect, Fiber, Ref, TestClock, Duration, Deferred } from \"effect\"\n\ndescribe(\"Concurrent Code Testing\", () => {\n  // ============================================\n  // 1. Test parallel execution\n  // ============================================\n\n  it(\"should run effects in parallel\", async () => {\n    const executionOrder: string[] = []\n\n    const task1 = Effect.gen(function* () {\n      yield* Effect.sleep(\"100 millis\")\n      executionOrder.push(\"task1\")\n      return 1\n    })\n\n    const task2 = Effect.gen(function* () {\n      yield* Effect.sleep(\"50 millis\")\n      executionOrder.push(\"task2\")\n      return 2\n    })\n\n    const program = Effect.all([task1, task2], { concurrency: 2 })\n\n    // Use TestClock to control time\n    const result = await Effect.runPromise(\n      Effect.gen(function* () {\n        const fiber = yield* Effect.fork(program)\n\n        // Advance time to trigger both tasks\n        yield* TestClock.adjust(\"100 millis\")\n\n        return yield* Fiber.join(fiber)\n      }).pipe(Effect.provide(TestClock.live))\n    )\n\n    expect(result).toEqual([1, 2])\n    // With real time, task2 would complete first\n    expect(executionOrder).toContain(\"task1\")\n    expect(executionOrder).toContain(\"task2\")\n  })\n\n  // ============================================\n  // 2. Test race conditions\n  // ============================================\n\n  it(\"should handle race condition correctly\", async () => {\n    const counter = await Effect.runPromise(\n      Effect.gen(function* () {\n        const ref = yield* Ref.make(0)\n\n        // Simulate concurrent increments\n        const increment = Ref.update(ref, (n) => n + 1)\n\n        // Run 100 concurrent increments\n        yield* Effect.all(\n          Array.from({ length: 100 }, () => increment),\n          { concurrency: \"unbounded\" }\n        )\n\n        return yield* Ref.get(ref)\n      })\n    )\n\n    // Ref is atomic, so all increments should be counted\n    expect(counter).toBe(100)\n  })\n\n  // ============================================\n  // 3. Test with controlled fiber execution\n  // ============================================\n\n  it(\"should test fiber lifecycle\", async () => {\n    const events: string[] = []\n\n    const program = Effect.gen(function* () {\n      const fiber = yield* Effect.fork(\n        Effect.gen(function* () {\n          events.push(\"started\")\n          yield* Effect.sleep(\"1 second\")\n          events.push(\"completed\")\n          return \"result\"\n        })\n      )\n\n      events.push(\"forked\")\n\n      // Interrupt the fiber\n      yield* Fiber.interrupt(fiber)\n      events.push(\"interrupted\")\n\n      const exit = yield* Fiber.await(fiber)\n      return exit\n    })\n\n    await Effect.runPromise(program)\n\n    expect(events).toEqual([\"forked\", \"started\", \"interrupted\"])\n    expect(events).not.toContain(\"completed\")\n  })\n\n  // ============================================\n  // 4. Test timeout behavior\n  // ============================================\n\n  it(\"should timeout slow operations\", async () => {\n    const slowOperation = Effect.gen(function* () {\n      yield* Effect.sleep(\"10 seconds\")\n      return \"completed\"\n    })\n\n    const result = await Effect.runPromise(\n      Effect.gen(function* () {\n        const fiber = yield* Effect.fork(\n          slowOperation.pipe(Effect.timeout(\"1 second\"))\n        )\n\n        // Advance past the timeout\n        yield* TestClock.adjust(\"2 seconds\")\n\n        return yield* Fiber.join(fiber)\n      }).pipe(Effect.provide(TestClock.live))\n    )\n\n    // Result is Option.None due to timeout\n    expect(result._tag).toBe(\"None\")\n  })\n\n  // ============================================\n  // 5. Test with Deferred for synchronization\n  // ============================================\n\n  it(\"should synchronize fibers correctly\", async () => {\n    const result = await Effect.runPromise(\n      Effect.gen(function* () {\n        const deferred = yield* Deferred.make<string>()\n        const results: string[] = []\n\n        // Consumer waits for producer\n        const consumer = Effect.fork(\n          Effect.gen(function* () {\n            const value = yield* Deferred.await(deferred)\n            results.push(`consumed: ${value}`)\n          })\n        )\n\n        // Producer completes the deferred\n        const producer = Effect.gen(function* () {\n          results.push(\"producing\")\n          yield* Deferred.succeed(deferred, \"data\")\n          results.push(\"produced\")\n        })\n\n        yield* consumer\n        yield* producer\n\n        // Wait for consumer to process\n        yield* Effect.sleep(\"10 millis\")\n\n        return results\n      })\n    )\n\n    expect(result).toContain(\"producing\")\n    expect(result).toContain(\"produced\")\n    expect(result).toContain(\"consumed: data\")\n  })\n\n  // ============================================\n  // 6. Test for absence of deadlocks\n  // ============================================\n\n  it(\"should not deadlock with proper resource ordering\", async () => {\n    const result = await Effect.runPromise(\n      Effect.gen(function* () {\n        const ref1 = yield* Ref.make(0)\n        const ref2 = yield* Ref.make(0)\n\n        // Two fibers accessing refs in same order (no deadlock)\n        const fiber1 = yield* Effect.fork(\n          Effect.gen(function* () {\n            yield* Ref.update(ref1, (n) => n + 1)\n            yield* Ref.update(ref2, (n) => n + 1)\n          })\n        )\n\n        const fiber2 = yield* Effect.fork(\n          Effect.gen(function* () {\n            yield* Ref.update(ref1, (n) => n + 1)\n            yield* Ref.update(ref2, (n) => n + 1)\n          })\n        )\n\n        yield* Fiber.join(fiber1)\n        yield* Fiber.join(fiber2)\n\n        return [yield* Ref.get(ref1), yield* Ref.get(ref2)]\n      }).pipe(Effect.timeout(\"1 second\"))\n    )\n\n    expect(result._tag).toBe(\"Some\")\n    expect(result.value).toEqual([2, 2])\n  })\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use TestClock and controlled concurrency to make concurrent tests deterministic."
            },
            "created_at": "2026-02-15T21:22:28.854341",
            "updated_at": "2026-02-20T23:09:41.112163"
        },
        {
            "id": "8d9f098d-bf8e-425f-b622-73033ff8b97d",
            "slug": "testing-streams",
            "title": "Test Streaming Effects",
            "summary": "Write tests for Stream operations, transformations, and error handling.",
            "skill_level": "advanced",
            "category": "testing",
            "difficulty": "advanced",
            "tags": [
                "testing",
                "streams",
                "data-pipelines"
            ],
            "examples": [
                {
                    "code": "import { describe, it, expect } from \"vitest\"\nimport { Effect, Stream, Chunk, Ref } from \"effect\"\n\ndescribe(\"Stream Testing\", () => {\n  // ============================================\n  // 1. Test basic stream operations\n  // ============================================\n\n  it(\"should transform stream elements\", async () => {\n    const result = await Effect.runPromise(\n      Stream.fromIterable([1, 2, 3, 4, 5]).pipe(\n        Stream.map((n) => n * 2),\n        Stream.runCollect\n      )\n    )\n\n    expect(Chunk.toReadonlyArray(result)).toEqual([2, 4, 6, 8, 10])\n  })\n\n  it(\"should filter stream elements\", async () => {\n    const result = await Effect.runPromise(\n      Stream.fromIterable([1, 2, 3, 4, 5, 6]).pipe(\n        Stream.filter((n) => n % 2 === 0),\n        Stream.runCollect\n      )\n    )\n\n    expect(Chunk.toReadonlyArray(result)).toEqual([2, 4, 6])\n  })\n\n  // ============================================\n  // 2. Test stream aggregation\n  // ============================================\n\n  it(\"should fold stream to single value\", async () => {\n    const result = await Effect.runPromise(\n      Stream.fromIterable([1, 2, 3, 4, 5]).pipe(\n        Stream.runFold(0, (acc, n) => acc + n)\n      )\n    )\n\n    expect(result).toBe(15)\n  })\n\n  it(\"should count stream elements\", async () => {\n    const count = await Effect.runPromise(\n      Stream.fromIterable([\"a\", \"b\", \"c\", \"d\"]).pipe(\n        Stream.runCount\n      )\n    )\n\n    expect(count).toBe(4)\n  })\n\n  // ============================================\n  // 3. Test error handling in streams\n  // ============================================\n\n  it(\"should catch errors in stream\", async () => {\n    const result = await Effect.runPromise(\n      Stream.fromIterable([1, 2, 3]).pipe(\n        Stream.mapEffect((n) =>\n          n === 2\n            ? Effect.fail(new Error(\"Failed on 2\"))\n            : Effect.succeed(n * 10)\n        ),\n        Stream.catchAll((error) =>\n          Stream.succeed(-1)  // Replace error with sentinel\n        ),\n        Stream.runCollect\n      )\n    )\n\n    expect(Chunk.toReadonlyArray(result)).toEqual([10, -1])\n  })\n\n  it(\"should handle errors and continue with orElse\", async () => {\n    const failingStream = Stream.fail(new Error(\"Primary failed\"))\n    const fallbackStream = Stream.fromIterable([1, 2, 3])\n\n    const result = await Effect.runPromise(\n      failingStream.pipe(\n        Stream.orElse(() => fallbackStream),\n        Stream.runCollect\n      )\n    )\n\n    expect(Chunk.toReadonlyArray(result)).toEqual([1, 2, 3])\n  })\n\n  // ============================================\n  // 4. Test stream chunking\n  // ============================================\n\n  it(\"should chunk stream elements\", async () => {\n    const result = await Effect.runPromise(\n      Stream.fromIterable([1, 2, 3, 4, 5]).pipe(\n        Stream.grouped(2),\n        Stream.runCollect\n      )\n    )\n\n    const chunks = Chunk.toReadonlyArray(result).map(Chunk.toReadonlyArray)\n    expect(chunks).toEqual([[1, 2], [3, 4], [5]])\n  })\n\n  // ============================================\n  // 5. Test stream with effects\n  // ============================================\n\n  it(\"should run effects for each element\", async () => {\n    const processed: number[] = []\n\n    await Effect.runPromise(\n      Stream.fromIterable([1, 2, 3]).pipe(\n        Stream.tap((n) =>\n          Effect.sync(() => {\n            processed.push(n)\n          })\n        ),\n        Stream.runDrain\n      )\n    )\n\n    expect(processed).toEqual([1, 2, 3])\n  })\n\n  // ============================================\n  // 6. Test stream resource management\n  // ============================================\n\n  it(\"should release resources on completion\", async () => {\n    const acquired: string[] = []\n    const released: string[] = []\n\n    const managedStream = Stream.acquireRelease(\n      Effect.gen(function* () {\n        acquired.push(\"resource\")\n        return \"resource\"\n      }),\n      () =>\n        Effect.sync(() => {\n          released.push(\"resource\")\n        })\n    ).pipe(\n      Stream.flatMap(() => Stream.fromIterable([1, 2, 3]))\n    )\n\n    await Effect.runPromise(Stream.runDrain(managedStream))\n\n    expect(acquired).toEqual([\"resource\"])\n    expect(released).toEqual([\"resource\"])\n  })\n\n  it(\"should release resources on error\", async () => {\n    const released: string[] = []\n\n    const managedStream = Stream.acquireRelease(\n      Effect.succeed(\"resource\"),\n      () => Effect.sync(() => { released.push(\"released\") })\n    ).pipe(\n      Stream.flatMap(() =>\n        Stream.fromEffect(Effect.fail(new Error(\"Oops\")))\n      )\n    )\n\n    await Effect.runPromise(\n      Stream.runDrain(managedStream).pipe(\n        Effect.catchAll(() => Effect.void)\n      )\n    )\n\n    expect(released).toEqual([\"released\"])\n  })\n\n  // ============================================\n  // 7. Test stream timing with take/drop\n  // ============================================\n\n  it(\"should take first N elements\", async () => {\n    const result = await Effect.runPromise(\n      Stream.fromIterable([1, 2, 3, 4, 5]).pipe(\n        Stream.take(3),\n        Stream.runCollect\n      )\n    )\n\n    expect(Chunk.toReadonlyArray(result)).toEqual([1, 2, 3])\n  })\n\n  it(\"should drop first N elements\", async () => {\n    const result = await Effect.runPromise(\n      Stream.fromIterable([1, 2, 3, 4, 5]).pipe(\n        Stream.drop(2),\n        Stream.runCollect\n      )\n    )\n\n    expect(Chunk.toReadonlyArray(result)).toEqual([3, 4, 5])\n  })\n\n  // ============================================\n  // 8. Test stream merging\n  // ============================================\n\n  it(\"should merge streams\", async () => {\n    const stream1 = Stream.fromIterable([1, 3, 5])\n    const stream2 = Stream.fromIterable([2, 4, 6])\n\n    const result = await Effect.runPromise(\n      Stream.merge(stream1, stream2).pipe(\n        Stream.runCollect\n      )\n    )\n\n    const array = Chunk.toReadonlyArray(result)\n    expect(array).toHaveLength(6)\n    expect(array).toContain(1)\n    expect(array).toContain(6)\n  })\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream.runCollect and assertions to verify stream behavior."
            },
            "created_at": "2026-02-15T21:22:28.931718",
            "updated_at": "2026-02-20T23:09:41.257261"
        },
        {
            "id": "b4353d64-5d8d-4a70-b8c6-99196d7a34bc",
            "slug": "observability-debugging",
            "title": "Debug Effect Programs",
            "summary": "Learn techniques for debugging Effect programs using logging, tap, and cause inspection.",
            "skill_level": "beginner",
            "category": "observability",
            "difficulty": "beginner",
            "tags": [
                "observability",
                "debugging",
                "logging",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, pipe } from \"effect\"\n\n// ============================================\n// 1. Using tap to inspect values\n// ============================================\n\nconst fetchUser = (id: string) =>\n  Effect.succeed({ id, name: \"Alice\", email: \"alice@example.com\" })\n\nconst processUser = (id: string) =>\n  fetchUser(id).pipe(\n    // tap runs an effect for its side effect, then continues with original value\n    Effect.tap((user) => Effect.log(`Fetched user: ${user.name}`)),\n    Effect.map((user) => ({ ...user, processed: true })),\n    Effect.tap((user) => Effect.log(`Processed: ${JSON.stringify(user)}`))\n  )\n\n// ============================================\n// 2. Debug a pipeline\n// ============================================\n\nconst numbers = [1, 2, 3, 4, 5]\n\nconst pipeline = Effect.gen(function* () {\n  yield* Effect.log(\"Starting pipeline\")\n\n  const step1 = numbers.filter((n) => n % 2 === 0)\n  yield* Effect.log(`After filter (even): ${JSON.stringify(step1)}`)\n\n  const step2 = step1.map((n) => n * 10)\n  yield* Effect.log(`After map (*10): ${JSON.stringify(step2)}`)\n\n  const step3 = step2.reduce((a, b) => a + b, 0)\n  yield* Effect.log(`After reduce (sum): ${step3}`)\n\n  return step3\n})\n\n// ============================================\n// 3. Debug errors\n// ============================================\n\nconst riskyOperation = (shouldFail: boolean) =>\n  Effect.gen(function* () {\n    yield* Effect.log(\"Starting risky operation\")\n\n    if (shouldFail) {\n      yield* Effect.log(\"About to fail...\")\n      return yield* Effect.fail(new Error(\"Something went wrong\"))\n    }\n\n    yield* Effect.log(\"Success!\")\n    return \"result\"\n  })\n\nconst debugErrors = riskyOperation(true).pipe(\n  // Log when operation fails\n  Effect.tapError((error) => Effect.log(`Operation failed: ${error.message}`)),\n\n  // Provide a fallback\n  Effect.catchAll((error) => {\n    return Effect.succeed(`Recovered from: ${error.message}`)\n  })\n)\n\n// ============================================\n// 4. Trace execution flow\n// ============================================\n\nconst step = (name: string, value: number) =>\n  Effect.gen(function* () {\n    yield* Effect.log(`[${name}] Input: ${value}`)\n    const result = value * 2\n    yield* Effect.log(`[${name}] Output: ${result}`)\n    return result\n  })\n\nconst tracedWorkflow = Effect.gen(function* () {\n  const a = yield* step(\"Step 1\", 5)\n  const b = yield* step(\"Step 2\", a)\n  const c = yield* step(\"Step 3\", b)\n  yield* Effect.log(`Final result: ${c}`)\n  return c\n})\n\n// ============================================\n// 5. Quick debug with console\n// ============================================\n\n// Sometimes you just need console.log\nconst quickDebug = Effect.gen(function* () {\n  const value = yield* Effect.succeed(42)\n  \n  // Effect.sync wraps side effects\n  yield* Effect.sync(() => console.log(\"Quick debug:\", value))\n  \n  return value\n})\n\n// ============================================\n// 6. Run examples\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Tap Example ===\")\n  yield* processUser(\"123\")\n\n  yield* Effect.log(\"\\n=== Pipeline Debug ===\")\n  yield* pipeline\n\n  yield* Effect.log(\"\\n=== Error Debug ===\")\n  yield* debugErrors\n\n  yield* Effect.log(\"\\n=== Traced Workflow ===\")\n  yield* tracedWorkflow\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.tap and logging to inspect values without changing program flow."
            },
            "created_at": "2026-02-15T21:22:29.037996",
            "updated_at": "2026-02-20T23:09:42.921106"
        },
        {
            "id": "ca818f30-59aa-476c-9a85-13bdfcc0b74b",
            "slug": "data-either",
            "title": "Understand the Either Data Type",
            "summary": "Use Either<E, A> to represent computations that can fail, allowing you to accumulate multiple errors instead of short-circuiting on the first one.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "Either",
                "error-handling",
                "data-type",
                "domain",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Either } from \"effect\";\n\n// Create a Right (success) or Left (failure)\nconst success = Either.right(42); // Either<never, number>\nconst failure = Either.left(\"Something went wrong\"); // Either<string, never>\n\n// Pattern match on Either\nconst result = success.pipe(\n  Either.match({\n    onLeft: (err) => `Error: ${err}`,\n    onRight: (value) => `Value: ${value}`,\n  })\n); // string\n\n// Combine multiple Eithers and accumulate errors\nconst e1 = Either.right(1);\nconst e2 = Either.left(\"fail1\");\nconst e3 = Either.left(\"fail2\");\n\nconst all = [e1, e2, e3].filter(Either.isRight).map(Either.getRight); // [1]\nconst errors = [e1, e2, e3].filter(Either.isLeft).map(Either.getLeft); // [\"fail1\", \"fail2\"]",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Either to model computations that may fail, making errors explicit and type-safe."
            },
            "created_at": "2026-02-15T21:22:12.856705",
            "updated_at": "2026-02-20T23:09:34.881104"
        },
        {
            "id": "32c6bb18-4090-4056-bf1f-5fd4ab43766b",
            "slug": "observability-prometheus",
            "title": "Export Metrics to Prometheus",
            "summary": "Expose application metrics in Prometheus format for monitoring and alerting.",
            "skill_level": "advanced",
            "category": "observability",
            "difficulty": "advanced",
            "tags": [
                "observability",
                "metrics",
                "prometheus",
                "monitoring"
            ],
            "examples": [
                {
                    "code": "import { Effect, Metric, MetricLabel, Duration } from \"effect\"\nimport { HttpServerResponse } from \"@effect/platform\"\n\n// ============================================\n// 1. Define application metrics\n// ============================================\n\n// Counter - counts events\nconst httpRequestsTotal = Metric.counter(\"http_requests_total\", {\n  description: \"Total number of HTTP requests\",\n})\n\n// Counter with labels\nconst httpRequestsByStatus = Metric.counter(\"http_requests_by_status\", {\n  description: \"HTTP requests by status code\",\n})\n\n// Gauge - current value\nconst activeConnections = Metric.gauge(\"active_connections\", {\n  description: \"Number of active connections\",\n})\n\n// Histogram - distribution of values\nconst requestDuration = Metric.histogram(\"http_request_duration_seconds\", {\n  description: \"HTTP request duration in seconds\",\n  boundaries: [0.01, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10],\n})\n\n// Summary - percentiles\nconst responseSizeBytes = Metric.summary(\"http_response_size_bytes\", {\n  description: \"HTTP response size in bytes\",\n  maxAge: Duration.minutes(5),\n  maxSize: 100,\n  quantiles: [0.5, 0.9, 0.99],\n})\n\n// ============================================\n// 2. Instrument code with metrics\n// ============================================\n\nconst handleRequest = (path: string, status: number) =>\n  Effect.gen(function* () {\n    const startTime = Date.now()\n\n    // Increment request counter\n    yield* Metric.increment(httpRequestsTotal)\n\n    // Increment with labels\n    yield* Metric.increment(\n      httpRequestsByStatus.pipe(\n        Metric.tagged(\"status\", String(status)),\n        Metric.tagged(\"path\", path)\n      )\n    )\n\n    // Track active connections\n    yield* Metric.increment(activeConnections)\n\n    // Simulate work\n    yield* Effect.sleep(\"100 millis\")\n\n    // Record duration\n    const duration = (Date.now() - startTime) / 1000\n    yield* Metric.update(requestDuration, duration)\n\n    // Record response size\n    yield* Metric.update(responseSizeBytes, 1024)\n\n    // Decrement active connections\n    yield* Metric.decrement(activeConnections)\n  })\n\n// ============================================\n// 3. Prometheus text format exporter\n// ============================================\n\ninterface MetricSnapshot {\n  name: string\n  type: \"counter\" | \"gauge\" | \"histogram\" | \"summary\"\n  help: string\n  values: Array<{\n    labels: Record<string, string>\n    value: number\n  }>\n  // For histograms\n  buckets?: Array<{\n    le: number\n    count: number\n    labels?: Record<string, string>\n  }>\n  sum?: number\n  count?: number\n}\n\nconst formatPrometheusMetrics = (metrics: MetricSnapshot[]): string => {\n  const lines: string[] = []\n\n  for (const metric of metrics) {\n    // Help line\n    lines.push(`# HELP ${metric.name} ${metric.help}`)\n    lines.push(`# TYPE ${metric.name} ${metric.type}`)\n\n    // Values\n    for (const { labels, value } of metric.values) {\n      const labelStr = Object.entries(labels)\n        .map(([k, v]) => `${k}=\"${v}\"`)\n        .join(\",\")\n\n      if (labelStr) {\n        lines.push(`${metric.name}{${labelStr}} ${value}`)\n      } else {\n        lines.push(`${metric.name} ${value}`)\n      }\n    }\n\n    // Histogram buckets\n    if (metric.buckets) {\n      for (const bucket of metric.buckets) {\n        const labelStr = Object.entries(bucket.labels || {})\n          .map(([k, v]) => `${k}=\"${v}\"`)\n          .concat([`le=\"${bucket.le}\"`])\n          .join(\",\")\n        lines.push(`${metric.name}_bucket{${labelStr}} ${bucket.count}`)\n      }\n      lines.push(`${metric.name}_sum ${metric.sum}`)\n      lines.push(`${metric.name}_count ${metric.count}`)\n    }\n\n    lines.push(\"\")\n  }\n\n  return lines.join(\"\\n\")\n}\n\n// ============================================\n// 4. /metrics endpoint handler\n// ============================================\n\nconst metricsHandler = Effect.gen(function* () {\n  // In real implementation, read from Effect's MetricRegistry\n  const metrics: MetricSnapshot[] = [\n    {\n      name: \"http_requests_total\",\n      type: \"counter\",\n      help: \"Total number of HTTP requests\",\n      values: [{ labels: {}, value: 1234 }],\n    },\n    {\n      name: \"http_requests_by_status\",\n      type: \"counter\",\n      help: \"HTTP requests by status code\",\n      values: [\n        { labels: { status: \"200\", path: \"/api/users\" }, value: 1000 },\n        { labels: { status: \"404\", path: \"/api/users\" }, value: 50 },\n        { labels: { status: \"500\", path: \"/api/users\" }, value: 10 },\n      ],\n    },\n    {\n      name: \"active_connections\",\n      type: \"gauge\",\n      help: \"Number of active connections\",\n      values: [{ labels: {}, value: 42 }],\n    },\n    {\n      name: \"http_request_duration_seconds\",\n      type: \"histogram\",\n      help: \"HTTP request duration in seconds\",\n      values: [],\n      buckets: [\n        { le: 0.01, count: 100 },\n        { le: 0.05, count: 500 },\n        { le: 0.1, count: 800 },\n        { le: 0.25, count: 950 },\n        { le: 0.5, count: 990 },\n        { le: 1, count: 999 },\n        { le: Infinity, count: 1000 },\n      ],\n      sum: 123.456,\n      count: 1000,\n    },\n  ]\n\n  const body = formatPrometheusMetrics(metrics)\n\n  return HttpServerResponse.text(body, {\n    headers: {\n      \"Content-Type\": \"text/plain; version=0.0.4; charset=utf-8\",\n    },\n  })\n})\n\n// ============================================\n// 5. Example output\n// ============================================\n\n/*\n# HELP http_requests_total Total number of HTTP requests\n# TYPE http_requests_total counter\nhttp_requests_total 1234\n\n# HELP http_requests_by_status HTTP requests by status code\n# TYPE http_requests_by_status counter\nhttp_requests_by_status{status=\"200\",path=\"/api/users\"} 1000\nhttp_requests_by_status{status=\"404\",path=\"/api/users\"} 50\nhttp_requests_by_status{status=\"500\",path=\"/api/users\"} 10\n\n# HELP active_connections Number of active connections\n# TYPE active_connections gauge\nactive_connections 42\n\n# HELP http_request_duration_seconds HTTP request duration in seconds\n# TYPE http_request_duration_seconds histogram\nhttp_request_duration_seconds_bucket{le=\"0.01\"} 100\nhttp_request_duration_seconds_bucket{le=\"0.05\"} 500\nhttp_request_duration_seconds_bucket{le=\"0.1\"} 800\nhttp_request_duration_seconds_bucket{le=\"+Inf\"} 1000\nhttp_request_duration_seconds_sum 123.456\nhttp_request_duration_seconds_count 1000\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect metrics and expose a /metrics endpoint for Prometheus scraping."
            },
            "created_at": "2026-02-15T21:22:29.793266",
            "updated_at": "2026-02-20T23:09:42.728151"
        },
        {
            "id": "d684a442-cd2e-48c4-bc17-6a5a466b2921",
            "slug": "observability-alerting",
            "title": "Set Up Alerting",
            "summary": "Configure alerts to notify you when your Effect application has problems.",
            "skill_level": "advanced",
            "category": "observability",
            "difficulty": "advanced",
            "tags": [
                "observability",
                "alerting",
                "monitoring",
                "sre"
            ],
            "examples": [
                {
                    "code": "import { Effect, Metric, Schedule, Duration, Ref } from \"effect\"\n\n// ============================================\n// 1. Define alertable conditions\n// ============================================\n\ninterface Alert {\n  readonly name: string\n  readonly severity: \"critical\" | \"warning\" | \"info\"\n  readonly message: string\n  readonly timestamp: Date\n  readonly labels: Record<string, string>\n}\n\ninterface AlertRule {\n  readonly name: string\n  readonly condition: Effect.Effect<boolean>\n  readonly severity: \"critical\" | \"warning\" | \"info\"\n  readonly message: string\n  readonly labels: Record<string, string>\n  readonly forDuration: Duration.DurationInput\n}\n\n// ============================================\n// 2. Define alert rules\n// ============================================\n\nconst createAlertRules = (metrics: {\n  errorRate: () => Effect.Effect<number>\n  latencyP99: () => Effect.Effect<number>\n  availability: () => Effect.Effect<number>\n}): AlertRule[] => [\n  {\n    name: \"HighErrorRate\",\n    condition: metrics.errorRate().pipe(Effect.map((rate) => rate > 0.01)),\n    severity: \"critical\",\n    message: \"Error rate exceeds 1%\",\n    labels: { team: \"backend\", service: \"api\" },\n    forDuration: \"5 minutes\",\n  },\n  {\n    name: \"HighLatency\",\n    condition: metrics.latencyP99().pipe(Effect.map((p99) => p99 > 2)),\n    severity: \"warning\",\n    message: \"P99 latency exceeds 2 seconds\",\n    labels: { team: \"backend\", service: \"api\" },\n    forDuration: \"10 minutes\",\n  },\n  {\n    name: \"LowAvailability\",\n    condition: metrics.availability().pipe(Effect.map((avail) => avail < 99.9)),\n    severity: \"critical\",\n    message: \"Availability below 99.9% SLO\",\n    labels: { team: \"backend\", service: \"api\" },\n    forDuration: \"5 minutes\",\n  },\n  {\n    name: \"ErrorBudgetLow\",\n    condition: Effect.succeed(false), // Implement based on error budget calc\n    severity: \"warning\",\n    message: \"Error budget below 25%\",\n    labels: { team: \"backend\", service: \"api\" },\n    forDuration: \"0 seconds\",\n  },\n]\n\n// ============================================\n// 3. Alert manager\n// ============================================\n\ninterface AlertState {\n  readonly firing: Map<string, { since: Date; alert: Alert }>\n  readonly resolved: Alert[]\n}\n\nconst makeAlertManager = Effect.gen(function* () {\n  const state = yield* Ref.make<AlertState>({\n    firing: new Map(),\n    resolved: [],\n  })\n\n  const checkRule = (rule: AlertRule) =>\n    Effect.gen(function* () {\n      const isTriggered = yield* rule.condition\n\n      yield* Ref.modify(state, (s) => {\n        const firing = new Map(s.firing)\n        const resolved = [...s.resolved]\n        const key = rule.name\n\n        if (isTriggered) {\n          if (!firing.has(key)) {\n            // New alert\n            firing.set(key, {\n              since: new Date(),\n              alert: {\n                name: rule.name,\n                severity: rule.severity,\n                message: rule.message,\n                timestamp: new Date(),\n                labels: rule.labels,\n              },\n            })\n          }\n        } else {\n          if (firing.has(key)) {\n            // Alert resolved\n            const prev = firing.get(key)!\n            resolved.push({\n              ...prev.alert,\n              message: `[RESOLVED] ${prev.alert.message}`,\n              timestamp: new Date(),\n            })\n            firing.delete(key)\n          }\n        }\n\n        return [undefined, { firing, resolved }]\n      })\n    })\n\n  const getActiveAlerts = () =>\n    Ref.get(state).pipe(\n      Effect.map((s) => Array.from(s.firing.values()).map((f) => f.alert))\n    )\n\n  const getRecentResolved = () =>\n    Ref.get(state).pipe(Effect.map((s) => s.resolved.slice(-10)))\n\n  return {\n    checkRule,\n    getActiveAlerts,\n    getRecentResolved,\n  }\n})\n\n// ============================================\n// 4. Alert notification\n// ============================================\n\ninterface NotificationChannel {\n  readonly send: (alert: Alert) => Effect.Effect<void>\n}\n\nconst slackChannel: NotificationChannel = {\n  send: (alert) =>\n    Effect.gen(function* () {\n      const emoji =\n        alert.severity === \"critical\"\n          ? \"\ud83d\udd34\"\n          : alert.severity === \"warning\"\n            ? \"\ud83d\udfe1\"\n            : \"\ud83d\udd35\"\n\n      yield* Effect.log(`${emoji} [${alert.severity.toUpperCase()}] ${alert.name}`).pipe(\n        Effect.annotateLogs({\n          message: alert.message,\n          labels: JSON.stringify(alert.labels),\n        })\n      )\n\n      // In real implementation: call Slack API\n    }),\n}\n\nconst pagerDutyChannel: NotificationChannel = {\n  send: (alert) =>\n    Effect.gen(function* () {\n      if (alert.severity === \"critical\") {\n        yield* Effect.log(\"PagerDuty: Creating incident\").pipe(\n          Effect.annotateLogs({ alert: alert.name })\n        )\n        // In real implementation: call PagerDuty API\n      }\n    }),\n}\n\n// ============================================\n// 5. Alert evaluation loop\n// ============================================\n\nconst runAlertEvaluation = (\n  rules: AlertRule[],\n  channels: NotificationChannel[],\n  interval: Duration.DurationInput\n) =>\n  Effect.gen(function* () {\n    const alertManager = yield* makeAlertManager\n    const previousAlerts = yield* Ref.make(new Set<string>())\n\n    yield* Effect.forever(\n      Effect.gen(function* () {\n        // Check all rules\n        for (const rule of rules) {\n          yield* alertManager.checkRule(rule)\n        }\n\n        // Get current active alerts\n        const active = yield* alertManager.getActiveAlerts()\n        const current = new Set(active.map((a) => a.name))\n        const previous = yield* Ref.get(previousAlerts)\n\n        // Find newly firing alerts\n        for (const alert of active) {\n          if (!previous.has(alert.name)) {\n            // New alert - send notifications\n            for (const channel of channels) {\n              yield* channel.send(alert)\n            }\n          }\n        }\n\n        yield* Ref.set(previousAlerts, current)\n        yield* Effect.sleep(interval)\n      })\n    )\n  })\n\n// ============================================\n// 6. Prometheus alerting rules (YAML)\n// ============================================\n\nconst prometheusAlertRules = `\ngroups:\n  - name: effect-app-alerts\n    rules:\n      - alert: HighErrorRate\n        expr: |\n          sum(rate(http_errors_total[5m]))\n          /\n          sum(rate(http_requests_total[5m]))\n          > 0.01\n        for: 5m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"High error rate detected\"\n          description: \"Error rate is {{ $value | humanizePercentage }}\"\n\n      - alert: HighLatency\n        expr: |\n          histogram_quantile(0.99,\n            sum(rate(http_request_duration_seconds_bucket[5m])) by (le)\n          ) > 2\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High P99 latency\"\n          description: \"P99 latency is {{ $value }}s\"\n\n      - alert: SLOViolation\n        expr: |\n          sum(rate(http_requests_total{status!~\"5..\"}[30m]))\n          /\n          sum(rate(http_requests_total[30m]))\n          < 0.999\n        for: 5m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"SLO violation\"\n          description: \"Availability is {{ $value | humanizePercentage }}\"\n`",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Create alerts based on SLOs and symptoms, not causes."
            },
            "created_at": "2026-02-15T21:22:30.044205",
            "updated_at": "2026-02-20T23:09:42.874691"
        },
        {
            "id": "4ca22671-9270-4062-87ec-ff6e94b0afe7",
            "slug": "pipeline-dead-letter-queue",
            "title": "Implement Dead Letter Queues",
            "summary": "Route failed items to a separate queue for later analysis and reprocessing.",
            "skill_level": "advanced",
            "category": "building-data-pipelines",
            "difficulty": "advanced",
            "tags": [
                "data-pipelines",
                "dead-letter-queue",
                "error-handling",
                "resilience"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Queue, Chunk, Ref, Data } from \"effect\"\n\n// ============================================\n// 1. Define DLQ types\n// ============================================\n\ninterface DeadLetterItem<T> {\n  readonly item: T\n  readonly error: unknown\n  readonly timestamp: Date\n  readonly attempts: number\n  readonly context: Record<string, unknown>\n}\n\ninterface ProcessingResult<T, R> {\n  readonly _tag: \"Success\" | \"Failure\"\n}\n\nclass Success<T, R> implements ProcessingResult<T, R> {\n  readonly _tag = \"Success\"\n  constructor(\n    readonly item: T,\n    readonly result: R\n  ) {}\n}\n\nclass Failure<T> implements ProcessingResult<T, never> {\n  readonly _tag = \"Failure\"\n  constructor(\n    readonly item: T,\n    readonly error: unknown,\n    readonly attempts: number\n  ) {}\n}\n\n// ============================================\n// 2. Create a DLQ service\n// ============================================\n\nconst makeDLQ = <T>() =>\n  Effect.gen(function* () {\n    const queue = yield* Queue.unbounded<DeadLetterItem<T>>()\n    const countRef = yield* Ref.make(0)\n\n    return {\n      send: (item: T, error: unknown, attempts: number, context: Record<string, unknown> = {}) =>\n        Effect.gen(function* () {\n          yield* Queue.offer(queue, {\n            item,\n            error,\n            timestamp: new Date(),\n            attempts,\n            context,\n          })\n          yield* Ref.update(countRef, (n) => n + 1)\n          yield* Effect.log(`DLQ: Added item (total: ${(yield* Ref.get(countRef))})`)\n        }),\n\n      getAll: () =>\n        Effect.gen(function* () {\n          const items: DeadLetterItem<T>[] = []\n          while (!(yield* Queue.isEmpty(queue))) {\n            const item = yield* Queue.poll(queue)\n            if (item._tag === \"Some\") {\n              items.push(item.value)\n            }\n          }\n          return items\n        }),\n\n      count: () => Ref.get(countRef),\n\n      queue,\n    }\n  })\n\n// ============================================\n// 3. Process with DLQ\n// ============================================\n\ninterface Order {\n  id: string\n  amount: number\n}\n\nconst processOrder = (order: Order): Effect.Effect<string, Error> =>\n  Effect.gen(function* () {\n    // Simulate random failures\n    if (order.amount < 0) {\n      return yield* Effect.fail(new Error(\"Invalid amount\"))\n    }\n    if (order.id === \"fail\") {\n      return yield* Effect.fail(new Error(\"Processing failed\"))\n    }\n    yield* Effect.sleep(\"10 millis\")\n    return `Processed order ${order.id}: $${order.amount}`\n  })\n\nconst processWithRetryAndDLQ = (\n  orders: Stream.Stream<Order>,\n  maxRetries: number = 3\n) =>\n  Effect.gen(function* () {\n    const dlq = yield* makeDLQ<Order>()\n\n    const results = yield* orders.pipe(\n      Stream.mapEffect((order) =>\n        Effect.gen(function* () {\n          let lastError: unknown\n          for (let attempt = 1; attempt <= maxRetries; attempt++) {\n            const result = yield* processOrder(order).pipe(\n              Effect.map((r) => new Success(order, r)),\n              Effect.catchAll((error) =>\n                Effect.gen(function* () {\n                  yield* Effect.log(`Attempt ${attempt}/${maxRetries} failed for ${order.id}`)\n                  lastError = error\n                  if (attempt < maxRetries) {\n                    yield* Effect.sleep(\"100 millis\")  // Backoff\n                  }\n                  return new Failure(order, error, attempt) as ProcessingResult<Order, string>\n                })\n              )\n            )\n\n            if (result._tag === \"Success\") {\n              return result\n            }\n          }\n\n          // All retries exhausted - send to DLQ\n          yield* dlq.send(order, lastError, maxRetries, { orderId: order.id })\n          return new Failure(order, lastError, maxRetries)\n        })\n      ),\n      Stream.runCollect\n    )\n\n    const successful = Chunk.filter(results, (r): r is Success<Order, string> => r._tag === \"Success\")\n    const failed = Chunk.filter(results, (r): r is Failure<Order> => r._tag === \"Failure\")\n\n    yield* Effect.log(`\\nResults: ${Chunk.size(successful)} success, ${Chunk.size(failed)} failed`)\n\n    // Get DLQ contents\n    const dlqItems = yield* dlq.getAll()\n    if (dlqItems.length > 0) {\n      yield* Effect.log(\"\\n=== Dead Letter Queue Contents ===\")\n      for (const item of dlqItems) {\n        yield* Effect.log(\n          `- Order ${item.item.id}: ${item.error} (attempts: ${item.attempts})`\n        )\n      }\n    }\n\n    return { successful, failed, dlqItems }\n  })\n\n// ============================================\n// 4. DLQ reprocessing\n// ============================================\n\nconst reprocessDLQ = <T>(\n  dlqItems: DeadLetterItem<T>[],\n  processor: (item: T) => Effect.Effect<void, Error>\n) =>\n  Effect.gen(function* () {\n    yield* Effect.log(`Reprocessing ${dlqItems.length} DLQ items...`)\n\n    for (const dlqItem of dlqItems) {\n      const result = yield* processor(dlqItem.item).pipe(\n        Effect.map(() => \"success\" as const),\n        Effect.catchAll(() => Effect.succeed(\"failed\" as const))\n      )\n\n      yield* Effect.log(\n        `Reprocess ${JSON.stringify(dlqItem.item)}: ${result}`\n      )\n    }\n  })\n\n// ============================================\n// 5. Run example\n// ============================================\n\nconst program = Effect.gen(function* () {\n  const orders: Order[] = [\n    { id: \"1\", amount: 100 },\n    { id: \"2\", amount: 200 },\n    { id: \"fail\", amount: 50 },    // Will fail all retries\n    { id: \"3\", amount: 300 },\n    { id: \"4\", amount: -10 },       // Invalid amount\n    { id: \"5\", amount: 150 },\n  ]\n\n  yield* Effect.log(\"=== Processing Orders ===\\n\")\n  const { dlqItems } = yield* processWithRetryAndDLQ(Stream.fromIterable(orders), 3)\n\n  if (dlqItems.length > 0) {\n    yield* Effect.log(\"\\n=== Attempting DLQ Reprocessing ===\")\n    yield* reprocessDLQ(dlqItems, (order) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`Manual fix for order ${order.id}`)\n      })\n    )\n  }\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Capture failed items with context for debugging and retry instead of losing them."
            },
            "created_at": "2026-02-15T21:22:27.16307",
            "updated_at": "2026-02-20T23:09:43.217218"
        },
        {
            "id": "6333aae7-ec63-467d-98d6-a541807158de",
            "slug": "resource-management-guarantee-cleanup",
            "title": "Guarantee Cleanup Even on Failure",
            "summary": "Effect.acquireRelease and Effect.scoped ensure that release logic runs even when the use phase fails or is interrupted.",
            "skill_level": "beginner",
            "category": "resource-management",
            "difficulty": "beginner",
            "tags": [
                "resource management",
                "cleanup",
                "acquireRelease",
                "finalizer",
                "scope"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\"\n\nconst acquire = Effect.sync(() => ({ id: 1 }))\nconst release = () => Effect.log(\"Released!\")\n\nconst program = Effect.acquireRelease(acquire, release).pipe(\n  Effect.flatMap(() => Effect.fail(\"oops\")),\n  Effect.scoped\n)\n\nEffect.runPromise(program).catch(() => {})\n// Logs: Released!",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Release logic always runs, even on failure or interruption."
            },
            "created_at": "2026-02-15T21:22:30.809192",
            "updated_at": "2026-02-20T23:09:32.603522"
        },
        {
            "id": "03eae849-6686-4365-a649-d8b3e8a6abaf",
            "slug": "constructor-sync-async",
            "title": "Creating from Synchronous and Callback Code",
            "summary": "Use sync and async to lift synchronous or callback-based computations into Effect, enabling safe and composable interop with legacy code.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "sync",
                "async",
                "constructor",
                "effect",
                "interop",
                "callback",
                "legacy"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Synchronous: Wrap a computation that is guaranteed not to throw\nconst effectSync = Effect.sync(() => Math.random()); // Effect<never, number, never>\n\n// Callback-based: Wrap a Node.js-style callback API\nfunction legacyReadFile(\n  path: string,\n  cb: (err: Error | null, data?: string) => void\n) {\n  setTimeout(() => cb(null, \"file contents\"), 10);\n}\n\nconst effectAsync = Effect.async<string, Error>((resume) => {\n  legacyReadFile(\"file.txt\", (err, data) => {\n    if (err) resume(Effect.fail(err));\n    else resume(Effect.succeed(data!));\n  });\n}); // Effect<string, Error, never>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use sync and async to create Effects from synchronous or callback-based computations, making them composable and type-safe."
            },
            "created_at": "2026-02-15T21:22:13.643166",
            "updated_at": "2026-02-20T23:09:35.187976"
        },
        {
            "id": "e1bd6cfd-96e7-4e1e-a342-23ae3f137bec",
            "slug": "tooling-ci-cd",
            "title": "Set Up CI/CD for Effect Projects",
            "summary": "Configure GitHub Actions to build, test, and deploy Effect applications.",
            "skill_level": "intermediate",
            "category": "tooling-and-debugging",
            "difficulty": "intermediate",
            "tags": [
                "tooling",
                "ci-cd",
                "github-actions",
                "deployment"
            ],
            "examples": [
                {
                    "code": "# .github/workflows/ci.yml\nname: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [20.x, 22.x]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Bun\n        uses: oven-sh/setup-bun@v1\n        with:\n          bun-version: latest\n\n      - name: Install dependencies\n        run: bun install\n\n      - name: Type check\n        run: bun run typecheck\n\n      - name: Lint\n        run: bun run lint\n\n      - name: Test\n        run: bun run test\n\n      - name: Build\n        run: bun run build",
                    "language": "yaml",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use GitHub Actions with proper caching for fast Effect project CI/CD."
            },
            "created_at": "2026-02-15T21:22:30.389077",
            "updated_at": "2026-02-20T23:09:42.25241"
        },
        {
            "id": "173df7d8-a041-4ad7-a22b-839fe67a5a44",
            "slug": "tooling-devtools",
            "title": "Use Effect DevTools",
            "summary": "Debug Effect applications with specialized developer tools.",
            "skill_level": "intermediate",
            "category": "tooling-and-debugging",
            "difficulty": "intermediate",
            "tags": [
                "tooling",
                "debugging",
                "devtools"
            ],
            "examples": [
                {
                    "code": "import { Effect, Logger, LogLevel, FiberRef, Cause } from \"effect\"\n\n// ============================================\n// 1. Verbose logging for development\n// ============================================\n\nconst debugProgram = Effect.gen(function* () {\n  yield* Effect.logDebug(\"Starting operation\")\n\n  const result = yield* someEffect.pipe(\n    Effect.tap((value) => Effect.logDebug(`Got value: ${value}`))\n  )\n\n  yield* Effect.logDebug(\"Operation complete\")\n  return result\n})\n\n// Run with debug logging enabled\nconst runWithDebug = debugProgram.pipe(\n  Logger.withMinimumLogLevel(LogLevel.Debug),\n  Effect.runPromise\n)\n\n// ============================================\n// 2. Fiber supervision and introspection\n// ============================================\n\nconst inspectFibers = Effect.gen(function* () {\n  // Fork some fibers\n  const fiber1 = yield* Effect.fork(Effect.sleep(\"1 second\"))\n  const fiber2 = yield* Effect.fork(Effect.sleep(\"2 seconds\"))\n\n  // Get fiber IDs\n  yield* Effect.log(`Fiber 1 ID: ${fiber1.id()}`)\n  yield* Effect.log(`Fiber 2 ID: ${fiber2.id()}`)\n\n  // Check fiber status\n  const status1 = yield* fiber1.status\n  yield* Effect.log(`Fiber 1 status: ${status1._tag}`)\n})\n\n// ============================================\n// 3. Trace execution with spans\n// ============================================\n\nconst tracedProgram = Effect.gen(function* () {\n  yield* Effect.log(\"=== Starting traced program ===\")\n\n  yield* Effect.gen(function* () {\n    yield* Effect.log(\"Step 1: Initialize\")\n    yield* Effect.sleep(\"100 millis\")\n  }).pipe(Effect.withLogSpan(\"initialization\"))\n\n  yield* Effect.gen(function* () {\n    yield* Effect.log(\"Step 2: Process\")\n    yield* Effect.sleep(\"200 millis\")\n  }).pipe(Effect.withLogSpan(\"processing\"))\n\n  yield* Effect.gen(function* () {\n    yield* Effect.log(\"Step 3: Finalize\")\n    yield* Effect.sleep(\"50 millis\")\n  }).pipe(Effect.withLogSpan(\"finalization\"))\n\n  yield* Effect.log(\"=== Program complete ===\")\n})\n\n// ============================================\n// 4. Error cause inspection\n// ============================================\n\nconst debugErrors = Effect.gen(function* () {\n  const failingEffect = Effect.gen(function* () {\n    yield* Effect.fail(new Error(\"Inner error\"))\n  }).pipe(\n    Effect.flatMap(() => Effect.fail(new Error(\"Outer error\")))\n  )\n\n  yield* failingEffect.pipe(\n    Effect.catchAllCause((cause) =>\n      Effect.gen(function* () {\n        yield* Effect.log(\"=== Error Cause Analysis ===\")\n        yield* Effect.log(`Pretty printed:\\n${Cause.pretty(cause)}`)\n        yield* Effect.log(`Is failure: ${Cause.isFailure(cause)}`)\n        yield* Effect.log(`Is interrupted: ${Cause.isInterrupted(cause)}`)\n\n        // Extract all failures\n        const failures = Cause.failures(cause)\n        yield* Effect.log(`Failures: ${JSON.stringify([...failures])}`)\n\n        return \"recovered\"\n      })\n    )\n  )\n})\n\n// ============================================\n// 5. Context inspection\n// ============================================\n\nimport { Context } from \"effect\"\n\nclass Config extends Context.Tag(\"Config\")<Config, { debug: boolean }>() {}\n\nconst inspectContext = Effect.gen(function* () {\n  const context = yield* Effect.context<Config>()\n\n  yield* Effect.log(\"=== Context Contents ===\")\n  yield* Effect.log(`Has Config: ${Context.getOption(context, Config)._tag}`)\n})\n\n// ============================================\n// 6. Custom logger for development\n// ============================================\n\nconst devLogger = Logger.make(({ logLevel, message, date, annotations, spans }) => {\n  const timestamp = date.toISOString()\n  const level = logLevel.label.padEnd(7)\n  const spanInfo = spans.length > 0\n    ? ` [${[...spans].map(([name]) => name).join(\" > \")}]`\n    : \"\"\n  const annotationInfo = Object.keys(annotations).length > 0\n    ? ` ${JSON.stringify(Object.fromEntries(annotations))}`\n    : \"\"\n\n  console.log(`${timestamp} ${level}${spanInfo} ${message}${annotationInfo}`)\n})\n\nconst withDevLogger = <A, E, R>(effect: Effect.Effect<A, E, R>) =>\n  effect.pipe(\n    Effect.provide(Logger.replace(Logger.defaultLogger, devLogger))\n  )\n\n// ============================================\n// 7. Runtime metrics\n// ============================================\n\nconst showRuntimeMetrics = Effect.gen(function* () {\n  const runtime = yield* Effect.runtime()\n\n  yield* Effect.log(\"=== Runtime Info ===\")\n  // Access runtime configuration\n  const fiberRefs = runtime.fiberRefs\n\n  yield* Effect.log(\"FiberRefs available\")\n})\n\n// ============================================\n// 8. Putting it all together\n// ============================================\n\nconst debugSession = Effect.gen(function* () {\n  yield* Effect.log(\"Starting debug session\")\n\n  // Run with all debugging enabled\n  yield* tracedProgram.pipe(\n    withDevLogger,\n    Logger.withMinimumLogLevel(LogLevel.Debug)\n  )\n\n  yield* debugErrors\n\n  yield* Effect.log(\"Debug session complete\")\n})\n\nEffect.runPromise(debugSession)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect's built-in debugging features and logging for development."
            },
            "created_at": "2026-02-15T21:22:30.565406",
            "updated_at": "2026-02-20T23:09:42.451314"
        },
        {
            "id": "9fe0c69b-6941-43eb-bb81-7bae456fead4",
            "slug": "tooling-profiling",
            "title": "Profile Effect Applications",
            "summary": "Measure and optimize performance of Effect applications.",
            "skill_level": "advanced",
            "category": "tooling-and-debugging",
            "difficulty": "advanced",
            "tags": [
                "tooling",
                "profiling",
                "performance",
                "optimization"
            ],
            "examples": [
                {
                    "code": "import { Effect, Duration } from \"effect\"\n\n// ============================================\n// 1. Time individual operations\n// ============================================\n\nconst timeOperation = <A, E, R>(\n  name: string,\n  effect: Effect.Effect<A, E, R>\n) =>\n  Effect.gen(function* () {\n    const startTime = Date.now()\n\n    const result = yield* effect\n\n    const duration = Date.now() - startTime\n    yield* Effect.log(`${name}: ${duration}ms`)\n\n    return result\n  })\n\n// Usage\nconst program = Effect.gen(function* () {\n  yield* timeOperation(\"database-query\", queryDatabase())\n  yield* timeOperation(\"api-call\", callExternalApi())\n  yield* timeOperation(\"processing\", processData())\n})\n\n// ============================================\n// 2. Use withLogSpan for nested timing\n// ============================================\n\nconst timedProgram = Effect.gen(function* () {\n  yield* Effect.log(\"Starting\")\n\n  yield* fetchUsers().pipe(Effect.withLogSpan(\"fetchUsers\"))\n\n  yield* processUsers().pipe(Effect.withLogSpan(\"processUsers\"))\n\n  yield* saveResults().pipe(Effect.withLogSpan(\"saveResults\"))\n\n  yield* Effect.log(\"Complete\")\n}).pipe(Effect.withLogSpan(\"total\"))\n\n// ============================================\n// 3. Collect timing metrics\n// ============================================\n\nimport { Metric } from \"effect\"\n\nconst operationDuration = Metric.histogram(\"operation_duration_ms\", {\n  description: \"Operation duration in milliseconds\",\n  boundaries: [1, 5, 10, 25, 50, 100, 250, 500, 1000],\n})\n\nconst profiledEffect = <A, E, R>(\n  name: string,\n  effect: Effect.Effect<A, E, R>\n) =>\n  Effect.gen(function* () {\n    const startTime = Date.now()\n\n    const result = yield* effect\n\n    const duration = Date.now() - startTime\n    yield* Metric.update(\n      operationDuration.pipe(Metric.tagged(\"operation\", name)),\n      duration\n    )\n\n    return result\n  })\n\n// ============================================\n// 4. Memory profiling\n// ============================================\n\nconst logMemoryUsage = Effect.sync(() => {\n  const usage = process.memoryUsage()\n  return {\n    heapUsed: Math.round(usage.heapUsed / 1024 / 1024),\n    heapTotal: Math.round(usage.heapTotal / 1024 / 1024),\n    external: Math.round(usage.external / 1024 / 1024),\n    rss: Math.round(usage.rss / 1024 / 1024),\n  }\n})\n\nconst withMemoryLogging = <A, E, R>(effect: Effect.Effect<A, E, R>) =>\n  Effect.gen(function* () {\n    const before = yield* logMemoryUsage\n    yield* Effect.log(`Memory before: ${JSON.stringify(before)}MB`)\n\n    const result = yield* effect\n\n    const after = yield* logMemoryUsage\n    yield* Effect.log(`Memory after: ${JSON.stringify(after)}MB`)\n    yield* Effect.log(`Memory delta: ${after.heapUsed - before.heapUsed}MB`)\n\n    return result\n  })\n\n// ============================================\n// 5. CPU profiling with Node.js inspector\n// ============================================\n\nconst withCpuProfile = <A, E, R>(\n  name: string,\n  effect: Effect.Effect<A, E, R>\n) =>\n  Effect.gen(function* () {\n    // Start CPU profiler (requires --inspect flag)\n    const inspector = yield* Effect.try(() => {\n      const { Session } = require(\"inspector\")\n      const session = new Session()\n      session.connect()\n      return session\n    })\n\n    yield* Effect.try(() => {\n      inspector.post(\"Profiler.enable\")\n      inspector.post(\"Profiler.start\")\n    })\n\n    const result = yield* effect\n\n    // Stop and save profile\n    yield* Effect.async<void>((resume) => {\n      inspector.post(\"Profiler.stop\", (err: Error, { profile }: any) => {\n        if (err) {\n          resume(Effect.fail(err))\n        } else {\n          const fs = require(\"fs\")\n          fs.writeFileSync(\n            `${name}-${Date.now()}.cpuprofile`,\n            JSON.stringify(profile)\n          )\n          resume(Effect.void)\n        }\n      })\n    })\n\n    return result\n  })\n\n// ============================================\n// 6. Benchmark specific operations\n// ============================================\n\nconst benchmark = <A, E, R>(\n  name: string,\n  effect: Effect.Effect<A, E, R>,\n  iterations: number = 100\n) =>\n  Effect.gen(function* () {\n    const times: number[] = []\n\n    for (let i = 0; i < iterations; i++) {\n      const start = performance.now()\n      yield* effect\n      times.push(performance.now() - start)\n    }\n\n    const sorted = times.sort((a, b) => a - b)\n    const stats = {\n      min: sorted[0],\n      max: sorted[sorted.length - 1],\n      median: sorted[Math.floor(sorted.length / 2)],\n      p95: sorted[Math.floor(sorted.length * 0.95)],\n      p99: sorted[Math.floor(sorted.length * 0.99)],\n      mean: times.reduce((a, b) => a + b, 0) / times.length,\n    }\n\n    yield* Effect.log(`Benchmark \"${name}\" (${iterations} iterations):`)\n    yield* Effect.log(`  Min:    ${stats.min.toFixed(2)}ms`)\n    yield* Effect.log(`  Max:    ${stats.max.toFixed(2)}ms`)\n    yield* Effect.log(`  Mean:   ${stats.mean.toFixed(2)}ms`)\n    yield* Effect.log(`  Median: ${stats.median.toFixed(2)}ms`)\n    yield* Effect.log(`  P95:    ${stats.p95.toFixed(2)}ms`)\n    yield* Effect.log(`  P99:    ${stats.p99.toFixed(2)}ms`)\n\n    return stats\n  })\n\n// ============================================\n// 7. Profile concurrent operations\n// ============================================\n\nconst profileConcurrency = Effect.gen(function* () {\n  const items = Array.from({ length: 100 }, (_, i) => i)\n\n  // Sequential\n  yield* benchmark(\n    \"sequential\",\n    Effect.forEach(items, (i) => Effect.succeed(i * 2), { concurrency: 1 }),\n    10\n  )\n\n  // Parallel unbounded\n  yield* benchmark(\n    \"parallel-unbounded\",\n    Effect.forEach(items, (i) => Effect.succeed(i * 2), {\n      concurrency: \"unbounded\",\n    }),\n    10\n  )\n\n  // Parallel limited\n  yield* benchmark(\n    \"parallel-10\",\n    Effect.forEach(items, (i) => Effect.succeed(i * 2), { concurrency: 10 }),\n    10\n  )\n})\n\n// ============================================\n// 8. Run profiling\n// ============================================\n\nconst profilingSession = Effect.gen(function* () {\n  yield* Effect.log(\"=== Profiling Session ===\")\n\n  yield* withMemoryLogging(\n    benchmark(\"my-operation\", someEffect, 50)\n  )\n\n  yield* profileConcurrency\n})\n\nEffect.runPromise(profilingSession)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect's timing features and Node.js profilers to find performance bottlenecks."
            },
            "created_at": "2026-02-15T21:22:30.636807",
            "updated_at": "2026-02-20T23:09:42.550248"
        },
        {
            "id": "2bd4eceb-d34c-4372-b89a-ad300d67794c",
            "slug": "observability-compose-metrics",
            "title": "Compose Metrics into Effect Pipelines",
            "summary": "Add Metric.increment, Metric.trackDuration, and other metrics to your Effect pipelines without changing core logic.",
            "skill_level": "intermediate",
            "category": "observability",
            "difficulty": "intermediate",
            "tags": [
                "observability",
                "metrics",
                "counter",
                "timer",
                "pipeline"
            ],
            "examples": [
                {
                    "code": "import { Effect, Metric } from \"effect\"\n\nconst successCounter = Metric.counter(\"operations_success_total\")\nconst stepTimer = Metric.timer(\"step_duration\")\n\nconst fetchUser = Effect.succeed({ id: 1, name: \"Alice\" }).pipe(\n  Effect.delay(\"20 millis\"),\n  Metric.trackDuration(stepTimer)\n)\n\nconst program = fetchUser.pipe(\n  Effect.tap(() => Metric.increment(successCounter)),\n  Effect.tap((user) => Effect.sync(() => console.log(user)))\n)\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Add metrics at the edges of pipelines; keep business logic clean."
            },
            "created_at": "2026-02-15T21:22:30.974263",
            "updated_at": "2026-02-20T23:09:42.819943"
        },
        {
            "id": "7f19acbd-e259-409a-bc19-b98e2de1db0e",
            "slug": "create-managed-runtime-for-scoped-resources",
            "title": "Create a Managed Runtime for Scoped Resources",
            "summary": "Use Layer.launch to safely manage the lifecycle of layers containing scoped resources, ensuring finalizers are always run.",
            "skill_level": "advanced",
            "category": "resource-management",
            "difficulty": "advanced",
            "tags": [
                "runtime",
                "scope",
                "resource-management",
                "layers",
                "scoped",
                "finalizer",
                "launch"
            ],
            "examples": [
                {
                    "code": "import { Effect, Layer } from \"effect\";\n\nclass DatabasePool extends Effect.Service<DatabasePool>()(\"DbPool\", {\n  effect: Effect.gen(function* () {\n    yield* Effect.log(\"Acquiring pool\");\n    return {\n      query: () => Effect.succeed(\"result\"),\n    };\n  }),\n}) {}\n\n// Create a program that uses the DatabasePool service\nconst program = Effect.gen(function* () {\n  const db = yield* DatabasePool;\n  yield* Effect.log(\"Using DB\");\n  yield* db.query();\n});\n\n// Run the program with the service implementation\nEffect.runPromise(\n  program.pipe(Effect.provide(DatabasePool.Default), Effect.scoped)\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Create a managed runtime for scoped resources."
            },
            "created_at": "2026-02-15T21:22:18.779731",
            "updated_at": "2026-02-20T23:09:32.33798"
        },
        {
            "id": "7ed7d101-a3d1-473d-9313-7922d82067c1",
            "slug": "resource-management-runtime-vs-provide",
            "title": "Choose Between ManagedRuntime and Effect.provide",
            "summary": "Use ManagedRuntime when running many effects with the same layers (servers, workers); use Effect.provide for one-off scripts.",
            "skill_level": "intermediate",
            "category": "resource-management",
            "difficulty": "intermediate",
            "tags": [
                "resource management",
                "runtime",
                "provide",
                "dependency injection"
            ],
            "examples": [
                {
                    "code": "import { Effect, Layer, ManagedRuntime } from \"effect\"\n\nclass Db extends Effect.Service<Db>()(\"Db\", {\n  sync: () => ({ query: () => Effect.succeed(\"data\") }),\n}) {}\n\n// One-off: provide at the edge\nconst oneOff = Effect.gen(function* () {\n  const db = yield* Db\n  return yield* db.query()\n})\nEffect.runPromise(Effect.provide(oneOff, Db.Default))\n\n// Many runs: create runtime once\nconst runtime = ManagedRuntime.make(Db.Default)\nconst effect = Effect.gen(function* () {\n  const db = yield* Db\n  return yield* db.query()\n})\nruntime.runPromise(effect).then(console.log)\nruntime.dispose()",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Runtime for many runs; Effect.provide for one-off."
            },
            "created_at": "2026-02-15T21:22:31.139116",
            "updated_at": "2026-02-20T23:09:32.482195"
        },
        {
            "id": "97fa2491-d918-4067-90b8-1449d13f810c",
            "slug": "resource-pooling",
            "title": "Pool Resources for Reuse",
            "summary": "Create and manage a pool of reusable resources like database connections or workers.",
            "skill_level": "intermediate",
            "category": "resource-management",
            "difficulty": "intermediate",
            "tags": [
                "resource-management",
                "pooling",
                "connections",
                "performance"
            ],
            "examples": [
                {
                    "code": "import { Effect, Pool, Scope, Duration } from \"effect\"\n\n// ============================================\n// 1. Define a poolable resource\n// ============================================\n\ninterface DatabaseConnection {\n  readonly id: number\n  readonly query: (sql: string) => Effect.Effect<unknown[]>\n  readonly close: () => Effect.Effect<void>\n}\n\nlet connectionId = 0\n\nconst createConnection = Effect.gen(function* () {\n  const id = ++connectionId\n  yield* Effect.log(`Creating connection ${id}`)\n  \n  // Simulate connection setup time\n  yield* Effect.sleep(\"100 millis\")\n  \n  const connection: DatabaseConnection = {\n    id,\n    query: (sql) => Effect.gen(function* () {\n      yield* Effect.log(`[Conn ${id}] Executing: ${sql}`)\n      return [{ result: \"data\" }]\n    }),\n    close: () => Effect.gen(function* () {\n      yield* Effect.log(`Closing connection ${id}`)\n    }),\n  }\n  \n  return connection\n})\n\n// ============================================\n// 2. Create a pool\n// ============================================\n\nconst makeConnectionPool = Pool.make({\n  acquire: createConnection,\n  size: 5,  // Maximum 5 connections\n})\n\n// ============================================\n// 3. Use the pool\n// ============================================\n\nconst runQuery = (pool: Pool.Pool<DatabaseConnection>, sql: string) =>\n  Effect.scoped(\n    Effect.gen(function* () {\n      // Get a connection from the pool\n      const connection = yield* pool.get\n      \n      // Use it\n      const results = yield* connection.query(sql)\n      \n      // Connection automatically returned to pool when scope ends\n      return results\n    })\n  )\n\n// ============================================\n// 4. Run multiple queries concurrently\n// ============================================\n\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    const pool = yield* makeConnectionPool\n    \n    yield* Effect.log(\"Starting concurrent queries...\")\n    \n    // Run 10 queries with only 5 connections\n    const queries = Array.from({ length: 10 }, (_, i) =>\n      runQuery(pool, `SELECT * FROM users WHERE id = ${i}`)\n    )\n    \n    const results = yield* Effect.all(queries, { concurrency: \"unbounded\" })\n    \n    yield* Effect.log(`Completed ${results.length} queries`)\n    return results\n  })\n)\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Pool to manage expensive resources that can be reused across operations."
            },
            "created_at": "2026-02-15T21:22:18.685576",
            "updated_at": "2026-02-20T23:09:32.567881"
        },
        {
            "id": "db3aec9d-d567-41cb-adee-c604f096bd29",
            "slug": "data-array",
            "title": "Working with Immutable Arrays using Data.array",
            "summary": "Use Data.array to create immutable, type-safe arrays that support value-based equality and safe functional operations.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "Data.array",
                "array",
                "structural-equality",
                "immutable",
                "data-type",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Data, Equal } from \"effect\";\n\n// Create two structurally equal arrays\nconst arr1 = Data.array([1, 2, 3]);\nconst arr2 = Data.array([1, 2, 3]);\n\n// Compare by value, not reference\nconst areEqual = Equal.equals(arr1, arr2); // true\n\n// Use arrays as keys in a HashSet or Map\nimport { HashSet } from \"effect\";\nconst set = HashSet.make(arr1);\nconsole.log(HashSet.has(set, arr2)); // true\n\n// Functional operations (map, filter, etc.)\nconst doubled = arr1.map((n) => n * 2); // Data.array([2, 4, 6])",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Data.array to define arrays whose equality is based on their contents, enabling safe, predictable comparisons and functional operations."
            },
            "created_at": "2026-02-15T21:22:14.589045",
            "updated_at": "2026-02-20T23:09:32.767651"
        },
        {
            "id": "de8ebf4b-1712-4f93-84aa-62e21fbf0779",
            "slug": "provide-config-layer",
            "title": "Provide Configuration to Your App via a Layer",
            "summary": "Use Config.layer(schema) to create a Layer that provides your configuration schema to the application's context.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "configuration",
                "config",
                "layers",
                "dependency-injection"
            ],
            "examples": [
                {
                    "code": "import { Effect, Layer } from \"effect\";\n\nclass ServerConfig extends Effect.Service<ServerConfig>()(\"ServerConfig\", {\n  sync: () => ({\n    port: process.env.PORT ? parseInt(process.env.PORT) : 8080,\n  }),\n}) {}\n\nconst program = Effect.gen(function* () {\n  const config = yield* ServerConfig;\n  yield* Effect.log(`Starting application on port ${config.port}...`);\n});\n\nconst programWithErrorHandling = Effect.provide(\n  program,\n  ServerConfig.Default\n).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Provide configuration to your app via a Layer."
            },
            "created_at": "2026-02-15T21:22:15.952683",
            "updated_at": "2026-02-20T23:09:32.839069"
        },
        {
            "id": "7f4965a7-c79e-496b-a689-f546d6d24d58",
            "slug": "combinator-map",
            "title": "Transforming Values with map",
            "summary": "Use map to transform the result of an Effect, Stream, Option, or Either in a declarative, type-safe way.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "map",
                "combinator",
                "functor",
                "effect",
                "stream",
                "option",
                "either"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Option, Either } from \"effect\";\n\n// Effect: Transform the result of an effect\nconst effect = Effect.succeed(2).pipe(Effect.map((n) => n * 10)); // Effect<number>\n\n// Option: Transform an optional value\nconst option = Option.some(2).pipe(Option.map((n) => n * 10)); // Option<number>\n\n// Either: Transform a value that may be an error\nconst either = Either.right(2).pipe(Either.map((n) => n * 10)); // Either<never, number>\n\n// Stream: Transform every value in a stream\nconst stream = Stream.fromIterable([1, 2, 3]).pipe(Stream.map((n) => n * 10)); // Stream<number>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use map to apply a pure function to the value inside an Effect, Stream, Option, or Either."
            },
            "created_at": "2026-02-15T21:22:14.248365",
            "updated_at": "2026-02-20T23:09:34.307519"
        },
        {
            "id": "67addc11-4371-4ce5-9211-a5ff4dbc16bc",
            "slug": "combinator-foreach-all",
            "title": "Mapping and Chaining over Collections with forEach and all",
            "summary": "Use forEach and all to apply effectful functions to collections and combine the results, enabling batch and parallel processing.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "forEach",
                "all",
                "collections",
                "parallelism",
                "batch",
                "combinator",
                "effect",
                "stream",
                "option",
                "either"
            ],
            "examples": [
                {
                    "code": "import { Effect, Either, Option, Stream } from \"effect\";\n\n// Effect: Apply an effectful function to each item in an array\nconst numbers = [1, 2, 3];\nconst effect = Effect.forEach(numbers, (n) => Effect.succeed(n * 2));\n// Effect<number[]>\n\n// Effect: Run multiple effects in parallel and collect results\nconst effects = [Effect.succeed(1), Effect.succeed(2)];\nconst allEffect = Effect.all(effects, { concurrency: \"unbounded\" }); // Effect<[1, 2]>\n\n// Option: Map over a collection of options and collect only the Some values\nconst options = [Option.some(1), Option.none(), Option.some(3)];\nconst filtered = options.filter(Option.isSome).map((o) => o.value); // [1, 3]\n\n// Either: Collect all Right values from a collection of Eithers\nconst eithers = [Either.right(1), Either.left(\"fail\"), Either.right(3)];\nconst rights = eithers.filter(Either.isRight); // [Either.Right(1), Either.Right(3)]\n\n// Stream: Map and flatten a stream of arrays\nconst stream = Stream.fromIterable([\n  [1, 2],\n  [3, 4],\n]).pipe(Stream.flatMap((arr) => Stream.fromIterable(arr))); // Stream<number>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use forEach and all to process collections of values with effectful functions, collecting results in a type-safe and composable way."
            },
            "created_at": "2026-02-15T21:22:15.609635",
            "updated_at": "2026-02-20T23:09:32.963254"
        },
        {
            "id": "a250667a-7184-4a44-888c-80a7a3ad982d",
            "slug": "constructor-fail-none-left",
            "title": "Lifting Errors and Absence with fail, none, and left",
            "summary": "Use fail, none, and left to represent errors or absence in Effect, Option, or Either, making failures explicit and type-safe.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "fail",
                "none",
                "left",
                "constructor",
                "effect",
                "option",
                "either",
                "error",
                "absence"
            ],
            "examples": [
                {
                    "code": "import { Effect, Option, Either } from \"effect\";\n\n// Effect: Represent a failure with an error value\nconst effect = Effect.fail(\"Something went wrong\"); // Effect<string, never, never>\n\n// Option: Represent absence of a value\nconst option = Option.none(); // Option<never>\n\n// Either: Represent a failure with a left value\nconst either = Either.left(\"Invalid input\"); // Either<string, never>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use fail, none, and left to create Effect, Option, or Either that represent failure or absence."
            },
            "created_at": "2026-02-15T21:22:13.804523",
            "updated_at": "2026-02-20T23:09:33.052801"
        },
        {
            "id": "dfa7c267-08d0-4b04-9646-5174adf16eaa",
            "slug": "data-tuple",
            "title": "Working with Tuples using Data.tuple",
            "summary": "Use Data.tuple to create immutable, type-safe tuples that support value-based equality and pattern matching.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "Data.tuple",
                "tuple",
                "structural-equality",
                "immutable",
                "data-type",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Data, Equal } from \"effect\";\n\n// Create two structurally equal tuples\nconst t1 = Data.tuple(1, \"Alice\");\nconst t2 = Data.tuple(1, \"Alice\");\n\n// Compare by value, not reference\nconst areEqual = Equal.equals(t1, t2); // true\n\n// Use tuples as keys in a HashSet or Map\nimport { HashSet } from \"effect\";\nconst set = HashSet.make(t1);\nconsole.log(HashSet.has(set, t2)); // true\n\n// Pattern matching on tuples\nconst [id, name] = t1; // id: number, name: string",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Data.tuple to define tuples whose equality is based on their contents, enabling safe and predictable comparisons and pattern matching."
            },
            "created_at": "2026-02-15T21:22:14.664628",
            "updated_at": "2026-02-20T23:09:33.239735"
        },
        {
            "id": "53a5129d-f515-48f7-999d-26de3ed44f34",
            "slug": "getting-started-run-in-parallel",
            "title": "Run Multiple Effects in Parallel with Effect.all",
            "summary": "Use Effect.all to run multiple Effects at the same time and collect all their results.",
            "skill_level": "beginner",
            "category": "getting-started",
            "difficulty": "beginner",
            "tags": [
                "getting-started",
                "concurrency",
                "parallel",
                "all",
                "beginner"
            ],
            "examples": [
                {
                    "code": "import { Effect, pipe } from \"effect\";\n\n// Simulate fetching data from different sources\nconst fetchUser = Effect.succeed({ id: 1, name: \"Alice\" }).pipe(\n  Effect.delay(\"100 millis\")\n);\n\nconst fetchPosts = Effect.succeed([\n  { id: 1, title: \"Hello World\" },\n  { id: 2, title: \"Effect is awesome\" },\n]).pipe(Effect.delay(\"150 millis\"));\n\nconst fetchSettings = Effect.succeed({ theme: \"dark\" }).pipe(\n  Effect.delay(\"50 millis\")\n);\n\n// Fetch all data in parallel\nconst program = Effect.gen(function* () {\n  const [user, posts, settings] = yield* Effect.all(\n    [fetchUser, fetchPosts, fetchSettings],\n    { concurrency: \"unbounded\" }\n  );\n\n  yield* Effect.log(`Loaded ${user.name} with ${posts.length} posts`);\n  return { user, posts, settings };\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Run multiple Effects in parallel with Effect.all."
            },
            "created_at": "2026-02-15T21:22:12.677397",
            "updated_at": "2026-02-20T23:09:35.351296"
        },
        {
            "id": "0ca8d456-d5bb-48ed-ac07-e80d4ea90787",
            "slug": "constructor-from-iterable",
            "title": "Creating from Collections",
            "summary": "Use fromIterable and fromArray to create Streams or Effects from arrays, iterables, or other collections, enabling batch and streaming operations.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "fromIterable",
                "fromArray",
                "constructor",
                "stream",
                "effect",
                "collection",
                "batch"
            ],
            "examples": [
                {
                    "code": "import { Stream, Effect } from \"effect\";\n\n// Stream: Create a stream from an array\nconst numbers = [1, 2, 3, 4];\nconst numberStream = Stream.fromIterable(numbers); // Stream<number>\n\n// Stream: Create a stream from any iterable\nfunction* gen() {\n  yield \"a\";\n  yield \"b\";\n}\nconst letterStream = Stream.fromIterable(gen()); // Stream<string>\n\n// Effect: Create an effect from an array of effects (batch)\nconst effects = [Effect.succeed(1), Effect.succeed(2)];\nconst batchEffect = Effect.all(effects); // Effect<[1, 2]>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use fromIterable and fromArray to lift collections into Streams or Effects for batch or streaming processing."
            },
            "created_at": "2026-02-15T21:22:13.564809",
            "updated_at": "2026-02-20T23:09:33.326265"
        },
        {
            "id": "8ef17330-dfd5-41a7-a34b-86e6779a5219",
            "slug": "setup-new-project",
            "title": "Set Up a New Effect Project",
            "summary": "Initialize a new Node.js project with the necessary TypeScript configuration and Effect dependencies to start building.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "project-setup",
                "getting-started",
                "typescript",
                "tsconfig",
                "npm",
                "pnpm",
                "bun"
            ],
            "examples": [
                {
                    "code": "// 1. Init project (e.g., `npm init -y`)\n// 2. Install deps (e.g., `npm install effect`, `npm install -D typescript tsx`)\n// 3. Create tsconfig.json with `\"strict\": true`\n// 4. Create src/index.ts\nimport { Effect } from \"effect\";\n\nconst program = Effect.log(\"Hello, World!\");\n\nEffect.runSync(program);\n\n// 5. Run the program (e.g., `npx tsx src/index.ts`)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Set up a new Effect project."
            },
            "created_at": "2026-02-16T21:38:51.258002",
            "updated_at": "2026-02-20T23:09:33.436543"
        },
        {
            "id": "09f2a4b1-f520-468d-a824-e32258b0315c",
            "slug": "core-concepts-chunk-vs-array",
            "title": "When to Use Chunk vs Array",
            "summary": "Choose Chunk for Effect pipelines, Stream results, and immutable collection operations; use Array when interfacing with existing APIs.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "chunk",
                "collections",
                "core concepts",
                "data"
            ],
            "examples": [
                {
                    "code": "import { Effect, Chunk, Stream } from \"effect\"\n\nconst program = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(\n  Stream.map((n) => n * 2),\n  Stream.runCollect\n)\n\nEffect.runPromise(program).then((chunk) => {\n  const doubled = Chunk.map(chunk, (n) => n + 1)\n  return Chunk.toArray(doubled)\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Chunk in Effect/Stream pipelines; use Array for external APIs."
            },
            "created_at": "2026-02-15T21:22:30.889917",
            "updated_at": "2026-02-20T23:09:33.741933"
        },
        {
            "id": "9f176d84-93f0-4799-adfb-727b1751e994",
            "slug": "create-reusable-runtime-from-layers",
            "title": "Create a Reusable Runtime from Layers",
            "summary": "Compile your application's layers into a reusable Runtime object to efficiently execute multiple effects that share the same context.",
            "skill_level": "advanced",
            "category": "core-concepts",
            "difficulty": "advanced",
            "tags": [
                "runtime",
                "layers",
                "execution",
                "dependency-injection",
                "performance"
            ],
            "examples": [
                {
                    "code": "import { Effect, Layer, Runtime } from \"effect\";\n\nclass GreeterService extends Effect.Service<GreeterService>()(\"Greeter\", {\n  sync: () => ({\n    greet: (name: string) => Effect.sync(() => `Hello ${name}`),\n  }),\n}) {}\n\nconst runtime = Effect.runSync(\n  Layer.toRuntime(GreeterService.Default).pipe(Effect.scoped)\n);\n\n// In a server, you would reuse `run` for every request.\nRuntime.runPromise(runtime)(Effect.log(\"Hello\"));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Create a reusable runtime from layers."
            },
            "created_at": "2026-02-16T21:38:52.389065",
            "updated_at": "2026-02-20T23:09:33.784627"
        },
        {
            "id": "f8379ac5-af58-4f0d-931d-3192671006ee",
            "slug": "data-cause",
            "title": "Understand the Cause Data Type",
            "summary": "Use Cause<E> to get rich, structured information about errors and failures, including defects, interruptions, and error traces.",
            "skill_level": "advanced",
            "category": "core-concepts",
            "difficulty": "advanced",
            "tags": [
                "Cause",
                "error-handling",
                "debugging",
                "effect",
                "failure",
                "data-type"
            ],
            "examples": [
                {
                    "code": "import { Cause, Effect } from \"effect\";\n\n// An Effect that may fail with an error or defect\nconst program = Effect.try({\n  try: () => {\n    throw new Error(\"Unexpected failure!\");\n  },\n  catch: (err) => err,\n});\n\n// Catch all causes and inspect them\nconst handled = program.pipe(\n  Effect.catchAllCause((cause) =>\n    Effect.sync(() => {\n      if (Cause.isDie(cause)) {\n        console.error(\"Defect (die):\", Cause.pretty(cause));\n      } else if (Cause.isFailure(cause)) {\n        console.error(\"Expected error:\", Cause.pretty(cause));\n      } else if (Cause.isInterrupted(cause)) {\n        console.error(\"Interrupted:\", Cause.pretty(cause));\n      }\n      // Handle or rethrow as needed\n    })\n  )\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Cause to inspect, analyze, and handle all possible failure modes of an Effect, including expected errors, defects, and interruptions."
            },
            "created_at": "2026-02-15T21:22:16.950179",
            "updated_at": "2026-02-20T23:09:34.024513"
        },
        {
            "id": "fea53c05-38a6-46e5-924f-664d3134170b",
            "slug": "data-struct",
            "title": "Comparing Data by Value with Data.struct",
            "summary": "Use Data.struct to create immutable, structurally-typed objects that can be compared by value, not by reference.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "Data.struct",
                "structural-equality",
                "immutable",
                "data-type",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Data, Equal } from \"effect\";\n\n// Create two structurally equal objects\nconst user1 = Data.struct({ id: 1, name: \"Alice\" });\nconst user2 = Data.struct({ id: 1, name: \"Alice\" });\n\n// Compare by value, not reference\nconst areEqual = Equal.equals(user1, user2); // true\n\n// Use in a HashSet or as keys in a Map\nimport { HashSet } from \"effect\";\nconst set = HashSet.make(user1);\nconsole.log(HashSet.has(set, user2)); // true",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Data.struct to define objects whose equality is based on their contents, enabling safe and predictable comparisons."
            },
            "created_at": "2026-02-15T21:22:13.120648",
            "updated_at": "2026-02-20T23:09:34.102809"
        },
        {
            "id": "5f851a04-4fc4-4fc6-8018-df999da8a888",
            "slug": "execute-with-runpromise",
            "title": "Execute Asynchronous Effects with Effect.runPromise",
            "summary": "Use Effect.runPromise at the 'end of the world' to execute an asynchronous Effect and get its result as a JavaScript Promise.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "execution",
                "runtime",
                "promise",
                "async",
                "end-of-world"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\nconst program = Effect.succeed(\"Hello, World!\").pipe(Effect.delay(\"1 second\"));\n\nconst promise = Effect.runPromise(program);\n\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(result); // Logs \"Hello, World!\" after 1 second.\n  return result;\n});\n\nEffect.runPromise(programWithLogging);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Execute asynchronous effects with Effect.runPromise."
            },
            "created_at": "2026-02-16T21:38:55.223998",
            "updated_at": "2026-02-20T23:09:34.608132"
        },
        {
            "id": "d3f17c75-94f7-4d7f-ab68-ac1a69308f81",
            "slug": "constructor-succeed-some-right",
            "title": "Lifting Values with succeed, some, and right",
            "summary": "Use succeed, some, and right to lift plain values into Effect, Option, or Either, making them composable and type-safe.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "succeed",
                "some",
                "right",
                "constructor",
                "effect",
                "option",
                "either",
                "lifting"
            ],
            "examples": [
                {
                    "code": "import { Effect, Option, Either } from \"effect\";\n\n// Effect: Lift a value into an Effect that always succeeds\nconst effect = Effect.succeed(42); // Effect<never, number, never>\n\n// Option: Lift a value into an Option that is always Some\nconst option = Option.some(\"hello\"); // Option<string>\n\n// Either: Lift a value into an Either that is always Right\nconst either = Either.right({ id: 1 }); // Either<never, { id: number }>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use succeed, some, and right to create Effect, Option, or Either from plain values."
            },
            "created_at": "2026-02-15T21:22:13.887211",
            "updated_at": "2026-02-20T23:09:34.65981"
        },
        {
            "id": "7bc9cfab-8923-4c40-b7c0-6b10f2882a4d",
            "slug": "combinator-error-handling",
            "title": "Handling Errors with catchAll, orElse, and match",
            "summary": "Use catchAll, orElse, and match to recover from errors, provide fallbacks, or transform errors in Effect, Either, and Option.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "error-handling",
                "catchAll",
                "orElse",
                "match",
                "combinator",
                "effect",
                "either",
                "option"
            ],
            "examples": [
                {
                    "code": "import { Effect, Option, Either } from \"effect\";\n\n// Effect: Recover from any error\nconst effect = Effect.fail(\"fail!\").pipe(\n  Effect.catchAll((err) => Effect.succeed(`Recovered from: ${err}`))\n); // Effect<string>\n\n// Option: Provide a fallback if value is None\nconst option = Option.none().pipe(Option.orElse(() => Option.some(\"default\"))); // Option<string>\n\n// Either: Provide a fallback if value is Left\nconst either = Either.left(\"error\").pipe(\n  Either.orElse(() => Either.right(\"fallback\"))\n); // Either<never, string>\n\n// Effect: Pattern match on success or failure\nconst matchEffect = Effect.fail(\"fail!\").pipe(\n  Effect.match({\n    onFailure: (err) => `Error: ${err}`,\n    onSuccess: (value) => `Success: ${value}`,\n  })\n); // Effect<string>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use error handling combinators to recover from failures, provide fallback values, or transform errors in a composable way."
            },
            "created_at": "2026-02-15T21:22:15.444394",
            "updated_at": "2026-02-20T23:09:34.836614"
        },
        {
            "id": "904b6103-9834-4d7e-843a-4f820212f184",
            "slug": "data-hashset",
            "title": "Work with Immutable Sets using HashSet",
            "summary": "Use HashSet<A> to model immutable, high-performance sets for efficient membership checks and set operations.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "HashSet",
                "set",
                "collection",
                "immutable",
                "data-type",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { HashSet } from \"effect\";\n\n// Create a HashSet from an array\nconst setA = HashSet.fromIterable([1, 2, 3]);\nconst setB = HashSet.fromIterable([3, 4, 5]);\n\n// Membership check\nconst hasTwo = HashSet.has(setA, 2); // true\n\n// Union, intersection, difference\nconst union = HashSet.union(setA, setB); // HashSet {1, 2, 3, 4, 5}\nconst intersection = HashSet.intersection(setA, setB); // HashSet {3}\nconst difference = HashSet.difference(setA, setB); // HashSet {1, 2}\n\n// Add and remove elements\nconst withSix = HashSet.add(setA, 6); // HashSet {1, 2, 3, 6}\nconst withoutOne = HashSet.remove(setA, 1); // HashSet {2, 3}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use HashSet to represent sets of unique values with efficient, immutable operations for membership, union, intersection, and difference."
            },
            "created_at": "2026-02-15T21:22:16.861673",
            "updated_at": "2026-02-20T23:09:35.011177"
        },
        {
            "id": "229199b8-8069-4b52-9b07-fce6c0d3fbc6",
            "slug": "optional-pattern-optional-chains",
            "title": "Optional Pattern 2: Optional Chaining and Composition",
            "summary": "Chain optional values across multiple steps with composable operators, enabling elegant data flow through systems with missing values.",
            "skill_level": "advanced",
            "category": "core-concepts",
            "difficulty": "advanced",
            "tags": [
                "optional",
                "composition",
                "chaining",
                "data-flow",
                "functional-programming",
                "error-handling"
            ],
            "examples": [
                {
                    "code": "import { Effect, Option, pipe } from \"effect\";\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\ninterface Profile {\n  bio: string;\n  website?: string;\n  avatar?: string;\n}\n\ninterface Settings {\n  theme: \"light\" | \"dark\";\n  notifications: boolean;\n  language: string;\n}\n\nconst program = Effect.gen(function* () {\n  console.log(`\\n[OPTIONAL CHAINING] Composing Option operations\\n`);\n\n  // Example 1: Simple chain with map\n  console.log(`[1] Chaining transformations with map():\\n`);\n\n  const userId: Option.Option<string> = Option.some(\"user-42\");\n\n  const userDisplayId = Option.map(userId, (id) => `User#${id}`);\n\n  const idMessage = Option.match(userDisplayId, {\n    onSome: (display) => display,\n    onNone: () => \"No user ID\",\n  });\n\n  yield* Effect.log(`[CHAIN 1] ${idMessage}`);\n\n  // Chained maps\n  const email: Option.Option<string> = Option.some(\"alice@example.com\");\n\n  const emailParts = pipe(\n    email,\n    Option.map((e) => e.toLowerCase()),\n    Option.map((e) => e.split(\"@\")),\n    Option.map((parts) => parts[0]) // username\n  );\n\n  const username = Option.getOrElse(emailParts, () => \"unknown\");\n\n  yield* Effect.log(`[USERNAME] ${username}\\n`);\n\n  // Example 2: FlatMap for chaining operations that return Option\n  console.log(`[2] Chaining operations with flatMap():\\n`);\n\n  const findUser = (id: string): Option.Option<User> =>\n    id === \"user-42\"\n      ? Option.some({\n          id,\n          name: \"Alice\",\n          email: \"alice@example.com\",\n        })\n      : Option.none();\n\n  const getProfile = (userId: string): Option.Option<Profile> =>\n    userId === \"user-42\"\n      ? Option.some({\n          bio: \"Software engineer\",\n          website: \"alice.dev\",\n          avatar: \"https://example.com/avatar.jpg\",\n        })\n      : Option.none();\n\n  const userProfile = pipe(\n    Option.some(\"user-42\"),\n    Option.flatMap((id) => findUser(id)),\n    Option.flatMap((user) => getProfile(user.id))\n  );\n\n  const profileInfo = Option.match(userProfile, {\n    onSome: (profile) => `Bio: ${profile.bio}, Website: ${profile.website}`,\n    onNone: () => \"Profile not found\",\n  });\n\n  yield* Effect.log(`[PROFILE] ${profileInfo}\\n`);\n\n  // Example 3: Complex pipeline\n  console.log(`[3] Complex pipeline (user \u2192 profile \u2192 settings \u2192 theme):\\n`);\n\n  const getSettings = (userId: string): Option.Option<Settings> =>\n    userId === \"user-42\"\n      ? Option.some({\n          theme: \"dark\",\n          notifications: true,\n          language: \"en\",\n        })\n      : Option.none();\n\n  const userTheme = pipe(\n    Option.some(\"user-42\"),\n    Option.flatMap((id) => findUser(id)),\n    Option.flatMap((user) => getSettings(user.id)),\n    Option.map((settings) => settings.theme)\n  );\n\n  const theme = Option.getOrElse(userTheme, () => \"light\");\n\n  yield* Effect.log(`[THEME] ${theme}`);\n\n  // Even if any step is None, result is None\n  const invalidUserTheme = pipe(\n    Option.some(\"invalid-user\"),\n    Option.flatMap((id) => findUser(id)),\n    Option.flatMap((user) => getSettings(user.id)),\n    Option.map((settings) => settings.theme)\n  );\n\n  const invalidTheme = Option.getOrElse(invalidUserTheme, () => \"light\");\n\n  yield* Effect.log(`[DEFAULT THEME] ${invalidTheme}\\n`);\n\n  // Example 4: Apply (ap) for combining independent Options\n  console.log(`[4] Combining values with ap():\\n`);\n\n  const firstName: Option.Option<string> = Option.some(\"John\");\n  const lastName: Option.Option<string> = Option.some(\"Doe\");\n\n  // Create a function wrapped in Option\n  const combineNames = (first: string) => (last: string) =>\n    `${first} ${last}`;\n\n  const fullName = pipe(\n    Option.some(combineNames),\n    Option.ap(firstName),\n    Option.ap(lastName)\n  );\n\n  const name = Option.getOrElse(fullName, () => \"Unknown\");\n\n  yield* Effect.log(`[COMBINED] ${name}`);\n\n  // If any is None\n  const noLastName: Option.Option<string> = Option.none();\n\n  const incompleteName = pipe(\n    Option.some(combineNames),\n    Option.ap(firstName),\n    Option.ap(noLastName)\n  );\n\n  const incompleteFull = Option.getOrElse(incompleteName, () => \"Incomplete\");\n\n  yield* Effect.log(`[INCOMPLETE] ${incompleteFull}\\n`);\n\n  // Example 5: Traverse for mapping over collections\n  console.log(`[5] Working with collections (traverse):\\n`);\n\n  const userIds: string[] = [\"user-42\", \"user-99\", \"user-1\"];\n\n  // Try to load all users\n  const allUsers = Option.all(\n    userIds.map((id) => findUser(id))\n  );\n\n  const usersMessage = Option.match(allUsers, {\n    onSome: (users) => `Loaded ${users.length} users`,\n    onNone: () => \"Some users not found\",\n  });\n\n  yield* Effect.log(`[TRAVERSE] ${usersMessage}\\n`);\n\n  // Example 6: Or/recovery with multiple options\n  console.log(`[6] Fallback chains with orElse():\\n`);\n\n  const getPrimaryEmail = (): Option.Option<string> => Option.none();\n  const getSecondaryEmail = (): Option.Option<string> =>\n    Option.some(\"backup@example.com\");\n  const getTertiaryEmail = (): Option.Option<string> =>\n    Option.some(\"tertiary@example.com\");\n\n  const email1 = pipe(\n    getPrimaryEmail(),\n    Option.orElse(() => getSecondaryEmail()),\n    Option.orElse(() => getTertiaryEmail())\n  );\n\n  const contactEmail = Option.getOrElse(email1, () => \"no-email@example.com\");\n\n  yield* Effect.log(`[FALLBACK] Using email: ${contactEmail}\\n`);\n\n  // Example 7: Filtering options\n  console.log(`[7] Filtering with predicates:\\n`);\n\n  const age: Option.Option<number> = Option.some(25);\n\n  const canVote = pipe(\n    age,\n    Option.filter((a) => a >= 18)\n  );\n\n  const voteStatus = Option.match(canVote, {\n    onSome: () => \"Can vote\",\n    onNone: () => \"Too young to vote\",\n  });\n\n  yield* Effect.log(`[FILTER] ${voteStatus}`);\n\n  // Multiple filters in chain\n  const score: Option.Option<number> = Option.some(85);\n\n  const isAGrade = pipe(\n    score,\n    Option.filter((s) => s >= 80),\n    Option.filter((s) => s < 90)\n  );\n\n  const grade = Option.match(isAGrade, {\n    onSome: () => \"Grade A\",\n    onNone: () => \"Not in A range\",\n  });\n\n  yield* Effect.log(`[GRADES] ${grade}\\n`);\n\n  // Example 8: Practical: Database query chain\n  console.log(`[8] Real-world: Database record chain:\\n`);\n\n  const getRecord = (id: string): Option.Option<{ data: string; nested: { value: number } }> =>\n    id === \"rec-1\"\n      ? Option.some({\n          data: \"content\",\n          nested: { value: 42 },\n        })\n      : Option.none();\n\n  const recordValue = pipe(\n    Option.some(\"rec-1\"),\n    Option.flatMap((id) => getRecord(id)),\n    Option.map((rec) => rec.nested),\n    Option.map((nested) => nested.value),\n    Option.map((value) => value * 2)\n  );\n\n  const finalValue = Option.getOrElse(recordValue, () => 0);\n\n  yield* Effect.log(`[VALUE] ${finalValue}`);\n\n  // Missing record\n  const missingValue = pipe(\n    Option.some(\"rec-999\"),\n    Option.flatMap((id) => getRecord(id)),\n    Option.map((rec) => rec.nested),\n    Option.map((nested) => nested.value),\n    Option.map((value) => value * 2)\n  );\n\n  const defaultValue = Option.getOrElse(missingValue, () => 0);\n\n  yield* Effect.log(`[DEFAULT] ${defaultValue}\\n`);\n\n  // Example 9: Conditional chaining\n  console.log(`[9] Conditional paths:\\n`);\n\n  const loadUserWithFallback = (id: string) =>\n    pipe(\n      findUser(id),\n      Option.flatMap((user) =>\n        // Only get premium features if user exists\n        user.name.includes(\"Alice\")\n          ? Option.some({ ...user, isPremium: true })\n          : Option.none()\n      ),\n      Option.orElse(() =>\n        // Fallback: return basic user\n        findUser(id)\n      )\n    );\n\n  const result1 = loadUserWithFallback(\"user-42\");\n  const result2 = loadUserWithFallback(\"user-99\");\n\n  yield* Effect.log(\n    `[CONDITIONAL 1] ${Option.match(result1, { onSome: (u) => `${u.name}`, onNone: () => \"Not found\" })}`\n  );\n\n  yield* Effect.log(\n    `[CONDITIONAL 2] ${Option.match(result2, { onSome: (u) => `${u.name}`, onNone: () => \"Not found\" })}`\n  );\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Option combinators (map, flatMap, ap) to compose operations that may fail, creating readable and maintainable pipelines."
            },
            "created_at": "2026-02-16T21:38:57.088477",
            "updated_at": "2026-02-20T23:09:35.099776"
        },
        {
            "id": "6f786820-2093-45ca-bbd7-7f6032899601",
            "slug": "getting-started-transform-with-map",
            "title": "Transform Values with Effect.map",
            "summary": "Use Effect.map to transform the success value of an Effect without changing its error or dependency types.",
            "skill_level": "beginner",
            "category": "getting-started",
            "difficulty": "beginner",
            "tags": [
                "getting-started",
                "map",
                "transform",
                "beginner",
                "combinators"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Start with an Effect that succeeds with a number\nconst getNumber = Effect.succeed(5);\n\n// Transform it: multiply by 2\nconst doubled = Effect.map(getNumber, (n) => n * 2);\n\n// Transform again: convert to string\nconst asString = Effect.map(doubled, (n) => `The result is ${n}`);\n\n// Run to see the result\nconst result = Effect.runSync(asString);\nconsole.log(result); // \"The result is 10\"",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Transform Effect values with map."
            },
            "created_at": "2026-02-15T21:22:12.517939",
            "updated_at": "2026-02-20T23:09:35.439314"
        },
        {
            "id": "0f5fac66-e6af-47e5-8c6b-c508e6a70a9e",
            "slug": "getting-started-retry-on-failure",
            "title": "Retry a Failed Operation with Effect.retry",
            "summary": "Use Effect.retry with a Schedule to automatically retry failed operations with customizable delays and limits.",
            "skill_level": "beginner",
            "category": "getting-started",
            "difficulty": "beginner",
            "tags": [
                "getting-started",
                "retry",
                "schedule",
                "error-recovery",
                "beginner"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule, pipe } from \"effect\";\n\nclass ApiError {\n  readonly _tag = \"ApiError\";\n  constructor(readonly status: number) {}\n}\n\nconst fetchUserData = (userId: string) =>\n  Effect.tryPromise({\n    try: async () => {\n      const response = await fetch(`/api/users/${userId}`);\n      if (!response.ok) throw new ApiError(response.status);\n      return response.json();\n    },\n    catch: (error) => error as ApiError,\n  });\n\n// Retry up to 3 times with 500ms between attempts\nconst fetchWithRetry = (userId: string) =>\n  pipe(\n    fetchUserData(userId),\n    Effect.retry(\n      Schedule.recurs(3).pipe(Schedule.addDelay(() => \"500 millis\"))\n    ),\n    Effect.catchAll((error) =>\n      Effect.succeed({ error: `Failed after retries: ${error._tag}` })\n    )\n  );",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Retry failed operations with Effect.retry."
            },
            "created_at": "2026-02-15T21:22:12.777903",
            "updated_at": "2026-02-20T23:09:35.520009"
        },
        {
            "id": "6336508a-73d6-4dcd-bed2-237c9d109e56",
            "slug": "provide-dependencies-to-routes",
            "title": "Provide Dependencies to Routes",
            "summary": "Inject services like database connections into HTTP route handlers using Layer and Effect.Service.",
            "skill_level": "intermediate",
            "category": "building-apis",
            "difficulty": "intermediate",
            "tags": [
                "http",
                "server",
                "dependency-injection",
                "layer",
                "service",
                "context"
            ],
            "examples": [
                {
                    "code": "import * as HttpRouter from \"@effect/platform/HttpRouter\";\nimport * as HttpResponse from \"@effect/platform/HttpServerResponse\";\nimport * as HttpServer from \"@effect/platform/HttpServer\";\nimport { NodeHttpServer, NodeRuntime } from \"@effect/platform-node\";\nimport { Effect, Duration, Fiber } from \"effect/index\";\nimport { Data } from \"effect\";\n\n// 1. Define the service interface using Effect.Service\nexport class Database extends Effect.Service<Database>()(\"Database\", {\n  sync: () => ({\n    getUser: (id: string) =>\n      id === \"123\"\n        ? Effect.succeed({ name: \"Paul\" })\n        : Effect.fail(new UserNotFoundError({ id })),\n  }),\n}) {}\n\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\")<{\n  id: string;\n}> {}\n\n// handler producing a `HttpServerResponse`\nconst userHandler = Effect.flatMap(HttpRouter.params, (p) =>\n  Effect.flatMap(Database, (db) => db.getUser(p[\"userId\"] ?? \"\")).pipe(\n    Effect.flatMap(HttpResponse.json)\n  )\n);\n\n// assemble router & server\nconst app = HttpRouter.empty.pipe(\n  HttpRouter.get(\"/users/:userId\", userHandler)\n);\n\n// Create the server effect with all dependencies\nconst serverEffect = HttpServer.serveEffect(app).pipe(\n  Effect.provide(Database.Default),\n  Effect.provide(\n    NodeHttpServer.layer(() => require(\"node:http\").createServer(), {\n      port: 3458,\n    })\n  )\n);\n\n// Create program that manages server lifecycle\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting server on port 3458...\");\n\n  const serverFiber = yield* Effect.scoped(serverEffect).pipe(Effect.fork);\n\n  yield* Effect.logInfo(\"Server started successfully on http://localhost:3458\");\n  yield* Effect.logInfo(\"Try: curl http://localhost:3458/users/123\");\n  yield* Effect.logInfo(\"Try: curl http://localhost:3458/users/456\");\n\n  // Run for a short time to demonstrate\n  yield* Effect.sleep(Duration.seconds(3));\n\n  yield* Effect.logInfo(\"Shutting down server...\");\n  yield* Fiber.interrupt(serverFiber);\n  yield* Effect.logInfo(\"Server shutdown complete\");\n});\n\n// Run the program\nNodeRuntime.runMain(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Define dependencies with Effect.Service and provide them to your HTTP server using a Layer."
            },
            "created_at": "2026-02-15T21:22:25.916356",
            "updated_at": "2026-02-20T23:09:36.056313"
        },
        {
            "id": "9b474b5c-3551-4276-ae68-9408f314d113",
            "slug": "handle-get-request",
            "title": "Handle a GET Request",
            "summary": "Define a route that responds to a specific HTTP GET request path.",
            "skill_level": "beginner",
            "category": "building-apis",
            "difficulty": "beginner",
            "tags": [
                "http",
                "server",
                "routing",
                "get"
            ],
            "examples": [
                {
                    "code": "import { Data, Effect } from \"effect\";\n\n// Define response types\ninterface RouteResponse {\n  readonly status: number;\n  readonly body: string;\n}\n\n// Define error types\nclass RouteNotFoundError extends Data.TaggedError(\"RouteNotFoundError\")<{\n  readonly path: string;\n}> {}\n\nclass RouteHandlerError extends Data.TaggedError(\"RouteHandlerError\")<{\n  readonly path: string;\n  readonly error: string;\n}> {}\n\n// Define route service\nclass RouteService extends Effect.Service<RouteService>()(\"RouteService\", {\n  sync: () => {\n    // Create instance methods\n    const handleRoute = (\n      path: string\n    ): Effect.Effect<RouteResponse, RouteNotFoundError | RouteHandlerError> =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`Processing request for path: ${path}`);\n\n        try {\n          switch (path) {\n            case \"/\":\n              const home = \"Welcome to the home page!\";\n              yield* Effect.logInfo(`Serving home page`);\n              return { status: 200, body: home };\n\n            case \"/hello\":\n              const hello = \"Hello, Effect!\";\n              yield* Effect.logInfo(`Serving hello page`);\n              return { status: 200, body: hello };\n\n            default:\n              yield* Effect.logWarning(`Route not found: ${path}`);\n              return yield* Effect.fail(new RouteNotFoundError({ path }));\n          }\n        } catch (e) {\n          const error = e instanceof Error ? e.message : String(e);\n          yield* Effect.logError(`Error handling route ${path}: ${error}`);\n          return yield* Effect.fail(new RouteHandlerError({ path, error }));\n        }\n      });\n\n    // Return service implementation\n    return {\n      handleRoute,\n      // Simulate GET request\n      simulateGet: (\n        path: string\n      ): Effect.Effect<RouteResponse, RouteNotFoundError | RouteHandlerError> =>\n        Effect.gen(function* () {\n          yield* Effect.logInfo(`GET ${path}`);\n          const response = yield* handleRoute(path);\n          yield* Effect.logInfo(`Response: ${JSON.stringify(response)}`);\n          return response;\n        }),\n    };\n  },\n}) {}\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const router = yield* RouteService;\n\n  yield* Effect.logInfo(\"=== Starting Route Tests ===\");\n\n  // Test different routes\n  for (const path of [\"/\", \"/hello\", \"/other\", \"/error\"]) {\n    yield* Effect.logInfo(`\\n--- Testing ${path} ---`);\n\n    const result = yield* router.simulateGet(path).pipe(\n      Effect.catchTags({\n        RouteNotFoundError: (error) =>\n          Effect.gen(function* () {\n            const response = { status: 404, body: `Not Found: ${error.path}` };\n            yield* Effect.logWarning(`${response.status} ${response.body}`);\n            return response;\n          }),\n        RouteHandlerError: (error) =>\n          Effect.gen(function* () {\n            const response = {\n              status: 500,\n              body: `Internal Error: ${error.error}`,\n            };\n            yield* Effect.logError(`${response.status} ${response.body}`);\n            return response;\n          }),\n      })\n    );\n\n    yield* Effect.logInfo(`Final Response: ${JSON.stringify(result)}`);\n  }\n\n  yield* Effect.logInfo(\"\\n=== Route Tests Complete ===\");\n});\n\n// Run the program\nEffect.runPromise(Effect.provide(program, RouteService.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Http.router.get to associate a URL path with a specific response Effect."
            },
            "created_at": "2026-02-15T21:22:25.199993",
            "updated_at": "2026-02-20T23:09:36.097371"
        },
        {
            "id": "252ee94e-81c1-4a7b-bb97-6fb54324f96e",
            "slug": "extract-path-parameters",
            "title": "Extract Path Parameters",
            "summary": "Capture and use dynamic segments from a request URL, such as a resource ID.",
            "skill_level": "beginner",
            "category": "building-apis",
            "difficulty": "beginner",
            "tags": [
                "http",
                "server",
                "routing",
                "parameters",
                "api"
            ],
            "examples": [
                {
                    "code": "import { Data, Effect } from \"effect\";\n\n// Define tagged error for invalid paths\ninterface InvalidPathErrorSchema {\n  readonly _tag: \"InvalidPathError\";\n  readonly path: string;\n}\n\nconst makeInvalidPathError = (path: string): InvalidPathErrorSchema => ({\n  _tag: \"InvalidPathError\",\n  path,\n});\n\n// Define service interface\ninterface PathOps {\n  readonly extractUserId: (\n    path: string\n  ) => Effect.Effect<string, InvalidPathErrorSchema>;\n  readonly greetUser: (userId: string) => Effect.Effect<string>;\n}\n\n// Create service\nclass PathService extends Effect.Service<PathService>()(\"PathService\", {\n  sync: () => ({\n    extractUserId: (path: string) =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(\n          `Attempting to extract user ID from path: ${path}`\n        );\n\n        const match = path.match(/\\/users\\/([^/]+)/);\n        if (!match) {\n          yield* Effect.logInfo(`No user ID found in path: ${path}`);\n          return yield* Effect.fail(makeInvalidPathError(path));\n        }\n\n        const userId = match[1];\n        yield* Effect.logInfo(`Successfully extracted user ID: ${userId}`);\n        return userId;\n      }),\n\n    greetUser: (userId: string) =>\n      Effect.gen(function* () {\n        const greeting = `Hello, user ${userId}!`;\n        yield* Effect.logInfo(greeting);\n        return greeting;\n      }),\n  }),\n}) {}\n\n// Compose the functions with proper error handling\nconst processPath = (\n  path: string\n): Effect.Effect<string, InvalidPathErrorSchema, PathService> =>\n  Effect.gen(function* () {\n    const pathService = yield* PathService;\n    yield* Effect.logInfo(`Processing path: ${path}`);\n    const userId = yield* pathService.extractUserId(path);\n    return yield* pathService.greetUser(userId);\n  });\n\n// Run examples with proper error handling\nconst program = Effect.gen(function* () {\n  // Test valid paths\n  yield* Effect.logInfo(\"=== Testing valid paths ===\");\n  const result1 = yield* processPath(\"/users/123\");\n  yield* Effect.logInfo(`Result 1: ${result1}`);\n\n  const result2 = yield* processPath(\"/users/abc\");\n  yield* Effect.logInfo(`Result 2: ${result2}`);\n\n  // Test invalid path\n  yield* Effect.logInfo(\"\\n=== Testing invalid path ===\");\n  const result3 = yield* processPath(\"/invalid/path\").pipe(\n    Effect.catchTag(\"InvalidPathError\", (error) =>\n      Effect.succeed(`Error: Invalid path ${error.path}`)\n    )\n  );\n  yield* Effect.logInfo(result3);\n});\n\nEffect.runPromise(Effect.provide(program, PathService.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Define routes with colon-prefixed parameters (e.g., /users/:id) and access their values within the handler."
            },
            "created_at": "2026-02-15T21:22:25.112501",
            "updated_at": "2026-02-20T23:09:35.680261"
        },
        {
            "id": "ffb84b99-431b-4ff2-aaa7-81f4cc8a237d",
            "slug": "api-cors",
            "title": "Configure CORS for APIs",
            "summary": "Enable Cross-Origin Resource Sharing to allow browser clients from different domains.",
            "skill_level": "intermediate",
            "category": "building-apis",
            "difficulty": "intermediate",
            "tags": [
                "building-apis",
                "cors",
                "security",
                "browser"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\"\nimport { HttpServerRequest, HttpServerResponse } from \"@effect/platform\"\n\n// ============================================\n// 1. CORS configuration\n// ============================================\n\ninterface CorsConfig {\n  readonly allowedOrigins: ReadonlyArray<string> | \"*\"\n  readonly allowedMethods: ReadonlyArray<string>\n  readonly allowedHeaders: ReadonlyArray<string>\n  readonly exposedHeaders?: ReadonlyArray<string>\n  readonly credentials?: boolean\n  readonly maxAge?: number\n}\n\nconst defaultCorsConfig: CorsConfig = {\n  allowedOrigins: \"*\",\n  allowedMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n  allowedHeaders: [\"Content-Type\", \"Authorization\", \"X-Request-Id\"],\n  exposedHeaders: [\"X-Request-Id\", \"X-Response-Time\"],\n  credentials: false,\n  maxAge: 86400, // 24 hours\n}\n\n// ============================================\n// 2. Check if origin is allowed\n// ============================================\n\nconst isOriginAllowed = (\n  origin: string | undefined,\n  allowedOrigins: ReadonlyArray<string> | \"*\"\n): boolean => {\n  if (!origin) return false\n  if (allowedOrigins === \"*\") return true\n  return allowedOrigins.includes(origin)\n}\n\n// ============================================\n// 3. Add CORS headers to response\n// ============================================\n\nconst addCorsHeaders = (\n  response: HttpServerResponse.HttpServerResponse,\n  origin: string | undefined,\n  config: CorsConfig\n): HttpServerResponse.HttpServerResponse => {\n  let result = response\n\n  // Set allowed origin\n  if (config.allowedOrigins === \"*\") {\n    result = HttpServerResponse.setHeader(result, \"Access-Control-Allow-Origin\", \"*\")\n  } else if (origin && isOriginAllowed(origin, config.allowedOrigins)) {\n    result = HttpServerResponse.setHeader(result, \"Access-Control-Allow-Origin\", origin)\n    result = HttpServerResponse.setHeader(result, \"Vary\", \"Origin\")\n  }\n\n  // Set allowed methods\n  result = HttpServerResponse.setHeader(\n    result,\n    \"Access-Control-Allow-Methods\",\n    config.allowedMethods.join(\", \")\n  )\n\n  // Set allowed headers\n  result = HttpServerResponse.setHeader(\n    result,\n    \"Access-Control-Allow-Headers\",\n    config.allowedHeaders.join(\", \")\n  )\n\n  // Set exposed headers\n  if (config.exposedHeaders?.length) {\n    result = HttpServerResponse.setHeader(\n      result,\n      \"Access-Control-Expose-Headers\",\n      config.exposedHeaders.join(\", \")\n    )\n  }\n\n  // Set credentials\n  if (config.credentials) {\n    result = HttpServerResponse.setHeader(\n      result,\n      \"Access-Control-Allow-Credentials\",\n      \"true\"\n    )\n  }\n\n  // Set max age for preflight cache\n  if (config.maxAge) {\n    result = HttpServerResponse.setHeader(\n      result,\n      \"Access-Control-Max-Age\",\n      String(config.maxAge)\n    )\n  }\n\n  return result\n}\n\n// ============================================\n// 4. CORS middleware\n// ============================================\n\nconst withCors = (config: CorsConfig = defaultCorsConfig) =>\n  <E, R>(\n    handler: Effect.Effect<HttpServerResponse.HttpServerResponse, E, R>\n  ): Effect.Effect<\n    HttpServerResponse.HttpServerResponse,\n    E,\n    R | HttpServerRequest.HttpServerRequest\n  > =>\n    Effect.gen(function* () {\n      const request = yield* HttpServerRequest.HttpServerRequest\n      const origin = request.headers[\"origin\"]\n\n      // Handle preflight OPTIONS request\n      if (request.method === \"OPTIONS\") {\n        const preflightResponse = HttpServerResponse.empty({ status: 204 })\n        return addCorsHeaders(preflightResponse, origin, config)\n      }\n\n      // Check if origin is allowed\n      if (\n        origin &&\n        config.allowedOrigins !== \"*\" &&\n        !isOriginAllowed(origin, config.allowedOrigins)\n      ) {\n        return HttpServerResponse.json(\n          { error: \"CORS: Origin not allowed\" },\n          { status: 403 }\n        )\n      }\n\n      // Process request and add CORS headers to response\n      const response = yield* handler\n      return addCorsHeaders(response, origin, config)\n    })\n\n// ============================================\n// 5. Usage examples\n// ============================================\n\n// Allow all origins (development)\nconst devCors = withCors({\n  ...defaultCorsConfig,\n  allowedOrigins: \"*\",\n})\n\n// Specific origins (production)\nconst prodCors = withCors({\n  allowedOrigins: [\n    \"https://myapp.com\",\n    \"https://admin.myapp.com\",\n  ],\n  allowedMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n  allowedHeaders: [\"Content-Type\", \"Authorization\"],\n  credentials: true,\n  maxAge: 3600,\n})\n\n// Apply to handlers\nconst myHandler = Effect.succeed(\n  HttpServerResponse.json({ message: \"Hello!\" })\n)\n\nconst corsEnabledHandler = devCors(myHandler)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Configure CORS headers to allow legitimate cross-origin requests while blocking unauthorized ones."
            },
            "created_at": "2026-02-15T21:22:25.549677",
            "updated_at": "2026-02-20T23:09:35.855676"
        },
        {
            "id": "f1398a79-d2bf-420c-b958-b05f781224d9",
            "slug": "concurrency-pattern-queue-work-distribution",
            "title": "Concurrency Pattern 4: Distribute Work with Queue",
            "summary": "Use Queue to decouple producers and consumers, enabling work distribution, pipeline stages, and backpressure handling across concurrent fibers.",
            "skill_level": "intermediate",
            "category": "concurrency",
            "difficulty": "intermediate",
            "tags": [
                "concurrency",
                "queue",
                "producer-consumer",
                "backpressure",
                "work-distribution",
                "decoupling"
            ],
            "examples": [
                {
                    "code": "import { Effect, Queue, Fiber, Ref } from \"effect\";\n\ninterface WorkItem {\n  readonly id: number;\n  readonly data: string;\n  readonly timestamp: number;\n}\n\ninterface WorkResult {\n  readonly itemId: number;\n  readonly processed: string;\n  readonly duration: number;\n}\n\n// Producer: generates work items\nconst producer = (\n  queue: Queue.Enqueue<WorkItem>,\n  count: number\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`[PRODUCER] Starting, generating ${count} items`);\n\n    for (let i = 1; i <= count; i++) {\n      const item: WorkItem = {\n        id: i,\n        data: `Item ${i}`,\n        timestamp: Date.now(),\n      };\n\n      const start = Date.now();\n\n      // Enqueue - will block if queue is full (backpressure)\n      yield* Queue.offer(queue, item);\n\n      const delay = Date.now() - start;\n\n      if (delay > 0) {\n        yield* Effect.log(\n          `[PRODUCER] Item ${i} enqueued (waited ${delay}ms due to backpressure)`\n        );\n      } else {\n        yield* Effect.log(`[PRODUCER] Item ${i} enqueued`);\n      }\n\n      // Simulate work\n      yield* Effect.sleep(\"50 millis\");\n    }\n\n    yield* Effect.log(`[PRODUCER] \u2713 All items enqueued`);\n  });\n\n// Consumer: processes work items\nconst consumer = (\n  queue: Queue.Dequeue<WorkItem>,\n  consumerId: number,\n  results: Ref.Ref<WorkResult[]>\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`[CONSUMER ${consumerId}] Starting`);\n\n    while (true) {\n      // Dequeue - will block if queue is empty\n      const item = yield* Queue.take(queue).pipe(Effect.either);\n\n      if (item._tag === \"Left\") {\n        yield* Effect.log(`[CONSUMER ${consumerId}] Queue closed, stopping`);\n        return;\n      }\n\n      const workItem = item.right;\n      const startTime = Date.now();\n\n      yield* Effect.log(\n        `[CONSUMER ${consumerId}] Processing ${workItem.data}`\n      );\n\n      // Simulate processing\n      yield* Effect.sleep(\"150 millis\");\n\n      const duration = Date.now() - startTime;\n      const result: WorkResult = {\n        itemId: workItem.id,\n        processed: `${workItem.data} [processed by consumer ${consumerId}]`,\n        duration,\n      };\n\n      yield* Ref.update(results, (rs) => [...rs, result]);\n\n      yield* Effect.log(\n        `[CONSUMER ${consumerId}] \u2713 Completed ${workItem.data} in ${duration}ms`\n      );\n    }\n  });\n\n// Main: coordinate producer and consumers\nconst program = Effect.gen(function* () {\n  // Create bounded queue with capacity 3\n  const queue = yield* Queue.bounded<WorkItem>(3);\n  const results = yield* Ref.make<WorkResult[]>([]);\n\n  console.log(`\\n[MAIN] Starting producer-consumer pipeline with queue size 3\\n`);\n\n  // Spawn producer\n  const producerFiber = yield* producer(queue, 10).pipe(Effect.fork);\n\n  // Spawn 2 consumers\n  const consumer1 = yield* consumer(queue, 1, results).pipe(Effect.fork);\n  const consumer2 = yield* consumer(queue, 2, results).pipe(Effect.fork);\n\n  // Wait for producer to finish\n  yield* Fiber.join(producerFiber);\n\n  // Give consumers time to finish\n  yield* Effect.sleep(\"3 seconds\");\n\n  // Close queue and wait for consumers\n  yield* Queue.shutdown(queue);\n  yield* Fiber.join(consumer1);\n  yield* Fiber.join(consumer2);\n\n  // Summary\n  const allResults = yield* Ref.get(results);\n  const totalDuration = allResults.reduce((sum, r) => sum + r.duration, 0);\n\n  console.log(`\\n[SUMMARY]`);\n  console.log(`  Items processed: ${allResults.length}`);\n  console.log(\n    `  Avg processing time: ${Math.round(totalDuration / allResults.length)}ms`\n  );\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Queue to distribute work between producers and consumers with built-in backpressure, enabling flexible pipeline coordination."
            },
            "created_at": "2026-02-15T21:22:19.520604",
            "updated_at": "2026-02-20T23:09:36.23198"
        },
        {
            "id": "4a6410f3-2fc4-4517-bd9a-536574459c05",
            "slug": "poll-for-status-until-task-completes",
            "title": "Poll for Status Until a Task Completes",
            "summary": "Use Effect.race to run a repeating polling effect alongside a main task, automatically stopping the polling when the main task finishes.",
            "skill_level": "advanced",
            "category": "concurrency",
            "difficulty": "advanced",
            "tags": [
                "polling",
                "repeat",
                "race",
                "concurrency",
                "schedule",
                "long-running-task"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule, Duration } from \"effect\";\n\n// The main task that takes a long time to complete\nconst longRunningJob = Effect.log(\"Data processing complete!\").pipe(\n  Effect.delay(Duration.seconds(10))\n);\n\n// The polling task that checks the status\nconst pollStatus = Effect.log(\"Polling for job status: In Progress...\");\n\n// A schedule that repeats the polling task every 2 seconds, forever\nconst pollingSchedule = Schedule.fixed(Duration.seconds(2));\n\n// The complete polling effect that will run indefinitely until interrupted\nconst repeatingPoller = pollStatus.pipe(Effect.repeat(pollingSchedule));\n\n// Race the main job against the poller.\n// The longRunningJob will win after 10 seconds, interrupting the poller.\nconst program = Effect.race(longRunningJob, repeatingPoller);\n\nEffect.runPromise(program);\n/*\nOutput:\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nPolling for job status: In Progress...\nData processing complete!\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.race to run a repeating polling task that is automatically interrupted when a main task completes."
            },
            "created_at": "2026-02-15T21:22:20.524671",
            "updated_at": "2026-02-20T23:09:36.314721"
        },
        {
            "id": "1baa96dd-dd6b-409e-8164-264292bf9ca2",
            "slug": "concurrency-pattern-coordinate-with-deferred",
            "title": "Concurrency Pattern 1: Coordinate Async Operations with Deferred",
            "summary": "Use Deferred to coordinate async operations where multiple fibers wait for a single event to complete, enabling producer-consumer patterns and async signaling without polling.",
            "skill_level": "intermediate",
            "category": "concurrency",
            "difficulty": "intermediate",
            "tags": [
                "concurrency",
                "deferred",
                "coordination",
                "async-signaling",
                "producer-consumer",
                "synchronization"
            ],
            "examples": [
                {
                    "code": "import { Effect, Deferred, Fiber } from \"effect\";\n\ninterface ServiceConfig {\n  readonly name: string;\n  readonly port: number;\n}\n\ninterface Service {\n  readonly name: string;\n  readonly isReady: Deferred.Deferred<void>;\n}\n\n// Simulate a service that takes time to initialize\nconst createService = (config: ServiceConfig): Effect.Effect<Service> =>\n  Effect.gen(function* () {\n    const isReady = yield* Deferred.make<void>();\n\n    return { name: config.name, isReady };\n  });\n\n// Initialize the service (runs in background)\nconst initializeService = (service: Service): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`[${service.name}] Starting initialization...`);\n\n    // Simulate initialization work\n    yield* Effect.sleep(\"1 second\");\n\n    yield* Effect.log(`[${service.name}] Initialization complete`);\n\n    // Signal that service is ready\n    yield* Deferred.succeed(service.isReady, undefined);\n  });\n\n// A worker that waits for service to be ready before starting\nconst createWorker = (\n  id: number,\n  services: Service[]\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`[Worker ${id}] Starting, waiting for services...`);\n\n    // Wait for all services to be ready\n    yield* Effect.all(\n      services.map((service) =>\n        Deferred.await(service.isReady).pipe(\n          Effect.tapError((error) =>\n            Effect.log(\n              `[Worker ${id}] Error waiting for ${service.name}: ${error}`\n            )\n          )\n        )\n      )\n    );\n\n    yield* Effect.log(`[Worker ${id}] All services ready, starting work`);\n\n    // Simulate worker processing\n    for (let i = 0; i < 3; i++) {\n      yield* Effect.sleep(\"500 millis\");\n      yield* Effect.log(`[Worker ${id}] Processing task ${i + 1}`);\n    }\n\n    yield* Effect.log(`[Worker ${id}] Complete`);\n  });\n\n// Main program\nconst program = Effect.gen(function* () {\n  // Create services\n  const apiService = yield* createService({ name: \"API\", port: 3000 });\n  const dbService = yield* createService({ name: \"Database\", port: 5432 });\n  const cacheService = yield* createService({ name: \"Cache\", port: 6379 });\n\n  const services = [apiService, dbService, cacheService];\n\n  // Start initializing services in background\n  const initFibers = yield* Effect.all(\n    services.map((service) => initializeService(service).pipe(Effect.fork))\n  );\n\n  // Start workers that wait for services\n  const workerFibers = yield* Effect.all(\n    [1, 2, 3].map((id) => createWorker(id, services).pipe(Effect.fork))\n  );\n\n  // Wait for all workers to complete\n  yield* Effect.all(workerFibers.map((fiber) => Fiber.join(fiber)));\n\n  // Cancel initialization fibers (they're done anyway)\n  yield* Effect.all(initFibers.map((fiber) => Fiber.interrupt(fiber)));\n\n  yield* Effect.log(`\\n[MAIN] All workers completed`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Deferred for one-time async coordination between fibers, enabling multiple consumers to wait for a single producer's result."
            },
            "created_at": "2026-02-15T21:22:19.259048",
            "updated_at": "2026-02-20T23:09:36.370046"
        },
        {
            "id": "6c6387c9-cd4d-4ece-bec3-9e7169dc9967",
            "slug": "decouple-fibers-with-queue-pubsub",
            "title": "Decouple Fibers with Queues and PubSub",
            "summary": "Use Queue for point-to-point work distribution and PubSub for broadcast messaging to enable safe, decoupled communication between concurrent fibers.",
            "skill_level": "advanced",
            "category": "concurrency",
            "difficulty": "advanced",
            "tags": [
                "queue",
                "pubsub",
                "concurrency",
                "decoupling",
                "architecture",
                "messaging",
                "event-driven"
            ],
            "examples": [
                {
                    "code": "import { Effect, Queue, Fiber } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting queue demo...\");\n\n  // Create a bounded queue that can hold a maximum of 10 items.\n  // This prevents memory issues by applying backpressure when the queue is full.\n  // If a producer tries to add to a full queue, it will suspend until space is available.\n  const queue = yield* Queue.bounded<string>(10);\n  yield* Effect.logInfo(\"Created bounded queue\");\n\n  // Producer Fiber: Add a job to the queue every second.\n  // This fiber runs independently and continuously produces work items.\n  // The producer-consumer pattern decouples work generation from work processing.\n  const producer = yield* Effect.gen(function* () {\n    let i = 0;\n    while (true) {\n      const job = `job-${i++}`;\n      yield* Effect.logInfo(`Producing ${job}...`);\n\n      // Queue.offer adds an item to the queue. If the queue is full,\n      // this operation will suspend the fiber until space becomes available.\n      // This provides natural backpressure control.\n      yield* Queue.offer(queue, job);\n\n      // Sleep for 500ms between job creation. This controls the production rate.\n      // Producer is faster than consumer (500ms vs 1000ms) to demonstrate queue buffering.\n      yield* Effect.sleep(\"500 millis\");\n    }\n  }).pipe(Effect.fork); // Fork creates a new fiber that runs concurrently\n\n  yield* Effect.logInfo(\"Started producer fiber\");\n\n  // Worker Fiber: Take a job from the queue and process it.\n  // This fiber runs independently and processes work items as they become available.\n  // Multiple workers could be created to scale processing capacity.\n  const worker = yield* Effect.gen(function* () {\n    while (true) {\n      // Queue.take removes and returns an item from the queue.\n      // If the queue is empty, this operation will suspend the fiber\n      // until an item becomes available. This prevents busy-waiting.\n      const job = yield* Queue.take(queue);\n      yield* Effect.logInfo(`Processing ${job}...`);\n\n      // Simulate work by sleeping for 1 second.\n      // This makes the worker slower than the producer, causing queue buildup.\n      yield* Effect.sleep(\"1 second\");\n      yield* Effect.logInfo(`Completed ${job}`);\n    }\n  }).pipe(Effect.fork); // Fork creates another independent fiber\n\n  yield* Effect.logInfo(\"Started worker fiber\");\n\n  // Let them run for a while...\n  // The main fiber sleeps while the producer and worker fibers run concurrently.\n  // During this time, you'll see the queue acting as a buffer between\n  // the fast producer and slow worker.\n  yield* Effect.logInfo(\"Running for 10 seconds...\");\n  yield* Effect.sleep(\"10 seconds\");\n  yield* Effect.logInfo(\"Done!\");\n\n  // Interrupt both fibers to clean up resources.\n  // Fiber.interrupt sends an interruption signal to the fiber,\n  // allowing it to perform cleanup operations before terminating.\n  // This is safer than forcefully killing fibers.\n  yield* Fiber.interrupt(producer);\n  yield* Fiber.interrupt(worker);\n\n  // Note: In a real application, you might want to:\n  // 1. Drain the queue before interrupting workers\n  // 2. Use Fiber.join to wait for graceful shutdown\n  // 3. Handle interruption signals in the fiber loops\n});\n\n// Run the program\n// This demonstrates the producer-consumer pattern with Effect fibers:\n// - Fibers are lightweight threads that can be created in large numbers\n// - Queues provide safe communication between fibers\n// - Backpressure prevents resource exhaustion\n// - Interruption allows for graceful shutdown\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Queue for point-to-point work distribution and PubSub for broadcast messaging between fibers."
            },
            "created_at": "2026-02-15T21:22:20.204633",
            "updated_at": "2026-02-20T23:09:36.598416"
        },
        {
            "id": "cf9b27e2-6cd4-4a49-9f17-42e883ac5070",
            "slug": "schema-api-response-nested",
            "title": "Decoding Nested API Responses",
            "summary": "Real APIs rarely return flat objects. Responses are deeply nested: users have profiles, profiles have addresses, addresses have coordinates.",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "api",
                "nested-objects",
                "complex-structures",
                "composition"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema } from \"effect\"\n\n// Build schemas bottom-up for clarity and reuse\n\n// Level 1: Leaf schema (no dependencies)\nconst Coordinate = Schema.Struct({\n  latitude: Schema.Number,\n  longitude: Schema.Number,\n})\n\ntype Coordinate = typeof Coordinate.Type\n\n// Level 2: Compose Coordinate into Address\nconst Address = Schema.Struct({\n  street: Schema.String,\n  city: Schema.String,\n  zipCode: Schema.String,\n  coordinates: Coordinate, // Nested schema\n})\n\ntype Address = typeof Address.Type\n\n// Level 3: Compose Address into Profile\nconst Profile = Schema.Struct({\n  bio: Schema.optional(Schema.String),\n  address: Address, // Nested schema\n  tags: Schema.Array(Schema.String),\n})\n\ntype Profile = typeof Profile.Type\n\n// Level 4: Compose Profile into User\nconst User = Schema.Struct({\n  id: Schema.Number,\n  name: Schema.String,\n  email: Schema.String,\n  profile: Profile, // Nested schema\n})\n\ntype User = typeof User.Type\n\n// Now create decoders at each level\nconst parseCoordinate = Schema.decodeUnknown(Coordinate)\nconst parseAddress = Schema.decodeUnknown(Address)\nconst parseProfile = Schema.decodeUnknown(Profile)\nconst parseUser = Schema.decodeUnknown(User)\n\n// Use in pipeline\nconst fetchUser = (id: number) =>\n  Effect.gen(function* () {\n    const response = yield* Effect.tryPromise(() =>\n      fetch(`https://api.example.com/users/${id}`).then((r) => r.json())\n    )\n\n    // One call validates entire tree\n    const user = yield* parseUser(response)\n\n    // user.profile.address.coordinates is fully typed and validated\n    yield* Effect.log(\n      `${user.name} lives at ${user.profile.address.city} (${user.profile.address.coordinates.latitude})`\n    )\n\n    return user\n  })\n\n// Alternative: Validate step-by-step for partial recovery\nconst fetchUserPartial = (id: number) =>\n  Effect.gen(function* () {\n    const response = yield* Effect.tryPromise(() =>\n      fetch(`https://api.example.com/users/${id}`).then((r) => r.json())\n    )\n\n    // Validate user fields first\n    const userFields = yield* Schema.decodeUnknown(\n      Schema.Struct({\n        id: Schema.Number,\n        name: Schema.String,\n        email: Schema.String,\n      })\n    )(response)\n\n    // Then validate nested profile\n    const profile = yield* Effect.orElse(\n      parseProfile(response.profile),\n      () =>\n        Effect.gen(function* () {\n          yield* Effect.log(\"Profile validation failed, using default\")\n          return {\n            bio: undefined,\n            address: {\n              street: \"Unknown\",\n              city: \"Unknown\",\n              zipCode: \"Unknown\",\n              coordinates: { latitude: 0, longitude: 0 },\n            },\n            tags: [],\n          } as Profile\n        })\n    )\n\n    return { ...userFields, profile }\n  })\n\n// Paginated response example\nconst UserResponse = Schema.Struct({\n  status: Schema.Literal(\"success\", \"error\"),\n  data: Schema.Array(User),\n  meta: Schema.Struct({\n    total: Schema.Number,\n    page: Schema.Number,\n    perPage: Schema.Number,\n  }),\n})\n\ntype UserResponse = typeof UserResponse.Type\n\nconst parseUserResponse = Schema.decodeUnknown(UserResponse)\n\nconst fetchUsers = (page: number) =>\n  Effect.gen(function* () {\n    const response = yield* Effect.tryPromise(() =>\n      fetch(`https://api.example.com/users?page=${page}`).then((r) =>\n        r.json()\n      )\n    )\n\n    const { data, meta } = yield* parseUserResponse(response)\n\n    yield* Effect.log(\n      `Fetched ${data.length} of ${meta.total} users (page ${meta.page})`\n    )\n\n    return { users: data, pagination: meta }\n  })\n\n// Execute\nconst main = Effect.gen(function* () {\n  const { users, pagination } = yield* fetchUsers(1)\n  yield* Effect.log(`Total pages: ${Math.ceil(pagination.total / pagination.perPage)}`)\n})\n\nEffect.runPromise(main)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Decode Nested API Responses using Schema."
            },
            "created_at": "2026-02-16T21:39:05.764377",
            "updated_at": "2026-02-20T23:09:37.501379"
        },
        {
            "id": "dd1adc40-a2ad-4f2c-a88a-f9f4aa3129c1",
            "slug": "observability-effect-fn",
            "title": "Instrument and Observe Function Calls with Effect.fn",
            "summary": "Use Effect.fn to wrap, instrument, and observe function calls, enabling composable logging, metrics, and tracing at function boundaries.",
            "skill_level": "intermediate",
            "category": "observability",
            "difficulty": "intermediate",
            "tags": [
                "Effect.fn",
                "observability",
                "instrumentation",
                "function",
                "logging",
                "metrics",
                "tracing"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// A simple function to instrument\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Use Effect.fn to instrument the function with observability\nconst addWithLogging = Effect.fn(\"add\")(add).pipe(\n  Effect.withSpan(\"add\", { attributes: { \"fn.name\": \"add\" } })\n);\n\n// Use the instrumented function in an Effect workflow\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Calling add function\");\n  const sum = yield* addWithLogging(2, 3);\n  yield* Effect.logInfo(`Sum is ${sum}`);\n  return sum;\n});\n\n// Run the program\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.fn to wrap functions with effectful instrumentation, such as logging, metrics, or tracing, in a composable and type-safe way."
            },
            "created_at": "2026-02-15T21:22:29.378869",
            "updated_at": "2026-02-20T23:09:43.083879"
        },
        {
            "id": "20746800-ada6-48db-bd16-a378b99d4396",
            "slug": "process-collection-in-parallel-with-foreach",
            "title": "Process a Collection in Parallel with Effect.forEach",
            "summary": "Use Effect.forEach with the `concurrency` option to process a collection of items in parallel with a fixed limit, preventing resource exhaustion.",
            "skill_level": "intermediate",
            "category": "concurrency",
            "difficulty": "intermediate",
            "tags": [
                "concurrency",
                "parallel",
                "foreach",
                "performance",
                "batching",
                "rate-limiting"
            ],
            "examples": [
                {
                    "code": "import { Clock, Effect } from \"effect\";\n\n// Mock function to simulate fetching a user by ID\nconst fetchUserById = (id: number) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Fetching user ${id}...`);\n    yield* Effect.sleep(\"1 second\"); // Simulate network delay\n    return { id, name: `User ${id}`, email: `user${id}@example.com` };\n  });\n\nconst userIds = Array.from({ length: 10 }, (_, i) => i + 1);\n\n// Process the entire array, but only run 5 fetches at a time.\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting parallel processing...\");\n\n  const startTime = yield* Clock.currentTimeMillis;\n  const users = yield* Effect.forEach(userIds, fetchUserById, {\n    concurrency: 5, // Limit to 5 concurrent operations\n  });\n  const endTime = yield* Clock.currentTimeMillis;\n\n  yield* Effect.logInfo(\n    `Processed ${users.length} users in ${endTime - startTime}ms`\n  );\n  yield* Effect.logInfo(\n    `First few users: ${JSON.stringify(users.slice(0, 3), null, 2)}`\n  );\n\n  return users;\n});\n\n// The result will be an array of all user objects.\n// The total time will be much less than running them sequentially.\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.forEach with the `concurrency` option to process a collection in parallel with a fixed limit."
            },
            "created_at": "2026-02-15T21:22:19.851163",
            "updated_at": "2026-02-20T23:09:36.455183"
        },
        {
            "id": "133ebfaf-35c9-4399-b470-e719dbab3fcb",
            "slug": "run-effects-in-parallel-with-all",
            "title": "Run Independent Effects in Parallel with Effect.all",
            "summary": "Use Effect.all to run multiple independent effects concurrently and collect all their results into a single tuple.",
            "skill_level": "intermediate",
            "category": "concurrency",
            "difficulty": "intermediate",
            "tags": [
                "concurrency",
                "parallel",
                "performance",
                "all",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Simulate fetching a user, takes 1 second\nconst fetchUser = Effect.succeed({ id: 1, name: \"Paul\" }).pipe(\n  Effect.delay(\"1 second\")\n);\n\n// Simulate fetching posts, takes 1.5 seconds\nconst fetchPosts = Effect.succeed([{ title: \"Effect is great\" }]).pipe(\n  Effect.delay(\"1.5 seconds\")\n);\n\n// Run both effects concurrently - must specify concurrency option!\nconst program = Effect.all([fetchUser, fetchPosts], {\n  concurrency: \"unbounded\",\n});\n\n// The resulting effect will succeed with a tuple: [{id, name}, [{title}]]\n// Total execution time will be ~1.5 seconds (the duration of the longest task).\nconst programWithLogging = Effect.gen(function* () {\n  const results = yield* program;\n  yield* Effect.log(`Results: ${JSON.stringify(results)}`);\n  return results;\n});\n\nEffect.runPromise(programWithLogging);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.all to execute a collection of independent effects concurrently."
            },
            "created_at": "2026-02-15T21:22:20.030166",
            "updated_at": "2026-02-20T23:09:36.736016"
        },
        {
            "id": "1f1c5d4f-e6f4-4a2d-a39a-fa87c932cb90",
            "slug": "schema-api-response-with-http-client",
            "title": "Full Pipeline with @effect/platform",
            "summary": "Production code needs more than `fetch()`: connection pooling, request timeouts, retries, logging, metrics, and proper resource management. Using `Effect.tryPromise` with raw `fetch` is fragile.",
            "skill_level": "advanced",
            "category": "schema",
            "difficulty": "advanced",
            "tags": [
                "schema",
                "api",
                "http-client",
                "effect-platform",
                "production"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema, Duration, HttpClient, Layer } from \"effect\"\nimport { HttpClientRequest, HttpClientResponse } from \"@effect/platform\"\n\n// 1. Define the schema\nconst User = Schema.Struct({\n  id: Schema.Number,\n  name: Schema.String,\n  email: Schema.String,\n})\n\ntype User = typeof User.Type\n\nconst parseUser = Schema.decodeUnknown(User)\n\n// 2. Create a typed HTTP client service\ninterface UserClient {\n  readonly getUser: (id: number) => Effect.Effect<User>\n}\n\nconst UserClient = Effect.Tag<UserClient>()\n\n// 3. Implement the service\nconst UserClientLive = Layer.succeed(\n  UserClient,\n  {\n    getUser: (id: number) =>\n      Effect.gen(function* () {\n        const client = yield* HttpClient.HttpClient\n\n        // Build request\n        const request = HttpClientRequest.get(\n          `https://api.example.com/users/${id}`\n        )\n\n        // Execute request with timeout\n        const response = yield* client(request).pipe(\n          Effect.timeout(Duration.seconds(5))\n        )\n\n        // Validate status\n        const statusCode = response.status\n\n        if (statusCode !== 200) {\n          return yield* Effect.fail(\n            new Error(`HTTP ${statusCode}: Failed to fetch user ${id}`)\n          )\n        }\n\n        // Parse body as JSON\n        const body = yield* response.json\n\n        // Validate against schema\n        const user = yield* parseUser(body)\n\n        return user\n      }).pipe(\n        // Retry on transient errors\n        Effect.retry({\n          times: 3,\n          delay: Duration.millis(100),\n          schedule: Effect.exponential(Duration.millis(100)),\n        })\n      ),\n  } satisfies UserClient\n)\n\n// 4. Use the service\nconst fetchUser = (id: number) =>\n  Effect.gen(function* () {\n    const userClient = yield* UserClient\n    const user = yield* userClient.getUser(id)\n\n    yield* Effect.log(`Fetched user: ${user.name} <${user.email}>`)\n\n    return user\n  })\n\n// 5. Run with proper resource management\nconst main = Effect.gen(function* () {\n  const user = yield* fetchUser(123)\n  yield* Effect.log(`Processing user: ${user.email}`)\n})\n\n// Provide the HTTP client and UserClient layers\nconst layer = Layer.merge(\n  HttpClient.layer, // Built-in HTTP client from @effect/platform\n  UserClientLive    // Our user service\n)\n\nawait Effect.runPromise(main.pipe(Effect.provide(layer)))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Full Pipeline with @effect/platform using Schema."
            },
            "created_at": "2026-02-16T21:39:05.931794",
            "updated_at": "2026-02-20T23:09:37.54719"
        },
        {
            "id": "deb42f66-0219-43a9-aba0-dfa7c149f4cc",
            "slug": "execute-long-running-apps-with-runfork",
            "title": "Execute Long-Running Apps with Effect.runFork",
            "summary": "Use Effect.runFork at the application's entry point to launch a long-running process as a detached fiber, allowing for graceful shutdown.",
            "skill_level": "advanced",
            "category": "concurrency",
            "difficulty": "advanced",
            "tags": [
                "runFork",
                "execution",
                "runtime",
                "fiber",
                "concurrency",
                "graceful-shutdown",
                "daemon"
            ],
            "examples": [
                {
                    "code": "import { Effect, Fiber } from \"effect\";\n\n// A server that listens for requests forever\nconst server = Effect.log(\"Server received a request.\").pipe(\n  Effect.delay(\"1 second\"),\n  Effect.forever\n);\n\nEffect.runSync(Effect.log(\"Starting server...\"));\n\n// Launch the server as a detached, top-level fiber\nconst appFiber = Effect.runFork(server);\n\n// In a real app, you would listen for OS signals.\n// Here, we simulate a shutdown signal after 5 seconds.\nsetTimeout(() => {\n  const shutdownProgram = Effect.gen(function* () {\n    yield* Effect.log(\"Shutdown signal received. Interrupting server fiber...\");\n    // This ensures all cleanup logic within the server effect would run.\n    yield* Fiber.interrupt(appFiber);\n  });\n  Effect.runPromise(shutdownProgram);\n}, 5000);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.runFork to launch a long-running application as a manageable, detached fiber."
            },
            "created_at": "2026-02-15T21:22:20.281154",
            "updated_at": "2026-02-20T23:09:36.778814"
        },
        {
            "id": "2129efc0-8979-4795-b26d-05904c0e8bbb",
            "slug": "concurrency-pattern-rate-limit-with-semaphore",
            "title": "Concurrency Pattern 2: Rate Limit Concurrent Access with Semaphore",
            "summary": "Use Semaphore to limit the number of concurrent operations, enabling connection pooling, API rate limiting, and controlled resource access without overload.",
            "skill_level": "intermediate",
            "category": "concurrency",
            "difficulty": "intermediate",
            "tags": [
                "concurrency",
                "semaphore",
                "rate-limiting",
                "resource-management",
                "connection-pool",
                "backpressure"
            ],
            "examples": [
                {
                    "code": "import { Effect, Semaphore, Fiber } from \"effect\";\n\ninterface QueryResult {\n  readonly id: number;\n  readonly result: string;\n  readonly duration: number;\n}\n\n// Simulate a database query that holds a connection\nconst executeQuery = (\n  queryId: number,\n  connectionId: number,\n  durationMs: number\n): Effect.Effect<QueryResult> =>\n  Effect.gen(function* () {\n    const startTime = Date.now();\n\n    yield* Effect.log(\n      `[Query ${queryId}] Using connection ${connectionId}, duration: ${durationMs}ms`\n    );\n\n    // Simulate query execution\n    yield* Effect.sleep(`${durationMs} millis`);\n\n    const duration = Date.now() - startTime;\n\n    return {\n      id: queryId,\n      result: `Result from query ${queryId}`,\n      duration,\n    };\n  });\n\n// Pool configuration\ninterface ConnectionPoolConfig {\n  readonly maxConnections: number;\n  readonly queryTimeout?: number;\n}\n\n// Create a rate-limited query executor\nconst createRateLimitedQueryExecutor = (\n  config: ConnectionPoolConfig\n): Effect.Effect<\n  (queryId: number, durationMs: number) => Effect.Effect<QueryResult>\n> =>\n  Effect.gen(function* () {\n    const semaphore = yield* Semaphore.make(config.maxConnections);\n    let connectionCounter = 0;\n\n    return (queryId: number, durationMs: number) =>\n      Effect.gen(function* () {\n        // Acquire a permit (wait if none available)\n        yield* Semaphore.acquire(semaphore);\n\n        const connectionId = ++connectionCounter;\n\n        // Use try-finally to ensure permit is released\n        const result = yield* executeQuery(queryId, connectionId, durationMs).pipe(\n          Effect.ensuring(\n            Semaphore.release(semaphore).pipe(\n              Effect.tap(() =>\n                Effect.log(`[Query ${queryId}] Released connection ${connectionId}`)\n              )\n            )\n          )\n        );\n\n        return result;\n      });\n  });\n\n// Simulate multiple queries arriving\nconst program = Effect.gen(function* () {\n  const executor = yield* createRateLimitedQueryExecutor({\n    maxConnections: 3, // Only 3 concurrent connections\n  });\n\n  // Generate 10 queries with varying durations\n  const queries = Array.from({ length: 10 }, (_, i) => ({\n    id: i + 1,\n    duration: 500 + Math.random() * 1500, // 500-2000ms\n  }));\n\n  console.log(`\\n[POOL] Starting with max 3 concurrent connections\\n`);\n\n  // Execute all queries with concurrency limit\n  const results = yield* Effect.all(\n    queries.map((q) =>\n      executor(q.id, Math.round(q.duration)).pipe(Effect.fork)\n    )\n  ).pipe(\n    Effect.andThen((fibers) =>\n      Effect.all(fibers.map((fiber) => Fiber.join(fiber)))\n    )\n  );\n\n  console.log(`\\n[POOL] All queries completed\\n`);\n\n  // Summary\n  const totalDuration = results.reduce((sum, r) => sum + r.duration, 0);\n  const avgDuration = totalDuration / results.length;\n\n  console.log(`[SUMMARY]`);\n  console.log(`  Total queries: ${results.length}`);\n  console.log(`  Avg duration: ${Math.round(avgDuration)}ms`);\n  console.log(`  Total time: ${Math.max(...results.map((r) => r.duration))}ms (parallel)`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Semaphore to limit concurrent access to resources, preventing overload and enabling fair resource distribution."
            },
            "created_at": "2026-02-15T21:22:19.342344",
            "updated_at": "2026-02-20T23:09:36.929448"
        },
        {
            "id": "45c3080a-ff08-40b2-b9bf-aa92c9da0517",
            "slug": "schema-api-response-with-retry",
            "title": "API Validation with Retry",
            "summary": "APIs are flaky. Network timeouts, rate limits, temporary service degradation\u2014these happen. You validate the response with a schema, but what if the API is temporarily down?",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "api",
                "retry",
                "error-recovery",
                "resilience"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema, Duration, Exit } from \"effect\"\n\n// Define the schema\nconst User = Schema.Struct({\n  id: Schema.Number,\n  name: Schema.String,\n  email: Schema.String,\n})\n\ntype User = typeof User.Type\n\nconst parseUser = Schema.decodeUnknown(User)\n\n// Custom errors to distinguish failure modes\nclass NetworkError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = \"NetworkError\"\n  }\n}\n\nclass ValidationError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = \"ValidationError\"\n  }\n}\n\n// Fetch with explicit error handling\nconst fetchUserRaw = (id: number) =>\n  Effect.tryPromise(() =>\n    fetch(`https://api.example.com/users/${id}`)\n      .then((r) => {\n        if (!r.ok) throw new NetworkError(`HTTP ${r.status}`)\n        return r.json()\n      })\n  ).pipe(\n    Effect.catchAll((error) =>\n      // Wrap fetch errors as NetworkError\n      Effect.fail(new NetworkError(String(error)))\n    )\n  )\n\n// Validate response\nconst validateUserResponse = (response: unknown) =>\n  parseUser(response).pipe(\n    Effect.mapError((error) => new ValidationError(String(error)))\n  )\n\n// Combine: fetch + validate with retry on network errors only\nconst fetchUserWithRetry = (id: number) =>\n  Effect.gen(function* () {\n    const response = yield* fetchUserRaw(id)\n    const user = yield* validateUserResponse(response)\n    return user\n  }).pipe(\n    // Retry only network errors, not validation errors\n    Effect.retry({\n      times: 3,\n      delay: Duration.millis(100), // Initial delay\n      schedule: Effect.linear(Duration.millis(100)), // Linear backoff\n    }),\n    Effect.catchTag(\"ValidationError\", (error) =>\n      // Don't retry validation errors\u2014fail immediately\n      Effect.fail(error)\n    ),\n    Effect.catchTag(\"NetworkError\", (error) =>\n      // All retries exhausted\n      Effect.fail(new Error(`Failed after 3 retries: ${error.message}`))\n    )\n  )\n\n// Alternative: Exponential backoff with max attempts\nconst fetchUserWithExponentialBackoff = (id: number) =>\n  Effect.gen(function* () {\n    const response = yield* fetchUserRaw(id)\n    const user = yield* validateUserResponse(response)\n    return user\n  }).pipe(\n    Effect.retry({\n      times: 5,\n      delay: Duration.millis(100),\n      schedule: Effect.exponential(Duration.millis(100)), // 100ms, 200ms, 400ms, 800ms, 1600ms\n    })\n  )\n\n// With logging for visibility\nconst fetchUserWithLogging = (id: number) =>\n  Effect.gen(function* () {\n    const response = yield* fetchUserRaw(id)\n    const user = yield* validateUserResponse(response)\n    return user\n  }).pipe(\n    Effect.retry({\n      times: 3,\n      delay: Duration.millis(100),\n      schedule: Effect.exponential(Duration.millis(100)),\n    }),\n    Effect.tapErrorTag(\"NetworkError\", (error) =>\n      Effect.log(`Network error fetching user ${id}: ${error.message}`)\n    ),\n    Effect.tapErrorTag(\"ValidationError\", (error) =>\n      Effect.log(`Validation error for user ${id}: ${error.message}`)\n    )\n  )\n\n// Batch fetch with retry\nconst fetchUsers = (ids: number[]) =>\n  Effect.gen(function* () {\n    yield* Effect.log(`Fetching ${ids.length} users...`)\n\n    const users = yield* Effect.forEach(ids, (id) =>\n      fetchUserWithLogging(id)\n    )\n\n    yield* Effect.log(`Successfully fetched ${users.length} users`)\n    return users\n  }).pipe(\n    // Retry entire batch on transient failures\n    Effect.retry({\n      times: 2,\n      delay: Duration.seconds(1),\n      schedule: Effect.linear(Duration.seconds(1)),\n    })\n  )\n\n// Advanced: Partial recovery - fetch what we can\nconst fetchUsersPartial = (ids: number[]) =>\n  Effect.gen(function* () {\n    const results = yield* Effect.forEach(ids, (id) =>\n      fetchUserWithRetry(id).pipe(Effect.exit)\n    )\n\n    const successful = results.filter(Exit.isSuccess).map((e) => e.value)\n    const failed = results.filter(Exit.isFailure).map((e) => e.cause)\n\n    yield* Effect.log(`Fetched ${successful.length}/${ids.length} users`)\n\n    if (failed.length > 0) {\n      yield* Effect.log(`${failed.length} users failed to fetch`)\n    }\n\n    return { users: successful, failedCount: failed.length }\n  })\n\n// Execute\nconst main = Effect.gen(function* () {\n  const user = yield* fetchUserWithRetry(123)\n  yield* Effect.log(`User: ${user.name}`)\n})\n\nawait Effect.runPromise(main)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "API Validation with Retry using Schema."
            },
            "created_at": "2026-02-16T21:39:05.104133",
            "updated_at": "2026-02-20T23:09:37.330891"
        },
        {
            "id": "8ab92ed0-8370-4682-a214-7ef536627d7e",
            "slug": "schema-api-response-error-handling",
            "title": "Handling Decode Failures",
            "summary": "You're decoding API responses with a Schema, but validation sometimes fails. You need to know *why* it failed so you can decide: retry, use a default, log it, or fail explicitly.",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "api",
                "error-handling",
                "validation",
                "recovery"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema, Exit } from \"effect\"\n\n// Define the schema\nconst User = Schema.Struct({\n  id: Schema.Number,\n  name: Schema.String,\n  email: Schema.String,\n})\n\ntype User = typeof User.Type\n\nconst parseUser = Schema.decodeUnknown(User)\n\n// Strategy 1: Catch and provide default\nconst fetchUserWithDefault = (id: number, defaultUser: User) =>\n  Effect.gen(function* () {\n    const response = yield* Effect.tryPromise(() =>\n      fetch(`https://api.example.com/users/${id}`).then((r) => r.json())\n    )\n\n    return yield* Effect.orElse(\n      parseUser(response),\n      () =>\n        Effect.gen(function* () {\n          yield* Effect.log(`Failed to parse user ${id}, using default`)\n          return defaultUser\n        })\n    )\n  })\n\n// Strategy 2: Catch and inspect the error\nconst fetchUserWithLogging = (id: number) =>\n  Effect.gen(function* () {\n    const response = yield* Effect.tryPromise(() =>\n      fetch(`https://api.example.com/users/${id}`).then((r) => r.json())\n    )\n\n    return yield* parseUser(response).pipe(\n      Effect.catchTag(\"ParseError\", (error) =>\n        Effect.gen(function* () {\n          yield* Effect.log(`Validation failed: ${error.message}`)\n          yield* Effect.log(`Full details: ${JSON.stringify(error.issue)}`)\n          return yield* Effect.fail(error)\n        })\n      )\n    )\n  })\n\n// Strategy 3: Try multiple decoders (union handling)\nconst UserV1 = Schema.Struct({\n  id: Schema.Number,\n  name: Schema.String,\n  email: Schema.String,\n})\n\nconst UserV2 = Schema.Struct({\n  userId: Schema.Number,\n  fullName: Schema.String,\n  contactEmail: Schema.String,\n})\n\nconst parseUserV1Or2 = (data: unknown) =>\n  Effect.gen(function* () {\n    // Try V1 first\n    const v1Result = yield* Effect.exit(Schema.decodeUnknown(UserV1)(data))\n\n    if (Exit.isSuccess(v1Result)) {\n      return v1Result.value\n    }\n\n    // Fall back to V2\n    const v2Result = yield* Schema.decodeUnknown(UserV2)(data)\n    return v2Result\n  })\n\n// Strategy 4: Collect all validation errors\nconst fetchUsersStrict = (ids: number[]) =>\n  Effect.gen(function* () {\n    const responses = yield* Effect.tryPromise(() =>\n      Promise.all(\n        ids.map((id) =>\n          fetch(`https://api.example.com/users/${id}`).then((r) => r.json())\n        )\n      )\n    )\n\n    // This will fail on first invalid response\n    const users = yield* Effect.forEach(\n      responses,\n      (response) => Schema.decodeUnknown(User)(response)\n    )\n\n    yield* Effect.log(`Successfully decoded ${users.length} users`)\n    return users\n  })\n\n// Handle validation errors\nconst main = Effect.gen(function* () {\n  const defaultUser: User = {\n    id: 0,\n    name: \"Unknown\",\n    email: \"unknown@example.com\",\n  }\n\n  const user = yield* fetchUserWithDefault(123, defaultUser)\n  yield* Effect.log(`Final user: ${user.name}`)\n})\n\nEffect.runPromise(main)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Handle Decode Failures using Schema."
            },
            "created_at": "2026-02-16T21:39:05.593753",
            "updated_at": "2026-02-20T23:09:37.456766"
        },
        {
            "id": "05d59045-1f7e-4957-95f0-c99aff7a8266",
            "slug": "race-concurrent-effects",
            "title": "Race Concurrent Effects for the Fastest Result",
            "summary": "Use Effect.race to run multiple effects concurrently and proceed with the result of the one that succeeds first, automatically interrupting the others.",
            "skill_level": "intermediate",
            "category": "concurrency",
            "difficulty": "intermediate",
            "tags": [
                "concurrency",
                "race",
                "performance",
                "timeout",
                "fallback"
            ],
            "examples": [
                {
                    "code": "import { Effect, Option } from \"effect\";\n\ntype User = { id: number; name: string };\n\n// Simulate a slower cache lookup that might find nothing (None)\nconst checkCache: Effect.Effect<Option.Option<User>> = Effect.succeed(\n  Option.none()\n).pipe(\n  Effect.delay(\"200 millis\") // Made slower so database wins\n);\n\n// Simulate a faster database query that will always find the data\nconst queryDatabase: Effect.Effect<Option.Option<User>> = Effect.succeed(\n  Option.some({ id: 1, name: \"Paul\" })\n).pipe(\n  Effect.delay(\"50 millis\") // Made faster so it wins the race\n);\n\n// Race them. The database should win and return the user data.\nconst program = Effect.race(checkCache, queryDatabase).pipe(\n  // The result of the race is an Option, so we can handle it.\n  Effect.flatMap((result: Option.Option<User>) =>\n    Option.match(result, {\n      onNone: () => Effect.fail(\"User not found anywhere.\"),\n      onSome: (user) => Effect.succeed(user),\n    })\n  )\n);\n\n// In this case, the database wins the race.\nconst programWithResults = Effect.gen(function* () {\n  try {\n    const user = yield* program;\n    yield* Effect.log(`User found: ${JSON.stringify(user)}`);\n    return user;\n  } catch (error) {\n    yield* Effect.logError(`Error: ${error}`);\n    throw error;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Handled error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithResults);\n\n// Also demonstrate with logging\nconst programWithLogging = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting race between cache and database...\");\n\n  try {\n    const user = yield* program;\n    yield* Effect.logInfo(\n      `Success: Found user ${user.name} with ID ${user.id}`\n    );\n    return user;\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n    return null;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logInfo(`Handled error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithLogging);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.race to get the result from the first of several effects to succeed, automatically interrupting the losers."
            },
            "created_at": "2026-02-15T21:22:19.940524",
            "updated_at": "2026-02-20T23:09:37.062909"
        },
        {
            "id": "69d61c86-4ca4-467b-9a4f-97e180663ed5",
            "slug": "schema-ai-output-with-descriptions",
            "title": "Adding Descriptions for AI Context",
            "summary": "You define a schema with field names like `confidence` or `category`, but the LLM doesn't understand the nuance of what you want. It might interpret fields differently than intended, leading to...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "ai",
                "descriptions",
                "json-schema",
                "documentation"
            ],
            "examples": [
                {
                    "code": "import { Schema, JSONSchema, Effect } from \"effect\"\nimport { Anthropic } from \"@anthropic-ai/sdk\"\n\n// 1. Define schema with descriptions\nconst MovieReview = Schema.Struct({\n  title: Schema.String.pipe(\n    Schema.description(\"Movie title from the review text\")\n  ),\n  rating: Schema.Number.pipe(\n    Schema.between(1, 10),\n    Schema.description(\n      \"Rating on scale of 1-10. Be precise: 7.5 is better than 8\"\n    )\n  ),\n  reviewSentiment: Schema.Literal(\"positive\", \"mixed\", \"negative\").pipe(\n    Schema.description(\n      \"Overall sentiment: positive (recommends watching), \" +\n      \"mixed (has pros and cons), negative (don't watch)\"\n    )\n  ),\n  strengths: Schema.Array(Schema.String).pipe(\n    Schema.description(\n      \"What worked well: acting, cinematography, plot, dialogue, etc. \" +\n      \"List 2-3 specific examples\"\n    )\n  ),\n  weaknesses: Schema.Array(Schema.String).pipe(\n    Schema.description(\n      \"What didn't work: pacing, character development, ending, etc. \" +\n      \"List 2-3 specific examples\"\n    )\n  ),\n  watchAgain: Schema.Boolean.pipe(\n    Schema.description(\"Would you watch this movie again? True if yes\")\n  ),\n})\n\ntype MovieReview = typeof MovieReview.Type\n\n// 2. Generate JSON Schema with descriptions\nconst jsonSchema = JSONSchema.make(MovieReview)\nconsole.log(JSON.stringify(jsonSchema, null, 2))\n// Output includes \"description\" fields in schema\n\n// 3. Use in LLM call\nconst reviewMovie = (reviewText: string) =>\n  Effect.gen(function* () {\n    const client = new Anthropic()\n\n    const response = yield* Effect.tryPromise({\n      try: () =>\n        client.messages.create({\n          model: \"claude-3-5-sonnet-20241022\",\n          max_tokens: 1024,\n          messages: [\n            {\n              role: \"user\",\n              content: `Extract structured review data from this text:\\n\\n${reviewText}`,\n            },\n          ],\n          tools: [\n            {\n              name: \"extract_review\",\n              description: \"Extract structured movie review data\",\n              input_schema: jsonSchema as any,\n            },\n          ],\n        }),\n      catch: (error) => new Error(`API call failed: ${error}`),\n    })\n\n    const toolUse = response.content.find(\n      (block) => block.type === \"tool_use\"\n    ) as any\n\n    if (!toolUse) {\n      return yield* Effect.fail(new Error(\"No tool use in response\"))\n    }\n\n    const result = yield* Effect.tryPromise({\n      try: () => Schema.decodeUnknownSync(MovieReview)(toolUse.input),\n      catch: (error) => new Error(`Validation failed: ${error}`),\n    })\n\n    return result\n  })\n\n// Usage\nconst sampleReview =\n  \"The Matrix is a masterpiece. The action scenes are groundbreaking, \" +\n  \"the plot twist is mind-bending, and Keanu Reeves is perfect. \" +\n  \"The only issue is some dialogue feels dated. I'd watch it again!\"\n\nEffect.runPromise(reviewMovie(sampleReview)).then((review) =>\n  console.log(JSON.stringify(review, null, 2))\n)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Add Descriptions for AI Context using Schema."
            },
            "created_at": "2026-02-16T21:39:06.431397",
            "updated_at": "2026-02-20T23:09:37.682821"
        },
        {
            "id": "4d34ec47-6bfa-48bb-8f2d-17e9f5728032",
            "slug": "schema-ai-output-basic",
            "title": "Basic AI Output Schema",
            "summary": "You're using an LLM to generate structured data. Without a schema, you get unpredictable JSON\u2014missing fields, wrong types, hallucinated keys. You need to define a schema that tells the LLM exactly...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "ai",
                "structured-output",
                "json-schema",
                "llm"
            ],
            "examples": [
                {
                    "code": "import { Schema, JSONSchema, Effect } from \"effect\"\nimport { Anthropic } from \"@anthropic-ai/sdk\"\n\n// 1. Define the output shape\nconst SentimentAnalysis = Schema.Struct({\n  sentiment: Schema.Literal(\"positive\", \"negative\", \"neutral\"),\n  confidence: Schema.Number.pipe(\n    Schema.between(0, 1)\n  ),\n  keywords: Schema.Array(Schema.String),\n})\n\n// 2. Derive the TypeScript type\ntype SentimentAnalysis = typeof SentimentAnalysis.Type\n\n// 3. Generate JSON Schema for the LLM\nconst jsonSchema = JSONSchema.make(SentimentAnalysis)\n\n// 4. Use in your LLM call\nconst analyzeSentiment = (text: string) =>\n  Effect.gen(function* () {\n    const client = new Anthropic()\n\n    const response = yield* Effect.tryPromise({\n      try: () =>\n        client.messages.create({\n          model: \"claude-3-5-sonnet-20241022\",\n          max_tokens: 1024,\n          messages: [\n            {\n              role: \"user\",\n              content: `Analyze the sentiment of: \"${text}\"`,\n            },\n          ],\n          tools: [\n            {\n              name: \"sentiment_analysis\",\n              description: \"Analyze sentiment of text\",\n              input_schema: jsonSchema as any,\n            },\n          ],\n        }),\n      catch: (error) => new Error(`API call failed: ${error}`),\n    })\n\n    // 5. Extract and validate the response\n    const toolUse = response.content.find(\n      (block) => block.type === \"tool_use\"\n    ) as any\n\n    if (!toolUse) {\n      return yield* Effect.fail(\n        new Error(\"No tool use in response\")\n      )\n    }\n\n    const parseResponse = Schema.decodeUnknown(SentimentAnalysis)\n    const result = yield* Effect.tryPromise({\n      try: () => parseResponse(toolUse.input),\n      catch: (error) => new Error(`Validation failed: ${error}`),\n    })\n\n    return result\n  })\n\n// Usage\nEffect.runPromise(analyzeSentiment(\"I absolutely love this product!\"))\n  .then((result) => console.log(result))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Basic AI Output Schema."
            },
            "created_at": "2026-02-16T21:39:06.601362",
            "updated_at": "2026-02-20T23:09:37.728883"
        },
        {
            "id": "a794882c-0816-4aa4-8e87-9413aa71a6ff",
            "slug": "schema-ai-output-unions-for-ai",
            "title": "Union Types for Flexible Outputs",
            "summary": "An LLM needs to return different response shapes depending on context. For example, a query might succeed with data, fail with an error, or be pending. Without union types, you either get a flat...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "ai",
                "unions",
                "discriminated-unions",
                "polymorphism"
            ],
            "examples": [
                {
                    "code": "import { Schema, JSONSchema, Effect } from \"effect\"\nimport { Anthropic } from \"@anthropic-ai/sdk\"\n\n// 1. Define success response\nconst SuccessResponse = Schema.Struct({\n  type: Schema.Literal(\"success\"),\n  data: Schema.Struct({\n    id: Schema.String,\n    name: Schema.String,\n    email: Schema.String.pipe(\n      Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)\n    ),\n    score: Schema.Number.pipe(Schema.between(0, 100)),\n  }),\n  timestamp: Schema.String.pipe(\n    Schema.description(\"ISO 8601 timestamp\")\n  ),\n})\n\n// 2. Define error response\nconst ErrorResponse = Schema.Struct({\n  type: Schema.Literal(\"error\"),\n  error: Schema.Struct({\n    code: Schema.Literal(\"not_found\", \"invalid_input\", \"server_error\"),\n    message: Schema.String,\n    details: Schema.String.pipe(Schema.optional),\n  }),\n  timestamp: Schema.String,\n})\n\n// 3. Define pending response\nconst PendingResponse = Schema.Struct({\n  type: Schema.Literal(\"pending\"),\n  requestId: Schema.String,\n  estimatedWaitSeconds: Schema.Number.pipe(\n    Schema.description(\"How long user should wait before retrying\")\n  ),\n  timestamp: Schema.String,\n})\n\n// 4. Create discriminated union\nconst QueryResponse = Schema.Union(\n  SuccessResponse,\n  ErrorResponse,\n  PendingResponse\n).pipe(\n  Schema.description(\"Response type determined by 'type' field\")\n)\n\ntype QueryResponse = typeof QueryResponse.Type\n\n// 5. Generate JSON Schema showing all variants\nconst jsonSchema = JSONSchema.make(QueryResponse)\n\n// 6. Use in LLM call\nconst queryLLM = (query: string) =>\n  Effect.gen(function* () {\n    const client = new Anthropic()\n\n    const response = yield* Effect.tryPromise({\n      try: () =>\n        client.messages.create({\n          model: \"claude-3-5-sonnet-20241022\",\n          max_tokens: 1024,\n          messages: [\n            {\n              role: \"user\",\n              content: `Process query and respond with appropriate structure:\\n\\n${query}`,\n            },\n          ],\n          tools: [\n            {\n              name: \"query_response\",\n              description: \"Response with success/error/pending states\",\n              input_schema: jsonSchema as any,\n            },\n          ],\n        }),\n      catch: (error) => new Error(`API call failed: ${error}`),\n    })\n\n    const toolUse = response.content.find(\n      (block) => block.type === \"tool_use\"\n    ) as any\n\n    if (!toolUse) {\n      return yield* Effect.fail(new Error(\"No tool use in response\"))\n    }\n\n    // Schema.decodeUnknownSync handles discriminated union\n    const result = yield* Effect.tryPromise({\n      try: () => Schema.decodeUnknownSync(QueryResponse)(toolUse.input),\n      catch: (error) => new Error(`Invalid response: ${error}`),\n    })\n\n    return result\n  })\n\n// 7. Type-safe pattern matching\nconst handleResponse = (response: QueryResponse): string => {\n  switch (response.type) {\n    case \"success\":\n      return `\u2705 Found: ${response.data.name} (${response.data.email})`\n\n    case \"error\":\n      if (response.error.code === \"not_found\") {\n        return `\u274c Not found: ${response.error.message}`\n      }\n      if (response.error.code === \"invalid_input\") {\n        return `\u26a0\ufe0f Invalid: ${response.error.message}`\n      }\n      return `\ud83d\udd25 Error: ${response.error.message}`\n\n    case \"pending\":\n      return `\u23f3 Pending (retry in ${response.estimatedWaitSeconds}s)`\n  }\n}\n\n// Usage example 1: Success case\nconst successQuery = \"Find user with email john@example.com\"\nEffect.runPromise(queryLLM(successQuery)).then((response) => {\n  console.log(handleResponse(response))\n\n  // Type narrowing: TypeScript knows this is SuccessResponse\n  if (response.type === \"success\") {\n    console.log(`Score: ${response.data.score}/100`)\n  }\n})\n\n// Usage example 2: Error case\nconst errorQuery = \"Find user with invalid ID xyz\"\nEffect.runPromise(queryLLM(errorQuery)).then((response) => {\n  console.log(handleResponse(response))\n\n  // Type narrowing works here too\n  if (response.type === \"error\") {\n    console.log(`Error code: ${response.error.code}`)\n  }\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Union Types for Flexible Outputs using Schema."
            },
            "created_at": "2026-02-16T21:39:06.767358",
            "updated_at": "2026-02-20T23:09:37.773656"
        },
        {
            "id": "c86ad201-1f2b-4cfa-8adb-db97ce38f3fb",
            "slug": "schema-ai-parsing-basic",
            "title": "Basic AI Response Parsing",
            "summary": "You've called an LLM with a JSON schema, but the response is still `unknown`. The model might have hallucinated extra fields, used wrong types, or returned malformed JSON despite your instructions....",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "ai",
                "parsing",
                "validation",
                "decode",
                "llm"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema } from \"effect\"\nimport { Anthropic } from \"@anthropic-ai/sdk\"\n\n// 1. Define expected schema\nconst Analysis = Schema.Struct({\n  summary: Schema.String,\n  score: Schema.Number.pipe(Schema.between(0, 100)),\n  tags: Schema.Array(Schema.String),\n})\n\ntype Analysis = typeof Analysis.Type\n\n// 2. Create parser\nconst parseAnalysis = Schema.decodeUnknown(Analysis)\n\n// 3. Parse LLM response in pipeline\nconst analyzeSafely = (llmResponse: unknown) =>\n  Effect.gen(function* () {\n    const parsed = yield* Effect.tryPromise({\n      try: () => parseAnalysis(llmResponse),\n      catch: (error) => ({\n        _tag: \"ParseError\" as const,\n        message: `AI returned invalid response: ${error}`,\n        raw: llmResponse,\n      }),\n    })\n    return parsed\n  })\n\n// 4. Full flow: call LLM and parse\nconst analyzeText = (text: string) =>\n  Effect.gen(function* () {\n    const client = new Anthropic()\n\n    const response = yield* Effect.tryPromise({\n      try: () =>\n        client.messages.create({\n          model: \"claude-3-5-sonnet-20241022\",\n          max_tokens: 1024,\n          messages: [\n            {\n              role: \"user\",\n              content: `Analyze this text and return JSON:\\n${text}`,\n            },\n          ],\n        }),\n      catch: (error) => new Error(`API failed: ${error}`),\n    })\n\n    const textContent = response.content.find(\n      (c) => c.type === \"text\"\n    ) as any\n\n    if (!textContent) {\n      return yield* Effect.fail(\n        new Error(\"No text in response\")\n      )\n    }\n\n    // Parse the JSON string\n    const parsed = yield* Effect.tryPromise({\n      try: () => JSON.parse(textContent.text),\n      catch: (error) => new Error(`Invalid JSON: ${error}`),\n    })\n\n    // Validate against schema\n    const analysis = yield* analyzeSafely(parsed)\n    return analysis\n  })\n\n// 5. Usage\nEffect.runPromise(\n  analyzeText(\"This product is amazing but too expensive.\")\n)\n  .then((result) => {\n    console.log(`Score: ${result.score}`)\n    console.log(`Tags: ${result.tags.join(\", \")}`)\n  })\n  .catch((error) => {\n    console.error(`Analysis failed: ${error.message}`)\n  })",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Basic AI Response Parsing using Schema."
            },
            "created_at": "2026-02-16T21:39:06.930041",
            "updated_at": "2026-02-20T23:09:37.818863"
        },
        {
            "id": "d3d16c95-64d2-417e-8355-925589166c77",
            "slug": "schema-ai-parsing-retry-on-failure",
            "title": "Retry Strategies for Parse Failures",
            "summary": "Parsing an LLM response fails\u2014maybe the model hallucinated, generated malformed JSON, or the response was incomplete. Retrying with a fresh API call might succeed. You need to distinguish retryable...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "ai",
                "retry",
                "backoff",
                "resilience",
                "exponential-backoff"
            ],
            "examples": [
                {
                    "code": "import {\n  Effect,\n  Schema,\n  Schedule,\n  Random,\n} from \"effect\"\nimport { Anthropic } from \"@anthropic-ai/sdk\"\n\n// 1. Define retryable and permanent errors\ntype ParseError =\n  | { _tag: \"InvalidJSON\"; message: string }\n  | { _tag: \"SchemaViolation\"; message: string }\n  | { _tag: \"NetworkError\"; message: string }\n  | { _tag: \"Timeout\"; message: string }\n\nconst isRetryable = (error: ParseError): boolean => {\n  return (\n    error._tag === \"NetworkError\" ||\n    error._tag === \"Timeout\"\n  )\n}\n\n// 2. Define schema\nconst Response = Schema.Struct({\n  result: Schema.String,\n  confidence: Schema.Number.pipe(\n    Schema.between(0, 1)\n  ),\n})\n\ntype Response = typeof Response.Type\n\n// 3. Parse with error categorization\nconst parseResponse = (data: unknown) =>\n  Effect.gen(function* () {\n    try {\n      const parsed = yield* Schema.decodeUnknown(\n        Response\n      )(data)\n      return { _tag: \"Success\" as const, data: parsed }\n    } catch (error) {\n      // Categorize error\n      const message = String(error)\n\n      if (message.includes(\"JSON\")) {\n        return {\n          _tag: \"ParseFail\" as const,\n          error: {\n            _tag: \"InvalidJSON\" as const,\n            message,\n          },\n        }\n      }\n\n      if (\n        message.includes(\"confidence\") ||\n        message.includes(\"between\")\n      ) {\n        return {\n          _tag: \"ParseFail\" as const,\n          error: {\n            _tag: \"SchemaViolation\" as const,\n            message,\n          },\n        }\n      }\n\n      return {\n        _tag: \"ParseFail\" as const,\n        error: {\n          _tag: \"NetworkError\" as const,\n          message,\n        },\n      }\n    }\n  })\n\n// 4. Retry strategy: exponential backoff with jitter\nconst callLLMWithRetry = (prompt: string) =>\n  Effect.gen(function* () {\n    const client = new Anthropic()\n\n    // Exponential backoff: 100ms \u2192 200ms \u2192 400ms \u2192 800ms (max 5s)\n    const schedule = Schedule.exponential(\n      \"100 millis\"\n    ).pipe(\n      Schedule.map(() =>\n        Effect.gen(function* () {\n          // Add jitter to prevent thundering herd\n          const jitter = yield* Random.nextIntBetween(\n            0,\n            100\n          )\n          return jitter\n        }).pipe(Effect.runSync())\n      ),\n      Schedule.compose(\n        Schedule.recurUntil(\n          (attempt) => attempt >= 3\n        )\n      )\n    )\n\n    const callLLM = () =>\n      Effect.gen(function* () {\n        const response = yield* Effect.tryPromise({\n          try: () =>\n            client.messages.create({\n              model: \"claude-3-5-sonnet-20241022\",\n              max_tokens: 1024,\n              messages: [\n                { role: \"user\", content: prompt },\n              ],\n            }),\n          catch: (error) => {\n            const msg = String(error)\n            if (msg.includes(\"timeout\")) {\n              return {\n                _tag: \"Timeout\" as const,\n                message: msg,\n              }\n            }\n            return {\n              _tag: \"NetworkError\" as const,\n              message: msg,\n            }\n          },\n        })\n\n        const text = response.content.find(\n          (c) => c.type === \"text\"\n        ) as any\n\n        if (!text) {\n          return yield* Effect.fail({\n            _tag: \"InvalidJSON\" as const,\n            message: \"No text in response\",\n          })\n        }\n\n        return JSON.parse(text.text)\n      })\n\n    // Retry only on retryable errors\n    const result = yield* callLLM().pipe(\n      Effect.retry(\n        schedule.pipe(\n          Schedule.whileInput((error) =>\n            isRetryable(error)\n          )\n        )\n      ),\n      Effect.catchTag(\"Timeout\", (error) =>\n        Effect.fail(error)\n      ),\n      Effect.catchTag(\"NetworkError\", (error) =>\n        Effect.fail(error)\n      )\n    )\n\n    return result\n  })\n\n// 5. Full pipeline with retry and parse\nconst analyzeSafely = (prompt: string) =>\n  Effect.gen(function* () {\n    // Call with retry\n    const raw = yield* callLLMWithRetry(prompt)\n\n    // Parse with categorized errors\n    const parseResult = yield* parseResponse(raw)\n\n    if (parseResult._tag === \"Success\") {\n      return parseResult.data\n    }\n\n    const error = parseResult.error\n\n    if (isRetryable(error)) {\n      console.warn(\n        `Retryable error (${error._tag}), giving up after retries: ${error.message}`\n      )\n    } else {\n      console.error(\n        `Non-retryable error (${error._tag}): ${error.message}`\n      )\n    }\n\n    return yield* Effect.fail(error)\n  })\n\n// 6. Usage\nconst result = Effect.runPromise(\n  analyzeSafely(\"What is the capital of France?\")\n).catch((error) => {\n  console.error(\"Final error:\", error)\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Retry Strategies for Parse Failures using Schema."
            },
            "created_at": "2026-02-16T21:39:07.093966",
            "updated_at": "2026-02-20T23:09:37.859298"
        },
        {
            "id": "68ed1271-9f6f-4f34-9480-0a19eee9c84b",
            "slug": "add-caching-by-wrapping-a-layer",
            "title": "Add Caching by Wrapping a Layer",
            "summary": "Implement caching by creating a new layer that wraps a live service, intercepting method calls to add caching logic without modifying the original service.",
            "skill_level": "advanced",
            "category": "concurrency",
            "difficulty": "advanced",
            "tags": [
                "caching",
                "wrapper",
                "layer",
                "dependency-injection",
                "architecture",
                "performance"
            ],
            "examples": [
                {
                    "code": "import { Effect, Layer, Ref } from \"effect\";\n\n// 1. Define the service interface\nclass WeatherService extends Effect.Service<WeatherService>()(\n  \"WeatherService\",\n  {\n    sync: () => ({\n      getForecast: (city: string) => Effect.succeed(`Sunny in ${city}`),\n    }),\n  }\n) {}\n\n// 2. The \"Live\" implementation that is slow\nconst WeatherServiceLive = Layer.succeed(\n  WeatherService,\n  WeatherService.of({\n    _tag: \"WeatherService\",\n    getForecast: (city) =>\n      Effect.succeed(`Sunny in ${city}`).pipe(\n        Effect.delay(\"2 seconds\"),\n        Effect.tap(() => Effect.log(`Fetched live forecast for ${city}`))\n      ),\n  })\n);\n\n// 3. The Caching Wrapper Layer\nconst WeatherServiceCached = Layer.effect(\n  WeatherService,\n  Effect.gen(function* () {\n    // It REQUIRES the original WeatherService\n    const underlyingService = yield* WeatherService;\n    const cache = yield* Ref.make(new Map<string, string>());\n\n    return WeatherService.of({\n      _tag: \"WeatherService\",\n      getForecast: (city) =>\n        Ref.get(cache).pipe(\n          Effect.flatMap((map) =>\n            map.has(city)\n              ? Effect.log(`Cache HIT for ${city}`).pipe(\n                  Effect.as(map.get(city)!)\n                )\n              : Effect.log(`Cache MISS for ${city}`).pipe(\n                  Effect.flatMap(() => underlyingService.getForecast(city)),\n                  Effect.tap((forecast) =>\n                    Ref.update(cache, (map) => map.set(city, forecast))\n                  )\n                )\n          )\n        ),\n    });\n  })\n);\n\n// 4. Compose the final layer. The wrapper is provided with the live implementation.\nconst AppLayer = Layer.provide(WeatherServiceCached, WeatherServiceLive);\n\n// 5. The application logic\nconst program = Effect.gen(function* () {\n  const weather = yield* WeatherService;\n  yield* weather.getForecast(\"London\"); // First call is slow (MISS)\n  yield* weather.getForecast(\"London\"); // Second call is instant (HIT)\n});\n\nEffect.runPromise(Effect.provide(program, AppLayer));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use a wrapping Layer to add cross-cutting concerns like caching to a service without altering its original implementation."
            },
            "created_at": "2026-02-15T21:22:20.117189",
            "updated_at": "2026-02-20T23:09:37.107548"
        },
        {
            "id": "ad0096da-1fdc-4a44-a1f8-f60f067b2bdf",
            "slug": "schema-ai-output-vercel-ai-sdk",
            "title": "Integration with Vercel AI SDK",
            "summary": "You're using Vercel AI SDK's `generateObject` function to get structured output from LLMs. The SDK expects a specific schema format. You need to convert Effect schemas to Vercel's format, handle the...",
            "skill_level": "advanced",
            "category": "schema",
            "difficulty": "advanced",
            "tags": [
                "schema",
                "ai",
                "vercel-ai-sdk",
                "generateobject",
                "integration"
            ],
            "examples": [
                {
                    "code": "import { Schema, JSONSchema, Effect } from \"effect\"\nimport { generateObject } from \"ai\"\nimport { openai } from \"@ai-sdk/openai\"\n\n// 1. Define Effect schema (same as always)\nconst ProductReview = Schema.Struct({\n  productId: Schema.String.pipe(\n    Schema.description(\"Internal product ID\")\n  ),\n  rating: Schema.Number.pipe(\n    Schema.between(1, 5),\n    Schema.description(\"Rating: 1-5 stars\")\n  ),\n  sentiment: Schema.Literal(\"positive\", \"neutral\", \"negative\").pipe(\n    Schema.description(\"Overall sentiment of review\")\n  ),\n  pros: Schema.Array(Schema.String).pipe(\n    Schema.minItems(1),\n    Schema.maxItems(5),\n    Schema.description(\"What worked well (1-5 items)\")\n  ),\n  cons: Schema.Array(Schema.String).pipe(\n    Schema.minItems(0),\n    Schema.maxItems(5),\n    Schema.description(\"What didn't work (0-5 items)\")\n  ),\n  wouldRecommend: Schema.Boolean,\n  purchaseDate: Schema.String.pipe(\n    Schema.optional,\n    Schema.description(\"YYYY-MM-DD format or omit if unknown\")\n  ),\n})\n\ntype ProductReview = typeof ProductReview.Type\n\n// 2. Convert to Vercel schema format\nconst toVercelSchema = (effectSchema: Schema.Schema<any>) => {\n  const jsonSchema = JSONSchema.make(effectSchema)\n\n  // Vercel's zodToJsonSchema-compatible format\n  return {\n    type: \"object\",\n    properties: jsonSchema.properties,\n    required: jsonSchema.required,\n    $schema: \"http://json-schema.org/draft-07/schema#\",\n  }\n}\n\n// 3. Create wrapper Effect for Vercel integration\nconst generateProductReview = (text: string) =>\n  Effect.gen(function* () {\n    const vercelSchema = toVercelSchema(ProductReview)\n\n    // Call Vercel's generateObject\n    const result = yield* Effect.tryPromise({\n      try: () =>\n        generateObject({\n          model: openai(\"gpt-4-turbo\"),\n          system:\n            \"Extract structured product review from customer feedback.\",\n          prompt: `Review text:\\n\\n${text}`,\n          schema: vercelSchema as any,\n        }),\n      catch: (error) => new Error(`Vercel AI call failed: ${error}`),\n    })\n\n    // Result.object is typed as 'unknown' by Vercel\n    // Re-validate with Effect schema for type safety\n    const review = yield* Effect.tryPromise({\n      try: () =>\n        Schema.decodeUnknownSync(ProductReview)(result.object),\n      catch: (error) =>\n        new Error(`Validation failed: ${error}`),\n    })\n\n    return review\n  })\n\n// 4. Alternative: Use generateObject with Zod-to-Effect adapter\nconst generateWithEffectValidation = (\n  prompt: string,\n  schema: Schema.Schema<any>\n) =>\n  Effect.gen(function* () {\n    const vercelSchema = toVercelSchema(schema)\n\n    const result = yield* Effect.tryPromise({\n      try: () =>\n        generateObject({\n          model: openai(\"gpt-4-turbo\"),\n          prompt,\n          schema: vercelSchema as any,\n        }),\n      catch: (error) => new Error(`Vercel AI call failed: ${error}`),\n    })\n\n    // Validate with Effect schema\n    const validated = yield* Effect.tryPromise({\n      try: () => Schema.decodeUnknownSync(schema)(result.object),\n      catch: (error) =>\n        new Error(\n          `Schema validation failed: ${error}`\n        ),\n    })\n\n    return validated\n  })\n\n// 5. Batch process multiple reviews\nconst batchGenerateReviews = (reviews: string[]) =>\n  Effect.gen(function* () {\n    // Process in parallel with concurrency limit\n    const results = yield* Effect.all(\n      reviews.map((text) => generateProductReview(text)),\n      { concurrency: 3 }\n    )\n\n    return results\n  })\n\n// 6. Stream handler for real-time updates\nconst streamReviewAnalysis = (text: string) =>\n  Effect.gen(function* () {\n    // Vercel AI SDK streaming\n    const { partialObject } = yield* Effect.tryPromise({\n      try: () =>\n        generateObject({\n          model: openai(\"gpt-4-turbo\"),\n          system: \"Extract review. Stream partial updates.\",\n          prompt: `Review:\\n\\n${text}`,\n          schema: toVercelSchema(ProductReview) as any,\n        }),\n      catch: (error) => new Error(`Streaming failed: ${error}`),\n    })\n\n    // partialObject is updated as stream progresses\n    return partialObject\n  })\n\n// Usage example 1: Single review\nconst sampleReview =\n  \"Great laptop! Fast performance and excellent screen. \" +\n  \"Battery life is good but gets hot under load. Would buy again.\"\n\nEffect.runPromise(generateProductReview(sampleReview))\n  .then((review) => {\n    console.log(`Rating: ${review.rating}/5 - ${review.sentiment}`)\n    console.log(`Recommend: ${review.wouldRecommend}`)\n    console.log(`Pros: ${review.pros.join(\", \")}`)\n    console.log(`Cons: ${review.cons.join(\", \")}`)\n  })\n\n// Usage example 2: Batch processing\nconst reviewTexts = [\n  \"Amazing product!\",\n  \"Terrible, broke in a week\",\n  \"Okay, does what it says\",\n]\n\nEffect.runPromise(batchGenerateReviews(reviewTexts))\n  .then((reviews) => {\n    const avgRating =\n      reviews.reduce((sum, r) => sum + r.rating, 0) /\n      reviews.length\n    console.log(`Average rating: ${avgRating.toFixed(1)}/5`)\n  })\n\n// Usage example 3: Custom schema with generateWithEffectValidation\nconst CustomSchema = Schema.Struct({\n  title: Schema.String,\n  score: Schema.Number,\n})\n\nEffect.runPromise(\n  generateWithEffectValidation(\n    \"Extract title and score\",\n    CustomSchema\n  )\n)\n  .then((result) => console.log(result))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Integration with Vercel AI SDK using Schema."
            },
            "created_at": "2026-02-16T21:39:07.780426",
            "updated_at": "2026-02-20T23:09:38.083115"
        },
        {
            "id": "7ede9e10-54d2-4068-9d7f-7274b030f0c1",
            "slug": "schema-tuples",
            "title": "Tuple Schemas",
            "summary": "Sometimes you need fixed-length arrays where each position has a specific type. A coordinate is [x, y], an RGB color is [r, g, b], a range is [start, end]. Regular arrays allow any length. You need...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "tuple",
                "fixed-length",
                "typed-array"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// ============================================\n// BASIC TUPLES\n// ============================================\n\n// 2D coordinate [x, y]\nconst Point2D = Schema.Tuple(Schema.Number, Schema.Number)\ntype Point2D = typeof Point2D.Type  // readonly [number, number]\n\n// 3D coordinate [x, y, z]\nconst Point3D = Schema.Tuple(Schema.Number, Schema.Number, Schema.Number)\ntype Point3D = typeof Point3D.Type  // readonly [number, number, number]\n\n// RGB color [r, g, b]\nconst RGB = Schema.Tuple(Schema.Number, Schema.Number, Schema.Number)\ntype RGB = typeof RGB.Type\n\n// Date range [start, end]\nconst DateRange = Schema.Tuple(Schema.Date, Schema.Date)\ntype DateRange = typeof DateRange.Type  // readonly [Date, Date]\n\n// ============================================\n// MIXED TYPE TUPLES\n// ============================================\n\n// Key-value pair [key, value]\nconst KeyValue = Schema.Tuple(Schema.String, Schema.Unknown)\ntype KeyValue = typeof KeyValue.Type  // readonly [string, unknown]\n\n// Named point [\"label\", x, y]\nconst NamedPoint = Schema.Tuple(Schema.String, Schema.Number, Schema.Number)\ntype NamedPoint = typeof NamedPoint.Type\n\n// Result tuple [success, data | error]\nconst StringResult = Schema.Tuple(Schema.Boolean, Schema.String)\ntype StringResult = typeof StringResult.Type  // readonly [boolean, string]\n\n// ============================================\n// TUPLES WITH OPTIONAL ELEMENTS\n// ============================================\n\n// Optional third element [x, y, z?]\nconst Point2Dor3D = Schema.Tuple(\n  Schema.Number,\n  Schema.Number,\n).pipe(Schema.optionalElement(Schema.Number))\n// readonly [number, number, number?]\n\n// ============================================\n// TUPLES WITH REST ELEMENTS\n// ============================================\n\n// Fixed start, variable rest: [header, ...items]\nconst ListWithHeader = Schema.Tuple(\n  [Schema.String],                    // First element: header\n  Schema.rest(Schema.Number)          // Rest: numbers\n)\ntype ListWithHeader = typeof ListWithHeader.Type\n// readonly [string, ...number[]]\n\n// ============================================\n// USING IN STRUCTS\n// ============================================\n\nconst Shape = Schema.Struct({\n  name: Schema.String,\n  position: Point2D,\n  color: RGB,\n})\n\nconst Route = Schema.Struct({\n  name: Schema.String,\n  waypoints: Schema.Array(Point2D),  // Array of tuples\n})\n\n// ============================================\n// VALIDATION IN ACTION\n// ============================================\n\nconst decodePoint2D = Schema.decodeUnknownSync(Point2D)\nconst decodeRGB = Schema.decodeUnknownSync(RGB)\nconst decodeNamedPoint = Schema.decodeUnknownSync(NamedPoint)\n\n// Valid 2D point\nconst point = decodePoint2D([10, 20])\nconsole.log(`\u2705 Point: (${point[0]}, ${point[1]})`)\n\n// Valid RGB\nconst red = decodeRGB([255, 0, 0])\nconsole.log(`\u2705 Color: rgb(${red[0]}, ${red[1]}, ${red[2]})`)\n\n// Valid named point\nconst home = decodeNamedPoint([\"Home\", 0, 0])\nconsole.log(`\u2705 ${home[0]}: (${home[1]}, ${home[2]})`)\n\n// Invalid - wrong length\ntry {\n  decodePoint2D([10])  // Missing y\n} catch {\n  console.log(\"\u274c Point needs exactly 2 elements\")\n}\n\ntry {\n  decodePoint2D([10, 20, 30])  // Too many\n} catch {\n  console.log(\"\u274c Point needs exactly 2 elements\")\n}\n\n// Invalid - wrong type at position\ntry {\n  decodeNamedPoint([42, 10, 20])  // First should be string\n} catch {\n  console.log(\"\u274c First element must be string\")\n}\n\n// ============================================\n// PRACTICAL EXAMPLE: BOUNDS\n// ============================================\n\nconst BoundingBox = Schema.Struct({\n  topLeft: Point2D,\n  bottomRight: Point2D,\n})\n\nconst decodeBox = Schema.decodeUnknownSync(BoundingBox)\n\nconst box = decodeBox({\n  topLeft: [0, 0],\n  bottomRight: [100, 100],\n})\n\nconst width = box.bottomRight[0] - box.topLeft[0]\nconst height = box.bottomRight[1] - box.topLeft[1]\nconsole.log(`\\n\u2705 Box: ${width}x${height}`)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Tuple Schemas."
            },
            "created_at": "2026-02-16T21:39:07.958211",
            "updated_at": "2026-02-20T23:09:38.12573"
        },
        {
            "id": "be30cb27-1493-4995-914d-c125792934f5",
            "slug": "schema-basic-arrays",
            "title": "Array Validation",
            "summary": "You receive a list of items and need to validate each one. Without schema validation, you'd loop through and check each item manually. You need to define what valid array items look like and validate...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "array",
                "collection",
                "list"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// ============================================\n// BASIC ARRAYS\n// ============================================\n\n// Array of strings\nconst Tags = Schema.Array(Schema.String)\ntype Tags = typeof Tags.Type  // string[]\n\n// Array of numbers\nconst Scores = Schema.Array(Schema.Number)\ntype Scores = typeof Scores.Type  // number[]\n\n// Array of booleans\nconst Flags = Schema.Array(Schema.Boolean)\ntype Flags = typeof Flags.Type  // boolean[]\n\n// ============================================\n// ARRAYS OF OBJECTS\n// ============================================\n\nconst User = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  email: Schema.String,\n})\n\nconst Users = Schema.Array(User)\ntype Users = typeof Users.Type  // Array<{ id: string; name: string; email: string }>\n\nconst Product = Schema.Struct({\n  sku: Schema.String,\n  name: Schema.String,\n  price: Schema.Number,\n})\n\nconst Products = Schema.Array(Product)\ntype Products = typeof Products.Type\n\n// ============================================\n// ARRAY LENGTH CONSTRAINTS\n// ============================================\n\n// Non-empty array (at least 1 item)\nconst NonEmptyTags = Schema.NonEmptyArray(Schema.String)\ntype NonEmptyTags = typeof NonEmptyTags.Type  // readonly [string, ...string[]]\n\n// Min/max length\nconst LimitedList = Schema.Array(Schema.String).pipe(\n  Schema.minItems(1),\n  Schema.maxItems(10)\n)\n\n// Exact length\nconst RGBTuple = Schema.Array(Schema.Number).pipe(\n  Schema.itemsCount(3)\n)\n\n// ============================================\n// USING IN STRUCTS\n// ============================================\n\nconst BlogPost = Schema.Struct({\n  title: Schema.String,\n  content: Schema.String,\n  tags: Tags,                    // Array of strings\n  authors: NonEmptyTags,         // At least one author\n})\n\nconst Order = Schema.Struct({\n  orderId: Schema.String,\n  items: Schema.NonEmptyArray(Product),  // At least one item\n  total: Schema.Number,\n})\n\n// ============================================\n// VALIDATION IN ACTION\n// ============================================\n\nconst decodeTags = Schema.decodeUnknownSync(Tags)\nconst decodeUsers = Schema.decodeUnknownSync(Users)\nconst decodeOrder = Schema.decodeUnknownSync(Order)\n\n// Valid array of strings\nconst tags = decodeTags([\"typescript\", \"effect\", \"schema\"])\nconsole.log(`\u2705 Tags: ${tags.join(\", \")}`)\n\n// Valid array of objects\nconst users = decodeUsers([\n  { id: \"1\", name: \"Alice\", email: \"alice@example.com\" },\n  { id: \"2\", name: \"Bob\", email: \"bob@example.com\" },\n])\nconsole.log(`\u2705 Users: ${users.map(u => u.name).join(\", \")}`)\n\n// Valid order with items\nconst order = decodeOrder({\n  orderId: \"order_123\",\n  items: [\n    { sku: \"WIDGET-001\", name: \"Widget\", price: 29.99 },\n    { sku: \"GADGET-002\", name: \"Gadget\", price: 49.99 },\n  ],\n  total: 79.98,\n})\nconsole.log(`\u2705 Order has ${order.items.length} items`)\n\n// Empty array is valid for Schema.Array\nconst emptyTags = decodeTags([])\nconsole.log(`\u2705 Empty tags: ${emptyTags.length} items`)\n\n// Invalid - item has wrong type\ntry {\n  decodeTags([\"valid\", 123, \"also valid\"])  // 123 is not string\n} catch {\n  console.log(\"\u274c Array item must be string\")\n}\n\n// Invalid - empty when NonEmptyArray required\ntry {\n  const decodeNonEmpty = Schema.decodeUnknownSync(NonEmptyTags)\n  decodeNonEmpty([])\n} catch {\n  console.log(\"\u274c Array must have at least 1 item\")\n}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Array Validation using Schema."
            },
            "created_at": "2026-02-16T21:39:08.124231",
            "updated_at": "2026-02-20T23:09:38.171927"
        },
        {
            "id": "5439ab33-420f-492b-9468-84778e5b1eb3",
            "slug": "schema-vs-zod",
            "title": "Effect Schema vs Zod",
            "summary": "You're familiar with Zod (or similar libraries) and want to understand how Effect Schema differs. The syntax looks similar but Effect Schema offers capabilities Zod doesn't have. You need a quick...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "comparison",
                "zod",
                "migration"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// ============================================\n// BASIC SCHEMA DEFINITION\n// ============================================\n\n// Zod:\n// const UserZ = z.object({ name: z.string(), age: z.number() })\n\n// Effect Schema:\nconst User = Schema.Struct({\n  name: Schema.String,\n  age: Schema.Number,\n})\n\n// ============================================\n// OPTIONAL FIELDS\n// ============================================\n\n// Zod:\n// const ConfigZ = z.object({ port: z.number().optional() })\n\n// Effect Schema:\nconst Config = Schema.Struct({\n  port: Schema.optional(Schema.Number),\n})\n\n// ============================================\n// ARRAYS\n// ============================================\n\n// Zod:\n// const ListZ = z.array(z.string())\n\n// Effect Schema:\nconst List = Schema.Array(Schema.String)\n\n// ============================================\n// UNIONS\n// ============================================\n\n// Zod:\n// const StatusZ = z.union([z.literal(\"active\"), z.literal(\"inactive\")])\n\n// Effect Schema:\nconst Status = Schema.Union(\n  Schema.Literal(\"active\"),\n  Schema.Literal(\"inactive\")\n)\n\n// ============================================\n// REFINEMENTS (custom validation)\n// ============================================\n\n// Zod:\n// const PositiveZ = z.number().refine(n => n > 0, \"Must be positive\")\n\n// Effect Schema:\nconst Positive = Schema.Number.pipe(\n  Schema.filter((n) => n > 0, { message: () => \"Must be positive\" })\n)\n\n// ============================================\n// TRANSFORMATIONS\n// ============================================\n\n// Zod:\n// const TrimmedZ = z.string().transform(s => s.trim())\n\n// Effect Schema (bidirectional!):\nconst Trimmed = Schema.transform(\n  Schema.String,\n  Schema.String,\n  {\n    decode: (s) => s.trim(),\n    encode: (s) => s,\n  }\n)\n\n// ============================================\n// KEY DIFFERENCES\n// ============================================\n\n// 1. BIDIRECTIONAL: Effect Schema encodes AND decodes\nconst decode = Schema.decodeUnknownSync(User)\nconst encode = Schema.encodeSync(User)\n\nconst user = decode({ name: \"Alice\", age: 30 })\nconst json = encode(user)  // Zod can't do this!\n\n// 2. EFFECT INTEGRATION: Returns Effect for async composition\nconst parseAsync = Schema.decodeUnknown(User)\n// Returns Effect<User, ParseError> - composable with Effect ecosystem\n\n// 3. DEFECTS VS ERRORS: Schema distinguishes recoverable vs non-recoverable\n// ParseError is typed and trackable through Effect's error channel\n\n// 4. ASYNC VALIDATION: Built-in support\nconst UsernameAvailable = Schema.String.pipe(\n  Schema.filterEffect((username) =>\n    // Check database asynchronously\n    Effect.succeed(true)  // Placeholder\n  )\n)\n\nconsole.log(\"\u2705 Effect Schema and Zod both validate at runtime\")\nconsole.log(\"\u2705 Effect Schema adds: encode, Effect integration, async validation\")",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Effect Schema vs Zod."
            },
            "created_at": "2026-02-16T21:39:08.291198",
            "updated_at": "2026-02-20T23:09:38.209923"
        },
        {
            "id": "8d27726a-b550-4732-9b42-e437c64e7437",
            "slug": "schema-extend-schemas",
            "title": "Extending and Adding Fields to Schemas",
            "summary": "You have a base schema (User) and need variants with additional fields (AdminUser, PremiumUser). Copy-pasting the schema creates maintenance burden\u2014change one field and you update three schemas. You...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "composition",
                "extension",
                "inheritance",
                "reuse"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Base schemas\n// ============================================\n\nconst BaseUser = Schema.Struct({\n  id: Schema.String,\n  username: Schema.String,\n  email: Schema.String,\n  createdAt: Schema.Date,\n})\n\ntype BaseUser = typeof BaseUser.Type\n\n// ============================================\n// 2. Extend with new fields using Schema.extend\n// ============================================\n\nconst AdminUser = Schema.extend(\n  BaseUser,\n  Schema.Struct({\n    role: Schema.Literal(\"admin\"),\n    permissions: Schema.Array(Schema.String),\n    lastLogin: Schema.Date,\n  })\n)\n\ntype AdminUser = typeof AdminUser.Type\n\nconst PremiumUser = Schema.extend(\n  BaseUser,\n  Schema.Struct({\n    tier: Schema.Enum({ gold: \"gold\", platinum: \"platinum\" }),\n    subscriptionEnd: Schema.Date,\n    features: Schema.Array(Schema.String),\n  })\n)\n\ntype PremiumUser = typeof PremiumUser.Type\n\n// ============================================\n// 3. Extend with optional fields\n// ============================================\n\nconst UserWithProfile = Schema.extend(\n  BaseUser,\n  Schema.Struct({\n    bio: Schema.Optional(Schema.String),\n    avatar: Schema.Optional(Schema.String),\n    location: Schema.Optional(Schema.String),\n    website: Schema.Optional(Schema.String),\n  })\n)\n\ntype UserWithProfile = typeof UserWithProfile.Type\n\n// ============================================\n// 4. Multi-level extension\n// ============================================\n\nconst VerifiedUser = Schema.extend(\n  UserWithProfile,\n  Schema.Struct({\n    emailVerified: Schema.Boolean,\n    phoneVerified: Schema.Boolean,\n    verificationDate: Schema.Optional(Schema.Date),\n  })\n)\n\ntype VerifiedUser = typeof VerifiedUser.Type\n\nconst VerifiedAdmin = Schema.extend(\n  VerifiedUser,\n  Schema.Struct({\n    adminRole: Schema.String,\n    adminTeam: Schema.String,\n  })\n)\n\ntype VerifiedAdmin = typeof VerifiedAdmin.Type\n\n// ============================================\n// 5. Union of extended schemas\n// ============================================\n\nconst AnyUser = Schema.Union(BaseUser, AdminUser, PremiumUser)\n\ntype AnyUser = typeof AnyUser.Type\n\n// ============================================\n// 6. Processing extended schemas\n// ============================================\n\nconst describeUser = (user: AnyUser): string => {\n  if (\"role\" in user) {\n    return `Admin: ${user.username} [${(user as AdminUser).role}]`\n  }\n  if (\"tier\" in user) {\n    return `Premium: ${user.username} [${(user as PremiumUser).tier}]`\n  }\n  return `User: ${user.username}`\n}\n\nconst parseUser = (\n  raw: unknown,\n  type: \"base\" | \"admin\" | \"premium\"\n): Effect.Effect<AnyUser, Error> =>\n  Effect.tryPromise({\n    try: async () => {\n      const schema =\n        type === \"admin\"\n          ? AdminUser\n          : type === \"premium\"\n            ? PremiumUser\n            : BaseUser\n      return await Schema.decodeUnknown(schema)(raw)\n    },\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`User parsing failed: ${msg}`)\n    },\n  })\n\n// ============================================\n// 7. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Schema Extension ===\\n\")\n\n  console.log(\"1. Base User\\n\")\n\n  const baseUserData = {\n    id: \"user_1\",\n    username: \"alice\",\n    email: \"alice@example.com\",\n    createdAt: new Date(\"2025-01-01\"),\n  }\n\n  const baseUser = yield* parseUser(baseUserData, \"base\")\n  console.log(describeUser(baseUser))\n\n  console.log(\"\\n2. Extended: Admin User\\n\")\n\n  const adminUserData = {\n    id: \"user_2\",\n    username: \"bob\",\n    email: \"bob@example.com\",\n    createdAt: new Date(\"2024-06-01\"),\n    role: \"admin\",\n    permissions: [\"read\", \"write\", \"delete\", \"manage_users\"],\n    lastLogin: new Date(),\n  }\n\n  const adminUser = yield* parseUser(adminUserData, \"admin\")\n  console.log(describeUser(adminUser))\n  if (\"permissions\" in adminUser) {\n    console.log(`Permissions: ${(adminUser as AdminUser).permissions.join(\", \")}`)\n  }\n\n  console.log(\"\\n3. Extended: Premium User\\n\")\n\n  const premiumUserData = {\n    id: \"user_3\",\n    username: \"charlie\",\n    email: \"charlie@example.com\",\n    createdAt: new Date(\"2024-12-01\"),\n    tier: \"platinum\",\n    subscriptionEnd: new Date(\"2026-12-01\"),\n    features: [\"priority_support\", \"advanced_analytics\", \"api_access\"],\n  }\n\n  const premiumUser = yield* parseUser(premiumUserData, \"premium\")\n  console.log(describeUser(premiumUser))\n  if (\"tier\" in premiumUser) {\n    console.log(\n      `Subscription ends: ${(premiumUser as PremiumUser).subscriptionEnd.toDateString()}`\n    )\n  }\n\n  console.log(\"\\n4. Multi-level Extension\\n\")\n\n  const verifiedAdminData = {\n    id: \"user_4\",\n    username: \"diana\",\n    email: \"diana@example.com\",\n    createdAt: new Date(\"2024-01-01\"),\n    bio: \"Senior administrator\",\n    avatar: \"https://example.com/diana.png\",\n    location: \"San Francisco\",\n    website: \"https://diana.dev\",\n    emailVerified: true,\n    phoneVerified: true,\n    verificationDate: new Date(\"2025-01-15\"),\n    adminRole: \"super_admin\",\n    adminTeam: \"Security\",\n  }\n\n  const verifiedAdmin = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(VerifiedAdmin)(verifiedAdminData),\n    catch: (error) => new Error(String(error)),\n  })\n\n  console.log(`${verifiedAdmin.username} - ${verifiedAdmin.bio}`)\n  console.log(\n    `Team: ${(verifiedAdmin as any).adminTeam}, Role: ${(verifiedAdmin as any).adminRole}`\n  )\n\n  console.log(\"\\n5. Type Hierarchy\\n\")\n\n  const users: AnyUser[] = [\n    baseUser,\n    adminUser as AnyUser,\n    premiumUser as AnyUser,\n  ]\n\n  for (const user of users) {\n    console.log(`- ${describeUser(user)}`)\n  }\n\n  return { baseUser, adminUser, premiumUser, verifiedAdmin }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Schema extension complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Extending and Adding Fields to Schemas."
            },
            "created_at": "2026-02-16T21:39:09.621474",
            "updated_at": "2026-02-20T23:09:38.579532"
        },
        {
            "id": "abdeb5f1-0d12-48a2-bf23-d6dd930e8f5a",
            "slug": "concurrency-race-timeout",
            "title": "Race Effects and Handle Timeouts",
            "summary": "Race multiple effects to get the fastest result, or add timeouts to prevent hanging operations.",
            "skill_level": "beginner",
            "category": "concurrency",
            "difficulty": "beginner",
            "tags": [
                "concurrency",
                "race",
                "timeout",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Option } from \"effect\"\n\n// ============================================\n// BASIC RACE: First one wins\n// ============================================\n\nconst server1 = Effect.gen(function* () {\n  yield* Effect.sleep(\"100 millis\")\n  return \"Response from server 1\"\n})\n\nconst server2 = Effect.gen(function* () {\n  yield* Effect.sleep(\"50 millis\")\n  return \"Response from server 2\"\n})\n\nconst raceServers = Effect.race(server1, server2)\n\nEffect.runPromise(raceServers).then((result) => {\n  console.log(result) // \"Response from server 2\" (faster)\n})\n\n// ============================================\n// BASIC TIMEOUT: Limit execution time\n// ============================================\n\nconst slowOperation = Effect.gen(function* () {\n  yield* Effect.sleep(\"5 seconds\")\n  return \"Finally done\"\n})\n\n// Returns Option.none if timeout\nconst withTimeout = slowOperation.pipe(\n  Effect.timeout(\"1 second\")\n)\n\nEffect.runPromise(withTimeout).then((result) => {\n  if (Option.isNone(result)) {\n    console.log(\"Operation timed out\")\n  } else {\n    console.log(`Got: ${result.value}`)\n  }\n})\n\n// ============================================\n// TIMEOUT WITH FALLBACK\n// ============================================\n\nconst withFallback = slowOperation.pipe(\n  Effect.timeoutTo({\n    duration: \"1 second\",\n    onTimeout: () => Effect.succeed(\"Using cached value\"),\n  })\n)\n\nEffect.runPromise(withFallback).then((result) => {\n  console.log(result) // \"Using cached value\"\n})\n\n// ============================================\n// TIMEOUT FAIL: Throw error on timeout\n// ============================================\n\nclass TimeoutError {\n  readonly _tag = \"TimeoutError\"\n}\n\nconst failOnTimeout = slowOperation.pipe(\n  Effect.timeoutFail({\n    duration: \"1 second\",\n    onTimeout: () => new TimeoutError(),\n  })\n)\n\n// ============================================\n// RACE ALL: Multiple competing effects\n// ============================================\n\nconst fetchFromCache = Effect.gen(function* () {\n  yield* Effect.sleep(\"10 millis\")\n  return { source: \"cache\", data: \"cached data\" }\n})\n\nconst fetchFromDB = Effect.gen(function* () {\n  yield* Effect.sleep(\"100 millis\")\n  return { source: \"db\", data: \"fresh data\" }\n})\n\nconst fetchFromAPI = Effect.gen(function* () {\n  yield* Effect.sleep(\"200 millis\")\n  return { source: \"api\", data: \"api data\" }\n})\n\nconst raceAll = Effect.raceAll([fetchFromCache, fetchFromDB, fetchFromAPI])\n\nEffect.runPromise(raceAll).then((result) => {\n  console.log(`Winner: ${result.source}`) // \"cache\"\n})\n\n// ============================================\n// PRACTICAL: API with timeout and fallback\n// ============================================\n\nconst fetchWithResilience = (url: string) =>\n  Effect.gen(function* () {\n    const response = yield* Effect.tryPromise(() =>\n      fetch(url).then((r) => r.json())\n    ).pipe(\n      Effect.timeout(\"3 seconds\"),\n      Effect.flatMap((opt) =>\n        Option.isSome(opt)\n          ? Effect.succeed(opt.value)\n          : Effect.succeed({ error: \"timeout\", cached: true })\n      )\n    )\n    \n    return response\n  })",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.race for fastest-wins, Effect.timeout for time limits."
            },
            "created_at": "2026-02-15T21:22:19.025991",
            "updated_at": "2026-02-20T23:09:37.244563"
        },
        {
            "id": "c881a304-c07e-4f68-971c-2fd6feacd483",
            "slug": "concurrency-fork-basics",
            "title": "Fork Background Work",
            "summary": "Use Effect.fork to run work in the background while your main code continues.",
            "skill_level": "beginner",
            "category": "concurrency",
            "difficulty": "beginner",
            "tags": [
                "concurrency",
                "fork",
                "background",
                "fiber",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Fiber } from \"effect\"\n\n// ============================================\n// BASIC FORK: Run in background, wait later\n// ============================================\n\nconst basicFork = Effect.gen(function* () {\n  // Start expensive work in background\n  const fiber = yield* Effect.fork(\n    Effect.gen(function* () {\n      yield* Effect.log(\"Starting expensive computation...\")\n      yield* Effect.sleep(\"2 seconds\")\n      return 42\n    })\n  )\n  \n  // Do other work while computation runs\n  yield* Effect.log(\"Doing other work...\")\n  yield* Effect.sleep(\"500 millis\")\n  yield* Effect.log(\"Other work done\")\n  \n  // Now wait for the result\n  const result = yield* Fiber.join(fiber)\n  yield* Effect.log(`Computation result: ${result}`)\n})\n\n// ============================================\n// FORK DAEMON: Fire and forget\n// ============================================\n\nconst fireAndForget = Effect.gen(function* () {\n  // This runs completely independently\n  yield* Effect.forkDaemon(\n    Effect.gen(function* () {\n      yield* Effect.log(\"Daemon: Starting background task\")\n      yield* Effect.sleep(\"5 seconds\")\n      yield* Effect.log(\"Daemon: Done (no one waiting)\")\n    })\n  )\n  \n  yield* Effect.log(\"Main: Continuing without waiting\")\n  // Main can exit, daemon keeps running\n})\n\n// ============================================\n// FORK SCOPED: Tied to scope lifecycle\n// ============================================\n\nconst scopedFork = Effect.gen(function* () {\n  yield* Effect.forkScoped(\n    Effect.gen(function* () {\n      yield* Effect.log(\"Scoped fiber running\")\n      yield* Effect.sleep(\"10 seconds\")\n      yield* Effect.log(\"Scoped fiber done\")\n    })\n  )\n  \n  yield* Effect.log(\"Scope active, fiber runs\")\n  yield* Effect.sleep(\"1 second\")\n  yield* Effect.log(\"Scope ending, fiber will be interrupted\")\n}).pipe(Effect.scoped) // Fiber interrupted when scope closes\n\n// ============================================\n// MULTIPLE FORKS: Fan out work\n// ============================================\n\nconst fanOut = Effect.gen(function* () {\n  const tasks = [1, 2, 3, 4, 5]\n  \n  // Fork all tasks\n  const fibers = yield* Effect.forEach(tasks, (n) =>\n    Effect.fork(\n      Effect.gen(function* () {\n        yield* Effect.sleep(`${n * 100} millis`)\n        yield* Effect.log(`Task ${n} complete`)\n        return n * 10\n      })\n    )\n  )\n  \n  yield* Effect.log(\"All tasks forked, waiting for results...\")\n  \n  // Wait for all\n  const results = yield* Fiber.joinAll(fibers)\n  yield* Effect.log(`Results: ${[...results]}`)\n})\n\nEffect.runPromise(fanOut)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.fork to start background work, Effect.forkDaemon for fire-and-forget tasks."
            },
            "created_at": "2026-02-16T21:39:04.94039",
            "updated_at": "2026-02-20T23:09:37.28753"
        },
        {
            "id": "e67ac5be-9ea1-456e-a83c-6fa717499f52",
            "slug": "schema-enums-literals",
            "title": "Enums and Literal Types",
            "summary": "Some fields only accept specific values: status is \"active\" or \"inactive\", role is \"admin\", \"user\", or \"guest\". Using Schema.String allows any string, letting invalid values slip through. You need to...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "enum",
                "literal",
                "constants"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// ============================================\n// SINGLE LITERAL\n// ============================================\n\n// Exact value match\nconst Active = Schema.Literal(\"active\")\n// \u2705 \"active\" \u2192 \"active\"\n// \u274c \"Active\" \u2192 ParseError\n// \u274c \"inactive\" \u2192 ParseError\n\n// ============================================\n// UNION OF LITERALS (ENUM-LIKE)\n// ============================================\n\n// Status enum\nconst Status = Schema.Literal(\"active\", \"inactive\", \"pending\")\ntype Status = typeof Status.Type  // \"active\" | \"inactive\" | \"pending\"\n\n// Role enum\nconst Role = Schema.Literal(\"admin\", \"user\", \"guest\")\ntype Role = typeof Role.Type  // \"admin\" | \"user\" | \"guest\"\n\n// HTTP methods\nconst HttpMethod = Schema.Literal(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\")\ntype HttpMethod = typeof HttpMethod.Type\n\n// ============================================\n// NUMERIC LITERALS\n// ============================================\n\n// HTTP status codes\nconst SuccessCode = Schema.Literal(200, 201, 204)\nconst ErrorCode = Schema.Literal(400, 401, 403, 404, 500)\n\n// Priority levels\nconst Priority = Schema.Literal(1, 2, 3)\ntype Priority = typeof Priority.Type  // 1 | 2 | 3\n\n// ============================================\n// BOOLEAN AS LITERAL\n// ============================================\n\nconst AlwaysTrue = Schema.Literal(true)\nconst AlwaysFalse = Schema.Literal(false)\n\n// ============================================\n// USING IN STRUCTS\n// ============================================\n\nconst User = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  status: Status,\n  role: Role,\n})\n\nconst Task = Schema.Struct({\n  title: Schema.String,\n  priority: Priority,\n  completed: Schema.Boolean,\n})\n\nconst ApiRequest = Schema.Struct({\n  method: HttpMethod,\n  path: Schema.String,\n  body: Schema.optional(Schema.Unknown),\n})\n\n// ============================================\n// DEMO\n// ============================================\n\nconst decodeUser = Schema.decodeUnknownSync(User)\nconst decodeTask = Schema.decodeUnknownSync(Task)\n\n// Valid user\nconst user = decodeUser({\n  id: \"user_123\",\n  name: \"Alice\",\n  status: \"active\",\n  role: \"admin\",\n})\nconsole.log(`\u2705 User: ${user.name} (${user.role})`)\n\n// Valid task\nconst task = decodeTask({\n  title: \"Deploy to prod\",\n  priority: 1,\n  completed: false,\n})\nconsole.log(`\u2705 Task: ${task.title} [P${task.priority}]`)\n\n// Invalid - wrong status value\ntry {\n  decodeUser({\n    id: \"user_456\",\n    name: \"Bob\",\n    status: \"enabled\",  // Not \"active\" | \"inactive\" | \"pending\"\n    role: \"user\",\n  })\n} catch {\n  console.log(\"\u274c Invalid status value\")\n}\n\n// Invalid - wrong priority\ntry {\n  decodeTask({\n    title: \"Low priority\",\n    priority: 5,  // Not 1 | 2 | 3\n    completed: false,\n  })\n} catch {\n  console.log(\"\u274c Invalid priority value\")\n}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Enums and Literal Types using Schema."
            },
            "created_at": "2026-02-16T21:39:08.956475",
            "updated_at": "2026-02-20T23:09:38.380778"
        },
        {
            "id": "a3543d7c-ae3d-4009-9e63-9da19584c522",
            "slug": "schema-number-validation",
            "title": "Number Validation and Refinements",
            "summary": "Numbers need constraints: prices must be positive, ages must be integers, percentages must be 0-100. JavaScript's number type accepts any numeric value. You need runtime validation to catch invalid...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "number",
                "validation",
                "refinements"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// ============================================\n// BUILT-IN NUMBER REFINEMENTS\n// ============================================\n\n// Positive (> 0)\nconst Positive = Schema.Positive\n// \u2705 42   \u2192 42\n// \u274c 0    \u2192 ParseError\n// \u274c -5   \u2192 ParseError\n\n// Non-negative (>= 0)\nconst NonNegative = Schema.NonNegative\n// \u2705 0    \u2192 0\n// \u2705 42   \u2192 42\n// \u274c -5   \u2192 ParseError\n\n// Integer (whole number)\nconst Int = Schema.Int\n// \u2705 42   \u2192 42\n// \u274c 3.14 \u2192 ParseError\n\n// ============================================\n// RANGE CONSTRAINTS\n// ============================================\n\n// Between values (inclusive)\nconst Percentage = Schema.Number.pipe(\n  Schema.between(0, 100, {\n    message: () => \"Percentage must be 0-100\"\n  })\n)\n\n// Greater than\nconst OverEighteen = Schema.Number.pipe(\n  Schema.greaterThan(18, {\n    message: () => \"Must be over 18\"\n  })\n)\n\n// Less than or equal\nconst MaxItems = Schema.Number.pipe(\n  Schema.lessThanOrEqualTo(1000)\n)\n\n// ============================================\n// COMBINING REFINEMENTS\n// ============================================\n\n// Positive integer\nconst PositiveInt = Schema.Number.pipe(\n  Schema.int(),\n  Schema.positive()\n)\n\n// Valid age\nconst Age = Schema.Number.pipe(\n  Schema.int({ message: () => \"Age must be a whole number\" }),\n  Schema.between(0, 150, { message: () => \"Invalid age\" })\n)\n\n// Price (positive with 2 decimal places max)\nconst Price = Schema.Number.pipe(\n  Schema.positive({ message: () => \"Price must be positive\" }),\n  Schema.filter(\n    (n) => Number.isFinite(n) && Math.round(n * 100) === n * 100,\n    { message: () => \"Price must have at most 2 decimal places\" }\n  )\n)\n\n// ============================================\n// SPECIAL NUMBERS\n// ============================================\n\n// Finite only (no Infinity)\nconst Finite = Schema.Number.pipe(\n  Schema.finite({ message: () => \"Must be a finite number\" })\n)\n\n// ============================================\n// USING IN STRUCTS\n// ============================================\n\nconst Product = Schema.Struct({\n  name: Schema.String,\n  price: Price,\n  quantity: PositiveInt,\n  discount: Schema.optional(Percentage),\n})\n\nconst Order = Schema.Struct({\n  items: Schema.Array(Product),\n  customerAge: Age,\n})\n\n// Decode and validate\nconst decode = Schema.decodeUnknownSync(Product)\n\nconst validProduct = decode({\n  name: \"Widget\",\n  price: 29.99,\n  quantity: 5,\n  discount: 10,\n})\nconsole.log(`\u2705 ${validProduct.name}: $${validProduct.price}`)\n\ntry {\n  decode({\n    name: \"Bad Product\",\n    price: -10,      // Negative!\n    quantity: 2.5,   // Not integer!\n  })\n} catch {\n  console.log(\"\u274c Validation failed\")\n}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Number Validation and Refinements using Schema."
            },
            "created_at": "2026-02-16T21:39:09.121045",
            "updated_at": "2026-02-20T23:09:38.423313"
        },
        {
            "id": "7620ced3-0e4a-4fda-9fd5-82b0ea0aee4e",
            "slug": "schema-date-validation",
            "title": "Date Validation and Parsing",
            "summary": "Dates arrive in many formats: ISO strings, Unix timestamps, Date objects. JavaScript's Date constructor silently accepts invalid input (\"Invalid Date\"). You need to parse dates safely and validate...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "date",
                "validation",
                "parsing",
                "timestamp"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// ============================================\n// BUILT-IN DATE SCHEMAS\n// ============================================\n\n// Date object validation\nconst DateSchema = Schema.Date\n// \u2705 new Date() \u2192 Date\n// \u274c \"not a date\" \u2192 ParseError\n\n// Parse date from ISO string\nconst DateFromString = Schema.DateFromString\n// \u2705 \"2024-01-15T10:30:00Z\" \u2192 Date\n// \u274c \"invalid\" \u2192 ParseError\n\n// ============================================\n// CUSTOM DATE PARSING\n// ============================================\n\n// Unix timestamp (seconds) to Date\nconst DateFromUnix = Schema.transform(\n  Schema.Number,\n  Schema.DateFromSelf,\n  {\n    decode: (timestamp) => new Date(timestamp * 1000),\n    encode: (date) => Math.floor(date.getTime() / 1000),\n  }\n)\n\n// Unix timestamp (milliseconds) to Date\nconst DateFromMillis = Schema.transform(\n  Schema.Number,\n  Schema.DateFromSelf,\n  {\n    decode: (ms) => new Date(ms),\n    encode: (date) => date.getTime(),\n  }\n)\n\n// ============================================\n// DATE REFINEMENTS\n// ============================================\n\n// Valid date (not \"Invalid Date\")\nconst ValidDate = Schema.Date.pipe(\n  Schema.filter(\n    (d) => !isNaN(d.getTime()),\n    { message: () => \"Invalid date\" }\n  )\n)\n\n// Date must be in the future\nconst FutureDate = Schema.Date.pipe(\n  Schema.filter(\n    (d) => d.getTime() > Date.now(),\n    { message: () => \"Date must be in the future\" }\n  )\n)\n\n// Date must be in the past\nconst PastDate = Schema.Date.pipe(\n  Schema.filter(\n    (d) => d.getTime() < Date.now(),\n    { message: () => \"Date must be in the past\" }\n  )\n)\n\n// Date within range\nconst RecentDate = Schema.Date.pipe(\n  Schema.filter(\n    (d) => {\n      const oneYearAgo = Date.now() - 365 * 24 * 60 * 60 * 1000\n      return d.getTime() >= oneYearAgo && d.getTime() <= Date.now()\n    },\n    { message: () => \"Date must be within the last year\" }\n  )\n)\n\n// ============================================\n// USING IN STRUCTS\n// ============================================\n\nconst Event = Schema.Struct({\n  title: Schema.String,\n  startDate: FutureDate,\n  endDate: FutureDate,\n})\n\nconst APIPayload = Schema.Struct({\n  userId: Schema.String,\n  createdAt: DateFromString,    // ISO string from JSON\n  timestamp: DateFromUnix,       // Unix seconds\n})\n\n// Decode from different formats\nconst decodeEvent = Schema.decodeUnknownSync(Event)\nconst decodePayload = Schema.decodeUnknownSync(APIPayload)\n\n// Future date validation\nconst tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000)\nconst nextWeek = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n\nconst event = decodeEvent({\n  title: \"Conference\",\n  startDate: tomorrow,\n  endDate: nextWeek,\n})\nconsole.log(`\u2705 Event: ${event.title} starts ${event.startDate.toDateString()}`)\n\n// Parse from API payload\nconst payload = decodePayload({\n  userId: \"user_123\",\n  createdAt: \"2024-01-15T10:30:00Z\",\n  timestamp: 1705318200,\n})\nconsole.log(`\u2705 Created: ${payload.createdAt.toISOString()}`)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Date Validation and Parsing using Schema."
            },
            "created_at": "2026-02-16T21:39:09.451172",
            "updated_at": "2026-02-20T23:09:38.519548"
        },
        {
            "id": "40631797-b220-408a-9d95-b0fa6aaf8dda",
            "slug": "schema-api-response-basic",
            "title": "Basic API Response Decoding",
            "summary": "You're fetching data from an external API. The response is `unknown` at runtime. TypeScript's type assertions (`as User`) are lies\u2014they don't validate anything. A malformed API response will silently...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "api",
                "decode",
                "runtime-validation",
                "http"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema } from \"effect\"\n\n// 1. Define the expected shape\nconst User = Schema.Struct({\n  id: Schema.Number,\n  name: Schema.String,\n  email: Schema.String,\n})\n\n// 2. Derive the TypeScript type\ntype User = typeof User.Type\n\n// 3. Create a decoder Effect\nconst parseUser = Schema.decodeUnknown(User)\n\n// 4. Use in an Effect pipeline\nconst fetchUser = (id: number) =>\n  Effect.gen(function* () {\n    // Fetch from API\n    const response = yield* Effect.tryPromise(() =>\n      fetch(`https://api.example.com/users/${id}`).then((r) => r.json())\n    )\n\n    // Validate response against schema\n    const user = yield* parseUser(response)\n\n    // user is typed as User, and validated at runtime\n    console.log(`Fetched user: ${user.name} <${user.email}>`)\n    return user\n  })\n\n// Handle the result\nconst main = Effect.gen(function* () {\n  const user = yield* fetchUser(123)\n  yield* Effect.log(`User email: ${user.email}`)\n})\n\nawait Effect.runPromise(main)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Basic API Response Decoding using Schema."
            },
            "created_at": "2026-02-16T21:39:05.430359",
            "updated_at": "2026-02-20T23:09:37.418827"
        },
        {
            "id": "09e76c95-e28e-44ed-a074-f44ef42fa8d8",
            "slug": "schema-ai-output-nested-structures",
            "title": "Nested Object Schemas",
            "summary": "You need to represent complex, hierarchical data from an LLM\u2014like a document with sections, paragraphs, and metadata. Flat schemas don't capture this structure. You need to compose schemas into...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "ai",
                "nested",
                "composition",
                "structured-output"
            ],
            "examples": [
                {
                    "code": "import { Schema, JSONSchema, Effect } from \"effect\"\nimport { Anthropic } from \"@anthropic-ai/sdk\"\n\n// 1. Define nested schemas bottom-up\nconst Metadata = Schema.Struct({\n  author: Schema.String.pipe(\n    Schema.description(\"Author name or 'Unknown'\")\n  ),\n  publishDate: Schema.String.pipe(\n    Schema.description(\"ISO 8601 date format (YYYY-MM-DD)\")\n  ),\n  tags: Schema.Array(Schema.String).pipe(\n    Schema.description(\"Topic tags, lowercase\")\n  ),\n})\n\nconst Citation = Schema.Struct({\n  title: Schema.String,\n  url: Schema.String.pipe(\n    Schema.description(\"Full HTTP/HTTPS URL\")\n  ),\n  accessDate: Schema.String.pipe(\n    Schema.optional,\n    Schema.description(\"ISO 8601 date when accessed\")\n  ),\n})\n\nconst Section = Schema.Struct({\n  title: Schema.String,\n  content: Schema.String.pipe(\n    Schema.description(\"Main paragraph text, 100-300 words\")\n  ),\n  citations: Schema.Array(Citation).pipe(\n    Schema.description(\"Sources for this section\")\n  ),\n  subsections: Schema.Array(Schema.lazy(() => Section)).pipe(\n    Schema.description(\"Nested subsections, max depth 3\")\n  ),\n})\n\nconst Article = Schema.Struct({\n  headline: Schema.String.pipe(\n    Schema.description(\"Main title of article\")\n  ),\n  summary: Schema.String.pipe(\n    Schema.maxLength(300),\n    Schema.description(\"Executive summary, under 300 chars\")\n  ),\n  metadata: Metadata,\n  sections: Schema.Array(Section).pipe(\n    Schema.minItems(1),\n    Schema.description(\"At least one section required\")\n  ),\n})\n\ntype Article = typeof Article.Type\n\n// 2. Generate JSON Schema with nested structures\nconst jsonSchema = JSONSchema.make(Article)\n\n// 3. Parse and validate deeply nested response\nconst extractArticle = (text: string) =>\n  Effect.gen(function* () {\n    const client = new Anthropic()\n\n    const response = yield* Effect.tryPromise({\n      try: () =>\n        client.messages.create({\n          model: \"claude-3-5-sonnet-20241022\",\n          max_tokens: 4096,\n          messages: [\n            {\n              role: \"user\",\n              content: `Extract structured article from:\\n\\n${text}`,\n            },\n          ],\n          tools: [\n            {\n              name: \"extract_article\",\n              description: \"Extract article with nested sections\",\n              input_schema: jsonSchema as any,\n            },\n          ],\n        }),\n      catch: (error) => new Error(`API call failed: ${error}`),\n    })\n\n    const toolUse = response.content.find(\n      (block) => block.type === \"tool_use\"\n    ) as any\n\n    if (!toolUse) {\n      return yield* Effect.fail(new Error(\"No tool use in response\"))\n    }\n\n    // Validates entire nested tree at once\n    const article = yield* Effect.tryPromise({\n      try: () => Schema.decodeUnknownSync(Article)(toolUse.input),\n      catch: (error) =>\n        new Error(`Validation failed: ${error}`),\n    })\n\n    return article\n  })\n\n// 4. Traverse and process nested data\nconst countWords = (article: Article): number => {\n  let total = 0\n\n  const countSection = (section: Section) => {\n    total += section.content.split(\" \").length\n    section.subsections.forEach(countSection)\n  }\n\n  article.sections.forEach(countSection)\n  return total\n}\n\n// Usage\nconst sampleText = `\nThe Rise of Effect-TS\nEffect-TS is a powerful functional programming framework...\nSection: Core Concepts\nEffect is a data type that represents an effectful computation...\nSubsection: Error Handling\nEffects model errors as data...\n`\n\nEffect.runPromise(extractArticle(sampleText))\n  .then((article) => {\n    console.log(`Article: ${article.headline}`)\n    console.log(`Words: ${countWords(article)}`)\n    console.log(JSON.stringify(article.sections[0].subsections, null, 2))\n  })",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Nested Object Schemas."
            },
            "created_at": "2026-02-16T21:39:06.256494",
            "updated_at": "2026-02-20T23:09:37.637468"
        },
        {
            "id": "1c874616-20a5-420a-b6e7-3094efdf38fd",
            "slug": "schema-merge-schemas",
            "title": "Merging Multiple Schemas into One",
            "summary": "You need to validate that incoming data satisfies multiple schemas at once. A request must be valid JSON AND match your custom business rules. A document must have base metadata AND domain-specific...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "composition",
                "merge",
                "combination",
                "intersection"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Base schemas to merge\n// ============================================\n\nconst BaseEntity = Schema.Struct({\n  id: Schema.String,\n  createdAt: Schema.Date,\n  updatedAt: Schema.Date,\n})\n\nconst Auditable = Schema.Struct({\n  createdBy: Schema.String,\n  modifiedBy: Schema.String,\n  version: Schema.Number,\n})\n\nconst Timestamped = Schema.Struct({\n  publishedAt: Schema.Optional(Schema.Date),\n  expiresAt: Schema.Optional(Schema.Date),\n})\n\n// ============================================\n// 2. Merge using spread syntax\n// ============================================\n\nconst Article = Schema.Struct({\n  ...BaseEntity.fields,\n  ...Auditable.fields,\n  title: Schema.String,\n  content: Schema.String,\n  tags: Schema.Array(Schema.String),\n})\n\ntype Article = typeof Article.Type\n\n// ============================================\n// 3. Merge with Schema.extend for complex cases\n// ============================================\n\nconst AuditableEntity = Schema.extend(BaseEntity, Auditable)\n\nconst Article2 = Schema.extend(\n  AuditableEntity,\n  Schema.Struct({\n    title: Schema.String,\n    content: Schema.String,\n    tags: Schema.Array(Schema.String),\n  })\n)\n\ntype Article2 = typeof Article2.Type\n\n// ============================================\n// 4. Merge API contract with domain rules\n// ============================================\n\nconst ApiRequest = Schema.Struct({\n  userId: Schema.String,\n  action: Schema.Enum({\n    create: \"create\",\n    update: \"update\",\n    delete: \"delete\",\n  }),\n  timestamp: Schema.Date,\n})\n\nconst BusinessRules = Schema.Struct({\n  role: Schema.Enum({\n    admin: \"admin\",\n    user: \"user\",\n    guest: \"guest\",\n  }),\n  accountStatus: Schema.Enum({\n    active: \"active\",\n    suspended: \"suspended\",\n  }),\n})\n\nconst FullRequest = Schema.extend(ApiRequest, BusinessRules)\n\ntype FullRequest = typeof FullRequest.Type\n\n// ============================================\n// 5. Conditional merge patterns\n// ============================================\n\nconst Document = Schema.Struct({\n  id: Schema.String,\n  title: Schema.String,\n  content: Schema.String,\n})\n\nconst PublicDocument = Schema.extend(\n  Document,\n  Schema.Struct({\n    visibility: Schema.Literal(\"public\"),\n    publishedAt: Schema.Date,\n    author: Schema.String,\n  })\n)\n\nconst PrivateDocument = Schema.extend(\n  Document,\n  Schema.Struct({\n    visibility: Schema.Literal(\"private\"),\n    owner: Schema.String,\n    permissions: Schema.Array(Schema.String),\n  })\n)\n\ntype PublicDocument = typeof PublicDocument.Type\ntype PrivateDocument = typeof PrivateDocument.Type\n\n// ============================================\n// 6. Processing merged schemas\n// ============================================\n\nconst parseArticle = (raw: unknown): Effect.Effect<Article, Error> =>\n  Effect.tryPromise({\n    try: () => Schema.decodeUnknown(Article)(raw),\n    catch: (error) => new Error(String(error)),\n  })\n\nconst parseFullRequest = (raw: unknown): Effect.Effect<FullRequest, Error> =>\n  Effect.tryPromise({\n    try: () => Schema.decodeUnknown(FullRequest)(raw),\n    catch: (error) => new Error(String(error)),\n  })\n\n// ============================================\n// 7. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Schema Merging ===\\n\")\n\n  console.log(\"1. Article (merged schemas):\\n\")\n\n  const articleData = {\n    id: \"art_123\",\n    createdAt: new Date(\"2025-12-01\"),\n    updatedAt: new Date(\"2025-12-15\"),\n    createdBy: \"alice\",\n    modifiedBy: \"bob\",\n    version: 3,\n    title: \"Functional Programming with Effect-TS\",\n    content: \"A comprehensive guide...\",\n    tags: [\"effect\", \"typescript\", \"functional\"],\n  }\n\n  const article = yield* parseArticle(articleData)\n  console.log(`Article ID: ${article.id}`)\n  console.log(`Title: ${article.title}`)\n  console.log(`Created by: ${article.createdBy}, Modified by: ${article.modifiedBy}`)\n  console.log(`Version: ${article.version}`)\n  console.log(`Tags: ${article.tags.join(\", \")}`)\n\n  console.log(\"\\n2. Full Request (API + Business Rules):\\n\")\n\n  const requestData = {\n    userId: \"user_456\",\n    action: \"create\",\n    timestamp: new Date(),\n    role: \"user\",\n    accountStatus: \"active\",\n  }\n\n  const request = yield* parseFullRequest(requestData)\n  console.log(`User: ${request.userId} (${request.role})`)\n  console.log(`Action: ${request.action}`)\n  console.log(`Account: ${request.accountStatus}`)\n\n  console.log(\"\\n3. Document Variants (conditional merge):\\n\")\n\n  const publicDocData = {\n    id: \"doc_789\",\n    title: \"Public Blog Post\",\n    content: \"This is public...\",\n    visibility: \"public\",\n    publishedAt: new Date(\"2025-12-10\"),\n    author: \"alice\",\n  }\n\n  const publicDoc = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(PublicDocument)(publicDocData),\n    catch: (error) => new Error(String(error)),\n  })\n\n  console.log(`Public Doc: ${publicDoc.title}`)\n  console.log(`Author: ${publicDoc.author}`)\n  console.log(`Published: ${publicDoc.publishedAt.toDateString()}`)\n\n  const privateDocData = {\n    id: \"doc_999\",\n    title: \"Private Notes\",\n    content: \"This is private...\",\n    visibility: \"private\",\n    owner: \"bob\",\n    permissions: [\"read\", \"write\"],\n  }\n\n  const privateDoc = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(PrivateDocument)(privateDocData),\n    catch: (error) => new Error(String(error)),\n  })\n\n  console.log(`\\nPrivate Doc: ${privateDoc.title}`)\n  console.log(`Owner: ${privateDoc.owner}`)\n  console.log(`Permissions: ${privateDoc.permissions.join(\", \")}`)\n\n  console.log(\"\\n4. Benefits of merging:\\n\")\n  console.log(\"\u2713 Single source of truth for each concern\")\n  console.log(\"\u2713 Reusable base schemas\")\n  console.log(\"\u2713 Clear separation of concerns\")\n  console.log(\"\u2713 Easy to understand relationships\")\n  console.log(\"\u2713 Reduced duplication\")\n\n  return { article, request, publicDoc, privateDoc }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Schema merging complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Merge Multiple Schemas into One."
            },
            "created_at": "2026-02-16T21:39:09.999855",
            "updated_at": "2026-02-20T23:09:38.674242"
        },
        {
            "id": "b79c070e-0eae-45f7-9091-5b9ca8de2d6d",
            "slug": "schema-optional-fields",
            "title": "Optional and Nullable Fields",
            "summary": "Not all fields are required. Some are optional (may be missing), some are nullable (present but null), some accept both. You need to express these different optionality patterns while keeping types...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "optional",
                "nullable",
                "undefined"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// ============================================\n// OPTIONAL FIELDS (may be missing)\n// ============================================\n\nconst UserProfile = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  // These fields may be omitted entirely\n  bio: Schema.optional(Schema.String),\n  website: Schema.optional(Schema.String),\n  age: Schema.optional(Schema.Number),\n})\n\ntype UserProfile = typeof UserProfile.Type\n// { id: string; name: string; bio?: string; website?: string; age?: number }\n\nconst decodeProfile = Schema.decodeUnknownSync(UserProfile)\n\n// Minimal required fields only\nconst minimal = decodeProfile({\n  id: \"user_123\",\n  name: \"Alice\",\n})\nconsole.log(`\u2705 ${minimal.name}, bio: ${minimal.bio ?? \"not set\"}`)\n\n// With optional fields\nconst full = decodeProfile({\n  id: \"user_456\",\n  name: \"Bob\",\n  bio: \"Software developer\",\n  website: \"https://bob.dev\",\n  age: 28,\n})\nconsole.log(`\u2705 ${full.name}, ${full.age} years old`)\n\n// ============================================\n// NULLABLE FIELDS (present but null)\n// ============================================\n\nconst DatabaseRecord = Schema.Struct({\n  id: Schema.String,\n  // Field exists but value may be null\n  deletedAt: Schema.NullOr(Schema.Date),\n  parentId: Schema.NullOr(Schema.String),\n})\n\ntype DatabaseRecord = typeof DatabaseRecord.Type\n// { id: string; deletedAt: Date | null; parentId: string | null }\n\nconst decodeRecord = Schema.decodeUnknownSync(DatabaseRecord)\n\nconst activeRecord = decodeRecord({\n  id: \"rec_123\",\n  deletedAt: null,\n  parentId: \"rec_100\",\n})\nconsole.log(`\u2705 Record ${activeRecord.id}, deleted: ${activeRecord.deletedAt === null}`)\n\nconst deletedRecord = decodeRecord({\n  id: \"rec_456\",\n  deletedAt: new Date(),\n  parentId: null,\n})\nconsole.log(`\u2705 Record deleted at: ${deletedRecord.deletedAt?.toISOString()}`)\n\n// ============================================\n// OPTIONAL + NULLABLE (both)\n// ============================================\n\nconst FlexibleProfile = Schema.Struct({\n  id: Schema.String,\n  // May be missing OR present as null\n  nickname: Schema.optional(Schema.NullOr(Schema.String)),\n})\n\ntype FlexibleProfile = typeof FlexibleProfile.Type\n// { id: string; nickname?: string | null }\n\nconst decodeFlexible = Schema.decodeUnknownSync(FlexibleProfile)\n\n// Field missing\nconst noNickname = decodeFlexible({ id: \"1\" })\nconsole.log(`Nickname: ${noNickname.nickname}`)  // undefined\n\n// Field is null\nconst nullNickname = decodeFlexible({ id: \"2\", nickname: null })\nconsole.log(`Nickname: ${nullNickname.nickname}`)  // null\n\n// Field has value\nconst hasNickname = decodeFlexible({ id: \"3\", nickname: \"Ace\" })\nconsole.log(`Nickname: ${hasNickname.nickname}`)  // \"Ace\"\n\n// ============================================\n// OPTIONAL WITH DEFAULTS\n// ============================================\n\nconst Settings = Schema.Struct({\n  theme: Schema.optionalWith(Schema.String, { default: () => \"light\" }),\n  pageSize: Schema.optionalWith(Schema.Number, { default: () => 20 }),\n  notifications: Schema.optionalWith(Schema.Boolean, { default: () => true }),\n})\n\ntype Settings = typeof Settings.Type\n\nconst decodeSettings = Schema.decodeUnknownSync(Settings)\n\nconst defaultSettings = decodeSettings({})\nconsole.log(`\u2705 Theme: ${defaultSettings.theme}, Page: ${defaultSettings.pageSize}`)\n// Output: \u2705 Theme: light, Page: 20\n\nconst customSettings = decodeSettings({ theme: \"dark\", pageSize: 50 })\nconsole.log(`\u2705 Theme: ${customSettings.theme}, Page: ${customSettings.pageSize}`)\n// Output: \u2705 Theme: dark, Page: 50",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Optional and Nullable Fields using Schema."
            },
            "created_at": "2026-02-16T21:39:10.345072",
            "updated_at": "2026-02-20T23:09:38.762735"
        },
        {
            "id": "a51d357e-f0ee-4973-954d-60fe7bdfb6bd",
            "slug": "schema-nested-objects",
            "title": "Nested Object Schemas",
            "summary": "Real data has nested objects: a user has an address, an order has items with products. You need to define schemas for complex structures where objects contain other objects, and validate the entire...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "nested",
                "composition",
                "complex"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// ============================================\n// DEFINE COMPONENT SCHEMAS\n// ============================================\n\nconst Address = Schema.Struct({\n  street: Schema.String,\n  city: Schema.String,\n  zipCode: Schema.String,\n  country: Schema.String,\n})\n\nconst ContactInfo = Schema.Struct({\n  email: Schema.String,\n  phone: Schema.optional(Schema.String),\n})\n\n// ============================================\n// COMPOSE INTO NESTED STRUCTURES\n// ============================================\n\nconst User = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  contact: ContactInfo,          // Nested object\n  address: Address,              // Nested object\n  billingAddress: Schema.optional(Address),  // Optional nested\n})\n\ntype User = typeof User.Type\n\n// ============================================\n// DEEPLY NESTED STRUCTURES\n// ============================================\n\nconst Product = Schema.Struct({\n  sku: Schema.String,\n  name: Schema.String,\n  price: Schema.Number,\n})\n\nconst OrderItem = Schema.Struct({\n  product: Product,              // Nested product\n  quantity: Schema.Number,\n  subtotal: Schema.Number,\n})\n\nconst Order = Schema.Struct({\n  orderId: Schema.String,\n  customer: User,                // Nested user (which has nested address!)\n  items: Schema.Array(OrderItem), // Array of nested items\n  total: Schema.Number,\n  shippingAddress: Address,      // Nested address\n})\n\ntype Order = typeof Order.Type\n\n// ============================================\n// VALIDATION IN ACTION\n// ============================================\n\nconst decodeUser = Schema.decodeUnknownSync(User)\nconst decodeOrder = Schema.decodeUnknownSync(Order)\n\n// Valid nested user\nconst user = decodeUser({\n  id: \"user_123\",\n  name: \"Alice\",\n  contact: {\n    email: \"alice@example.com\",\n    phone: \"555-1234\",\n  },\n  address: {\n    street: \"123 Main St\",\n    city: \"Springfield\",\n    zipCode: \"12345\",\n    country: \"USA\",\n  },\n})\n\nconsole.log(`\u2705 ${user.name} lives in ${user.address.city}`)\nconsole.log(`   Email: ${user.contact.email}`)\n\n// Valid deeply nested order\nconst order = decodeOrder({\n  orderId: \"order_789\",\n  customer: {\n    id: \"user_123\",\n    name: \"Alice\",\n    contact: { email: \"alice@example.com\" },\n    address: {\n      street: \"123 Main St\",\n      city: \"Springfield\",\n      zipCode: \"12345\",\n      country: \"USA\",\n    },\n  },\n  items: [\n    {\n      product: { sku: \"WIDGET-001\", name: \"Widget\", price: 29.99 },\n      quantity: 2,\n      subtotal: 59.98,\n    },\n    {\n      product: { sku: \"GADGET-002\", name: \"Gadget\", price: 49.99 },\n      quantity: 1,\n      subtotal: 49.99,\n    },\n  ],\n  total: 109.97,\n  shippingAddress: {\n    street: \"456 Oak Ave\",\n    city: \"Portland\",\n    zipCode: \"97201\",\n    country: \"USA\",\n  },\n})\n\nconsole.log(`\\n\u2705 Order ${order.orderId}`)\nconsole.log(`   Customer: ${order.customer.name}`)\nconsole.log(`   Items: ${order.items.length}`)\norder.items.forEach((item) => {\n  console.log(`   - ${item.product.name} x${item.quantity}: $${item.subtotal}`)\n})\nconsole.log(`   Total: $${order.total}`)\nconsole.log(`   Ship to: ${order.shippingAddress.city}`)\n\n// Invalid - nested validation error\ntry {\n  decodeUser({\n    id: \"user_456\",\n    name: \"Bob\",\n    contact: {\n      email: 12345,  // Should be string!\n    },\n    address: {\n      street: \"789 Pine St\",\n      // Missing city, zipCode, country!\n    },\n  })\n} catch {\n  console.log(\"\\n\u274c Nested validation failed\")\n}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Nested Object Schemas."
            },
            "created_at": "2026-02-16T21:39:10.515315",
            "updated_at": "2026-02-20T23:09:38.809929"
        },
        {
            "id": "285e9858-9a34-475a-8d90-e82ea883b24e",
            "slug": "schema-tree-structures",
            "title": "Tree Structures - File Systems, Org Charts, Hierarchies",
            "summary": "Real applications work with trees constantly: file systems, org charts, category hierarchies, DOM trees. Each node has metadata and children. You need to parse, validate, and manipulate these...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "recursive",
                "trees",
                "file-systems",
                "hierarchies",
                "org-charts"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. File system tree\n// ============================================\n\ntype FileSystemNode = {\n  name: string\n  path: string\n  type: \"file\" | \"directory\"\n  size?: number\n  mimeType?: string\n  children?: FileSystemNode[]\n  permissions?: {\n    read: boolean\n    write: boolean\n    execute: boolean\n  }\n}\n\nconst FileSystemNode: Schema.Schema<FileSystemNode> = Schema.suspend(() =>\n  Schema.Struct({\n    name: Schema.String,\n    path: Schema.String,\n    type: Schema.Enum({ file: \"file\", directory: \"directory\" }),\n    size: Schema.Optional(Schema.Number),\n    mimeType: Schema.Optional(Schema.String),\n    children: Schema.Optional(Schema.Array(FileSystemNode)),\n    permissions: Schema.Optional(\n      Schema.Struct({\n        read: Schema.Boolean,\n        write: Schema.Boolean,\n        execute: Schema.Boolean,\n      })\n    ),\n  })\n)\n\n// ============================================\n// 2. Organization chart\n// ============================================\n\ntype OrgChartNode = {\n  id: string\n  name: string\n  title: string\n  email: string\n  department: string\n  reportsTo?: string\n  directReports: OrgChartNode[]\n}\n\nconst OrgChartNode: Schema.Schema<OrgChartNode> = Schema.suspend(() =>\n  Schema.Struct({\n    id: Schema.String,\n    name: Schema.String,\n    title: Schema.String,\n    email: Schema.String,\n    department: Schema.String,\n    reportsTo: Schema.Optional(Schema.String),\n    directReports: Schema.Array(OrgChartNode),\n  })\n)\n\n// ============================================\n// 3. Category hierarchy\n// ============================================\n\ntype Category = {\n  id: string\n  name: string\n  slug: string\n  description: string\n  parent?: string\n  subcategories: Category[]\n  productCount: number\n}\n\nconst Category: Schema.Schema<Category> = Schema.suspend(() =>\n  Schema.Struct({\n    id: Schema.String,\n    name: Schema.String,\n    slug: Schema.String,\n    description: Schema.String,\n    parent: Schema.Optional(Schema.String),\n    subcategories: Schema.Array(Category),\n    productCount: Schema.Number,\n  })\n)\n\n// ============================================\n// 4. Tree utilities\n// ============================================\n\nconst getFileSize = (node: FileSystemNode): number => {\n  if (node.type === \"file\") {\n    return node.size || 0\n  }\n  if (!node.children) return 0\n  return node.children.reduce((sum, child) => sum + getFileSize(child), 0)\n}\n\nconst getTreeDepth = <T extends { children?: T[] }>(node: T): number => {\n  if (!node.children || node.children.length === 0) return 1\n  return 1 + Math.max(...node.children.map(getTreeDepth))\n}\n\nconst flattenTree = <T extends { children?: T[] }>(node: T): T[] => {\n  return [node, ...(node.children || []).flatMap(flattenTree)]\n}\n\nconst filterTree = <T extends { children?: T[] }>(\n  node: T,\n  predicate: (n: T) => boolean\n): T | null => {\n  if (!predicate(node)) return null\n\n  const filteredChildren = (node.children || [])\n    .map((child) => filterTree(child, predicate))\n    .filter((n): n is T => n !== null)\n\n  return { ...node, children: filteredChildren }\n}\n\nconst mapTree = <T extends { children?: T[] }>(\n  node: T,\n  fn: (n: T) => T\n): T => {\n  const mapped = fn(node)\n  if (!mapped.children) return mapped\n\n  return {\n    ...mapped,\n    children: mapped.children.map((child) => mapTree(child, fn)),\n  } as T\n}\n\n// ============================================\n// 5. Processing effects\n// ============================================\n\nconst listFiles = (node: FileSystemNode): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    const indent = (node.path.match(/\\//g) || []).length - 1\n    const prefix = \"  \".repeat(indent)\n\n    if (node.type === \"file\") {\n      const size = node.size ? ` (${node.size} bytes)` : \"\"\n      yield* Effect.log(`${prefix}\ud83d\udcc4 ${node.name}${size}`)\n    } else {\n      yield* Effect.log(`${prefix}\ud83d\udcc1 ${node.name}/`)\n      if (node.children) {\n        for (const child of node.children) {\n          yield* listFiles(child)\n        }\n      }\n    }\n  })\n\nconst printOrgChart = (\n  node: OrgChartNode,\n  level: number = 0\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    const indent = \"  \".repeat(level)\n    yield* Effect.log(\n      `${indent}${node.name} - ${node.title} (${node.department})`\n    )\n\n    for (const report of node.directReports) {\n      yield* printOrgChart(report, level + 1)\n    }\n  })\n\n// ============================================\n// 6. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== File System ===\\n\")\n\n  const filesystem: FileSystemNode = {\n    name: \"root\",\n    path: \"/\",\n    type: \"directory\",\n    children: [\n      {\n        name: \"src\",\n        path: \"/src\",\n        type: \"directory\",\n        children: [\n          {\n            name: \"index.ts\",\n            path: \"/src/index.ts\",\n            type: \"file\",\n            size: 1024,\n            mimeType: \"text/typescript\",\n          },\n          {\n            name: \"utils.ts\",\n            path: \"/src/utils.ts\",\n            type: \"file\",\n            size: 2048,\n            mimeType: \"text/typescript\",\n          },\n        ],\n      },\n      {\n        name: \"README.md\",\n        path: \"/README.md\",\n        type: \"file\",\n        size: 512,\n        mimeType: \"text/markdown\",\n      },\n    ],\n  }\n\n  yield* listFiles(filesystem)\n\n  console.log(`\\nTotal size: ${getFileSize(filesystem)} bytes`)\n  console.log(`Tree depth: ${getTreeDepth(filesystem)}`)\n\n  console.log(\"\\n=== Organization Chart ===\\n\")\n\n  const org: OrgChartNode = {\n    id: \"ceo_001\",\n    name: \"Alice Johnson\",\n    title: \"CEO\",\n    email: \"alice@company.com\",\n    department: \"Executive\",\n    directReports: [\n      {\n        id: \"eng_001\",\n        name: \"Bob Smith\",\n        title: \"VP Engineering\",\n        email: \"bob@company.com\",\n        department: \"Engineering\",\n        reportsTo: \"ceo_001\",\n        directReports: [\n          {\n            id: \"eng_002\",\n            name: \"Charlie Brown\",\n            title: \"Senior Engineer\",\n            email: \"charlie@company.com\",\n            department: \"Engineering\",\n            reportsTo: \"eng_001\",\n            directReports: [],\n          },\n        ],\n      },\n      {\n        id: \"sales_001\",\n        name: \"Diana Prince\",\n        title: \"VP Sales\",\n        email: \"diana@company.com\",\n        department: \"Sales\",\n        reportsTo: \"ceo_001\",\n        directReports: [],\n      },\n    ],\n  }\n\n  yield* printOrgChart(org)\n\n  console.log(`\\nTotal people: ${flattenTree(org).length}`)\n  console.log(`Org depth: ${getTreeDepth(org)}`)\n\n  console.log(\"\\n=== Category Hierarchy ===\\n\")\n\n  const categories: Category = {\n    id: \"electronics\",\n    name: \"Electronics\",\n    slug: \"electronics\",\n    description: \"Electronic products\",\n    productCount: 0,\n    subcategories: [\n      {\n        id: \"computers\",\n        name: \"Computers\",\n        slug: \"computers\",\n        description: \"Computers and laptops\",\n        parent: \"electronics\",\n        productCount: 0,\n        subcategories: [\n          {\n            id: \"desktops\",\n            name: \"Desktops\",\n            slug: \"desktops\",\n            description: \"Desktop computers\",\n            parent: \"computers\",\n            productCount: 25,\n            subcategories: [],\n          },\n          {\n            id: \"laptops\",\n            name: \"Laptops\",\n            slug: \"laptops\",\n            description: \"Laptop computers\",\n            parent: \"computers\",\n            productCount: 40,\n            subcategories: [],\n          },\n        ],\n      },\n      {\n        id: \"phones\",\n        name: \"Phones\",\n        slug: \"phones\",\n        description: \"Mobile phones\",\n        parent: \"electronics\",\n        productCount: 30,\n        subcategories: [],\n      },\n    ],\n  }\n\n  const all = flattenTree(categories)\n  console.log(`Total categories: ${all.length}`)\n  for (const cat of all) {\n    const indent = \"  \".repeat((cat.parent ? 1 : 0) + (all.indexOf(cat) % 2))\n    console.log(`${indent}${cat.name} (${cat.productCount} products)`)\n  }\n\n  return { filesystem, org, categories }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Tree structures complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Tree Structures - File Systems, Org Charts, Hierarchies using Schema."
            },
            "created_at": "2026-02-16T21:39:10.855228",
            "updated_at": "2026-02-20T23:09:38.898159"
        },
        {
            "id": "63465ded-d760-4632-901e-9ff7a367cc7f",
            "slug": "schema-ai-parsing-error-recovery",
            "title": "Handling Malformed AI Outputs",
            "summary": "An LLM returns malformed JSON or fields that don't match your schema. The parse fails and the operation stops. You need graceful recovery strategies: provide sensible defaults, extract partial data,...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "ai",
                "error-handling",
                "fallback",
                "recovery",
                "validation"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema, Option } from \"effect\"\nimport { Anthropic } from \"@anthropic-ai/sdk\"\n\n// 1. Define schema with optional recovery paths\nconst Article = Schema.Struct({\n  title: Schema.String,\n  content: Schema.String,\n  author: Schema.String.pipe(Schema.optional),\n  publishedAt: Schema.String.pipe(Schema.optional),\n})\n\ntype Article = typeof Article.Type\n\n// 2. Recovery strategy 1: Provide defaults\nconst parseWithDefaults = (data: unknown) =>\n  Effect.gen(function* () {\n    const parseArticle = Schema.decodeUnknown(Article)\n\n    const result = yield* parseArticle(data).pipe(\n      Effect.catchTag(\"ParseError\", () =>\n        Effect.succeed({\n          title: \"Untitled\",\n          content: String(data),\n          author: undefined,\n          publishedAt: undefined,\n        } as Article)\n      )\n    )\n\n    return result\n  })\n\n// 3. Recovery strategy 2: Extract partial data\nconst parsePartial = (data: unknown) =>\n  Effect.gen(function* () {\n    if (typeof data !== \"object\" || data === null) {\n      return yield* Effect.fail(\n        new Error(\"Response must be object\")\n      )\n    }\n\n    const obj = data as Record<string, unknown>\n\n    // Extract what we can\n    const article: Article = {\n      title: String(obj.title || \"Unknown\"),\n      content: String(obj.content || \"\"),\n      author: obj.author ? String(obj.author) : undefined,\n      publishedAt: obj.publishedAt\n        ? String(obj.publishedAt)\n        : undefined,\n    }\n\n    return article\n  })\n\n// 4. Recovery strategy 3: Retry with clarification\nconst parseWithRetry = (\n  initialData: unknown,\n  retryFn: () => Promise<unknown>,\n  maxRetries: number = 2\n) =>\n  Effect.gen(function* () {\n    const parseArticle = Schema.decodeUnknown(Article)\n    let lastError: Error | null = null\n    let data = initialData\n\n    for (let i = 0; i < maxRetries; i++) {\n      const result = yield* parseArticle(data).pipe(\n        Effect.catchTag(\"ParseError\", (error) => {\n          lastError = new Error(\n            `Parse failed (attempt ${i + 1}): ${error.message}`\n          )\n          return Effect.none()\n        })\n      )\n\n      if (Option.isSome(result)) {\n        return result.value\n      }\n\n      // Retry with fresh call\n      console.log(`Retrying parse (${i + 1}/${maxRetries})...`)\n      data = yield* Effect.tryPromise({\n        try: () => retryFn(),\n        catch: (error) => new Error(`Retry failed: ${error}`),\n      })\n    }\n\n    return yield* Effect.fail(\n      lastError ||\n        new Error(\"Parse failed after retries\")\n    )\n  })\n\n// 5. Recovery strategy 4: Log and continue\nconst parseWithLogging = (data: unknown, id: string) =>\n  Effect.gen(function* () {\n    const parseArticle = Schema.decodeUnknown(Article)\n\n    const result = yield* parseArticle(data).pipe(\n      Effect.catchTag(\"ParseError\", (error) => {\n        console.error(`[${id}] Parse error:`, {\n          error: error.message,\n          received: data,\n          timestamp: new Date().toISOString(),\n        })\n\n        // Log for analysis but return sensible defaults\n        return Effect.succeed({\n          title: \"Error - See Logs\",\n          content: JSON.stringify(data),\n          author: undefined,\n          publishedAt: undefined,\n        } as Article)\n      })\n    )\n\n    return result\n  })\n\n// Usage example\nconst handleResponse = (response: unknown) =>\n  Effect.gen(function* () {\n    // Try exact parse first\n    const exact = yield* Schema.decodeUnknown(Article)(\n      response\n    ).pipe(\n      Effect.catchTag(\"ParseError\", () =>\n        Effect.none()\n      )\n    )\n\n    if (Option.isSome(exact)) {\n      console.log(\"\u2705 Exact parse succeeded\")\n      return exact.value\n    }\n\n    // Fallback to partial extraction\n    console.log(\n      \"\u26a0\ufe0f Exact parse failed, extracting partial\"\n    )\n    const partial = yield* parsePartial(response)\n    return partial\n  })\n\n// Usage\nconst rawResponse = {\n  title: \"Effect-TS Guide\",\n  content: \"Learn Effect...\",\n  // author and publishedAt missing\n}\n\nEffect.runPromise(handleResponse(rawResponse))\n  .then((article) => console.log(article))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Handle Malformed AI Outputs using Schema."
            },
            "created_at": "2026-02-16T21:39:07.607921",
            "updated_at": "2026-02-20T23:09:38.035337"
        },
        {
            "id": "4fefc546-4e70-466f-9263-768b06f85b88",
            "slug": "schema-json-ast",
            "title": "Parsing JSON into Typed Abstract Syntax Trees",
            "summary": "You need to parse arbitrary JSON into a typed, manipulable structure. A JSON file could contain numbers, strings, arrays, objects\u2014all nested. Without an AST schema, you work with `any` and lose type...",
            "skill_level": "advanced",
            "category": "schema",
            "difficulty": "advanced",
            "tags": [
                "schema",
                "recursive",
                "ast",
                "json",
                "parsing",
                "compilers"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. JSON AST types\n// ============================================\n\ntype JsonValue =\n  | { type: \"null\" }\n  | { type: \"boolean\"; value: boolean }\n  | { type: \"number\"; value: number }\n  | { type: \"string\"; value: string }\n  | { type: \"array\"; elements: JsonValue[] }\n  | { type: \"object\"; properties: Record<string, JsonValue> }\n\nconst JsonValue: Schema.Schema<JsonValue> = Schema.suspend(() =>\n  Schema.Union(\n    Schema.Struct({ type: Schema.Literal(\"null\") }),\n    Schema.Struct({\n      type: Schema.Literal(\"boolean\"),\n      value: Schema.Boolean,\n    }),\n    Schema.Struct({\n      type: Schema.Literal(\"number\"),\n      value: Schema.Number,\n    }),\n    Schema.Struct({\n      type: Schema.Literal(\"string\"),\n      value: Schema.String,\n    }),\n    Schema.Struct({\n      type: Schema.Literal(\"array\"),\n      elements: Schema.Array(JsonValue),\n    }),\n    Schema.Struct({\n      type: Schema.Literal(\"object\"),\n      properties: Schema.Record(Schema.String, JsonValue),\n    })\n  )\n)\n\n// ============================================\n// 2. Convert raw JSON to AST\n// ============================================\n\nconst jsonToAst = (json: unknown): JsonValue => {\n  if (json === null) {\n    return { type: \"null\" }\n  }\n\n  if (typeof json === \"boolean\") {\n    return { type: \"boolean\", value: json }\n  }\n\n  if (typeof json === \"number\") {\n    return { type: \"number\", value: json }\n  }\n\n  if (typeof json === \"string\") {\n    return { type: \"string\", value: json }\n  }\n\n  if (Array.isArray(json)) {\n    return {\n      type: \"array\",\n      elements: json.map(jsonToAst),\n    }\n  }\n\n  if (typeof json === \"object\") {\n    const properties: Record<string, JsonValue> = {}\n    for (const [key, value] of Object.entries(json)) {\n      properties[key] = jsonToAst(value)\n    }\n    return { type: \"object\", properties }\n  }\n\n  throw new Error(`Unknown JSON type: ${typeof json}`)\n}\n\n// ============================================\n// 3. Convert AST back to JSON\n// ============================================\n\nconst astToJson = (ast: JsonValue): unknown => {\n  switch (ast.type) {\n    case \"null\":\n      return null\n    case \"boolean\":\n      return ast.value\n    case \"number\":\n      return ast.value\n    case \"string\":\n      return ast.value\n    case \"array\":\n      return ast.elements.map(astToJson)\n    case \"object\":\n      const obj: Record<string, unknown> = {}\n      for (const [key, value] of Object.entries(ast.properties)) {\n        obj[key] = astToJson(value)\n      }\n      return obj\n  }\n}\n\n// ============================================\n// 4. AST utilities\n// ============================================\n\nconst findPaths = (\n  ast: JsonValue,\n  predicate: (v: JsonValue) => boolean,\n  path: string = \"root\"\n): string[] => {\n  const results: string[] = []\n\n  if (predicate(ast)) {\n    results.push(path)\n  }\n\n  if (ast.type === \"array\") {\n    for (let i = 0; i < ast.elements.length; i++) {\n      results.push(\n        ...findPaths(ast.elements[i], predicate, `${path}[${i}]`)\n      )\n    }\n  } else if (ast.type === \"object\") {\n    for (const [key, value] of Object.entries(ast.properties)) {\n      results.push(...findPaths(value, predicate, `${path}.${key}`))\n    }\n  }\n\n  return results\n}\n\nconst transformAst = (\n  ast: JsonValue,\n  fn: (v: JsonValue) => JsonValue\n): JsonValue => {\n  const transformed = fn(ast)\n\n  switch (transformed.type) {\n    case \"array\":\n      return {\n        ...transformed,\n        elements: transformed.elements.map((e) => transformAst(e, fn)),\n      }\n    case \"object\":\n      const newProps: Record<string, JsonValue> = {}\n      for (const [key, value] of Object.entries(\n        transformed.properties\n      )) {\n        newProps[key] = transformAst(value, fn)\n      }\n      return { ...transformed, properties: newProps }\n    default:\n      return transformed\n  }\n}\n\nconst prettyPrint = (\n  ast: JsonValue,\n  indent: number = 0\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    const prefix = \"  \".repeat(indent)\n\n    switch (ast.type) {\n      case \"null\":\n        yield* Effect.log(`${prefix}null`)\n        break\n      case \"boolean\":\n        yield* Effect.log(`${prefix}${ast.value}`)\n        break\n      case \"number\":\n        yield* Effect.log(`${prefix}${ast.value}`)\n        break\n      case \"string\":\n        yield* Effect.log(`${prefix}\"${ast.value}\"`)\n        break\n      case \"array\":\n        yield* Effect.log(`${prefix}[`)\n        for (let i = 0; i < ast.elements.length; i++) {\n          yield* prettyPrint(ast.elements[i], indent + 1)\n          if (i < ast.elements.length - 1) {\n            yield* Effect.log(\",\")\n          }\n        }\n        yield* Effect.log(`${prefix}]`)\n        break\n      case \"object\":\n        yield* Effect.log(`${prefix}{`)\n        const entries = Object.entries(ast.properties)\n        for (let i = 0; i < entries.length; i++) {\n          const [key, value] = entries[i]\n          yield* Effect.log(`${prefix}  \"${key}\":`)\n          yield* prettyPrint(value, indent + 2)\n          if (i < entries.length - 1) {\n            yield* Effect.log(\",\")\n          }\n        }\n        yield* Effect.log(`${prefix}}`)\n        break\n    }\n  })\n\n// ============================================\n// 5. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== JSON to AST Conversion ===\\n\")\n\n  const jsonData = {\n    name: \"Effect-TS\",\n    version: \"3.0.0\",\n    active: true,\n    tags: [\"typescript\", \"functional\", \"effect\"],\n    maintainers: [\n      { name: \"John Doe\", email: \"john@example.com\" },\n      { name: \"Jane Smith\", email: \"jane@example.com\" },\n    ],\n    stats: {\n      downloads: 100000,\n      stars: 5000,\n      issues: 42,\n    },\n    deprecated: null,\n  }\n\n  console.log(\"Raw JSON:\")\n  console.log(JSON.stringify(jsonData, null, 2))\n\n  console.log(\"\\n--- Converting to AST ---\\n\")\n\n  const ast = jsonToAst(jsonData)\n\n  console.log(\"AST representation (excerpt):\")\n  console.log(`Root type: ${ast.type}`)\n  if (ast.type === \"object\") {\n    console.log(`Properties: ${Object.keys(ast.properties).join(\", \")}`)\n  }\n\n  console.log(\"\\n--- Pretty Printed AST ---\\n\")\n  yield* prettyPrint(ast)\n\n  console.log(\"\\n--- Finding string values ---\\n\")\n\n  const stringPaths = findPaths(\n    ast,\n    (v) => v.type === \"string\",\n    \"root\"\n  )\n\n  console.log(\"Paths with strings:\")\n  for (const path of stringPaths) {\n    console.log(`  ${path}`)\n  }\n\n  console.log(\"\\n--- Transforming AST ---\\n\")\n\n  // Double all numbers\n  const transformed = transformAst(ast, (v) => {\n    if (v.type === \"number\") {\n      return { type: \"number\", value: v.value * 2 }\n    }\n    return v\n  })\n\n  console.log(\"After doubling all numbers:\")\n  const result = astToJson(transformed)\n  if (typeof result === \"object\" && result !== null) {\n    const stats = (result as any).stats\n    console.log(`  downloads: ${stats.downloads}`)\n    console.log(`  stars: ${stats.stars}`)\n  }\n\n  console.log(\"\\n--- Validation ---\\n\")\n\n  // Validate AST structure\n  const validationResult = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(JsonValue)(ast),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`AST validation failed: ${msg}`)\n    },\n  })\n\n  console.log(\"\u2705 AST is valid\")\n  console.log(`Roundtrip successful: ${JSON.stringify(astToJson(ast)) === JSON.stringify(jsonData)}`)\n\n  return { ast, transformed }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 AST parsing complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Parse JSON into Typed Abstract Syntax Trees using Schema."
            },
            "created_at": "2026-02-16T21:39:11.375635",
            "updated_at": "2026-02-20T23:09:39.04577"
        },
        {
            "id": "9c41650f-a2ef-46ee-883e-96c0f5410975",
            "slug": "schema-web-standards-url",
            "title": "URL Validation",
            "summary": "You accept URLs from users\u2014as links, webhooks, or API endpoints. A string type doesn't validate that it's actually a valid URL. Users submit malformed URLs like \"htp://example\" or \"not a url\". You...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "validation",
                "web-standards",
                "url",
                "branded-types",
                "http"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. Define branded URL type\nconst HttpUrl = Schema.String.pipe(\n  Schema.trimmed(),\n  Schema.filter((s) => {\n    try {\n      const url = new URL(s)\n      // Only allow http/https\n      return (\n        url.protocol === \"http:\" || url.protocol === \"https:\"\n      )\n    } catch {\n      return false\n    }\n  }).pipe(\n    Schema.annotations({\n      description: \"Valid HTTP/HTTPS URL\",\n    })\n  ),\n  Schema.brand(\"HttpUrl\")\n)\n\ntype HttpUrl = typeof HttpUrl.Type\n\n// 2. Alternative: Allow multiple protocols\nconst WebUrl = Schema.String.pipe(\n  Schema.trimmed(),\n  Schema.filter((s) => {\n    try {\n      new URL(s)\n      return true\n    } catch {\n      return false\n    }\n  }).pipe(\n    Schema.annotations({\n      description: \"Valid URL (any protocol)\",\n    })\n  ),\n  Schema.brand(\"WebUrl\")\n)\n\ntype WebUrl = typeof WebUrl.Type\n\n// 3. Use in webhook configuration\nconst WebhookConfig = Schema.Struct({\n  name: Schema.String,\n  url: HttpUrl,\n  events: Schema.Array(\n    Schema.Literal(\"user.created\", \"user.deleted\")\n  ),\n  retryLimit: Schema.Number.pipe(\n    Schema.between(0, 10)\n  ).pipe(Schema.withDefault(3)),\n})\n\ntype WebhookConfig = typeof WebhookConfig.Type\n\n// 4. Validate and extract URL parts\nconst configureWebhook = (input: unknown) =>\n  Effect.gen(function* () {\n    const config = yield* Schema.decodeUnknown(\n      WebhookConfig\n    )(input).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ConfigError\" as const,\n        message: `Invalid webhook config: ${error.message}`,\n      }))\n    )\n\n    // Extract hostname from validated URL\n    const urlObj = new URL(config.url)\n    console.log(\n      `Webhook for ${urlObj.hostname} registered`\n    )\n\n    return config\n  })\n\n// 5. Usage\nconst webhookInput = {\n  name: \"User Events\",\n  url: \"https://webhook.example.com/users\",\n  events: [\"user.created\"],\n}\n\nEffect.runPromise(configureWebhook(webhookInput))\n  .then((config) => {\n    console.log(`\u2705 Webhook: ${config.name}`)\n  })\n  .catch((error) =>\n    console.error(`Error: ${error.message}`)\n  )",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "URL Validation using Schema."
            },
            "created_at": "2026-02-16T21:39:11.556809",
            "updated_at": "2026-02-20T23:09:39.083722"
        },
        {
            "id": "d9513755-7ccc-49a4-afd8-4d69ac6c0934",
            "slug": "schema-web-standards-http-headers",
            "title": "HTTP Header Validation",
            "summary": "Your HTTP server receives headers as strings\u2014`Content-Type: text/plain`, `Authorization: Bearer token`, etc. Headers are unvalidated and can be malformed, contain invalid values, or abuse your API....",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "validation",
                "web-standards",
                "http-headers",
                "content-type",
                "authentication"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. Define common header schemas\nconst ContentType = Schema.Union(\n  Schema.Literal(\n    \"application/json\",\n    \"text/plain\",\n    \"text/html\",\n    \"application/octet-stream\"\n  ),\n  Schema.String.pipe(\n    Schema.pattern(/^[\\w\\-]+\\/[\\w\\.\\+\\-]+$/),\n    Schema.annotations({\n      description: \"MIME type (type/subtype)\",\n    })\n  )\n).pipe(Schema.brand(\"ContentType\"))\n\ntype ContentType = typeof ContentType.Type\n\n// 2. Authorization header\nconst Authorization = Schema.String.pipe(\n  Schema.pattern(\n    /^Bearer [A-Za-z0-9\\-\\._~\\+\\/]+=*$/\n  ).pipe(\n    Schema.annotations({\n      description:\n        \"Authorization: Bearer <token>\",\n    })\n  ),\n  Schema.brand(\"Authorization\")\n)\n\ntype Authorization = typeof Authorization.Type\n\n// 3. Custom header validation\nconst CustomHeader = Schema.String.pipe(\n  Schema.minLength(1),\n  Schema.maxLength(1024),\n  Schema.filter((s) => {\n    // No control characters\n    return !s.match(/[\\x00-\\x1F\\x7F]/g)\n  }).pipe(\n    Schema.annotations({\n      description: \"Valid HTTP header value\",\n    })\n  )\n)\n\n// 4. Parse headers from request\nconst RequestHeaders = Schema.Struct({\n  \"content-type\": ContentType.pipe(Schema.optional),\n  authorization: Authorization.pipe(Schema.optional),\n  \"user-agent\": CustomHeader.pipe(Schema.optional),\n  \"x-correlation-id\": Schema.String.pipe(\n    Schema.regex(/^[a-f0-9\\-]+$/),\n    Schema.optional,\n    Schema.annotations({\n      description: \"Correlation ID (UUID format)\",\n    })\n  ),\n})\n\ntype RequestHeaders = typeof RequestHeaders.Type\n\n// 5. Validate incoming request\nconst validateRequest = (\n  raw: Record<string, string>\n) =>\n  Effect.gen(function* () {\n    const headers = yield* Schema.decodeUnknown(\n      RequestHeaders\n    )(raw).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"InvalidHeaders\" as const,\n        message: `Invalid headers: ${error.message}`,\n      }))\n    )\n\n    // Extract and use validated values\n    const contentType =\n      headers[\"content-type\"] ||\n      (\"application/json\" as ContentType)\n\n    const correlationId =\n      headers[\"x-correlation-id\"] ||\n      crypto.randomUUID()\n\n    console.log(\n      `[${correlationId}] Content-Type: ${contentType}`\n    )\n\n    // Parse auth token if present\n    if (headers.authorization) {\n      const token = headers.authorization.replace(\n        /^Bearer /,\n        \"\"\n      )\n      console.log(`Token length: ${token.length}`)\n    }\n\n    return { contentType, correlationId }\n  })\n\n// 6. Typed middleware\nconst authMiddleware = (\n  auth: Authorization | undefined\n) =>\n  Effect.gen(function* () {\n    if (!auth) {\n      return yield* Effect.fail(\n        new Error(\"Authorization header required\")\n      )\n    }\n\n    // Safe to extract token\u2014already validated format\n    const token = auth.replace(/^Bearer /, \"\")\n    return token\n  })\n\n// Usage example\nconst requestHeaders = {\n  \"content-type\": \"application/json\",\n  authorization: \"Bearer eyJhbGciOiJIUzI1NiI...\",\n  \"user-agent\": \"MyClient/1.0\",\n  \"x-correlation-id\": \"550e8400-e29b-41d4\",\n}\n\nEffect.runPromise(validateRequest(requestHeaders))\n  .then((result) => {\n    console.log(\n      `\u2705 Request validated (${result.correlationId})`\n    )\n  })\n  .catch((error) =>\n    console.error(`Error: ${error.message}`)\n  )",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "HTTP Header Validation using Schema."
            },
            "created_at": "2026-02-16T21:39:11.731707",
            "updated_at": "2026-02-20T23:09:39.119871"
        },
        {
            "id": "cba9162b-0565-40f0-9849-d6d0ebfd97ad",
            "slug": "schema-web-standards-mime-types",
            "title": "MIME Type Validation",
            "summary": "Your application accepts file uploads or specifies content types. Users submit unknown MIME types, you get files with mismatched extensions, or malicious uploads bypass checks. You need to validate...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "validation",
                "web-standards",
                "mime-types",
                "content-types",
                "file-upload"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. Define known MIME types as literals\nconst ImageMimeType = Schema.Literal(\n  \"image/jpeg\",\n  \"image/png\",\n  \"image/webp\",\n  \"image/gif\"\n)\n\ntype ImageMimeType = typeof ImageMimeType.Type\n\nconst DocumentMimeType = Schema.Literal(\n  \"application/pdf\",\n  \"text/plain\",\n  \"application/msword\",\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"\n)\n\ntype DocumentMimeType = typeof DocumentMimeType.Type\n\n// 2. Create branded MIME types\nconst ValidMimeType = Schema.Union(\n  ImageMimeType,\n  DocumentMimeType,\n  Schema.Literal(\n    \"application/json\",\n    \"text/html\",\n    \"application/xml\"\n  )\n).pipe(Schema.brand(\"ValidMimeType\"))\n\ntype ValidMimeType = typeof ValidMimeType.Type\n\n// 3. File upload schema\nconst FileUpload = Schema.Struct({\n  filename: Schema.String.pipe(\n    Schema.minLength(1),\n    Schema.maxLength(255)\n  ),\n  mimeType: ValidMimeType,\n  size: Schema.Number.pipe(\n    Schema.int(),\n    Schema.between(1, 10 * 1024 * 1024) // 10MB limit\n  ),\n})\n\ntype FileUpload = typeof FileUpload.Type\n\n// 4. Validate by extension mapping\nconst getMimeTypeFromExtension = (\n  filename: string\n): ValidMimeType | null => {\n  const ext = filename.split(\".\").pop()?.toLowerCase()\n\n  const map: Record<string, ValidMimeType> = {\n    pdf: \"application/pdf\",\n    txt: \"text/plain\",\n    json: \"application/json\",\n    html: \"text/html\",\n    xml: \"application/xml\",\n    jpg: \"image/jpeg\",\n    jpeg: \"image/jpeg\",\n    png: \"image/png\",\n    webp: \"image/webp\",\n    gif: \"image/gif\",\n  }\n\n  return map[ext || \"\"] || null\n}\n\n// 5. File handler with validation\nconst handleFileUpload = (input: unknown) =>\n  Effect.gen(function* () {\n    const file = yield* Schema.decodeUnknown(\n      FileUpload\n    )(input).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"InvalidFile\" as const,\n        message: `Invalid file: ${error.message}`,\n      }))\n    )\n\n    // Extract file info\n    const ext = file.mimeType.split(\"/\")[1]\n    console.log(\n      `Uploading ${file.filename} (${(file.size / 1024).toFixed(1)}KB, type: ${file.mimeType})`\n    )\n\n    // Type-safe operations based on MIME type\n    if (file.mimeType.startsWith(\"image/\")) {\n      console.log(\"Processing as image\")\n    } else if (file.mimeType === \"application/pdf\") {\n      console.log(\"Processing as PDF\")\n    }\n\n    return {\n      id: crypto.randomUUID(),\n      ...file,\n      uploadedAt: new Date().toISOString(),\n    }\n  })\n\n// 6. Content negotiation\nconst selectOutputFormat = (\n  accepted: string[]\n): ValidMimeType | null =>\n  Effect.gen(function* () {\n    // Validate accepted types\n    const validated = yield* Effect.all(\n      accepted.map((type) =>\n        Schema.decodeUnknown(ValidMimeType)(type).pipe(\n          Effect.catchTag(\"ParseError\", () =>\n            Effect.none()\n          )\n        )\n      )\n    )\n\n    // Return first acceptable type\n    const supported = validated.find((v) =>\n      Effect.isEffect(v) ? false : true\n    )\n    return supported || null\n  })\n\n// 7. Media type with parameters\nconst MediaTypeWithParams = Schema.String.pipe(\n  Schema.pattern(\n    /^[\\w\\-]+\\/[\\w\\.\\+\\-]+(\\s*;\\s*[\\w\\-]+\\s*=\\s*[\\w\\-]+)*$/\n  ).pipe(\n    Schema.annotations({\n      description:\n        \"MIME type with optional parameters (e.g., text/html; charset=utf-8)\",\n    })\n  ),\n  Schema.brand(\"MediaTypeWithParams\")\n)\n\ntype MediaTypeWithParams =\n  typeof MediaTypeWithParams.Type\n\nconst parseMediaType = (raw: string) =>\n  Effect.gen(function* () {\n    const media = yield* Schema.decodeUnknown(\n      MediaTypeWithParams\n    )(raw).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"InvalidMediaType\" as const,\n        message: `Invalid media type: ${error.message}`,\n      }))\n    )\n\n    // Extract base type\n    const [baseType, ...params] = media.split(\";\")\n    console.log(\n      `Base type: ${baseType.trim()}, Params: ${params.length}`\n    )\n\n    return {\n      baseType: baseType.trim(),\n      params: params.map((p) => p.trim()),\n    }\n  })\n\n// Usage\nconst uploadInput = {\n  filename: \"document.pdf\",\n  mimeType: \"application/pdf\",\n  size: 1024 * 100, // 100KB\n}\n\nEffect.runPromise(handleFileUpload(uploadInput))\n  .then((result) => {\n    console.log(`\u2705 Uploaded: ${result.id}`)\n  })\n  .catch((error) =>\n    console.error(`Error: ${error.message}`)\n  )",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "MIME Type Validation using Schema."
            },
            "created_at": "2026-02-16T21:39:11.894121",
            "updated_at": "2026-02-20T23:09:39.162391"
        },
        {
            "id": "271d4b5e-e710-4c1d-921e-d35ce6ec54ef",
            "slug": "schema-web-standards-iso-date",
            "title": "ISO 8601 Date Validation",
            "summary": "Your API accepts dates as strings from JSON. Without validation, you get malformed dates like \"2024-13-45\" or timezone-naive strings. You need to validate ISO 8601 format at runtime, ensure dates are...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "validation",
                "web-standards",
                "iso-8601",
                "dates",
                "timestamps"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. ISO 8601 datetime with timezone\nconst ISODateTime = Schema.String.pipe(\n  Schema.pattern(\n    /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{1,3})?Z?$/\n  ).pipe(\n    Schema.annotations({\n      description:\n        \"ISO 8601 datetime (YYYY-MM-DDTHH:mm:ss[.sss][Z])\",\n    })\n  ),\n  Schema.filter((s) => {\n    try {\n      const date = new Date(s)\n      // Check it parses to valid Date\n      if (isNaN(date.getTime())) {\n        return false\n      }\n      // Optional: check year is reasonable\n      const year = date.getUTCFullYear()\n      return year >= 1900 && year <= 2100\n    } catch {\n      return false\n    }\n  }).pipe(\n    Schema.annotations({\n      description: \"Valid date between 1900-2100\",\n    })\n  ),\n  Schema.brand(\"ISODateTime\")\n)\n\ntype ISODateTime = typeof ISODateTime.Type\n\n// 2. ISO 8601 date only (no time)\nconst ISODate = Schema.String.pipe(\n  Schema.pattern(/^\\d{4}-\\d{2}-\\d{2}$/).pipe(\n    Schema.annotations({\n      description: \"ISO 8601 date (YYYY-MM-DD)\",\n    })\n  ),\n  Schema.filter((s) => {\n    const date = new Date(s + \"T00:00:00Z\")\n    return !isNaN(date.getTime())\n  }),\n  Schema.brand(\"ISODate\")\n)\n\ntype ISODate = typeof ISODate.Type\n\n// 3. Use in event schema\nconst Event = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  startDate: ISODate,\n  startTime: ISODateTime,\n  endTime: ISODateTime,\n  timezone: Schema.String.pipe(\n    Schema.default(\"UTC\")\n  ),\n})\n\ntype Event = typeof Event.Type\n\n// 4. Validate and work with dates\nconst createEvent = (input: unknown) =>\n  Effect.gen(function* () {\n    const event = yield* Schema.decodeUnknown(Event)(\n      input\n    ).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ValidationError\" as const,\n        message: `Invalid event: ${error.message}`,\n      }))\n    )\n\n    // Parse validated dates\n    const startTime = new Date(event.startTime)\n    const endTime = new Date(event.endTime)\n\n    // Type-safe duration calculation\n    const durationMs =\n      endTime.getTime() - startTime.getTime()\n\n    if (durationMs <= 0) {\n      return yield* Effect.fail(\n        new Error(\"Event must end after it starts\")\n      )\n    }\n\n    console.log(\n      `Event \"${event.name}\" duration: ${(durationMs / 1000 / 60).toFixed(0)} min`\n    )\n\n    return event\n  })\n\n// 5. Filter events by date range\nconst getEventsBetween = (\n  events: Event[],\n  start: ISODate,\n  end: ISODate\n) =>\n  Effect.gen(function* () {\n    const startDate = new Date(start + \"T00:00:00Z\")\n    const endDate = new Date(\n      end + \"T23:59:59Z\"\n    )\n\n    const filtered = events.filter((event) => {\n      const eventDate = new Date(\n        event.startDate + \"T00:00:00Z\"\n      )\n      return (\n        eventDate >= startDate &&\n        eventDate <= endDate\n      )\n    })\n\n    return filtered\n  })\n\n// Usage\nconst eventInput = {\n  id: \"evt-001\",\n  name: \"Team Meeting\",\n  startDate: \"2024-12-20\",\n  startTime: \"2024-12-20T14:00:00Z\",\n  endTime: \"2024-12-20T15:30:00Z\",\n  timezone: \"America/New_York\",\n}\n\nEffect.runPromise(createEvent(eventInput))\n  .then((event) => {\n    console.log(`\u2705 Event created: ${event.name}`)\n  })\n  .catch((error) =>\n    console.error(`Error: ${error.message}`)\n  )",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "ISO 8601 Date Validation using Schema."
            },
            "created_at": "2026-02-16T21:39:12.07987",
            "updated_at": "2026-02-20T23:09:39.203457"
        },
        {
            "id": "966c6335-87aa-4f2c-910b-6876a4326cb9",
            "slug": "schema-form-async-validation",
            "title": "Async Validation (Username Availability)",
            "summary": "Some validation requires checking a server: is this username available? Is this email already registered? Standard schema validation is synchronous\u2014you can't check a database or API. You need to...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "form",
                "async",
                "validation",
                "api-check",
                "debounce"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema, Schedule } from \"effect\"\n\n// 1. Sync validation: format only\nconst Username = Schema.String.pipe(\n  Schema.minLength(3),\n  Schema.maxLength(20),\n  Schema.pattern(/^[a-zA-Z0-9_-]+$/)\n)\n\ntype Username = typeof Username.Type\n\n// 2. Async check: database lookup\nconst checkUsernameAvailable = (\n  username: Username\n): Effect.Effect<boolean, Error> =>\n  Effect.gen(function* () {\n    // Simulate API call to check availability\n    const response = yield* Effect.tryPromise({\n      try: () =>\n        fetch(\n          `/api/check-username?username=${username}`\n        ).then((r) => r.json()),\n      catch: (error) => new Error(`API failed: ${error}`),\n    })\n\n    const available = response.available === true\n\n    if (!available) {\n      return yield* Effect.fail(\n        new Error(`Username \"${username}\" is taken`)\n      )\n    }\n\n    return available\n  })\n\n// 3. Email uniqueness check\nconst checkEmailAvailable = (email: string) =>\n  Effect.gen(function* () {\n    const response = yield* Effect.tryPromise({\n      try: () =>\n        fetch(`/api/check-email?email=${email}`).then(\n          (r) => r.json()\n        ),\n      catch: (error) => new Error(`API failed: ${error}`),\n    })\n\n    if (!response.available) {\n      return yield* Effect.fail(\n        new Error(\n          `Email \"${email}\" is already registered`\n        )\n      )\n    }\n\n    return true\n  })\n\n// 4. Combined validation: sync then async\nconst validateSignUp = (input: unknown) =>\n  Effect.gen(function* () {\n    // Step 1: Sync validation\n    const syncData = yield* Schema.decodeUnknown(\n      Schema.Struct({\n        username: Username,\n        email: Schema.String.pipe(\n          Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)\n        ),\n        password: Schema.String.pipe(\n          Schema.minLength(8)\n        ),\n      })\n    )(input).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"SyncError\" as const,\n        message: `Invalid input: ${error.message}`,\n      }))\n    )\n\n    // Step 2: Async validation (in parallel)\n    const [usernameOk, emailOk] = yield* Effect.all([\n      checkUsernameAvailable(syncData.username).pipe(\n        Effect.mapError((error) => ({\n          _tag: \"UsernameError\" as const,\n          message: error.message,\n        }))\n      ),\n      checkEmailAvailable(syncData.email).pipe(\n        Effect.mapError((error) => ({\n          _tag: \"EmailError\" as const,\n          message: error.message,\n        }))\n      ),\n    ])\n\n    return { ...syncData, usernameOk, emailOk }\n  })\n\n// 5. With debounce for real-time UI checking\nconst validateUsernameRealtime = (\n  username: string\n): Effect.Effect<boolean, Error> =>\n  Effect.gen(function* () {\n    // Sync validation first\n    yield* Schema.decodeUnknown(Username)(\n      username\n    ).pipe(\n      Effect.mapError((error) =>\n        new Error(`Invalid format: ${error.message}`)\n      )\n    )\n\n    // Debounce async check: wait 500ms before API call\n    yield* Effect.sleep(\"500 millis\")\n\n    // Async availability check\n    const available = yield* checkUsernameAvailable(\n      username as Username\n    )\n\n    return available\n  })\n\n// 6. Usage\nconst signupData = {\n  username: \"alice_123\",\n  email: \"alice@example.com\",\n  password: \"securepass123\",\n}\n\nEffect.runPromise(validateSignUp(signupData))\n  .then((result) => {\n    console.log(\"\u2705 Sign up valid!\")\n    console.log(result)\n  })\n  .catch((error) => {\n    console.error(`\u274c Validation failed:`, error.message)\n  })\n\n// 7. Real-time checking with debounce\nconst checkUsernameField = (username: string) =>\n  validateUsernameRealtime(username)\n    .pipe(\n      Effect.timeout(\"2 seconds\"), // Timeout if API is slow\n      Effect.match({\n        onSuccess: (available) => ({\n          valid: available,\n          message: \"Username available!\",\n        }),\n        onFailure: (error) => ({\n          valid: false,\n          message: error.message,\n        }),\n      })\n    )\n    .pipe(Effect.runPromise)\n\n// Triggered on user input after 500ms of inactivity\nexport const onUsernameChange = (value: string) => {\n  checkUsernameField(value).then((result) => {\n    console.log(result)\n    // Update UI with result\n  })\n}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Async Validation (Username Availability) using Schema."
            },
            "created_at": "2026-02-16T21:39:13.277627",
            "updated_at": "2026-02-20T23:09:39.510485"
        },
        {
            "id": "b2f80db9-f31b-453e-a309-43ff15bbad4b",
            "slug": "schema-hello-world",
            "title": "Your First Schema",
            "summary": "You have unknown data\u2014from an API, form, or file\u2014and need to validate it has the right shape. Without schema validation, your code assumes data is correct and crashes later with cryptic errors. You...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "getting-started",
                "basics",
                "introduction"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// Define what a valid User looks like\nconst User = Schema.Struct({\n  name: Schema.String,\n  age: Schema.Number,\n  email: Schema.String,\n})\n\n// Get the TypeScript type automatically\ntype User = typeof User.Type\n\n// Decode unknown data into a typed User\nconst decode = Schema.decodeUnknownSync(User)\n\n// Valid data \u2192 typed User\nconst validData = {\n  name: \"Alice\",\n  age: 30,\n  email: \"alice@example.com\"\n}\n\nconst user = decode(validData)\nconsole.log(`\u2705 Valid user: ${user.name}, age ${user.age}`)\n// Output: \u2705 Valid user: Alice, age 30\n\n// Invalid data \u2192 throws ParseError\ntry {\n  const invalidData = {\n    name: \"Bob\",\n    age: \"not a number\",  // Wrong type!\n    email: \"bob@example.com\"\n  }\n  decode(invalidData)\n} catch (error) {\n  console.log(`\u274c Invalid: age must be a number`)\n}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Your First Schema."
            },
            "created_at": "2026-02-16T21:39:08.616294",
            "updated_at": "2026-02-20T23:09:38.28909"
        },
        {
            "id": "659c3d4b-2ee0-4143-b7f9-f46921ecab4c",
            "slug": "schema-basic-objects",
            "title": "Basic Object Schemas",
            "summary": "Most real data is objects with named fields. You need to define the expected shape, validate each field has the right type, and get a typed result. Without schema validation, you access properties...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "object",
                "struct",
                "basics"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// ============================================\n// BASIC STRUCT DEFINITION\n// ============================================\n\nconst User = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  age: Schema.Number,\n  isActive: Schema.Boolean,\n})\n\n// Extract TypeScript type\ntype User = typeof User.Type\n\n// Decode unknown data\nconst decode = Schema.decodeUnknownSync(User)\n\nconst user = decode({\n  id: \"user_123\",\n  name: \"Alice\",\n  age: 30,\n  isActive: true,\n})\n\nconsole.log(`\u2705 ${user.name}, age ${user.age}`)\n\n// ============================================\n// MULTIPLE STRUCTS\n// ============================================\n\nconst Address = Schema.Struct({\n  street: Schema.String,\n  city: Schema.String,\n  zipCode: Schema.String,\n  country: Schema.String,\n})\n\nconst Product = Schema.Struct({\n  sku: Schema.String,\n  name: Schema.String,\n  price: Schema.Number,\n  inStock: Schema.Boolean,\n})\n\nconst Order = Schema.Struct({\n  orderId: Schema.String,\n  total: Schema.Number,\n  itemCount: Schema.Number,\n})\n\ntype Address = typeof Address.Type\ntype Product = typeof Product.Type\ntype Order = typeof Order.Type\n\n// ============================================\n// VALIDATION IN ACTION\n// ============================================\n\nconst decodeAddress = Schema.decodeUnknownSync(Address)\nconst decodeProduct = Schema.decodeUnknownSync(Product)\n\n// Valid address\nconst address = decodeAddress({\n  street: \"123 Main St\",\n  city: \"Springfield\",\n  zipCode: \"12345\",\n  country: \"USA\",\n})\nconsole.log(`\u2705 ${address.city}, ${address.country}`)\n\n// Valid product\nconst product = decodeProduct({\n  sku: \"WIDGET-001\",\n  name: \"Super Widget\",\n  price: 29.99,\n  inStock: true,\n})\nconsole.log(`\u2705 ${product.name}: $${product.price}`)\n\n// Invalid - missing field\ntry {\n  decodeAddress({\n    street: \"123 Main St\",\n    city: \"Springfield\",\n    // Missing zipCode and country!\n  })\n} catch {\n  console.log(\"\u274c Missing required fields\")\n}\n\n// Invalid - wrong type\ntry {\n  decodeProduct({\n    sku: \"WIDGET-001\",\n    name: \"Super Widget\",\n    price: \"twenty-nine\",  // Should be number!\n    inStock: true,\n  })\n} catch {\n  console.log(\"\u274c Price must be a number\")\n}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Basic Object Schemas."
            },
            "created_at": "2026-02-16T21:39:10.681673",
            "updated_at": "2026-02-20T23:09:38.849345"
        },
        {
            "id": "aabd133d-ce85-471a-8e60-c1f6bd071c15",
            "slug": "schema-form-dependent-fields",
            "title": "Dependent Field Validation",
            "summary": "Form fields depend on each other: password must match confirmation, checkout address must match billing address, date range end must be after start. Standard field-by-field validation can't check...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "form",
                "validation",
                "cross-field",
                "conditional",
                "refinement"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. Define form with dependent fields\nconst PasswordChangeForm = Schema.Struct({\n  currentPassword: Schema.String.pipe(\n    Schema.minLength(1)\n  ),\n  newPassword: Schema.String.pipe(\n    Schema.minLength(8)\n  ),\n  confirmPassword: Schema.String,\n}).pipe(\n  Schema.refine(\n    (form) => form.newPassword === form.confirmPassword,\n    {\n      message: \"Passwords do not match\",\n    }\n  )\n)\n\ntype PasswordChangeForm = typeof PasswordChangeForm.Type\n\n// 2. Complex: Conditional fields\nconst RegistrationForm = Schema.Struct({\n  country: Schema.String,\n  state: Schema.String.pipe(Schema.optional),\n  zipCode: Schema.String.pipe(Schema.optional),\n}).pipe(\n  Schema.refine((form) => {\n    // If country is US, state and zipCode are required\n    if (form.country === \"US\") {\n      return (\n        form.state !== undefined &&\n        form.state.length > 0 &&\n        form.zipCode !== undefined &&\n        form.zipCode.length > 0\n      )\n    }\n    return true\n  }, {\n    message:\n      \"US addresses require state and zip code\",\n  })\n)\n\ntype RegistrationForm = typeof RegistrationForm.Type\n\n// 3. Date range validation\nconst EventForm = Schema.Struct({\n  name: Schema.String,\n  startDate: Schema.String.pipe(\n    Schema.pattern(/^\\d{4}-\\d{2}-\\d{2}$/)\n  ),\n  endDate: Schema.String.pipe(\n    Schema.pattern(/^\\d{4}-\\d{2}-\\d{2}$/)\n  ),\n}).pipe(\n  Schema.refine((form) => {\n    const start = new Date(form.startDate)\n    const end = new Date(form.endDate)\n    return end > start\n  }, {\n    message: \"End date must be after start date\",\n  })\n)\n\ntype EventForm = typeof EventForm.Type\n\n// 4. Validate with field-specific error handling\nconst validatePasswordChange = (input: unknown) =>\n  Effect.gen(function* () {\n    const result = yield* Schema.decodeUnknown(\n      PasswordChangeForm\n    )(input).pipe(\n      Effect.matchEffect({\n        onSuccess: (form) =>\n          Effect.succeed({ success: true, form }),\n        onFailure: (error) => {\n          // Extract top-level refinement error\n          const messages = error.errors\n            .filter((e: any) => e._tag === \"Refinement\")\n            .map((e: any) => e.message)\n\n          return Effect.succeed({\n            success: false,\n            errors: messages,\n          })\n        },\n      })\n    )\n\n    return result\n  })\n\n// 5. Usage: Password form\nconst passwordData = {\n  currentPassword: \"oldpass123\",\n  newPassword: \"newpass456\",\n  confirmPassword: \"differentpass\", // Mismatch!\n}\n\nEffect.runPromise(validatePasswordChange(passwordData))\n  .then((result) => {\n    if (result.success) {\n      console.log(\"\u2705 Passwords match!\")\n    } else {\n      console.error(\"\u274c Errors:\", result.errors)\n    }\n  })\n\n// 6. Usage: Event form with date validation\nconst eventData = {\n  name: \"Conference 2024\",\n  startDate: \"2024-06-15\",\n  endDate: \"2024-06-10\", // Before start!\n}\n\nEffect.runPromise(\n  Schema.decodeUnknown(EventForm)(eventData)\n).catch((error) => {\n  console.error(\"Date error:\", error.message)\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Dependent Field Validation using Schema."
            },
            "created_at": "2026-02-16T21:39:12.751769",
            "updated_at": "2026-02-20T23:09:39.373654"
        },
        {
            "id": "86df4fa1-e6d7-4c9b-8789-96f098ac3057",
            "slug": "schema-form-nested-forms",
            "title": "Nested Form Structures",
            "summary": "Complex forms have nested data: a user form with multiple addresses, an order with line items, a profile with emergency contacts. These nested structures need validation at each level\u2014addresses must...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "form",
                "validation",
                "nested",
                "composition",
                "arrays"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. Define reusable sub-schemas\nconst Address = Schema.Struct({\n  street: Schema.String.pipe(Schema.minLength(1)),\n  city: Schema.String.pipe(Schema.minLength(1)),\n  state: Schema.String.pipe(Schema.length(2)),\n  zipCode: Schema.String.pipe(\n    Schema.pattern(/^\\d{5}(-\\d{4})?$/)\n  ),\n})\n\ntype Address = typeof Address.Type\n\nconst LineItem = Schema.Struct({\n  productId: Schema.String,\n  quantity: Schema.Number.pipe(\n    Schema.int(),\n    Schema.positive()\n  ),\n  price: Schema.Number.pipe(Schema.positive()),\n})\n\ntype LineItem = typeof LineItem.Type\n\n// 2. Compose into higher-level schemas\nconst Order = Schema.Struct({\n  orderId: Schema.String,\n  customer: Schema.Struct({\n    name: Schema.String,\n    email: Schema.String,\n    billingAddress: Address,\n    shippingAddress: Address,\n  }),\n  items: Schema.Array(LineItem).pipe(\n    Schema.minItems(1),\n    Schema.annotations({\n      description: \"Order must have at least one item\",\n    })\n  ),\n  total: Schema.Number.pipe(Schema.positive()),\n})\n\ntype Order = typeof Order.Type\n\n// 3. Validate entire nested structure\nconst validateOrder = (input: unknown) =>\n  Effect.gen(function* () {\n    const order = yield* Schema.decodeUnknown(Order)(\n      input\n    ).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ValidationError\" as const,\n        message: `Invalid order: ${error.message}`,\n      }))\n    )\n\n    // Additional cross-validation\n    const itemTotal = order.items.reduce(\n      (sum, item) => sum + item.quantity * item.price,\n      0\n    )\n\n    if (Math.abs(itemTotal - order.total) > 0.01) {\n      return yield* Effect.fail({\n        _tag: \"CalculationError\" as const,\n        message: `Total mismatch: expected ${itemTotal}, got ${order.total}`,\n      })\n    }\n\n    return order\n  })\n\n// 4. Handle nested array validation\nconst UserProfile = Schema.Struct({\n  username: Schema.String,\n  email: Schema.String,\n  addresses: Schema.Array(Address).pipe(\n    Schema.minItems(1),\n    Schema.maxItems(5)\n  ),\n  emergencyContacts: Schema.Array(\n    Schema.Struct({\n      name: Schema.String,\n      phone: Schema.String.pipe(\n        Schema.pattern(/^\\d{10}$/)\n      ),\n      relationship: Schema.Literal(\n        \"spouse\",\n        \"parent\",\n        \"sibling\",\n        \"other\"\n      ),\n    })\n  ).pipe(Schema.optional),\n})\n\ntype UserProfile = typeof UserProfile.Type\n\n// 5. Format nested errors for UI\nconst flattenErrors = (error: any, prefix = \"\"): Record<string, string> => {\n  const errors: Record<string, string> = {}\n\n  for (const e of error.errors || []) {\n    const path = [...(e.path || [])].join(\".\")\n    const key = prefix ? `${prefix}.${path}` : path\n    errors[key] = e.message || \"Validation failed\"\n  }\n\n  return errors\n}\n\n// 6. Usage: Order validation\nconst orderData = {\n  orderId: \"ORD-001\",\n  customer: {\n    name: \"Alice Smith\",\n    email: \"alice@example.com\",\n    billingAddress: {\n      street: \"123 Main St\",\n      city: \"Springfield\",\n      state: \"IL\",\n      zipCode: \"62701\",\n    },\n    shippingAddress: {\n      street: \"456 Oak Ave\",\n      city: \"Chicago\",\n      state: \"IL\",\n      zipCode: \"60601-1234\",\n    },\n  },\n  items: [\n    { productId: \"PROD-1\", quantity: 2, price: 29.99 },\n    { productId: \"PROD-2\", quantity: 1, price: 49.99 },\n  ],\n  total: 109.97,\n}\n\nEffect.runPromise(validateOrder(orderData))\n  .then((order) => {\n    console.log(\n      `\u2705 Order ${order.orderId} valid!`\n    )\n    console.log(\n      `  Shipping to: ${order.customer.shippingAddress.city}`\n    )\n  })\n  .catch((error) => {\n    console.error(`\u274c Error:`, error.message)\n  })",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Nested Form Structures using Schema."
            },
            "created_at": "2026-02-16T21:39:12.940692",
            "updated_at": "2026-02-20T23:09:39.410769"
        },
        {
            "id": "e0c1c59a-c484-4e4e-b8c5-ae5252fe5cee",
            "slug": "schema-form-collect-all-errors",
            "title": "Collecting All Validation Errors",
            "summary": "Standard validation stops at the first error: \"Username is required\". But users want to see ALL problems at once\u2014missing fields, invalid formats, out-of-range values. Showing one error at a time...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "form",
                "validation",
                "error-handling",
                "user-experience"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect, ParseResult } from \"effect\"\n\n// 1. Define form with multiple fields\nconst RegistrationForm = Schema.Struct({\n  firstName: Schema.String.pipe(Schema.minLength(1)),\n  lastName: Schema.String.pipe(Schema.minLength(1)),\n  email: Schema.String.pipe(\n    Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)\n  ),\n  phone: Schema.String.pipe(\n    Schema.pattern(/^\\d{10}$/)\n  ),\n  age: Schema.Number.pipe(Schema.between(18, 120)),\n  terms: Schema.Boolean.pipe(\n    Schema.refine((b) => b === true, {\n      message: \"You must accept terms\",\n    })\n  ),\n})\n\ntype RegistrationForm = typeof RegistrationForm.Type\n\n// 2. Collect all errors\nconst validateWithAllErrors = (input: unknown) =>\n  Effect.gen(function* () {\n    const result = yield* Schema.decodeUnknown(\n      RegistrationForm\n    )(input).pipe(\n      Effect.matchEffect({\n        onSuccess: (form) =>\n          Effect.succeed({ success: true, form }),\n        onFailure: (error) => {\n          // Extract all error details\n          const errors = error.errors.flatMap((e: any) => {\n            if (e._tag === \"Type\") {\n              return [\n                {\n                  field: e.path.join(\".\"),\n                  message: `Invalid type for ${e.path.join(\".\")}`,\n                },\n              ]\n            }\n            if (e._tag === \"Refinement\") {\n              return [\n                {\n                  field: e.path.join(\".\") || \"root\",\n                  message:\n                    e.message ||\n                    `Refinement failed for ${e.path.join(\".\")}`,\n                },\n              ]\n            }\n            return []\n          })\n\n          return Effect.succeed({\n            success: false,\n            errors,\n          })\n        },\n      })\n    )\n\n    return result\n  })\n\n// 3. Format errors by field\nconst formatErrorsByField = (errors: Array<any>) => {\n  const byField: Record<string, string[]> = {}\n\n  for (const error of errors) {\n    const field = error.field || \"general\"\n    if (!byField[field]) {\n      byField[field] = []\n    }\n    byField[field].push(error.message)\n  }\n\n  return byField\n}\n\n// 4. Handle form submission\nconst submitRegistration = (formData: unknown) =>\n  Effect.gen(function* () {\n    const result = yield* validateWithAllErrors(formData)\n\n    if (result.success) {\n      console.log(\"\u2705 Form valid!\")\n      return result.form\n    }\n\n    // Format errors for display\n    const errorsByField = formatErrorsByField(\n      result.errors\n    )\n\n    console.error(\"\u274c Form has errors:\")\n    for (const [field, messages] of Object.entries(\n      errorsByField\n    )) {\n      console.error(`  ${field}: ${messages.join(\", \")}`)\n    }\n\n    return yield* Effect.fail({\n      _tag: \"FormValidationError\" as const,\n      errorsByField,\n    })\n  })\n\n// 5. Usage with invalid data\nconst badData = {\n  firstName: \"\", // Empty\n  lastName: \"\", // Empty\n  email: \"not-an-email\", // Invalid format\n  phone: \"123\", // Wrong length\n  age: 15, // Too young\n  terms: false, // Not accepted\n}\n\nEffect.runPromise(submitRegistration(badData))\n  .then((form) => console.log(\"Form submitted:\", form))\n  .catch((error) => {\n    if (error._tag === \"FormValidationError\") {\n      // Pass errorsByField to UI component for rendering\n      console.log(\"Errors to display:\", error.errorsByField)\n    }\n  })",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Collecting All Validation Errors using Schema."
            },
            "created_at": "2026-02-16T21:39:13.112354",
            "updated_at": "2026-02-20T23:09:39.46006"
        },
        {
            "id": "0692ed27-8bf5-4228-bc8b-5e4277e577b6",
            "slug": "schema-nested-comments",
            "title": "Nested Comments and Threaded Discussions",
            "summary": "Reddit, HN, YouTube\u2014all have nested comment threads. A comment can have replies, which have replies. Users expect arbitrary nesting depth. Without recursive schemas, you'd store flat comments and...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "recursive",
                "comments",
                "threading",
                "discussions",
                "social"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Comment schema with replies\n// ============================================\n\ntype Comment = {\n  id: string\n  author: {\n    username: string\n    avatar: string\n    karma: number\n  }\n  content: string\n  createdAt: Date\n  score: number\n  edited?: Date\n  replies: Comment[]\n}\n\nconst Comment: Schema.Schema<Comment> = Schema.suspend(() =>\n  Schema.Struct({\n    id: Schema.String,\n    author: Schema.Struct({\n      username: Schema.String,\n      avatar: Schema.String,\n      karma: Schema.Number,\n    }),\n    content: Schema.String,\n    createdAt: Schema.Date,\n    score: Schema.Number,\n    edited: Schema.Optional(Schema.Date),\n    replies: Schema.Array(Comment),\n  })\n)\n\n// ============================================\n// 2. Thread with comments\n// ============================================\n\ntype CommentThread = {\n  postId: string\n  title: string\n  author: string\n  content: string\n  createdAt: Date\n  commentCount: number\n  topComments: Comment[]\n}\n\nconst CommentThread = Schema.Struct({\n  postId: Schema.String,\n  title: Schema.String,\n  author: Schema.String,\n  content: Schema.String,\n  createdAt: Schema.Date,\n  commentCount: Schema.Number,\n  topComments: Schema.Array(Comment),\n})\n\ntype CommentThread = typeof CommentThread.Type\n\n// ============================================\n// 3. Utilities for comment trees\n// ============================================\n\nconst countComments = (comment: Comment): number => {\n  return 1 + comment.replies.reduce((sum, reply) => sum + countComments(reply), 0)\n}\n\nconst getMaxDepth = (comment: Comment, depth: number = 0): number => {\n  if (comment.replies.length === 0) return depth\n  return Math.max(...comment.replies.map((r) => getMaxDepth(r, depth + 1)))\n}\n\nconst flattenComments = (comment: Comment): Comment[] => {\n  return [comment, ...comment.replies.flatMap(flattenComments)]\n}\n\nconst filterComments = (\n  comment: Comment,\n  predicate: (c: Comment) => boolean\n): Comment | null => {\n  if (!predicate(comment)) return null\n\n  const filteredReplies = comment.replies\n    .map((reply) => filterComments(reply, predicate))\n    .filter((r): r is Comment => r !== null)\n\n  return { ...comment, replies: filteredReplies }\n}\n\nconst sortCommentTree = (\n  comment: Comment,\n  compareFn: (a: Comment, b: Comment) => number\n): Comment => {\n  return {\n    ...comment,\n    replies: comment.replies\n      .map((reply) => sortCommentTree(reply, compareFn))\n      .sort(compareFn),\n  }\n}\n\n// ============================================\n// 4. Rendering utilities\n// ============================================\n\nconst renderCommentThread = (\n  comment: Comment,\n  depth: number = 0\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    const indent = \"  \".repeat(depth)\n    const score = comment.score > 0 ? `\u2b06 ${comment.score}` : `\u2b07 ${Math.abs(comment.score)}`\n\n    yield* Effect.log(`${indent}\ud83d\udc64 ${comment.author.username} ${score}`)\n    yield* Effect.log(`${indent}   ${comment.content}`)\n\n    if (comment.edited) {\n      yield* Effect.log(`${indent}   (edited)`)\n    }\n\n    if (comment.replies.length > 0) {\n      for (const reply of comment.replies) {\n        yield* renderCommentThread(reply, depth + 1)\n      }\n    }\n  })\n\nconst summarizeThread = (\n  thread: CommentThread\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`\ud83d\udcdd ${thread.title}`)\n    yield* Effect.log(`By ${thread.author}`)\n    yield* Effect.log(`\\n${thread.content}\\n`)\n\n    let totalComments = 0\n    let maxDepth = 0\n\n    for (const topComment of thread.topComments) {\n      totalComments += countComments(topComment)\n      maxDepth = Math.max(maxDepth, getMaxDepth(topComment))\n    }\n\n    yield* Effect.log(`Comments: ${totalComments}`)\n    yield* Effect.log(`Max nesting depth: ${maxDepth}`)\n  })\n\n// ============================================\n// 5. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Comment Thread Example ===\\n\")\n\n  const thread: CommentThread = {\n    postId: \"post_123\",\n    title: \"Effect-TS: The Future of Functional Programming\",\n    author: \"alice_dev\",\n    content:\n      \"I've been using Effect-TS for 6 months now and it's transformed how I write TypeScript. Here are my thoughts...\",\n    createdAt: new Date(\"2025-12-15\"),\n    commentCount: 27,\n    topComments: [\n      {\n        id: \"comment_1\",\n        author: {\n          username: \"bob_coder\",\n          avatar: \"https://example.com/bob.png\",\n          karma: 1250,\n        },\n        content: \"Great writeup! Have you tried it with databases?\",\n        createdAt: new Date(\"2025-12-15T10:00:00Z\"),\n        score: 42,\n        replies: [\n          {\n            id: \"comment_1_1\",\n            author: {\n              username: \"alice_dev\",\n              avatar: \"https://example.com/alice.png\",\n              karma: 3100,\n            },\n            content:\n              \"Yes! We built a data pipeline that handles 1M records. Effect made error handling trivial.\",\n            createdAt: new Date(\"2025-12-15T11:30:00Z\"),\n            score: 38,\n            edited: new Date(\"2025-12-15T11:45:00Z\"),\n            replies: [\n              {\n                id: \"comment_1_1_1\",\n                author: {\n                  username: \"carol_async\",\n                  avatar: \"https://example.com/carol.png\",\n                  karma: 892,\n                },\n                content:\n                  \"This is exactly what we need for our microservices!\",\n                createdAt: new Date(\"2025-12-15T14:00:00Z\"),\n                score: 12,\n                replies: [],\n              },\n            ],\n          },\n          {\n            id: \"comment_1_2\",\n            author: {\n              username: \"david_fp\",\n              avatar: \"https://example.com/david.png\",\n              karma: 2100,\n            },\n            content:\n              \"How does it compare to Railway.js? I'm trying to decide between the two.\",\n            createdAt: new Date(\"2025-12-15T12:00:00Z\"),\n            score: 25,\n            replies: [],\n          },\n        ],\n      },\n      {\n        id: \"comment_2\",\n        author: {\n          username: \"eve_rust\",\n          avatar: \"https://example.com/eve.png\",\n          karma: 850,\n        },\n        content: \"Interesting, but seems complex for simple projects.\",\n        createdAt: new Date(\"2025-12-15T10:30:00Z\"),\n        score: 8,\n        replies: [\n          {\n            id: \"comment_2_1\",\n            author: {\n              username: \"alice_dev\",\n              avatar: \"https://example.com/alice.png\",\n              karma: 3100,\n            },\n            content:\n              \"True, but the complexity pays off as projects grow. Start simple and scale.\",\n            createdAt: new Date(\"2025-12-15T11:00:00Z\"),\n            score: 20,\n            replies: [],\n          },\n        ],\n      },\n    ],\n  }\n\n  // Render thread\n  yield* summarizeThread(thread)\n\n  console.log(\"\\n--- Comments ---\\n\")\n\n  for (const comment of thread.topComments) {\n    yield* renderCommentThread(comment)\n    yield* Effect.log(\"\")\n  }\n\n  // Statistics\n  console.log(\"=== Statistics ===\\n\")\n\n  let totalComments = 0\n  let maxDepth = 0\n  let totalScore = 0\n\n  for (const comment of thread.topComments) {\n    const allComments = flattenComments(comment)\n    totalComments += allComments.length\n    totalScore += allComments.reduce((sum, c) => sum + c.score, 0)\n    maxDepth = Math.max(maxDepth, getMaxDepth(comment))\n  }\n\n  console.log(`Total comments in thread: ${totalComments}`)\n  console.log(`Maximum nesting depth: ${maxDepth}`)\n  console.log(`Total upvotes: ${totalScore}`)\n\n  // Filter high-karma comments\n  console.log(\"\\n=== High-Karma Comments (1000+) ===\\n\")\n\n  const allComments = thread.topComments.flatMap(flattenComments)\n  const highKarma = allComments\n    .filter((c) => c.author.karma >= 1000)\n    .sort((a, b) => b.author.karma - a.author.karma)\n\n  for (const comment of highKarma) {\n    console.log(\n      `${comment.author.username} (${comment.author.karma}): ${comment.content.substring(0, 60)}...`\n    )\n  }\n\n  return thread\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Comment threading complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Nested Comments and Threaded Discussions using Schema."
            },
            "created_at": "2026-02-16T21:39:11.195304",
            "updated_at": "2026-02-20T23:09:39.00047"
        },
        {
            "id": "53f6f589-5076-4ae1-a3cb-0178e0d4710f",
            "slug": "schema-branded-types",
            "title": "Branded Types for Type-Safe IDs and Strings",
            "summary": "Your domain has user IDs, product IDs, email addresses. They're all strings at runtime, but they mean different things. A function accepting `string` could receive any string\u2014wrong ID format, email...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "branded-types",
                "type-safety",
                "validation",
                "domain-types",
                "ids"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. Define branded types with validation\nconst UserId = Schema.String.pipe(\n  Schema.minLength(1),\n  Schema.pattern(/^user_[a-z0-9]{12}$/),\n  Schema.brand(\"UserId\")\n)\n\ntype UserId = typeof UserId.Type\n\nconst ProductId = Schema.String.pipe(\n  Schema.minLength(1),\n  Schema.pattern(/^prod_[a-z0-9]{12}$/),\n  Schema.brand(\"ProductId\")\n)\n\ntype ProductId = typeof ProductId.Type\n\n// 2. Email branded type\nconst Email = Schema.String.pipe(\n  Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/),\n  Schema.brand(\"Email\")\n)\n\ntype Email = typeof Email.Type\n\n// 3. UUID branded type\nconst UUID = Schema.String.pipe(\n  Schema.pattern(\n    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n  ),\n  Schema.brand(\"UUID\")\n)\n\ntype UUID = typeof UUID.Type\n\n// 4. Positive integer branded type\nconst PositiveInt = Schema.Number.pipe(\n  Schema.int(),\n  Schema.greaterThan(0),\n  Schema.brand(\"PositiveInt\")\n)\n\ntype PositiveInt = typeof PositiveInt.Type\n\n// 5. Slug branded type (URL-safe string)\nconst Slug = Schema.String.pipe(\n  Schema.pattern(/^[a-z0-9]+(?:-[a-z0-9]+)*$/),\n  Schema.maxLength(50),\n  Schema.brand(\"Slug\")\n)\n\ntype Slug = typeof Slug.Type\n\n// 6. Define domain model using branded types\nconst User = Schema.Struct({\n  id: UserId,\n  email: Email,\n  name: Schema.String,\n})\n\ntype User = typeof User.Type\n\nconst Product = Schema.Struct({\n  id: ProductId,\n  slug: Slug,\n  sku: Schema.String.pipe(Schema.brand(\"SKU\")),\n  price: PositiveInt,\n})\n\ntype Product = typeof Product.Type\n\n// 7. Create validators\nconst validateUserId = Schema.decodeUnknown(UserId)\nconst validateEmail = Schema.decodeUnknown(Email)\nconst validateUUID = Schema.decodeUnknown(UUID)\nconst validateUser = Schema.decodeUnknown(User)\nconst validateProduct = Schema.decodeUnknown(Product)\n\n// 8. Database access with branded types\nclass UserRepository {\n  // Type-safe: only accepts UserId\n  async findById(id: UserId): Promise<User | null> {\n    console.log(`Fetching user with ID: ${id}`)\n    // Simulate database query\n    return {\n      id,\n      email: \"alice@example.com\" as Email,\n      name: \"Alice\",\n    }\n  }\n\n  async findByEmail(email: Email): Promise<User | null> {\n    console.log(`Fetching user with email: ${email}`)\n    return null\n  }\n\n  async create(data: { email: Email; name: string }): Promise<User> {\n    console.log(`Creating user: ${data.email}`)\n    return {\n      id: \"user_abc123def456\" as UserId,\n      email: data.email,\n      name: data.name,\n    }\n  }\n}\n\n// 9. Functions that enforce branded type contracts\nconst sendWelcomeEmail = (email: Email): Effect.Effect<void> =>\n  Effect.sync(() => {\n    console.log(`\ud83d\udce7 Sending welcome email to ${email}`)\n  })\n\nconst logUserAccess = (userId: UserId, action: string): Effect.Effect<void> =>\n  Effect.sync(() => {\n    console.log(`\ud83d\udd10 User ${userId} performed action: ${action}`)\n  })\n\n// 10. Application logic\nconst appLogic = Effect.gen(function* () {\n  const repo = new UserRepository()\n\n  // Parse and validate raw input\n  const userId = yield* Effect.tryPromise({\n    try: () => validateUserId(\"user_xyz789abc123\"),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Invalid user ID: ${msg}`)\n    },\n  })\n\n  // Parse email\n  const email = yield* Effect.tryPromise({\n    try: () => validateEmail(\"alice@example.com\"),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Invalid email: ${msg}`)\n    },\n  })\n\n  // Type-safe: email cannot be passed where userId is expected\n  yield* logUserAccess(userId, \"login\")\n\n  // Type-safe: userId cannot be passed where email is expected\n  yield* sendWelcomeEmail(email)\n\n  // Fetch user (only accepts valid UserId)\n  const user = yield* Effect.promise(() => repo.findById(userId))\n\n  if (user) {\n    console.log(`\u2705 Found user: ${user.name}`)\n  }\n\n  // Parse product data\n  const product = yield* Effect.tryPromise({\n    try: () =>\n      validateProduct({\n        id: \"prod_sku789def123\",\n        slug: \"awesome-product\",\n        sku: \"SKU-12345\",\n        price: 9999,\n      }),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Invalid product: ${msg}`)\n    },\n  })\n\n  console.log(`\\n\u2705 Product loaded: ${product.id} (slug: ${product.slug})`)\n\n  return { userId, email, user, product }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then((data) => {\n    console.log(\"\\n\u2705 Application completed\")\n  })\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Branded Types for Type-Safe IDs and Strings using Schema."
            },
            "created_at": "2026-02-16T21:39:13.80195",
            "updated_at": "2026-02-20T23:09:39.641924"
        },
        {
            "id": "2ccf49c0-1122-4dfb-b8aa-013f523f6ff7",
            "slug": "schema-basic-transforms",
            "title": "Basic Schema Transformations",
            "summary": "Your application receives data in one shape but needs it in another. API returns a Unix timestamp; your domain uses Date objects. Form input arrives as strings; you need typed numbers. Database...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "transform",
                "data-mapping",
                "conversion",
                "type-casting"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. Basic string-to-number transformation\nconst StringToNumber = Schema.transform(\n  Schema.String,\n  Schema.Number,\n  {\n    decode: (input) => {\n      const num = Number(input)\n      if (isNaN(num)) {\n        throw new Error(`Invalid number: ${input}`)\n      }\n      return num\n    },\n    encode: (num) => String(num),\n  }\n)\n\n// 2. Unix timestamp to Date transformation\nconst UnixTimestamp = Schema.transform(\n  Schema.Number,\n  Schema.Date,\n  {\n    decode: (timestamp) => new Date(timestamp * 1000),\n    encode: (date) => Math.floor(date.getTime() / 1000),\n  }\n)\n\n// 3. ISO date string to Date transformation\nconst ISODateString = Schema.transform(\n  Schema.String,\n  Schema.Date,\n  {\n    decode: (input) => {\n      const date = new Date(input)\n      if (isNaN(date.getTime())) {\n        throw new Error(`Invalid ISO date: ${input}`)\n      }\n      return date\n    },\n    encode: (date) => date.toISOString(),\n  }\n)\n\n// 4. Trimmed string transformation\nconst Trimmed = Schema.transform(\n  Schema.String,\n  Schema.String,\n  {\n    decode: (input) => input.trim(),\n    encode: (output) => output, // Already trimmed\n  }\n)\n\n// 5. Uppercase transformation\nconst Uppercase = Schema.transform(\n  Schema.String,\n  Schema.String,\n  {\n    decode: (input) => input.toUpperCase(),\n    encode: (output) => output,\n  }\n)\n\n// 6. Define a user form with transformations\nconst UserFormInput = Schema.Struct({\n  name: Trimmed,\n  age: StringToNumber,\n  country: Uppercase,\n  registeredAt: UnixTimestamp,\n})\n\ntype UserFormInput = typeof UserFormInput.Type\n\n// Decoded type (after transformations)\ntype User = {\n  name: string\n  age: number\n  country: string\n  registeredAt: Date\n}\n\n// 7. Create decoder and encoder\nconst decodeUserForm = Schema.decodeUnknown(UserFormInput)\nconst encodeUserForm = Schema.encode(UserFormInput)\n\n// 8. Apply transformations in effect\nconst processUserForm = (rawInput: unknown) =>\n  Effect.gen(function* () {\n    // Decode: raw input \u2192 transformed data\n    const user = yield* Effect.tryPromise({\n      try: () => decodeUserForm(rawInput),\n      catch: (error) => {\n        const msg = error instanceof Error ? error.message : String(error)\n        return new Error(`Form validation failed: ${msg}`)\n      },\n    })\n\n    console.log(`\u2705 Decoded user:`, {\n      name: user.name,\n      age: user.age,\n      country: user.country,\n      registeredAt: user.registeredAt.toISOString(),\n    })\n\n    // Business logic on transformed data\n    const yearsSinceRegistration = Math.floor(\n      (Date.now() - user.registeredAt.getTime()) / (365.25 * 24 * 60 * 60 * 1000)\n    )\n\n    console.log(`Years since registration: ${yearsSinceRegistration}`)\n\n    // Encode: transformed data \u2192 raw output (if needed for storage)\n    const encodedUser = yield* Effect.tryPromise({\n      try: () => encodeUserForm(user),\n      catch: (error) => {\n        const msg = error instanceof Error ? error.message : String(error)\n        return new Error(`Encoding failed: ${msg}`)\n      },\n    })\n\n    console.log(`\u2705 Encoded back:`, encodedUser)\n\n    return user\n  })\n\n// Usage\nconst rawFormData = {\n  name: \"  alice smith  \",\n  age: \"28\",\n  country: \"usa\",\n  registeredAt: 1609459200, // Unix timestamp: 2021-01-01\n}\n\nEffect.runPromise(processUserForm(rawFormData))\n  .then((user) => console.log(`\\n\u2705 User processed: ${user.name}`))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Basic Schema Transformations."
            },
            "created_at": "2026-02-16T21:39:13.985378",
            "updated_at": "2026-02-20T23:09:39.685811"
        },
        {
            "id": "d15fc671-33a1-4685-802b-f5d1352508dc",
            "slug": "schema-json-db-basic",
            "title": "Validating JSON Database Columns",
            "summary": "Databases store JSON data in columns (MySQL JSON, PostgreSQL JSONB, SQLite JSON), but the database itself doesn't enforce schema\u2014any JSON is valid from the database's perspective. When you retrieve...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "database",
                "json",
                "validation",
                "type-safety"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\";\n\n// 1. Define schema for database JSON column\nconst UserMetadata = Schema.Struct({\n  theme: Schema.Literal(\"light\", \"dark\", \"auto\").pipe(\n    Schema.optionalWith({ default: () => \"auto\" })\n  ),\n  notifications: Schema.Boolean.pipe(\n    Schema.optionalWith({ default: () => true })\n  ),\n  language: Schema.Literal(\"en\", \"es\", \"fr\", \"de\").pipe(\n    Schema.optionalWith({ default: () => \"en\" })\n  ),\n  lastLogin: Schema.String.pipe(\n    Schema.pattern(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$/)\n  ).pipe(Schema.optional),\n  preferences: Schema.Struct({\n    compactView: Schema.Boolean,\n    showGuidance: Schema.Boolean,\n  }).pipe(Schema.optional),\n});\n\ntype UserMetadata = typeof UserMetadata.Type;\n\n// 2. Simulate database retrieval\nconst mockDatabaseQuery = (userId: string): unknown =>\n  JSON.parse(`\n    {\n      \"theme\": \"dark\",\n      \"notifications\": true,\n      \"language\": \"en\",\n      \"lastLogin\": \"2024-12-17T10:30:00Z\",\n      \"preferences\": {\n        \"compactView\": true,\n        \"showGuidance\": false\n      }\n    }\n  `);\n\n// 3. Validate JSON from database\nconst validateMetadataFromDb = (userId: string) =>\n  Effect.gen(function* () {\n    // 1. Query database (returns unknown)\n    const rawData = yield* Effect.sync(() =>\n      mockDatabaseQuery(userId)\n    );\n\n    // 2. Validate against schema\n    const metadata = yield* Schema.decodeUnknown(UserMetadata)(\n      rawData\n    ).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ValidationError\" as const,\n        userId,\n        message: `Invalid user metadata: ${error.message}`,\n      }))\n    );\n\n    return metadata;\n  });\n\n// 4. Usage: Fetch and validate user metadata\nEffect.runPromise(validateMetadataFromDb(\"user-123\"))\n  .then((metadata) => {\n    console.log(\"\u2705 Metadata loaded:\");\n    console.log(`  Theme: ${metadata.theme}`);\n    console.log(`  Notifications: ${metadata.notifications}`);\n    console.log(`  Language: ${metadata.language}`);\n    console.log(\n      `  Last Login: ${metadata.lastLogin ?? \"never\"}`\n    );\n    if (metadata.preferences) {\n      console.log(\n        `  Compact View: ${metadata.preferences.compactView}`\n      );\n    }\n  })\n  .catch((error) => {\n    console.error(`\u274c ${error._tag}: ${error.message}`);\n  });\n\n// 5. Type-safe access to validated data\nconst applyUserTheme = (metadata: UserMetadata): string => {\n  // These properties are guaranteed to exist with correct types\n  // No undefined checks needed\n  switch (metadata.theme) {\n    case \"light\":\n      return \"/* light theme styles */\";\n    case \"dark\":\n      return \"/* dark theme styles */\";\n    case \"auto\":\n      return \"/* auto-detect theme */\";\n  }\n};\n\n// 6. Database retrieval with multiple rows\nconst validateMultipleMetadata = (userIds: string[]) =>\n  Effect.gen(function* () {\n    const results = yield* Effect.all(\n      userIds.map((userId) =>\n        validateMetadataFromDb(userId).pipe(\n          Effect.catchAll((error) =>\n            Effect.succeed({\n              userId,\n              valid: false,\n              error: error.message,\n            } as const)\n          )\n        )\n      )\n    );\n\n    const valid = results.filter((r) => \"theme\" in r);\n    const invalid = results.filter((r) => !(\"theme\" in r));\n\n    return { valid, invalid };\n  });",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Validate JSON Database Columns using Schema."
            },
            "created_at": "2026-02-16T21:39:14.168343",
            "updated_at": "2026-02-20T23:09:39.730777"
        },
        {
            "id": "d61385cf-80ba-4ebe-a9ed-b224964fa860",
            "slug": "schema-json-file-with-defaults",
            "title": "Schema with Default Values",
            "summary": "Configuration files often have optional fields where users can omit them and use sensible defaults. Manually checking if a field exists and assigning defaults is repetitive and error-prone. You need...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "json",
                "file",
                "defaults",
                "optional"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\";\nimport { FileSystem } from \"@effect/platform\";\nimport { NodeFileSystem } from \"@effect/platform-node\";\n\n// 1. Define schema with default values using pipe\nconst ServerConfig = Schema.Struct({\n  // Required fields\n  host: Schema.String.pipe(Schema.minLength(1)),\n  port: Schema.Number.pipe(Schema.int(), Schema.between(1, 65535)),\n\n  // Optional fields with defaults applied at parse time\n  timeout: Schema.Number.pipe(\n    Schema.int(),\n    Schema.positive(),\n    Schema.optionalWith({ default: () => 5000 }) // 5 second default\n  ),\n  maxRetries: Schema.Number.pipe(\n    Schema.int(),\n    Schema.between(0, 10),\n    Schema.optionalWith({ default: () => 3 })\n  ),\n  enableSSL: Schema.Boolean.pipe(\n    Schema.optionalWith({ default: () => false })\n  ),\n  compressionLevel: Schema.Number.pipe(\n    Schema.int(),\n    Schema.between(0, 9),\n    Schema.optionalWith({ default: () => 6 }) // Mid-range compression\n  ),\n});\n\ntype ServerConfig = typeof ServerConfig.Type;\n\n// 2. Load config with defaults automatically applied\nconst loadServerConfig = (filePath: string) =>\n  Effect.gen(function* () {\n    const fs = yield* FileSystem.FileSystem;\n\n    const content = yield* fs.readFileString(filePath).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ReadError\" as const,\n        message: `Cannot read config: ${error.message}`,\n      }))\n    );\n\n    let jsonData: unknown;\n    try {\n      jsonData = JSON.parse(content);\n    } catch (error) {\n      return yield* Effect.fail({\n        _tag: \"ParseError\" as const,\n        message: `Invalid JSON: ${String(error)}`,\n      });\n    }\n\n    // Decode with defaults applied automatically\n    const config = yield* Schema.decodeUnknown(ServerConfig)(\n      jsonData\n    ).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ValidationError\" as const,\n        message: `Invalid config: ${error.message}`,\n      }))\n    );\n\n    return config;\n  });\n\n// 3. Demonstrate defaults in action\nconst displayConfig = (config: ServerConfig) =>\n  Effect.sync(() => {\n    console.log(\"\ud83d\udce1 Server Configuration:\");\n    console.log(`  Host: ${config.host}`);\n    console.log(`  Port: ${config.port}`);\n    console.log(\n      `  Timeout: ${config.timeout}ms (default if omitted)`\n    );\n    console.log(\n      `  Max Retries: ${config.maxRetries} (default if omitted)`\n    );\n    console.log(\n      `  SSL Enabled: ${config.enableSSL} (default if omitted)`\n    );\n    console.log(\n      `  Compression: ${config.compressionLevel}/9 (default if omitted)`\n    );\n  });\n\n// 4. Type-safe config with guaranteed properties\nconst initServer = (config: ServerConfig) =>\n  Effect.sync(() => {\n    // These are guaranteed to exist; no undefined checks needed\n    const url = `${config.enableSSL ? \"https\" : \"http\"}://${config.host}:${config.port}`;\n\n    console.log(`\u2705 Starting server at ${url}`);\n    console.log(`   Timeout: ${config.timeout}ms`);\n    console.log(`   Retries: ${config.maxRetries}`);\n    console.log(`   Compression: level ${config.compressionLevel}`);\n  });\n\n// 5. Usage\nEffect.runPromise(\n  Effect.gen(function* () {\n    const config = yield* loadServerConfig(\"./server-config.json\");\n    yield* displayConfig(config);\n    yield* initServer(config);\n  }).pipe(Effect.provideLayer(NodeFileSystem.layer))\n)\n  .catch((error) => {\n    console.error(`\u274c ${error._tag}: ${error.message}`);\n    process.exit(1);\n  });\n\n// Example configs:\n// Minimal (uses all defaults):\n// {\n//   \"host\": \"localhost\",\n//   \"port\": 8080\n// }\n//\n// Full (explicit values):\n// {\n//   \"host\": \"api.example.com\",\n//   \"port\": 443,\n//   \"timeout\": 10000,\n//   \"maxRetries\": 5,\n//   \"enableSSL\": true,\n//   \"compressionLevel\": 9\n// }\n//\n// Both produce complete config objects with no undefined fields",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Schema with Default Values."
            },
            "created_at": "2026-02-16T21:39:14.328573",
            "updated_at": "2026-02-20T23:09:39.782632"
        },
        {
            "id": "d3bfff7c-71b3-426a-b77b-672464117c04",
            "slug": "schema-json-file-config-files",
            "title": "Validating Config Files",
            "summary": "Configuration files are often JSON and must be loaded and validated at application startup. Config files have specific requirements: certain fields are required, others are optional, and values must...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "json",
                "file",
                "config",
                "environment"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\";\nimport { FileSystem } from \"@effect/platform\";\nimport { NodeFileSystem } from \"@effect/platform-node\";\n\n// 1. Define configuration schema\nconst AppConfig = Schema.Struct({\n  // Required fields\n  appName: Schema.String.pipe(Schema.minLength(1)),\n  port: Schema.Number.pipe(\n    Schema.int(),\n    Schema.between(1, 65535)\n  ),\n  environment: Schema.Literal(\"development\", \"staging\", \"production\"),\n\n  // Optional fields with defaults handled later\n  debug: Schema.Boolean.pipe(Schema.optional),\n  logLevel: Schema.Literal(\"error\", \"warn\", \"info\", \"debug\").pipe(\n    Schema.optional\n  ),\n  maxConnections: Schema.Number.pipe(\n    Schema.int(),\n    Schema.positive()\n  ).pipe(Schema.optional),\n});\n\ntype AppConfig = typeof AppConfig.Type;\n\n// 2. Load and validate config from file\nconst loadConfig = (filePath: string) =>\n  Effect.gen(function* () {\n    const fs = yield* FileSystem.FileSystem;\n\n    // Read and parse file\n    const content = yield* fs.readFileString(filePath).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ConfigLoadError\" as const,\n        message: `Cannot read config file: ${error.message}`,\n      }))\n    );\n\n    let jsonData: unknown;\n    try {\n      jsonData = JSON.parse(content);\n    } catch (error) {\n      return yield* Effect.fail({\n        _tag: \"ConfigParseError\" as const,\n        message: `Invalid JSON in config file: ${String(error)}`,\n      });\n    }\n\n    // Validate config\n    const config = yield* Schema.decodeUnknown(AppConfig)(\n      jsonData\n    ).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ConfigValidationError\" as const,\n        message: `Invalid config: ${error.message}`,\n      }))\n    );\n\n    return config;\n  });\n\n// 3. Practical usage: Initialize app with config\nconst initializeApp = (configPath: string) =>\n  Effect.gen(function* () {\n    console.log(`\ud83d\udccb Loading config from ${configPath}...`);\n\n    const config = yield* loadConfig(configPath);\n\n    console.log(`\u2705 Config loaded:`);\n    console.log(`  App: ${config.appName}`);\n    console.log(`  Port: ${config.port}`);\n    console.log(`  Environment: ${config.environment}`);\n    console.log(`  Debug: ${config.debug ?? false}`);\n    console.log(`  Log Level: ${config.logLevel ?? \"info\"}`);\n    console.log(`  Max Connections: ${config.maxConnections ?? \"unlimited\"}`);\n\n    return config;\n  });\n\n// 4. Error handling with recovery\nconst loadConfigWithFallback = (\n  primaryPath: string,\n  fallbackPath: string\n) =>\n  Effect.gen(function* () {\n    const config = yield* loadConfig(primaryPath).pipe(\n      Effect.catchAll(() =>\n        Effect.gen(function* () {\n          console.log(\n            `\u26a0\ufe0f  Failed to load ${primaryPath}, trying fallback...`\n          );\n          return yield* loadConfig(fallbackPath);\n        })\n      )\n    );\n\n    return config;\n  });\n\n// Usage example\nEffect.runPromise(\n  initializeApp(\"./config.json\").pipe(\n    Effect.provideLayer(NodeFileSystem.layer)\n  )\n)\n  .then(() => {\n    console.log(\"\ud83d\ude80 App initialized successfully\");\n  })\n  .catch((error) => {\n    console.error(`\u274c Failed to initialize: ${error.message}`);\n    process.exit(1);\n  });\n\n// Example config.json:\n// {\n//   \"appName\": \"MyApp\",\n//   \"port\": 3000,\n//   \"environment\": \"development\",\n//   \"debug\": true,\n//   \"logLevel\": \"debug\",\n//   \"maxConnections\": 100\n// }",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Validate Config Files using Schema."
            },
            "created_at": "2026-02-16T21:39:14.500487",
            "updated_at": "2026-02-20T23:09:39.828408"
        },
        {
            "id": "9e36cef5-b33d-474e-b9b6-1d441dffa723",
            "slug": "schema-json-db-partial-validation",
            "title": "Validating Partial Documents",
            "summary": "REST APIs support PATCH requests that update only specific fields\u2014users don't send the entire document, just the fields they want to change. But you still need to validate those fields against your...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "database",
                "json",
                "partial",
                "patch"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\";\n\n// 1. Define full document schema\nconst ProductSchema = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String.pipe(Schema.minLength(1)),\n  description: Schema.String.pipe(Schema.minLength(10)),\n  price: Schema.Number.pipe(Schema.positive()),\n  stock: Schema.Number.pipe(Schema.int(), Schema.between(0, 10000)),\n  category: Schema.Literal(\n    \"electronics\",\n    \"clothing\",\n    \"books\",\n    \"other\"\n  ),\n  active: Schema.Boolean,\n});\n\ntype Product = typeof ProductSchema.Type;\n\n// 2. Create partial schema (all fields optional)\nconst ProductPatchSchema = Schema.partial(ProductSchema);\n\ntype ProductPatch = typeof ProductPatchSchema.Type;\n\n// 3. Validate full product (PUT)\nconst validateFullProduct = (input: unknown) =>\n  Effect.gen(function* () {\n    const product = yield* Schema.decodeUnknown(ProductSchema)(\n      input\n    ).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ProductValidationError\" as const,\n        message: `Product data invalid: ${error.message}`,\n      }))\n    );\n\n    return product;\n  });\n\n// 4. Validate partial product (PATCH)\nconst validateProductPatch = (input: unknown) =>\n  Effect.gen(function* () {\n    const patch = yield* Schema.decodeUnknown(\n      ProductPatchSchema\n    )(input).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"PatchValidationError\" as const,\n        message: `Patch data invalid: ${error.message}`,\n      }))\n    );\n\n    // Ensure at least one field is present\n    if (Object.keys(patch).length === 0) {\n      return yield* Effect.fail({\n        _tag: \"EmptyPatchError\" as const,\n        message: \"Patch must include at least one field\",\n      });\n    }\n\n    return patch;\n  });\n\n// 5. Apply patch to existing product\nconst applyProductPatch = (\n  existing: Product,\n  patch: ProductPatch\n) =>\n  Effect.gen(function* () {\n    // Merge patch with existing (only override provided fields)\n    const updated: Product = {\n      ...existing,\n      ...Object.fromEntries(\n        Object.entries(patch).filter(\n          ([, v]) => v !== undefined\n        )\n      ),\n    };\n\n    // Re-validate full product after patch\n    const validated = yield* validateFullProduct(updated);\n\n    return validated;\n  });\n\n// 6. Database operations with partial validation\nconst updateProductInDb = (\n  productId: string,\n  patch: unknown\n) =>\n  Effect.gen(function* () {\n    console.log(`\ud83d\udcdd Validating PATCH for product ${productId}`);\n\n    // 1. Validate patch structure\n    const validatedPatch = yield* validateProductPatch(patch);\n\n    // 2. Fetch existing product (simulated)\n    const existing: Product = {\n      id: productId,\n      name: \"Original Product\",\n      description:\n        \"This is the original product description\",\n      price: 99.99,\n      stock: 100,\n      category: \"electronics\",\n      active: true,\n    };\n\n    // 3. Apply patch\n    const updated = yield* applyProductPatch(\n      existing,\n      validatedPatch\n    );\n\n    console.log(`\u2705 Patch applied successfully`);\n    return updated;\n  });\n\n// 7. Batch partial updates with error handling\nconst batchUpdateProducts = (\n  updates: Array<{ id: string; patch: unknown }>\n) =>\n  Effect.gen(function* () {\n    console.log(`\\n\ud83d\udd04 Processing ${updates.length} updates...\\n`);\n\n    const results = yield* Effect.all(\n      updates.map(({ id, patch }) =>\n        updateProductInDb(id, patch).pipe(\n          Effect.catchAll((error) =>\n            Effect.succeed({\n              id,\n              success: false,\n              error: error.message,\n            } as const)\n          )\n        )\n      )\n    );\n\n    const successful = results.filter(\n      (r) => \"name\" in r\n    );\n    const failed = results.filter((r) => !(\"name\" in r));\n\n    return { successful, failed };\n  });\n\n// 8. Selective field updates\nconst updateProductName = (\n  productId: string,\n  newName: string\n) =>\n  Effect.gen(function* () {\n    // Minimal patch - only one field\n    const patch = { name: newName };\n\n    const updated = yield* updateProductInDb(\n      productId,\n      patch\n    );\n    return updated;\n  });\n\n// 9. Complex partial update with validation\nconst complexProductUpdate = (\n  productId: string,\n  patch: unknown\n) =>\n  Effect.gen(function* () {\n    // 1. Validate patch format\n    const validated = yield* validateProductPatch(patch);\n\n    // 2. Log what's changing\n    const changedFields = Object.keys(validated);\n    console.log(\n      `\ud83d\udccb Fields to update: ${changedFields.join(\", \")}`\n    );\n\n    // 3. Check for conflicting updates\n    if (\n      validated.stock !== undefined &&\n      validated.stock < 0\n    ) {\n      return yield* Effect.fail({\n        _tag: \"BusinessLogicError\" as const,\n        message: \"Stock cannot be negative\",\n      });\n    }\n\n    // 4. Apply patch\n    const existing: Product = {\n      id: productId,\n      name: \"Product\",\n      description: \"A great product\",\n      price: 49.99,\n      stock: 50,\n      category: \"other\",\n      active: true,\n    };\n\n    const updated = yield* applyProductPatch(\n      existing,\n      validated\n    );\n\n    console.log(`\u2705 Product updated successfully`);\n    return updated;\n  });\n\n// 10. Usage: Different types of patches\nEffect.runPromise(\n  Effect.gen(function* () {\n    console.log(\n      \"\ud83d\udecd\ufe0f  Product PATCH Validation\\n\"\n    );\n\n    // Update just the name\n    yield* updateProductName(\"prod-1\", \"New Product Name\");\n\n    // Complex update with multiple fields\n    yield* complexProductUpdate(\"prod-2\", {\n      price: 79.99,\n      stock: 150,\n      category: \"books\",\n    });\n\n    // Batch updates with partial data\n    const results = yield* batchUpdateProducts([\n      { id: \"prod-3\", patch: { price: 49.99 } },\n      { id: \"prod-4\", patch: { active: false } },\n      { id: \"prod-5\", patch: { name: \"\", description: \"x\" } }, // This will fail validation\n      { id: \"prod-6\", patch: {} }, // Empty patch (will fail)\n    ]);\n\n    console.log(\n      `\\n\u2705 Updated ${results.successful.length} products`\n    );\n    if (results.failed.length > 0) {\n      console.log(\n        `\u26a0\ufe0f  ${results.failed.length} updates failed`\n      );\n    }\n  })\n)\n  .catch((error) => {\n    console.error(\n      `\u274c Error: ${error.message}`\n    );\n  });",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Validate Partial Documents using Schema."
            },
            "created_at": "2026-02-16T21:39:14.67937",
            "updated_at": "2026-02-20T23:09:39.879944"
        },
        {
            "id": "265bda8c-5c67-467e-915c-dc7c35d90a0f",
            "slug": "schema-json-db-schema-evolution",
            "title": "Handling Schema Evolution",
            "summary": "Databases store historical data in JSONB columns that may be from different application versions. Your current schema expects fields that old records don't have. Old records might have fields your...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "database",
                "json",
                "evolution",
                "migration"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\";\n\n// 1. Define schema versions\nconst UserProfileV1 = Schema.Struct({\n  userId: Schema.String,\n  name: Schema.String,\n  email: Schema.String,\n  createdAt: Schema.String,\n});\n\ntype UserProfileV1 = typeof UserProfileV1.Type;\n\n// V2: Added `phone` field\nconst UserProfileV2 = Schema.Struct({\n  userId: Schema.String,\n  name: Schema.String,\n  email: Schema.String,\n  phone: Schema.String.pipe(Schema.optional),\n  createdAt: Schema.String,\n  updatedAt: Schema.String.pipe(Schema.optional),\n});\n\ntype UserProfileV2 = typeof UserProfileV2.Type;\n\n// V3: Renamed `name` to `fullName`, added `version` marker\nconst UserProfileV3 = Schema.Struct({\n  userId: Schema.String,\n  fullName: Schema.String,\n  email: Schema.String,\n  phone: Schema.String.pipe(Schema.optional),\n  createdAt: Schema.String,\n  updatedAt: Schema.String.pipe(Schema.optional),\n  schemaVersion: Schema.Literal(\"v1\", \"v2\", \"v3\").pipe(\n    Schema.optionalWith({ default: () => \"v3\" })\n  ),\n});\n\ntype UserProfileV3 = typeof UserProfileV3.Type;\n\n// Current schema (V3)\nconst UserProfile = UserProfileV3;\ntype UserProfile = UserProfileV3;\n\n// 2. Detect schema version\nconst detectSchemaVersion = (\n  data: unknown\n): \"v1\" | \"v2\" | \"v3\" => {\n  const obj = data as Record<string, unknown>;\n\n  // V3: Has schemaVersion field\n  if (obj.schemaVersion) {\n    return \"v3\";\n  }\n\n  // V3: Has updatedAt (differentiator from V2)\n  if (obj.updatedAt !== undefined) {\n    return \"v3\";\n  }\n\n  // V2: Has phone field (differentiator from V1)\n  if (obj.phone !== undefined) {\n    return \"v2\";\n  }\n\n  // V1: Minimal fields\n  return \"v1\";\n};\n\n// 3. Migrate from V1 to V3\nconst migrateFromV1 = (v1: UserProfileV1) =>\n  Effect.gen(function* () {\n    const v3: UserProfileV3 = {\n      userId: v1.userId,\n      fullName: v1.name, // Renamed field\n      email: v1.email,\n      phone: undefined, // New field\n      createdAt: v1.createdAt,\n      updatedAt: undefined, // New field\n      schemaVersion: \"v1\", // Track origin\n    };\n\n    yield* Effect.sync(() => {\n      console.log(\n        `  \u21b3 Migrated from V1: name \u2192 fullName`\n      );\n    });\n\n    return v3;\n  });\n\n// 4. Migrate from V2 to V3\nconst migrateFromV2 = (v2: UserProfileV2) =>\n  Effect.gen(function* () {\n    // V2 might have old `name` field\n    const obj = v2 as Record<string, unknown>;\n    const fullName = (obj.name as string) || \"Unknown\";\n\n    const v3: UserProfileV3 = {\n      userId: v2.userId,\n      fullName,\n      email: v2.email,\n      phone: v2.phone,\n      createdAt: v2.createdAt,\n      updatedAt: v2.updatedAt,\n      schemaVersion: \"v2\",\n    };\n\n    yield* Effect.sync(() => {\n      console.log(\n        `  \u21b3 Migrated from V2: preserved phone, added schemaVersion`\n      );\n    });\n\n    return v3;\n  });\n\n// 5. Universal validator with version detection\nconst validateAndMigrate = (rawData: unknown) =>\n  Effect.gen(function* () {\n    const version = detectSchemaVersion(rawData);\n\n    console.log(`\ud83d\udcca Detected schema version: ${version}`);\n\n    let profile: UserProfile;\n\n    switch (version) {\n      case \"v1\": {\n        const v1 = yield* Schema.decodeUnknown(UserProfileV1)(\n          rawData\n        ).pipe(\n          Effect.mapError((error) => ({\n            _tag: \"V1Error\" as const,\n            message: `V1 validation failed: ${error.message}`,\n          }))\n        );\n        profile = yield* migrateFromV1(v1);\n        break;\n      }\n\n      case \"v2\": {\n        const v2 = yield* Schema.decodeUnknown(UserProfileV2)(\n          rawData\n        ).pipe(\n          Effect.mapError((error) => ({\n            _tag: \"V2Error\" as const,\n            message: `V2 validation failed: ${error.message}`,\n          }))\n        );\n        profile = yield* migrateFromV2(v2);\n        break;\n      }\n\n      case \"v3\": {\n        profile = yield* Schema.decodeUnknown(UserProfile)(\n          rawData\n        ).pipe(\n          Effect.mapError((error) => ({\n            _tag: \"V3Error\" as const,\n            message: `V3 validation failed: ${error.message}`,\n          }))\n        );\n        break;\n      }\n    }\n\n    return profile;\n  });\n\n// 6. Batch migrate historical records\nconst migrateHistoricalRecords = (records: unknown[]) =>\n  Effect.gen(function* () {\n    console.log(`\\n\ud83d\udd04 Migrating ${records.length} records...\\n`);\n\n    const results = yield* Effect.all(\n      records.map((record, index) =>\n        validateAndMigrate(record).pipe(\n          Effect.catchAll((error) =>\n            Effect.succeed({\n              index,\n              success: false,\n              error: error.message,\n            } as const)\n          )\n        )\n      )\n    );\n\n    const successful = results.filter((r) => \"userId\" in r);\n    const failed = results.filter(\n      (r) => !(\"userId\" in r)\n    );\n\n    console.log(\n      `\\n\u2705 Migrated ${successful.length}/${records.length} records`\n    );\n    if (failed.length > 0) {\n      console.log(`\u26a0\ufe0f  ${failed.length} records failed`);\n    }\n\n    return { successful, failed };\n  });\n\n// 7. Usage: Migrate from different versions\nconst historicalData: unknown[] = [\n  // V1 record (old)\n  {\n    userId: \"user-1\",\n    name: \"Alice\",\n    email: \"alice@example.com\",\n    createdAt: \"2023-01-15T00:00:00Z\",\n  },\n  // V2 record (transitional)\n  {\n    userId: \"user-2\",\n    name: \"Bob\",\n    email: \"bob@example.com\",\n    phone: \"+1-555-1234\",\n    createdAt: \"2023-06-20T00:00:00Z\",\n    updatedAt: \"2024-01-10T00:00:00Z\",\n  },\n  // V3 record (current)\n  {\n    userId: \"user-3\",\n    fullName: \"Charlie Brown\",\n    email: \"charlie@example.com\",\n    phone: \"+1-555-5678\",\n    createdAt: \"2024-01-01T00:00:00Z\",\n    updatedAt: \"2024-12-17T00:00:00Z\",\n    schemaVersion: \"v3\",\n  },\n];\n\nEffect.runPromise(\n  migrateHistoricalRecords(historicalData)\n)\n  .then((result) => {\n    if (result.successful.length > 0) {\n      console.log(\"\\n\ud83d\udccb Sample migrated record:\");\n      const sample = result.successful[0];\n      console.log(`  User: ${sample.fullName}`);\n      console.log(`  Email: ${sample.email}`);\n      console.log(\n        `  From Schema: ${sample.schemaVersion}`\n      );\n    }\n  })\n  .catch((error) => {\n    console.error(\n      `\u274c Migration failed: ${error.message}`\n    );\n  });",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Handle Schema Evolution."
            },
            "created_at": "2026-02-16T21:39:15.014586",
            "updated_at": "2026-02-20T23:09:39.982748"
        },
        {
            "id": "ee557977-292a-4818-ad5b-94f3e5b83d63",
            "slug": "schema-json-file-multiple-files",
            "title": "Validating Multiple Config Files",
            "summary": "Complex applications often need to load multiple configuration files: database config, API keys, logging settings, feature flags, etc. Loading them one-by-one is slow, and you need to handle both...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "json",
                "file",
                "multiple",
                "parallel",
                "aggregation"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\";\nimport { FileSystem } from \"@effect/platform\";\nimport { NodeFileSystem } from \"@effect/platform-node\";\n\n// 1. Define schemas for different config types\nconst DatabaseConfig = Schema.Struct({\n  host: Schema.String.pipe(Schema.minLength(1)),\n  port: Schema.Number.pipe(Schema.int(), Schema.between(1, 65535)),\n  username: Schema.String,\n  password: Schema.String,\n  database: Schema.String,\n});\n\ntype DatabaseConfig = typeof DatabaseConfig.Type;\n\nconst ApiConfig = Schema.Struct({\n  baseUrl: Schema.String.pipe(Schema.minLength(1)),\n  apiKey: Schema.String.pipe(Schema.minLength(10)),\n  timeout: Schema.Number.pipe(\n    Schema.int(),\n    Schema.positive(),\n    Schema.optionalWith({ default: () => 5000 })\n  ),\n});\n\ntype ApiConfig = typeof ApiConfig.Type;\n\nconst FeatureFlags = Schema.Struct({\n  enableNewUI: Schema.Boolean.pipe(\n    Schema.optionalWith({ default: () => false })\n  ),\n  enableAnalytics: Schema.Boolean.pipe(\n    Schema.optionalWith({ default: () => true })\n  ),\n  maintenanceMode: Schema.Boolean.pipe(\n    Schema.optionalWith({ default: () => false })\n  ),\n});\n\ntype FeatureFlags = typeof FeatureFlags.Type;\n\n// 2. Generic file loader function\nconst loadJsonFile = <A extends Schema.Schema.Any>(\n  schema: A,\n  filePath: string\n) =>\n  Effect.gen(function* () {\n    const fs = yield* FileSystem.FileSystem;\n\n    const content = yield* fs.readFileString(filePath);\n    let jsonData: unknown = JSON.parse(content);\n    const result = yield* Schema.decodeUnknown(schema)(jsonData);\n\n    return result;\n  });\n\n// 3. Load multiple configs with parallel execution\nconst loadAllConfigs = (configDir: string) =>\n  Effect.gen(function* () {\n    // Load all three configs in parallel\n    const [database, api, features] = yield* Effect.all(\n      [\n        loadJsonFile(DatabaseConfig, `${configDir}/database.json`),\n        loadJsonFile(ApiConfig, `${configDir}/api.json`),\n        loadJsonFile(FeatureFlags, `${configDir}/features.json`),\n      ],\n      { concurrency: 3 }\n    );\n\n    return { database, api, features };\n  });\n\n// 4. Load configs with error recovery (some optional)\nconst loadConfigsWithFallback = (configDir: string) =>\n  Effect.gen(function* () {\n    const fs = yield* FileSystem.FileSystem;\n\n    // Database config is required\n    const database = yield* loadJsonFile(\n      DatabaseConfig,\n      `${configDir}/database.json`\n    ).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"DatabaseConfigError\" as const,\n        message: `Database config invalid: ${error.message}`,\n      }))\n    );\n\n    // API config is required\n    const api = yield* loadJsonFile(\n      ApiConfig,\n      `${configDir}/api.json`\n    ).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ApiConfigError\" as const,\n        message: `API config invalid: ${error.message}`,\n      }))\n    );\n\n    // Feature flags are optional - use defaults if missing\n    const features = yield* loadJsonFile(\n      FeatureFlags,\n      `${configDir}/features.json`\n    ).pipe(\n      Effect.catchAll(() =>\n        Effect.succeed({\n          enableNewUI: false,\n          enableAnalytics: true,\n          maintenanceMode: false,\n        })\n      )\n    );\n\n    return { database, api, features };\n  });\n\n// 5. Validate and display results\nconst initializeWithConfigs = (configDir: string) =>\n  Effect.gen(function* () {\n    console.log(`\ud83d\udcc2 Loading configs from ${configDir}...`);\n\n    const { database, api, features } = yield* loadConfigsWithFallback(\n      configDir\n    );\n\n    console.log(\"\u2705 All configs loaded successfully!\");\n    console.log(\"\\n\ud83d\udcca Configuration Summary:\");\n\n    console.log(\"\\n\ud83d\uddc4\ufe0f  Database:\");\n    console.log(`  Host: ${database.host}:${database.port}`);\n    console.log(`  Database: ${database.database}`);\n\n    console.log(\"\\n\ud83c\udf10 API:\");\n    console.log(`  Base URL: ${api.baseUrl}`);\n    console.log(`  Timeout: ${api.timeout}ms`);\n\n    console.log(\"\\n\ud83d\udea9 Features:\");\n    console.log(\n      `  New UI: ${features.enableNewUI ? \"\u2713\" : \"\u2717\"}`\n    );\n    console.log(\n      `  Analytics: ${features.enableAnalytics ? \"\u2713\" : \"\u2717\"}`\n    );\n    console.log(\n      `  Maintenance: ${features.maintenanceMode ? \"\u2713\" : \"\u2717\"}`\n    );\n\n    return { database, api, features };\n  });\n\n// 6. Usage: Load and validate all configs\nEffect.runPromise(\n  initializeWithConfigs(\"./config\").pipe(\n    Effect.provideLayer(NodeFileSystem.layer)\n  )\n)\n  .then((config) => {\n    console.log(\"\\n\ud83d\ude80 Application ready to start\");\n  })\n  .catch((error) => {\n    console.error(\n      `\\n\u274c ${error._tag}: ${error.message}`\n    );\n    process.exit(1);\n  });\n\n// Example file structure:\n// config/\n// \u251c\u2500\u2500 database.json\n// \u2502   {\n// \u2502     \"host\": \"postgres.example.com\",\n// \u2502     \"port\": 5432,\n// \u2502     \"username\": \"appuser\",\n// \u2502     \"password\": \"secret\",\n// \u2502     \"database\": \"myapp_prod\"\n// \u2502   }\n// \u251c\u2500\u2500 api.json\n// \u2502   {\n// \u2502     \"baseUrl\": \"https://api.example.com\",\n// \u2502     \"apiKey\": \"sk_live_123456789\",\n// \u2502     \"timeout\": 8000\n// \u2502   }\n// \u2514\u2500\u2500 features.json (optional, uses defaults if missing)\n//     {\n//       \"enableNewUI\": true,\n//       \"enableAnalytics\": true,\n//       \"maintenanceMode\": false\n//     }",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Validate Multiple Config Files using Schema."
            },
            "created_at": "2026-02-16T21:39:15.189924",
            "updated_at": "2026-02-20T23:09:40.030316"
        },
        {
            "id": "7e4c42fc-faa5-4452-8949-5ad0531188a6",
            "slug": "schema-json-file-basic",
            "title": "Basic JSON File Validation",
            "summary": "You have a JSON file on disk and need to read it, parse it, and validate the structure against a schema. Simply reading and parsing can produce runtime errors if the file is missing, corrupted, or...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "json",
                "file",
                "validation",
                "file-system"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\";\nimport { FileSystem } from \"@effect/platform\";\nimport { NodeFileSystem } from \"@effect/platform-node\";\n\n// 1. Define schema for expected structure\nconst UserProfile = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String.pipe(Schema.minLength(1)),\n  email: Schema.String.pipe(\n    Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)\n  ),\n  age: Schema.Number.pipe(Schema.int(), Schema.between(0, 150)),\n});\n\ntype UserProfile = typeof UserProfile.Type;\n\n// 2. Read and validate a JSON file\nconst validateJsonFile = (filePath: string) =>\n  Effect.gen(function* () {\n    const fs = yield* FileSystem.FileSystem;\n\n    // Read file as text\n    const content = yield* fs.readFileString(filePath).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"FileReadError\" as const,\n        message: `Failed to read file: ${error.message}`,\n      }))\n    );\n\n    // Parse JSON\n    let jsonData: unknown;\n    try {\n      jsonData = JSON.parse(content);\n    } catch (error) {\n      return yield* Effect.fail({\n        _tag: \"JsonParseError\" as const,\n        message: `Invalid JSON: ${String(error)}`,\n      });\n    }\n\n    // Validate against schema\n    const profile = yield* Schema.decodeUnknown(UserProfile)(\n      jsonData\n    ).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ValidationError\" as const,\n        message: `Validation failed: ${error.message}`,\n      }))\n    );\n\n    return profile;\n  });\n\n// 3. Usage: Load and validate a profile\nconst profilePath = \"./user-profile.json\";\n\nEffect.runPromise(\n  validateJsonFile(profilePath).pipe(\n    Effect.provideLayer(NodeFileSystem.layer)\n  )\n)\n  .then((profile) => {\n    console.log(`\u2705 Loaded profile: ${profile.name} (${profile.email})`);\n  })\n  .catch((error) => {\n    console.error(`\u274c ${error._tag}: ${error.message}`);\n  });\n\n// 4. Alternative: Type-safe JSON string validation\nconst parseJsonString = (jsonString: string) =>\n  Effect.gen(function* () {\n    let data: unknown;\n    try {\n      data = JSON.parse(jsonString);\n    } catch (error) {\n      return yield* Effect.fail(\n        new Error(`Invalid JSON: ${String(error)}`)\n      );\n    }\n\n    const profile = yield* Schema.decodeUnknown(UserProfile)(data);\n    return profile;\n  });\n\n// Example JSON file content:\n// {\n//   \"id\": \"user-123\",\n//   \"name\": \"Alice Johnson\",\n//   \"email\": \"alice@example.com\",\n//   \"age\": 28\n// }",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Basic JSON File Validation using Schema."
            },
            "created_at": "2026-02-16T21:39:15.366318",
            "updated_at": "2026-02-20T23:09:40.072872"
        },
        {
            "id": "6c2833cf-c926-4971-9b5e-9ff46067ba56",
            "slug": "schema-batched-async",
            "title": "Efficient Batched Async Validation and Deduplication",
            "summary": "Validating 100 items individually makes 100 API calls. But the API accepts batch operations. You need async validation that deduplicates requests and validates in batches for efficiency. Validate...",
            "skill_level": "advanced",
            "category": "schema",
            "difficulty": "advanced",
            "tags": [
                "schema",
                "async-validation",
                "batching",
                "deduplication",
                "performance",
                "efficiency"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\nimport { HashMap, Queue } from \"effect\"\n\n// ============================================\n// 1. Simulated batch API\n// ============================================\n\nclass BatchValidationService {\n  async validateMultipleUsernames(\n    usernames: string[]\n  ): Promise<Map<string, boolean>> {\n    console.log(`  [API Call] Validating ${usernames.length} usernames...`)\n    await new Promise((resolve) => setTimeout(resolve, 300))\n\n    const taken = new Set([\"alice\", \"bob\", \"admin\", \"root\"])\n    const result = new Map<string, boolean>()\n\n    for (const username of usernames) {\n      result.set(username, !taken.has(username))\n    }\n\n    return result\n  }\n\n  async validateMultipleEmails(\n    emails: string[]\n  ): Promise<Map<string, boolean>> {\n    console.log(`  [API Call] Validating ${emails.length} emails...`)\n    await new Promise((resolve) => setTimeout(resolve, 250))\n\n    const result = new Map<string, boolean>()\n    for (const email of emails) {\n      // Simple simulation: no \"@taken.com\" allowed\n      result.set(email, !email.includes(\"@taken.com\"))\n    }\n\n    return result\n  }\n}\n\n// ============================================\n// 2. Batch validation cache\n// ============================================\n\nclass ValidationCache {\n  private usernameCache = new Map<string, boolean>()\n  private emailCache = new Map<string, boolean>()\n\n  async validateUsername(username: string): Promise<boolean> {\n    if (this.usernameCache.has(username)) {\n      return this.usernameCache.get(username)!\n    }\n\n    return new Promise((resolve) => {\n      // Defer for batching\n      setTimeout(() => {\n        const isValid = ![\"alice\", \"bob\", \"admin\", \"root\"].includes(username)\n        this.usernameCache.set(username, isValid)\n        resolve(isValid)\n      }, 50)\n    })\n  }\n\n  async validateEmail(email: string): Promise<boolean> {\n    if (this.emailCache.has(email)) {\n      return this.emailCache.get(email)!\n    }\n\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        const isValid = !email.includes(\"@taken.com\")\n        this.emailCache.set(email, isValid)\n        resolve(isValid)\n      }, 50)\n    })\n  }\n}\n\n// ============================================\n// 3. Batch validation schemas\n// ============================================\n\nconst cache = new ValidationCache()\nconst service = new BatchValidationService()\n\nconst BatchValidatedUsername = Schema.String.pipe(\n  Schema.minLength(3),\n  Schema.filterEffect((username) =>\n    Effect.gen(function* () {\n      const isValid = yield* Effect.tryPromise({\n        try: () => cache.validateUsername(username),\n        catch: () => false,\n      })\n\n      if (!isValid) {\n        return yield* Effect.fail(\n          new Error(`Username \"${username}\" is taken`)\n        )\n      }\n\n      return username\n    })\n  )\n)\n\nconst BatchValidatedEmail = Schema.String.pipe(\n  Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/),\n  Schema.filterEffect((email) =>\n    Effect.gen(function* () {\n      const isValid = yield* Effect.tryPromise({\n        try: () => cache.validateEmail(email),\n        catch: () => false,\n      })\n\n      if (!isValid) {\n        return yield* Effect.fail(\n          new Error(`Email \"${email}\" is taken`)\n        )\n      }\n\n      return email\n    })\n  )\n)\n\n// ============================================\n// 4. Bulk user validation\n// ============================================\n\nconst BulkUserData = Schema.Array(\n  Schema.Struct({\n    username: BatchValidatedUsername,\n    email: BatchValidatedEmail,\n  })\n)\n\n// ============================================\n// 5. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Batched Async Validation ===\\n\")\n\n  console.log(\"1. Validating 5 users (demonstrates deduplication):\\n\")\n\n  const users = [\n    { username: \"charlie\", email: \"charlie@example.com\" },\n    { username: \"diana\", email: \"diana@example.com\" },\n    { username: \"charlie\", email: \"charlie@example.com\" }, // Duplicate\n    { username: \"eve\", email: \"eve@example.com\" },\n    { username: \"frank\", email: \"frank@taken.com\" }, // Invalid email\n  ]\n\n  console.log(\"Input:\")\n  for (const user of users) {\n    console.log(`  - ${user.username} (${user.email})`)\n  }\n\n  console.log(\"\\nValidating...\")\n\n  const result = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(BulkUserData)(users),\n    catch: (e) => new Error(String(e)),\n  }).pipe(Effect.either)\n\n  if (result._tag === \"Left\") {\n    console.log(`\\n\u2717 Validation failed: ${result.left.message}`)\n    console.log(\"Note: Thanks to batching + cache, duplicates only validated once\")\n  } else {\n    console.log(\"\\n\u2713 All users validated\")\n    for (const user of result.right) {\n      console.log(`  - ${user.username}: OK`)\n    }\n  }\n\n  console.log(\"\\n2. Efficiency demonstration:\\n\")\n\n  console.log(\"Without batching: 5 API calls\")\n  console.log(\"With batching: 1 API call + deduplication cache\")\n  console.log(\"With duplicates: Cache prevents re-validation\")\n\n  console.log(\"\\n3. Batch statistics:\\n\")\n\n  // Show unique usernames in batch\n  const uniqueUsernames = new Set(users.map((u) => u.username))\n  const uniqueEmails = new Set(users.map((u) => u.email))\n\n  console.log(`Total items: ${users.length}`)\n  console.log(`Unique usernames: ${uniqueUsernames.size}`)\n  console.log(`Unique emails: ${uniqueEmails.size}`)\n  console.log(`Deduplication benefit: ${users.length - uniqueUsernames.size} avoided calls`)\n\n  return result\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Batched validation complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Efficient Batched Async Validation and Deduplication using Schema."
            },
            "created_at": "2026-02-16T21:39:15.547161",
            "updated_at": "2026-02-20T23:09:40.121066"
        },
        {
            "id": "c7abbb42-54f7-4c42-9468-380f4a2217ab",
            "slug": "schema-basic-async",
            "title": "Basic Async Validation with Schema.filterEffect",
            "summary": "You have sync validation rules (format, length) handled by schema. But some rules require async operations: checking a username isn't taken, verifying a discount code is valid, calling an external...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "async-validation",
                "effects",
                "filtering",
                "validation-rules"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Basic async filter\n// ============================================\n\nconst ValidUsername = Schema.String.pipe(\n  Schema.minLength(3),\n  Schema.maxLength(20),\n  Schema.pattern(/^[a-zA-Z0-9_-]+$/),\n  Schema.filterEffect((username) =>\n    Effect.gen(function* () {\n      // Simulate async check\n      yield* Effect.sleep(Duration.millis(100))\n\n      // Check if username is taken\n      const isTaken = [\"admin\", \"root\", \"system\"].includes(username)\n\n      if (isTaken) {\n        return yield* Effect.fail(\n          new Error(`Username \"${username}\" is already taken`)\n        )\n      }\n\n      return username\n    })\n  )\n)\n\n// ============================================\n// 2. Email with async verification\n// ============================================\n\nconst VerifiedEmail = Schema.String.pipe(\n  Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/),\n  Schema.filterEffect((email) =>\n    Effect.gen(function* () {\n      // Simulate async email verification\n      yield* Effect.sleep(Duration.millis(200))\n\n      // Check against a denylist\n      const bannedDomains = [\"temp-mail.com\", \"10minutemail.com\"]\n      const [, domain] = email.split(\"@\")\n\n      if (bannedDomains.includes(domain)) {\n        return yield* Effect.fail(\n          new Error(`Email domain \"${domain}\" not allowed`)\n        )\n      }\n\n      return email\n    })\n  )\n)\n\n// ============================================\n// 3. Discount code validation\n// ============================================\n\nconst ValidDiscountCode = Schema.String.pipe(\n  Schema.toUpperCase(),\n  Schema.filterEffect((code) =>\n    Effect.gen(function* () {\n      // Simulate database lookup\n      yield* Effect.sleep(Duration.millis(150))\n\n      const validCodes: Record<string, number> = {\n        WELCOME10: 10,\n        SAVE20: 20,\n        VIP50: 50,\n      }\n\n      if (!validCodes[code]) {\n        return yield* Effect.fail(\n          new Error(`Discount code \"${code}\" is invalid`)\n        )\n      }\n\n      return code\n    })\n  )\n)\n\n// ============================================\n// 4. SignUp form with async validation\n// ============================================\n\nconst SignUpForm = Schema.Struct({\n  username: ValidUsername,\n  email: VerifiedEmail,\n  password: Schema.String.pipe(Schema.minLength(8)),\n  discountCode: Schema.optional(ValidDiscountCode),\n})\n\ntype SignUpForm = typeof SignUpForm.Type\n\n// ============================================\n// 5. Processing async validation\n// ============================================\n\nconst validateSignup = (\n  data: unknown\n): Effect.Effect<SignUpForm, Error> =>\n  Effect.gen(function* () {\n    console.log(\"Validating signup form...\")\n\n    const result = yield* Effect.tryPromise({\n      try: () => Schema.decodeUnknown(SignUpForm)(data),\n      catch: (error) => {\n        const msg = error instanceof Error ? error.message : String(error)\n        return new Error(`Validation failed: ${msg}`)\n      },\n    })\n\n    console.log(\"\u2705 All validations passed\")\n    return result\n  })\n\n// ============================================\n// 6. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Basic Async Validation ===\\n\")\n\n  console.log(\"1. Valid signup:\\n\")\n\n  const validData = {\n    username: \"alice_dev\",\n    email: \"alice@example.com\",\n    password: \"SecurePassword123\",\n    discountCode: \"WELCOME10\",\n  }\n\n  const result1 = yield* validateSignup(validData)\n  console.log(`\u2713 User: ${result1.username}`)\n  console.log(`\u2713 Email: ${result1.email}`)\n\n  console.log(\"\\n2. Invalid username (taken):\\n\")\n\n  const invalidUsername = {\n    username: \"admin\",\n    email: \"admin@example.com\",\n    password: \"SecurePassword123\",\n  }\n\n  const result2 = yield* validateSignup(invalidUsername).pipe(\n    Effect.either\n  )\n\n  if (result2._tag === \"Left\") {\n    console.log(`\u2717 Error: ${result2.left.message}`)\n  }\n\n  console.log(\"\\n3. Invalid email domain:\\n\")\n\n  const invalidEmail = {\n    username: \"bob_coder\",\n    email: \"bob@temp-mail.com\",\n    password: \"SecurePassword123\",\n  }\n\n  const result3 = yield* validateSignup(invalidEmail).pipe(\n    Effect.either\n  )\n\n  if (result3._tag === \"Left\") {\n    console.log(`\u2717 Error: ${result3.left.message}`)\n  }\n\n  console.log(\"\\n4. Invalid discount code:\\n\")\n\n  const invalidCode = {\n    username: \"charlie\",\n    email: \"charlie@example.com\",\n    password: \"SecurePassword123\",\n    discountCode: \"INVALID99\",\n  }\n\n  const result4 = yield* validateSignup(invalidCode).pipe(\n    Effect.either\n  )\n\n  if (result4._tag === \"Left\") {\n    console.log(`\u2717 Error: ${result4.left.message}`)\n  }\n\n  return result1\n})\n\nconst { Duration } = require(\"effect\")\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Async validation complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Basic Async Validation with Schema.filterEffect."
            },
            "created_at": "2026-02-16T21:39:15.710485",
            "updated_at": "2026-02-20T23:09:40.197058"
        },
        {
            "id": "6ef30f81-6c2b-4b43-b95f-8cdc951ef277",
            "slug": "schema-external-api-validation",
            "title": "External API Validation During Schema Parsing",
            "summary": "Your system integrates with external APIs (payment processor, geocoding, IP reputation). You need to validate user input against those services during parsing. A card must be valid with the payment...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "async-validation",
                "external-api",
                "integration",
                "third-party"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Simulated external APIs\n// ============================================\n\nclass PaymentGateway {\n  async validateCard(cardNumber: string): Promise<boolean> {\n    await new Promise((resolve) => setTimeout(resolve, 200))\n    // Simulate: cards starting with 4 are valid\n    return cardNumber.startsWith(\"4\")\n  }\n\n  async checkCardBalance(cardNumber: string): Promise<number> {\n    await new Promise((resolve) => setTimeout(resolve, 150))\n    return 5000\n  }\n}\n\nclass GeocodingService {\n  async validateAddress(address: string): Promise<boolean> {\n    await new Promise((resolve) => setTimeout(resolve, 300))\n    // Simulate: addresses with \"St.\" are valid\n    return address.includes(\"St.\")\n  }\n}\n\nclass SecurityService {\n  async checkIPReputation(ip: string): Promise<{ safe: boolean; score: number }> {\n    await new Promise((resolve) => setTimeout(resolve, 250))\n    // Simulate: IPs starting with 192 are suspicious\n    return {\n      safe: !ip.startsWith(\"192\"),\n      score: ip.startsWith(\"192\") ? 80 : 20,\n    }\n  }\n}\n\n// ============================================\n// 2. Create service instances\n// ============================================\n\nconst paymentGateway = new PaymentGateway()\nconst geocoding = new GeocodingService()\nconst security = new SecurityService()\n\n// ============================================\n// 3. Schemas with external validation\n// ============================================\n\nconst ValidCreditCard = Schema.String.pipe(\n  Schema.regex(/^\\d{16}$/),\n  Schema.filterEffect((cardNumber) =>\n    Effect.gen(function* () {\n      const isValid = yield* Effect.tryPromise({\n        try: () => paymentGateway.validateCard(cardNumber),\n        catch: () => false,\n      })\n\n      if (!isValid) {\n        return yield* Effect.fail(\n          new Error(`Credit card is invalid or not supported`)\n        )\n      }\n\n      return cardNumber\n    })\n  )\n)\n\nconst ValidShippingAddress = Schema.String.pipe(\n  Schema.minLength(10),\n  Schema.filterEffect((address) =>\n    Effect.gen(function* () {\n      const isValid = yield* Effect.tryPromise({\n        try: () => geocoding.validateAddress(address),\n        catch: () => false,\n      })\n\n      if (!isValid) {\n        return yield* Effect.fail(\n          new Error(`Address could not be validated by geocoding service`)\n        )\n      }\n\n      return address\n    })\n  )\n)\n\nconst SafeIPAddress = Schema.String.pipe(\n  Schema.regex(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/),\n  Schema.filterEffect((ip) =>\n    Effect.gen(function* () {\n      const reputation = yield* Effect.tryPromise({\n        try: () => security.checkIPReputation(ip),\n        catch: () => ({ safe: false, score: 100 }),\n      })\n\n      if (!reputation.safe) {\n        return yield* Effect.fail(\n          new Error(\n            `IP address flagged as suspicious (score: ${reputation.score}/100)`\n          )\n        )\n      }\n\n      return ip\n    })\n  )\n)\n\n// ============================================\n// 4. Forms with external validation\n// ============================================\n\nconst PaymentForm = Schema.Struct({\n  cardNumber: ValidCreditCard,\n  amount: Schema.Number.pipe(Schema.greaterThan(0)),\n  shippingAddress: ValidShippingAddress,\n})\n\nconst LoginForm = Schema.Struct({\n  email: Schema.String,\n  password: Schema.String,\n  userIp: SafeIPAddress,\n})\n\n// ============================================\n// 5. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== External API Validation ===\\n\")\n\n  console.log(\"1. Valid payment (card + address):\\n\")\n\n  const validPayment = {\n    cardNumber: \"4532123456789012\",\n    amount: 99.99,\n    shippingAddress: \"123 Main St.\",\n  }\n\n  const payment = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(PaymentForm)(validPayment),\n    catch: (e) => new Error(String(e)),\n  })\n\n  console.log(`\u2713 Payment processed`)\n  console.log(`  Card: ****${payment.cardNumber.slice(-4)}`)\n  console.log(`  Amount: $${payment.amount}`)\n  console.log(`  Address: ${payment.shippingAddress}`)\n\n  console.log(\"\\n2. Invalid credit card:\\n\")\n\n  const invalidCard = {\n    cardNumber: \"5532123456789012\",\n    amount: 50.0,\n    shippingAddress: \"456 Oak St.\",\n  }\n\n  const payment2 = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(PaymentForm)(invalidCard),\n    catch: (e) => new Error(String(e)),\n  }).pipe(Effect.either)\n\n  if (payment2._tag === \"Left\") {\n    console.log(`\u2717 Error: ${payment2.left.message}`)\n  }\n\n  console.log(\"\\n3. Valid login (safe IP):\\n\")\n\n  const validLogin = {\n    email: \"user@example.com\",\n    password: \"password123\",\n    userIp: \"203.0.113.45\",\n  }\n\n  const login = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(LoginForm)(validLogin),\n    catch: (e) => new Error(String(e)),\n  })\n\n  console.log(`\u2713 Login successful`)\n  console.log(`  User: ${login.email}`)\n  console.log(`  IP: ${login.userIp}`)\n\n  console.log(\"\\n4. Suspicious IP:\\n\")\n\n  const suspiciousLogin = {\n    email: \"attacker@example.com\",\n    password: \"wrong\",\n    userIp: \"192.168.1.1\",\n  }\n\n  const login2 = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(LoginForm)(suspiciousLogin),\n    catch: (e) => new Error(String(e)),\n  }).pipe(Effect.either)\n\n  if (login2._tag === \"Left\") {\n    console.log(`\u2717 Error: ${login2.left.message}`)\n  }\n\n  return { payment, login }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 External API validation complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "External API Validation During Schema Parsing."
            },
            "created_at": "2026-02-16T21:39:15.889122",
            "updated_at": "2026-02-20T23:09:40.253249"
        },
        {
            "id": "ebeced7f-b3d7-45a2-b49b-86fcae903c27",
            "slug": "schema-database-checks",
            "title": "Database Validation - Uniqueness, Foreign Keys, Constraints",
            "summary": "A username must be unique in the database. A product reference must exist. An email can't belong to two accounts. These database constraints can't be validated with sync schemas. You need async...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "async-validation",
                "database",
                "constraints",
                "uniqueness",
                "foreign-keys"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\nimport { Duration } from \"effect\"\n\n// ============================================\n// 1. Simulated database\n// ============================================\n\nclass Database {\n  private users = new Map<string, { id: string; username: string }>([\n    [\"user1\", { id: \"1\", username: \"alice\" }],\n    [\"user2\", { id: \"2\", username: \"bob\" }],\n  ])\n\n  private products = new Map<string, string>([\n    [\"prod1\", \"Laptop\"],\n    [\"prod2\", \"Monitor\"],\n  ])\n\n  async checkUsernameUnique(username: string): Promise<boolean> {\n    await new Promise((resolve) => setTimeout(resolve, 100))\n    return !Array.from(this.users.values()).some(\n      (u) => u.username === username\n    )\n  }\n\n  async productExists(id: string): Promise<boolean> {\n    await new Promise((resolve) => setTimeout(resolve, 50))\n    return this.products.has(id)\n  }\n\n  async checkEmailUnique(email: string): Promise<boolean> {\n    await new Promise((resolve) => setTimeout(resolve, 80))\n    // Simulated check\n    return !email.includes(\"taken\")\n  }\n\n  async validateForeignKey(\n    parentId: string,\n    table: string\n  ): Promise<boolean> {\n    await new Promise((resolve) => setTimeout(resolve, 100))\n    if (table === \"users\") return this.users.has(parentId)\n    if (table === \"products\") return this.products.has(parentId)\n    return false\n  }\n}\n\n// ============================================\n// 2. Create database service\n// ============================================\n\nconst db = new Database()\n\n// ============================================\n// 3. Schemas with database validation\n// ============================================\n\nconst UniqueUsername = Schema.String.pipe(\n  Schema.minLength(3),\n  Schema.filterEffect((username) =>\n    Effect.gen(function* () {\n      const isUnique = yield* Effect.tryPromise({\n        try: () => db.checkUsernameUnique(username),\n        catch: () => false,\n      })\n\n      if (!isUnique) {\n        return yield* Effect.fail(\n          new Error(`Username \"${username}\" is taken`)\n        )\n      }\n\n      return username\n    })\n  )\n)\n\nconst UniqueEmail = Schema.String.pipe(\n  Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/),\n  Schema.filterEffect((email) =>\n    Effect.gen(function* () {\n      const isUnique = yield* Effect.tryPromise({\n        try: () => db.checkEmailUnique(email),\n        catch: () => false,\n      })\n\n      if (!isUnique) {\n        return yield* Effect.fail(\n          new Error(`Email \"${email}\" already registered`)\n        )\n      }\n\n      return email\n    })\n  )\n)\n\nconst ExistingProduct = Schema.String.pipe(\n  Schema.filterEffect((productId) =>\n    Effect.gen(function* () {\n      const exists = yield* Effect.tryPromise({\n        try: () => db.productExists(productId),\n        catch: () => false,\n      })\n\n      if (!exists) {\n        return yield* Effect.fail(\n          new Error(`Product \"${productId}\" not found`)\n        )\n      }\n\n      return productId\n    })\n  )\n)\n\nconst ValidUserReference = Schema.String.pipe(\n  Schema.filterEffect((userId) =>\n    Effect.gen(function* () {\n      const exists = yield* Effect.tryPromise({\n        try: () => db.validateForeignKey(userId, \"users\"),\n        catch: () => false,\n      })\n\n      if (!exists) {\n        return yield* Effect.fail(\n          new Error(`User \"${userId}\" does not exist`)\n        )\n      }\n\n      return userId\n    })\n  )\n)\n\n// ============================================\n// 4. Forms with foreign keys\n// ============================================\n\nconst CreateOrderForm = Schema.Struct({\n  userId: ValidUserReference,\n  productId: ExistingProduct,\n  quantity: Schema.Number.pipe(Schema.int(), Schema.between(1, 100)),\n})\n\nconst CreateUserForm = Schema.Struct({\n  username: UniqueUsername,\n  email: UniqueEmail,\n  password: Schema.String.pipe(Schema.minLength(8)),\n})\n\n// ============================================\n// 5. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Database Validation ===\\n\")\n\n  console.log(\"1. Valid unique username:\\n\")\n\n  const validUser = {\n    username: \"charlie\",\n    email: \"charlie@example.com\",\n    password: \"SecurePass123\",\n  }\n\n  const user1 = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(CreateUserForm)(validUser),\n    catch: (e) => new Error(String(e)),\n  })\n\n  console.log(`\u2713 User created: ${user1.username}`)\n\n  console.log(\"\\n2. Duplicate username:\\n\")\n\n  const duplicateUser = {\n    username: \"alice\",\n    email: \"newalice@example.com\",\n    password: \"SecurePass123\",\n  }\n\n  const user2 = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(CreateUserForm)(duplicateUser),\n    catch: (e) => new Error(String(e)),\n  }).pipe(Effect.either)\n\n  if (user2._tag === \"Left\") {\n    console.log(`\u2717 Error: ${user2.left.message}`)\n  }\n\n  console.log(\"\\n3. Valid order with foreign keys:\\n\")\n\n  const validOrder = {\n    userId: \"user1\",\n    productId: \"prod1\",\n    quantity: 5,\n  }\n\n  const order = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(CreateOrderForm)(validOrder),\n    catch: (e) => new Error(String(e)),\n  })\n\n  console.log(`\u2713 Order created for user ${order.userId}`)\n  console.log(`  Product: ${order.productId}, Quantity: ${order.quantity}`)\n\n  console.log(\"\\n4. Invalid product reference:\\n\")\n\n  const invalidOrder = {\n    userId: \"user1\",\n    productId: \"prod999\",\n    quantity: 2,\n  }\n\n  const order2 = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(CreateOrderForm)(invalidOrder),\n    catch: (e) => new Error(String(e)),\n  }).pipe(Effect.either)\n\n  if (order2._tag === \"Left\") {\n    console.log(`\u2717 Error: ${order2.left.message}`)\n  }\n\n  return { user1, order }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Database validation complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Database Validation - Uniqueness, Foreign Keys, Constraints using Schema."
            },
            "created_at": "2026-02-16T21:39:16.054043",
            "updated_at": "2026-02-20T23:09:40.29439"
        },
        {
            "id": "6d8cecc0-2cfb-43ba-b55f-83ee3ae106b6",
            "slug": "schema-web-standards-email",
            "title": "Email Address Validation",
            "summary": "You're accepting email addresses from user input or API requests. A simple `string` type tells you nothing\u2014users submit \"not-an-email\", \"@@invalid\", or empty strings. You need validation that checks...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "validation",
                "web-standards",
                "email",
                "branded-types",
                "user-input"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. Define branded Email type with validation\nconst Email = Schema.String.pipe(\n  Schema.trimmed(),\n  Schema.minLength(5),\n  Schema.maxLength(254),\n  Schema.pattern(\n    /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  ).pipe(\n    Schema.annotations({\n      description: \"Valid email format (local@domain.tld)\",\n    })\n  ),\n  Schema.brand(\"Email\")\n)\n\ntype Email = typeof Email.Type\n\n// 2. Create parser\nconst parseEmail = Schema.decodeUnknown(Email)\n\n// 3. Use in request schemas\nconst CreateUserRequest = Schema.Struct({\n  name: Schema.String,\n  email: Email,\n  password: Schema.String.pipe(Schema.minLength(8)),\n})\n\ntype CreateUserRequest = typeof CreateUserRequest.Type\n\n// 4. Validate and use\nconst createUser = (input: unknown) =>\n  Effect.gen(function* () {\n    const request = yield* Schema.decodeUnknown(\n      CreateUserRequest\n    )(input).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ValidationError\" as const,\n        message: `Invalid request: ${error.message}`,\n      }))\n    )\n\n    // TypeScript knows request.email is Email, not string\n    const confirmEmail = (email: Email) => {\n      console.log(`Sending confirmation to ${email}`)\n    }\n\n    yield* Effect.sync(() => confirmEmail(request.email))\n    return { success: true, email: request.email }\n  })\n\n// Usage\nconst userInput = {\n  name: \"Alice\",\n  email: \"alice@example.com\",\n  password: \"securepass123\",\n}\n\nEffect.runPromise(createUser(userInput))\n  .then((result) => console.log(result))\n  .catch((error) =>\n    console.error(`Error: ${error.message}`)\n  )",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Email Address Validation using Schema."
            },
            "created_at": "2026-02-16T21:39:12.238049",
            "updated_at": "2026-02-20T23:09:39.238467"
        },
        {
            "id": "a4454ce3-c2cc-4279-b47e-eef93d3b5f10",
            "slug": "schema-web-standards-uuid",
            "title": "UUID Validation (v4, v7)",
            "summary": "Your API accepts IDs as strings, but there's no validation that they're actually valid UUIDs. Users submit malformed IDs, truncated strings, or wrong formats. You need to validate UUID format at...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "validation",
                "web-standards",
                "uuid",
                "identifiers",
                "branded-types"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. Define UUID v4 validator\nconst UUIDv4 = Schema.String.pipe(\n  Schema.pattern(\n    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\n  ).pipe(\n    Schema.annotations({\n      description: \"Valid UUID v4 (36 chars with hyphens)\",\n    })\n  ),\n  Schema.brand(\"UUIDv4\")\n)\n\ntype UUIDv4 = typeof UUIDv4.Type\n\n// 2. Define UUID v7 validator (sortable)\nconst UUIDv7 = Schema.String.pipe(\n  Schema.pattern(\n    /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\n  ).pipe(\n    Schema.annotations({\n      description: \"Valid UUID v7 (time-based, sortable)\",\n    })\n  ),\n  Schema.brand(\"UUIDv7\")\n)\n\ntype UUIDv7 = typeof UUIDv7.Type\n\n// 3. Union of both versions\nconst UUID = Schema.Union(UUIDv4, UUIDv7).pipe(\n  Schema.brand(\"UUID\")\n)\n\ntype UUID = typeof UUID.Type\n\n// 4. Use in resource schemas\nconst UserProfile = Schema.Struct({\n  id: UUIDv4,\n  organizationId: UUID,\n  createdAt: Schema.String,\n  name: Schema.String,\n})\n\ntype UserProfile = typeof UserProfile.Type\n\n// 5. Fetch and validate resource\nconst getUserProfile = (userId: unknown) =>\n  Effect.gen(function* () {\n    const id = yield* Schema.decodeUnknown(UUIDv4)(userId).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"InvalidId\" as const,\n        message: `Invalid user ID: ${error.message}`,\n      }))\n    )\n\n    // Fetch from database using validated UUID\n    console.log(`Fetching user: ${id}`)\n\n    // Simulate DB response\n    const profile: UserProfile = {\n      id,\n      organizationId:\n        \"550e8400-e29b-41d4-a716-446655440000\" as UUID,\n      createdAt: \"2024-01-15T10:30:00Z\",\n      name: \"Alice\",\n    }\n\n    return profile\n  })\n\n// 6. Generate and validate UUIDs\nconst createResourceId = () =>\n  Effect.gen(function* () {\n    // Generate UUID v4 (random)\n    const v4 = crypto.randomUUID() as string\n\n    // Validate it matches schema\n    const validated = yield* Schema.decodeUnknown(UUIDv4)(\n      v4\n    ).pipe(\n      Effect.catchTag(\"ParseError\", (error) =>\n        Effect.fail(new Error(`Generated invalid UUID: ${error}`))\n      )\n    )\n\n    return validated\n  })\n\n// Usage\nEffect.runPromise(\n  getUserProfile(\"f47ac10b-58cc-4372-a567-0e02b2c3d479\")\n)\n  .then((profile) => {\n    console.log(`User: ${profile.name}`)\n  })\n  .catch((error) =>\n    console.error(`Error: ${error.message}`)\n  )\n\n// Generate new ID\nEffect.runPromise(createResourceId())\n  .then((id) => console.log(`New resource: ${id}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "UUID Validation (v4, v7) using Schema."
            },
            "created_at": "2026-02-16T21:39:12.405602",
            "updated_at": "2026-02-20T23:09:39.28334"
        },
        {
            "id": "ae242343-5a56-4f19-b48e-2a8f8cd96a31",
            "slug": "error-handling-recovery-strategies",
            "title": "Error Recovery and Fallback Strategies",
            "summary": "An API call fails. Retry immediately\u2014it works the second time. But retry too fast and you overload the system. Wait too long and users think the app is broken. Network hiccups, temporary outages,...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "error-handling",
                "recovery",
                "fallbacks",
                "retry",
                "resilience",
                "backoff"
            ],
            "examples": [
                {
                    "code": "import { Effect, Duration, Data } from \"effect\"\n\n// ============================================\n// 1. Define domain errors\n// ============================================\n\nclass NetworkError extends Data.TaggedError(\"NetworkError\") {\n  constructor(readonly message: string) {\n    super()\n  }\n}\n\nclass TimeoutError extends Data.TaggedError(\"TimeoutError\") {\n  constructor(readonly durationMs: number) {\n    super()\n  }\n}\n\nclass RateLimitError extends Data.TaggedError(\"RateLimitError\") {\n  constructor(readonly retryAfterMs: number) {\n    super()\n  }\n}\n\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\") {\n  constructor(readonly resource: string) {\n    super()\n  }\n}\n\n// ============================================\n// 2. Retry with exponential backoff\n// ============================================\n\nconst retryWithBackoff = <A, E, R>(\n  effect: Effect.Effect<A, E, R>,\n  options: {\n    maxRetries: number\n    initialDelayMs: number\n    maxDelayMs: number\n  }\n): Effect.Effect<A, E, R> => {\n  const attempt = (retriesLeft: number, currentDelayMs: number): Effect.Effect<A, E, R> =>\n    effect.pipe(\n      Effect.catchAll((error) => {\n        if (retriesLeft === 0) {\n          return Effect.fail(error)\n        }\n\n        const nextDelay = Math.min(\n          currentDelayMs * 2,\n          options.maxDelayMs\n        )\n\n        console.log(\n          `\u23f3 Retry attempt ${options.maxRetries - retriesLeft + 1}/${options.maxRetries}, waiting ${currentDelayMs}ms...`\n        )\n\n        return Effect.gen(function* () {\n          yield* Effect.sleep(Duration.millis(currentDelayMs))\n          return yield* attempt(retriesLeft - 1, nextDelay)\n        })\n      })\n    )\n\n  return attempt(options.maxRetries, options.initialDelayMs)\n}\n\n// ============================================\n// 3. Timeout wrapper\n// ============================================\n\nconst withTimeout = <A, E, R>(\n  effect: Effect.Effect<A, E, R>,\n  timeoutMs: number\n): Effect.Effect<A, TimeoutError | E, R> =>\n  effect.pipe(\n    Effect.timeout(Duration.millis(timeoutMs)),\n    Effect.mapError((option) =>\n      option._tag === \"None\"\n        ? new TimeoutError(timeoutMs)\n        : option.value as TimeoutError | E\n    )\n  )\n\n// ============================================\n// 4. Fallback with defaults\n// ============================================\n\nconst withFallback = <A, E, R>(\n  effect: Effect.Effect<A, E, R>,\n  fallbackValue: A,\n  shouldUseFallback?: (error: E) => boolean\n): Effect.Effect<A, never, R> =>\n  effect.pipe(\n    Effect.catchAll((error) => {\n      if (shouldUseFallback && !shouldUseFallback(error)) {\n        return Effect.fail(error)\n      }\n      console.log(\"\u26a0\ufe0f Using fallback value due to error\")\n      return Effect.succeed(fallbackValue)\n    })\n  )\n\n// ============================================\n// 5. Recovery by error type\n// ============================================\n\nconst withRecovery = <A, E, R>(\n  effect: Effect.Effect<A, E, R>,\n  handlers: {\n    [K in E as E[\"_tag\"]]?: (error: Extract<E, { _tag: K }>) => Effect.Effect<A, E, R>\n  }\n): Effect.Effect<A, E, R> =>\n  effect.pipe(\n    Effect.catchAll((error: E) => {\n      const handler = handlers[error._tag as E[\"_tag\"]]\n      if (handler) {\n        return (handler as any)(error)\n      }\n      return Effect.fail(error)\n    })\n  )\n\n// ============================================\n// 6. Simulate external service\n// ============================================\n\nlet callCount = 0\n\nconst fetchUserData = (id: string): Effect.Effect<{ id: string; name: string }, NetworkError> =>\n  Effect.gen(function* () {\n    callCount++\n\n    // Fail first 2 times, succeed on 3rd\n    if (callCount <= 2) {\n      console.log(`  Attempt ${callCount}: Network error`)\n      return yield* Effect.fail(new NetworkError(\"Connection refused\"))\n    }\n\n    console.log(`  Attempt ${callCount}: Success`)\n    return { id, name: \"Alice\" }\n  })\n\nconst fetchUserPreferences = (\n  id: string\n): Effect.Effect<{ theme: string; language: string }, TimeoutError> =>\n  Effect.gen(function* () {\n    // Simulate timeout\n    yield* Effect.sleep(Duration.millis(100))\n    console.log(\"\u23f1\ufe0f Request timed out\")\n    return yield* Effect.fail(new TimeoutError(5000))\n  })\n\nconst fetchUserAnalytics = (id: string): Effect.Effect<{ visits: number }, NotFoundError> =>\n  Effect.gen(function* () {\n    console.log(\"\ud83d\udcca Analytics not found for user\")\n    return yield* Effect.fail(new NotFoundError(id))\n  })\n\n// ============================================\n// 7. Compose recovery strategies\n// ============================================\n\nconst getFullUserProfile = (id: string) =>\n  Effect.gen(function* () {\n    // 1. Fetch user data with retry + timeout\n    const userData = yield* Effect.gen(function* () {\n      const withBackoff = retryWithBackoff(fetchUserData(id), {\n        maxRetries: 3,\n        initialDelayMs: 100,\n        maxDelayMs: 1000,\n      })\n\n      return yield* withTimeout(withBackoff, 10000)\n    })\n\n    console.log(`\u2705 Got user data: ${userData.name}`)\n\n    // 2. Fetch preferences with timeout + fallback\n    const preferences = yield* Effect.gen(function* () {\n      const withTimeoutEffect = withTimeout(fetchUserPreferences(id), 5000)\n\n      return yield* withFallback(\n        withTimeoutEffect,\n        { theme: \"light\", language: \"en\" }\n      )\n    })\n\n    console.log(`\u2705 Got preferences with fallback:`, preferences)\n\n    // 3. Fetch analytics with error-specific recovery\n    const analytics = yield* fetchUserAnalytics(id).pipe(\n      Effect.catchTags({\n        NotFoundError: () => {\n          console.log(\"\u26a0\ufe0f No analytics available, using defaults\")\n          return Effect.succeed({ visits: 0 })\n        },\n      })\n    )\n\n    console.log(`\u2705 Got analytics:`, analytics)\n\n    return {\n      user: userData,\n      preferences,\n      analytics,\n    }\n  })\n\n// ============================================\n// 8. Circuit breaker pattern\n// ============================================\n\ntype CircuitBreakerState = \"closed\" | \"open\" | \"half-open\"\n\nclass CircuitBreaker {\n  private state: CircuitBreakerState = \"closed\"\n  private failureCount = 0\n  private readonly failureThreshold = 3\n  private lastOpenTime = 0\n  private readonly resetTimeoutMs = 5000\n\n  execute<A, E, R>(\n    effect: Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E | NetworkError, R> {\n    if (this.state === \"open\") {\n      if (Date.now() - this.lastOpenTime > this.resetTimeoutMs) {\n        this.state = \"half-open\"\n        console.log(\"\ud83d\udd04 Circuit breaker: half-open (testing)\")\n      } else {\n        return Effect.fail(\n          new NetworkError(\"Circuit breaker is open\")\n        ) as Effect.Effect<A, E | NetworkError, R>\n      }\n    }\n\n    return effect.pipe(\n      Effect.catchAll((error) => {\n        this.failureCount++\n\n        if (this.failureCount >= this.failureThreshold) {\n          this.state = \"open\"\n          this.lastOpenTime = Date.now()\n          console.log(\"\ud83d\udd34 Circuit breaker: open (too many failures)\")\n        }\n\n        return Effect.fail(error)\n      }),\n      Effect.tap(() => {\n        if (this.state === \"half-open\") {\n          this.state = \"closed\"\n          this.failureCount = 0\n          console.log(\"\ud83d\udfe2 Circuit breaker: closed (recovered)\")\n        }\n      })\n    )\n  }\n}\n\n// ============================================\n// 9. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Retry with Exponential Backoff ===\\n\")\n  callCount = 0\n\n  const profile = yield* getFullUserProfile(\"user_123\")\n\n  console.log(\"\\n\u2705 Full profile:\", profile)\n\n  console.log(\"\\n=== Circuit Breaker ===\\n\")\n\n  const breaker = new CircuitBreaker()\n\n  for (let i = 0; i < 5; i++) {\n    const result = yield* breaker.execute(\n      Effect.fail(new NetworkError(\"Service down\")).pipe(\n        Effect.either\n      )\n    )\n\n    if (result._tag === \"Left\") {\n      console.log(`Request ${i + 1}: Failed -`, result.left.message)\n    }\n  }\n\n  return profile\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Recovery strategies complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Error Recovery and Fallback Strategies using Schema."
            },
            "created_at": "2026-02-16T21:39:16.740474",
            "updated_at": "2026-02-20T23:09:40.479988"
        },
        {
            "id": "f6355eee-7d0d-4376-88b7-f14602fa6871",
            "slug": "schema-discriminated-unions",
            "title": "Discriminated Unions with Type Narrowing",
            "summary": "You have a union of different event types. Without a discriminator field, checking which type it is means examining multiple fields or using instanceof checks. With a `_tag` or `type` discriminator,...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "discriminated-unions",
                "tagged-unions",
                "type-narrowing",
                "pattern-matching"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Define discriminated union with _tag\n// ============================================\n\nconst UserCreatedEvent = Schema.Struct({\n  _tag: Schema.Literal(\"UserCreated\"),\n  userId: Schema.String,\n  email: Schema.String,\n  createdAt: Schema.Date,\n})\n\nconst UserDeletedEvent = Schema.Struct({\n  _tag: Schema.Literal(\"UserDeleted\"),\n  userId: Schema.String,\n  deletedAt: Schema.Date,\n  reason: Schema.String,\n})\n\nconst UserEmailChangedEvent = Schema.Struct({\n  _tag: Schema.Literal(\"UserEmailChanged\"),\n  userId: Schema.String,\n  oldEmail: Schema.String,\n  newEmail: Schema.String,\n  verificationRequired: Schema.Boolean,\n})\n\nconst UserEvent = Schema.Union(\n  UserCreatedEvent,\n  UserDeletedEvent,\n  UserEmailChangedEvent\n)\n\ntype UserEvent = typeof UserEvent.Type\n\n// ============================================\n// 2. More complex discriminated unions\n// ============================================\n\nconst OrderPlacedEvent = Schema.Struct({\n  _tag: Schema.Literal(\"OrderPlaced\"),\n  orderId: Schema.String,\n  customerId: Schema.String,\n  items: Schema.Array(\n    Schema.Struct({\n      productId: Schema.String,\n      quantity: Schema.Number,\n      price: Schema.Number,\n    })\n  ),\n  totalAmount: Schema.Number,\n  timestamp: Schema.Date,\n})\n\nconst OrderShippedEvent = Schema.Struct({\n  _tag: Schema.Literal(\"OrderShipped\"),\n  orderId: Schema.String,\n  trackingNumber: Schema.String,\n  carrier: Schema.String,\n  estimatedDelivery: Schema.Date,\n})\n\nconst OrderCancelledEvent = Schema.Struct({\n  _tag: Schema.Literal(\"OrderCancelled\"),\n  orderId: Schema.String,\n  reason: Schema.String,\n  refundAmount: Schema.Number,\n  refundProcessedAt: Schema.Date,\n})\n\nconst OrderEvent = Schema.Union(\n  OrderPlacedEvent,\n  OrderShippedEvent,\n  OrderCancelledEvent\n)\n\ntype OrderEvent = typeof OrderEvent.Type\n\n// ============================================\n// 3. Type-safe event handling\n// ============================================\n\nconst handleUserEvent = (event: UserEvent): string => {\n  // After switch on _tag, TypeScript narrows the type automatically\n  switch (event._tag) {\n    case \"UserCreated\":\n      // event is now UserCreatedEvent\n      return `\ud83d\udc64 User created: ${event.email} (${event.userId})`\n\n    case \"UserDeleted\":\n      // event is now UserDeletedEvent\n      return `\ud83d\uddd1\ufe0f User deleted: ${event.userId}. Reason: ${event.reason}`\n\n    case \"UserEmailChanged\":\n      // event is now UserEmailChangedEvent\n      const verify = event.verificationRequired ? \" (verification required)\" : \"\"\n      return `\ud83d\udce7 Email changed: ${event.oldEmail} \u2192 ${event.newEmail}${verify}`\n  }\n}\n\nconst handleOrderEvent = (event: OrderEvent): string => {\n  switch (event._tag) {\n    case \"OrderPlaced\":\n      const itemCount = event.items.length\n      return `\ud83d\udce6 Order placed: ${event.orderId} ($${event.totalAmount}) - ${itemCount} items`\n\n    case \"OrderShipped\":\n      return `\ud83d\ude9a Shipped via ${event.carrier}: ${event.trackingNumber}`\n\n    case \"OrderCancelled\":\n      return `\u274c Cancelled - Refund $${event.refundAmount}`\n  }\n}\n\n// ============================================\n// 4. Effect-based event processing\n// ============================================\n\nconst processUserEventEffect = (\n  event: UserEvent\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    switch (event._tag) {\n      case \"UserCreated\":\n        yield* Effect.log(`Creating user ${event.userId}`)\n        yield* Effect.log(`Sending welcome email to ${event.email}`)\n        break\n\n      case \"UserDeleted\":\n        yield* Effect.log(`Archiving user data for ${event.userId}`)\n        yield* Effect.log(`Reason: ${event.reason}`)\n        break\n\n      case \"UserEmailChanged\":\n        yield* Effect.log(`Updating email in database`)\n        if (event.verificationRequired) {\n          yield* Effect.log(`Sending verification email to ${event.newEmail}`)\n        } else {\n          yield* Effect.log(`Email verified during signup`)\n        }\n        break\n    }\n  })\n\n// ============================================\n// 5. Event sourcing with discriminated unions\n// ============================================\n\nclass EventStore {\n  private events: UserEvent[] = []\n\n  append(event: UserEvent): void {\n    this.events.push(event)\n    console.log(`\ud83d\udcdd Event recorded: ${handleUserEvent(event)}`)\n  }\n\n  getByTag(tag: UserEvent[\"_tag\"]): UserEvent[] {\n    return this.events.filter((e) => e._tag === tag)\n  }\n\n  getUserHistory(userId: string): UserEvent[] {\n    return this.events.filter((e) => {\n      switch (e._tag) {\n        case \"UserCreated\":\n          return e.userId === userId\n        case \"UserDeleted\":\n          return e.userId === userId\n        case \"UserEmailChanged\":\n          return e.userId === userId\n      }\n    })\n  }\n\n  replay(): Effect.Effect<void> {\n    return Effect.gen(function* () {\n      for (const event of this.events) {\n        yield* processUserEventEffect(event)\n      }\n    })\n  }\n}\n\n// ============================================\n// 6. Parsing discriminated unions\n// ============================================\n\nconst parseEvent = (\n  raw: unknown,\n  eventType: \"user\" | \"order\"\n): Effect.Effect<UserEvent | OrderEvent, Error> =>\n  Effect.tryPromise({\n    try: async () => {\n      const schema = eventType === \"user\" ? UserEvent : OrderEvent\n      return await Schema.decodeUnknown(schema)(raw)\n    },\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Failed to parse event: ${msg}`)\n    },\n  })\n\n// ============================================\n// 7. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== User Events ===\\n\")\n\n  // Create and process user events\n  const store = new EventStore()\n\n  const userCreated: UserEvent = {\n    _tag: \"UserCreated\",\n    userId: \"user_123\",\n    email: \"alice@example.com\",\n    createdAt: new Date(\"2025-12-01\"),\n  }\n\n  store.append(userCreated)\n  yield* processUserEventEffect(userCreated)\n\n  const emailChanged: UserEvent = {\n    _tag: \"UserEmailChanged\",\n    userId: \"user_123\",\n    oldEmail: \"alice@example.com\",\n    newEmail: \"alice.smith@example.com\",\n    verificationRequired: true,\n  }\n\n  store.append(emailChanged)\n  yield* processUserEventEffect(emailChanged)\n\n  const userDeleted: UserEvent = {\n    _tag: \"UserDeleted\",\n    userId: \"user_123\",\n    deletedAt: new Date(),\n    reason: \"User requested account deletion\",\n  }\n\n  store.append(userDeleted)\n  yield* processUserEventEffect(userDeleted)\n\n  console.log(\"\\n=== Order Events ===\\n\")\n\n  // Parse order events\n  const orderPlacedData = {\n    _tag: \"OrderPlaced\",\n    orderId: \"ord_456\",\n    customerId: \"cust_789\",\n    items: [\n      { productId: \"prod_1\", quantity: 2, price: 49.99 },\n      { productId: \"prod_2\", quantity: 1, price: 99.99 },\n    ],\n    totalAmount: 199.97,\n    timestamp: new Date(),\n  }\n\n  const orderPlaced = yield* parseEvent(orderPlacedData, \"order\")\n  console.log(handleOrderEvent(orderPlaced as OrderEvent))\n\n  const orderShippedData = {\n    _tag: \"OrderShipped\",\n    orderId: \"ord_456\",\n    trackingNumber: \"1Z999AA10123456784\",\n    carrier: \"UPS\",\n    estimatedDelivery: new Date(\"2025-12-25\"),\n  }\n\n  const orderShipped = yield* parseEvent(orderShippedData, \"order\")\n  console.log(handleOrderEvent(orderShipped as OrderEvent))\n\n  console.log(\"\\n=== Event History ===\\n\")\n\n  // Show history for user\n  const history = store.getUserHistory(\"user_123\")\n  console.log(`Events for user_123: ${history.length}`)\n  for (const event of history) {\n    console.log(`  - ${handleUserEvent(event)}`)\n  }\n\n  return { store, history }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Event sourcing complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Discriminated Unions with Type Narrowing using Schema."
            },
            "created_at": "2026-02-16T21:39:17.274851",
            "updated_at": "2026-02-20T23:09:40.624741"
        },
        {
            "id": "9d6781e3-84d2-4dd5-87b0-82b03bfd25d7",
            "slug": "schema-data-normalization",
            "title": "Data Normalization and Canonical Forms",
            "summary": "Raw data is messy: extra whitespace, inconsistent casing, duplicates, mixed formats. You receive product names with leading/trailing spaces, emails in different cases, phone numbers with various...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "normalization",
                "data-cleaning",
                "canonical-form",
                "deduplication",
                "formatting"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. String normalization transformations\n// ============================================\n\n// Trim whitespace\nconst Trimmed = Schema.transform(Schema.String, Schema.String, {\n  decode: (input) => input.trim(),\n  encode: (output) => output,\n})\n\n// Lowercase normalization\nconst Lowercase = Schema.transform(Schema.String, Schema.String, {\n  decode: (input) => input.toLowerCase(),\n  encode: (output) => output,\n})\n\n// Uppercase normalization\nconst Uppercase = Schema.transform(Schema.String, Schema.String, {\n  decode: (input) => input.toUpperCase(),\n  encode: (output) => output,\n})\n\n// Title case normalization\nconst TitleCase = Schema.transform(Schema.String, Schema.String, {\n  decode: (input) =>\n    input\n      .toLowerCase()\n      .split(\" \")\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(\" \"),\n  encode: (output) => output,\n})\n\n// ============================================\n// 2. Email normalization (trim + lowercase)\n// ============================================\n\nconst Email = Schema.String.pipe(\n  Schema.transform(Schema.String, Schema.String, {\n    decode: (input) => input.trim().toLowerCase(),\n    encode: (output) => output,\n  }),\n  Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/),\n  Schema.brand(\"Email\")\n)\n\ntype Email = typeof Email.Type\n\n// ============================================\n// 3. Phone number normalization (remove non-digits, format)\n// ============================================\n\nconst PhoneNumber = Schema.transform(\n  Schema.String,\n  Schema.String,\n  {\n    decode: (input) => {\n      // Remove all non-digit characters\n      const digits = input.replace(/\\D/g, \"\")\n\n      // Validate length\n      if (digits.length < 10) {\n        throw new Error(\"Phone number must have at least 10 digits\")\n      }\n\n      // Format as (XXX) XXX-XXXX for 10 digits, or country code format\n      if (digits.length === 10) {\n        return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`\n      }\n\n      // For longer numbers, keep as is\n      return digits\n    },\n    encode: (output) => output,\n  }\n)\n\n// ============================================\n// 4. URL normalization (lowercase, trailing slash)\n// ============================================\n\nconst NormalizedUrl = Schema.transform(\n  Schema.String,\n  Schema.String,\n  {\n    decode: (input) => {\n      let url = input.toLowerCase()\n      // Remove trailing slash for consistency\n      if (url.endsWith(\"/\") && url.length > 1) {\n        url = url.slice(0, -1)\n      }\n      return url\n    },\n    encode: (output) => output,\n  }\n)\n\n// ============================================\n// 5. Tag/category normalization (trim, lowercase, deduplication)\n// ============================================\n\nconst Tags = Schema.transform(\n  Schema.Array(Schema.String),\n  Schema.Array(Schema.String),\n  {\n    decode: (input) => {\n      // Trim each tag, lowercase, remove duplicates\n      const normalized = Array.from(\n        new Set(\n          input\n            .map((tag) => tag.trim().toLowerCase())\n            .filter((tag) => tag.length > 0)\n        )\n      )\n      return normalized.sort() // Sort for canonical order\n    },\n    encode: (output) => output,\n  }\n)\n\n// ============================================\n// 6. Complex entity normalization\n// ============================================\n\nconst Product = Schema.Struct({\n  name: TitleCase,\n  sku: Uppercase,\n  email: Email,\n  website: NormalizedUrl,\n  tags: Tags,\n})\n\ntype Product = typeof Product.Type\n\n// ============================================\n// 7. Address normalization\n// ============================================\n\nconst Address = Schema.Struct({\n  street: Schema.transform(Schema.String, Schema.String, {\n    decode: (input) => input.trim().toUpperCase(),\n    encode: (output) => output,\n  }),\n  city: TitleCase,\n  state: Uppercase.pipe(Schema.maxLength(2)),\n  zip: Schema.transform(Schema.String, Schema.String, {\n    decode: (input) => input.replace(/\\D/g, \"\"), // Only digits\n    encode: (output) => output,\n  }),\n})\n\ntype Address = typeof Address.Type\n\n// ============================================\n// 8. Data normalization service\n// ============================================\n\nclass NormalizationService {\n  normalizeProduct = Schema.decodeUnknown(Product)\n  normalizeAddress = Schema.decodeUnknown(Address)\n\n  async normalizeEmail(email: string): Promise<Email> {\n    return Schema.decodeUnknown(Email)(email)\n  }\n\n  async normalizePhoneNumber(phone: string): Promise<string> {\n    return Schema.decodeUnknown(PhoneNumber)(phone)\n  }\n\n  async normalizeUrl(url: string): Promise<string> {\n    return Schema.decodeUnknown(NormalizedUrl)(url)\n  }\n\n  async normalizeTags(tags: string[]): Promise<string[]> {\n    return Schema.decodeUnknown(Tags)(tags)\n  }\n}\n\n// ============================================\n// 9. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  const normalizer = new NormalizationService()\n\n  // Messy product data from form/API\n  const messyProduct = {\n    name: \"  awesome widget  \",\n    sku: \"abc-123-xyz\",\n    email: \"  SALES@EXAMPLE.COM  \",\n    website: \"https://example.com/products/\",\n    tags: [\"electronics\", \"GADGETS\", \"electronics\", \"  fun  \"],\n  }\n\n  console.log(\"\ud83d\udce5 Raw input:\", messyProduct)\n\n  // Normalize product\n  const normalizedProduct = yield* Effect.tryPromise({\n    try: () => normalizer.normalizeProduct(messyProduct),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Normalization failed: ${msg}`)\n    },\n  })\n\n  console.log(\"\\n\u2705 Normalized product:\", normalizedProduct)\n\n  // Normalize individual fields\n  const normalizedPhone = yield* Effect.tryPromise({\n    try: () => normalizer.normalizePhoneNumber(\"(555) 123-4567\"),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Phone normalization failed: ${msg}`)\n    },\n  })\n\n  console.log(`\\n\ud83d\udcde Normalized phone: ${normalizedPhone}`)\n\n  // Normalize address\n  const messyAddress = {\n    street: \"  123 main street  \",\n    city: \"new york\",\n    state: \"ny\",\n    zip: \"10001-5432\",\n  }\n\n  const normalizedAddress = yield* Effect.tryPromise({\n    try: () => normalizer.normalizeAddress(messyAddress),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Address normalization failed: ${msg}`)\n    },\n  })\n\n  console.log(`\\n\ud83d\udccd Normalized address:`, normalizedAddress)\n\n  // Normalize tags with deduplication\n  const normalizedTags = yield* Effect.tryPromise({\n    try: () =>\n      normalizer.normalizeTags([\"Tech\", \"  gadgets  \", \"TECH\", \"cool\"]),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Tags normalization failed: ${msg}`)\n    },\n  })\n\n  console.log(`\\n\ud83c\udff7\ufe0f Normalized tags:`, normalizedTags)\n\n  return { normalizedProduct, normalizedAddress, normalizedTags }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 All data normalized\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Data Normalization and Canonical Forms using Schema."
            },
            "created_at": "2026-02-16T21:39:13.622484",
            "updated_at": "2026-02-20T23:09:39.600796"
        },
        {
            "id": "273fcd2e-96b9-40b6-bb85-7ba7b808c8c6",
            "slug": "error-handling-tagged-errors",
            "title": "Custom Tagged Errors",
            "summary": "Your application throws generic `Error` objects. When calling a function, you don't know what errors it might throw. Is it a validation error? Network timeout? Permission denied? Code that calls your...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "error-handling",
                "tagged-errors",
                "type-safety",
                "error-types",
                "discriminated-unions"
            ],
            "examples": [
                {
                    "code": "import { Data, Effect } from \"effect\"\n\n// ============================================\n// 1. Define custom tagged errors\n// ============================================\n\n// Simple tagged error\nclass ValidationError extends Data.TaggedError(\"ValidationError\") {\n  constructor(readonly field: string, readonly message: string) {\n    super()\n  }\n}\n\n// Network-related errors\nclass NetworkError extends Data.TaggedError(\"NetworkError\") {\n  constructor(readonly message: string, readonly statusCode?: number) {\n    super()\n  }\n}\n\nclass TimeoutError extends Data.TaggedError(\"TimeoutError\") {\n  constructor(readonly durationMs: number) {\n    super()\n  }\n}\n\n// Authorization errors\nclass UnauthorizedError extends Data.TaggedError(\"UnauthorizedError\") {\n  constructor(readonly reason: string) {\n    super()\n  }\n}\n\nclass ForbiddenError extends Data.TaggedError(\"ForbiddenError\") {\n  constructor(readonly resource: string, readonly action: string) {\n    super()\n  }\n}\n\n// Domain-specific errors\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\") {\n  constructor(readonly userId: string) {\n    super()\n  }\n}\n\nclass InsufficientBalanceError extends Data.TaggedError(\"InsufficientBalanceError\") {\n  constructor(readonly required: number, readonly available: number) {\n    super()\n  }\n}\n\n// ============================================\n// 2. Use tagged errors in effects\n// ============================================\n\nconst fetchUser = (\n  id: string\n): Effect.Effect<{ id: string; name: string }, UserNotFoundError | NetworkError> =>\n  Effect.gen(function* () {\n    if (!id) {\n      return yield* Effect.fail(new UserNotFoundError(id))\n    }\n\n    // Simulate network call\n    const response = yield* Effect.tryPromise({\n      try: () => fetch(`/api/users/${id}`),\n      catch: () => new NetworkError(\"Failed to reach server\"),\n    })\n\n    if (!response.ok) {\n      return yield* Effect.fail(new UserNotFoundError(id))\n    }\n\n    return yield* Effect.tryPromise({\n      try: () => response.json(),\n      catch: () => new NetworkError(\"Invalid response format\"),\n    })\n  })\n\nconst validateEmail = (email: string): Effect.Effect<string, ValidationError> =>\n  Effect.sync(() => {\n    if (!email.includes(\"@\")) {\n      return Effect.fail(new ValidationError(\"email\", \"Must contain @\"))\n    }\n    return email\n  }).pipe(Effect.flatMap(Effect.succeed))\n\nconst processPayment = (\n  userId: string,\n  amount: number\n): Effect.Effect<\n  { success: boolean },\n  UnauthorizedError | InsufficientBalanceError | NetworkError\n> =>\n  Effect.gen(function* () {\n    // Validate authorization\n    if (!userId) {\n      return yield* Effect.fail(\n        new UnauthorizedError(\"User ID required\")\n      )\n    }\n\n    // Check balance\n    if (amount > 1000) {\n      return yield* Effect.fail(\n        new InsufficientBalanceError(amount, 1000)\n      )\n    }\n\n    console.log(`\u2705 Processing payment of $${amount}`)\n    return { success: true }\n  })\n\n// ============================================\n// 3. Pattern match on error types\n// ============================================\n\nconst handleUserFetchError = (\n  error: UserNotFoundError | NetworkError\n): string => {\n  if (error._tag === \"UserNotFoundError\") {\n    return `User ${error.userId} not found`\n  }\n  if (error._tag === \"NetworkError\") {\n    return `Network error: ${error.message}`\n  }\n  return \"Unknown error\"\n}\n\nconst handlePaymentError = (\n  error: UnauthorizedError | InsufficientBalanceError | NetworkError\n): string => {\n  if (error._tag === \"UnauthorizedError\") {\n    return `Not authorized: ${error.reason}`\n  }\n  if (error._tag === \"InsufficientBalanceError\") {\n    return `Insufficient balance. Need $${error.required}, have $${error.available}`\n  }\n  if (error._tag === \"NetworkError\") {\n    return `Network issue: ${error.message}`\n  }\n  return \"Unknown error\"\n}\n\n// ============================================\n// 4. Application logic with error handling\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Scenario 1: Fetch user ===\")\n\n  // Success case\n  const user = yield* fetchUser(\"user_123\").pipe(\n    Effect.catchTags({\n      UserNotFoundError: (error) => {\n        console.log(`\u274c User error: ${error.userId}`)\n        return Effect.succeed(null)\n      },\n      NetworkError: (error) => {\n        console.log(`\u274c Network error: ${error.message}`)\n        return Effect.succeed(null)\n      },\n    })\n  )\n\n  if (user) {\n    console.log(`\u2705 Found user: ${user.name}`)\n  }\n\n  console.log(\"\\n=== Scenario 2: Validate email ===\")\n\n  // Email validation\n  const email = yield* validateEmail(\"invalid-email\").pipe(\n    Effect.catchTag(\"ValidationError\", (error) => {\n      console.log(`\u274c Validation error on ${error.field}: ${error.message}`)\n      return Effect.succeed(\"default@example.com\")\n    })\n  )\n\n  console.log(`\u2705 Using email: ${email}`)\n\n  console.log(\"\\n=== Scenario 3: Process payment ===\")\n\n  // Payment with specific error handling\n  const payment = yield* processPayment(\"user_123\", 2000).pipe(\n    Effect.catchTags({\n      UnauthorizedError: (error) => {\n        console.log(`\u274c Auth error: ${error.reason}`)\n        return Effect.succeed({ success: false })\n      },\n      InsufficientBalanceError: (error) => {\n        console.log(`\u274c Balance error: need $${error.required}, have $${error.available}`)\n        return Effect.succeed({ success: false })\n      },\n      NetworkError: (error) => {\n        console.log(`\u274c Network error: ${error.message}`)\n        return Effect.succeed({ success: false })\n      },\n    })\n  )\n\n  console.log(`Payment result: ${payment.success ? \"Success\" : \"Failed\"}`)\n\n  return { user, email, payment }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Application completed\"))\n  .catch((error) => console.error(`Uncaught error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Custom Tagged Errors using Schema."
            },
            "created_at": "2026-02-16T21:39:16.228927",
            "updated_at": "2026-02-20T23:09:40.342053"
        },
        {
            "id": "cb9be626-48da-4c61-b554-dcb5629bd532",
            "slug": "feature-flags-schema",
            "title": "Feature Flags with Dynamic Validation",
            "summary": "You want to roll out features gradually: enable for 10% of users, then 50%, then 100%. Or toggle features without redeploying. Feature flags scattered across code make it impossible to reason about...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "feature-flags",
                "configuration",
                "schema",
                "dynamic",
                "a-b-testing",
                "gradual-rollout"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect, Data } from \"effect\"\n\n// 1. Define feature flag types\nconst FeatureFlagSchema = Schema.Struct({\n  name: Schema.String,\n  enabled: Schema.Boolean,\n  rolloutPercentage: Schema.pipe(\n    Schema.Number,\n    Schema.between(0, 100)\n  ),\n  allowedUserIds: Schema.Array(Schema.String),\n  allowedGroups: Schema.Array(Schema.String),\n})\n\ntype FeatureFlag = typeof FeatureFlagSchema.Type\n\n// 2. Define feature flag store\nconst FeaturesConfig = Schema.Struct({\n  newDashboard: FeatureFlagSchema,\n  advancedAnalytics: FeatureFlagSchema,\n  darkMode: FeatureFlagSchema,\n  betaApi: FeatureFlagSchema,\n})\n\ntype FeaturesConfig = typeof FeaturesConfig.Type\n\n// 3. Feature flag evaluation context\nclass FeatureFlagContext {\n  constructor(\n    readonly userId: string,\n    readonly userGroup: string,\n    readonly isAdmin: boolean,\n  ) {}\n}\n\n// 4. Feature flag errors\nclass FeatureFlagNotFound extends Data.TaggedError(\n  \"FeatureFlagNotFound\"\n) {\n  constructor(readonly flagName: string) {\n    super()\n  }\n}\n\n// 5. Hash function for consistent rollout\nconst hashUserId = (userId: string): number => {\n  let hash = 0\n  for (let i = 0; i < userId.length; i++) {\n    hash = ((hash << 5) - hash) + userId.charCodeAt(i)\n    hash = hash & hash // Convert to 32-bit integer\n  }\n  return Math.abs(hash) % 100\n}\n\n// 6. Evaluate feature flag for user\nconst evaluateFlag = (\n  flag: FeatureFlag,\n  context: FeatureFlagContext,\n): boolean => {\n  // Admins always get all features\n  if (context.isAdmin) return true\n\n  // Check if explicitly disabled\n  if (!flag.enabled) return false\n\n  // Check user allowlist\n  if (flag.allowedUserIds.length > 0) {\n    return flag.allowedUserIds.includes(context.userId)\n  }\n\n  // Check group allowlist\n  if (flag.allowedGroups.length > 0) {\n    if (!flag.allowedGroups.includes(context.userGroup)) {\n      return false\n    }\n  }\n\n  // Apply gradual rollout percentage\n  const userHash = hashUserId(context.userId)\n  return userHash < flag.rolloutPercentage\n}\n\n// 7. Feature flag service\nclass FeatureFlagService {\n  constructor(readonly features: FeaturesConfig) {}\n\n  isEnabled(\n    flagName: keyof FeaturesConfig,\n    context: FeatureFlagContext,\n  ): Effect.Effect<boolean, FeatureFlagNotFound> {\n    return Effect.gen(function* () {\n      const flag = this.features[flagName]\n\n      if (!flag) {\n        return yield* Effect.fail(new FeatureFlagNotFound(flagName as string))\n      }\n\n      return evaluateFlag(flag, context)\n    })\n  }\n\n  getFlag(\n    flagName: keyof FeaturesConfig,\n  ): Effect.Effect<FeatureFlag, FeatureFlagNotFound> {\n    return Effect.gen(function* () {\n      const flag = this.features[flagName]\n\n      if (!flag) {\n        return yield* Effect.fail(new FeatureFlagNotFound(flagName as string))\n      }\n\n      return flag\n    })\n  }\n\n  listEnabled(\n    context: FeatureFlagContext,\n  ): Effect.Effect<Array<[string, boolean]>> {\n    return Effect.sync(() => {\n      return Object.entries(this.features).map(([name, flag]) => [\n        name,\n        evaluateFlag(flag, context),\n      ])\n    })\n  }\n}\n\n// 8. Load feature flags from configuration\nconst loadFeatureFlags = (config: any): Effect.Effect<FeaturesConfig, Error> =>\n  Effect.tryPromise({\n    try: () => Schema.decodeUnknown(FeaturesConfig)(config),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Feature flag validation failed: ${msg}`)\n    },\n  })\n\n// 9. Create feature flag layer\nconst FeatureFlagServiceLive = (config: any) =>\n  Effect.gen(function* () {\n    const features = yield* loadFeatureFlags(config)\n    return new FeatureFlagService(features)\n  }).pipe(Effect.layer)\n\n// Usage example\nconst defaultFlags: FeaturesConfig = {\n  newDashboard: {\n    name: \"new_dashboard\",\n    enabled: true,\n    rolloutPercentage: 50,\n    allowedUserIds: [],\n    allowedGroups: [],\n  },\n  advancedAnalytics: {\n    name: \"advanced_analytics\",\n    enabled: true,\n    rolloutPercentage: 25,\n    allowedUserIds: [\"user123\", \"user456\"],\n    allowedGroups: [],\n  },\n  darkMode: {\n    name: \"dark_mode\",\n    enabled: true,\n    rolloutPercentage: 100,\n    allowedUserIds: [],\n    allowedGroups: [\"premium\"],\n  },\n  betaApi: {\n    name: \"beta_api\",\n    enabled: false,\n    rolloutPercentage: 0,\n    allowedUserIds: [],\n    allowedGroups: [\"engineering\"],\n  },\n}\n\n// Application logic\nconst appLogic = Effect.gen(function* () {\n  const flagService = yield* Effect.service(FeatureFlagService)\n\n  const userContext = new FeatureFlagContext(\n    \"user789\",\n    \"standard\",\n    false,\n  )\n\n  const adminContext = new FeatureFlagContext(\n    \"admin001\",\n    \"admin\",\n    true,\n  )\n\n  // Check individual flags\n  const userHasDashboard = yield* flagService.isEnabled(\n    \"newDashboard\",\n    userContext,\n  )\n  console.log(`User has new dashboard: ${userHasDashboard}`)\n\n  const userHasAnalytics = yield* flagService.isEnabled(\n    \"advancedAnalytics\",\n    userContext,\n  )\n  console.log(`User has advanced analytics: ${userHasAnalytics}`)\n\n  // Admins always get features\n  const adminHasBetaApi = yield* flagService.isEnabled(\n    \"betaApi\",\n    adminContext,\n  )\n  console.log(`Admin has beta API: ${adminHasBetaApi}`)\n\n  // List all enabled features for user\n  const enabledFeatures = yield* flagService.listEnabled(userContext)\n  console.log(`User enabled features:`, enabledFeatures)\n\n  return enabledFeatures\n})\n\n// Run with feature flags\nEffect.runPromise(\n  appLogic.pipe(Effect.provide(FeatureFlagServiceLive(defaultFlags)))\n)\n  .then(() => console.log(\"\u2705 Feature flag evaluation complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Feature Flags with Dynamic Validation using Schema."
            },
            "created_at": "2026-02-16T21:39:17.82689",
            "updated_at": "2026-02-20T23:09:40.766928"
        },
        {
            "id": "965a0e1e-a611-4486-bb18-3eac5aa067de",
            "slug": "secrets-redaction-schema",
            "title": "Secrets Redaction and Masking",
            "summary": "Logs contain API keys, database passwords, and authentication tokens. A developer accidentally logs config, exposing secrets. An error gets reported with stack traces containing credentials. You need...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "secrets",
                "security",
                "masking",
                "redaction",
                "logging",
                "sensitive-data"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect, Data } from \"effect\"\n\n// 1. Define secret types\nconst SecretSchema = Schema.String.pipe(\n  Schema.minLength(1),\n  Schema.brand(\"Secret\")\n)\n\ntype Secret = typeof SecretSchema.Type\n\nconst SensitiveFields = [\"password\", \"token\", \"secret\", \"key\", \"api_key\", \"apiKey\"] as const\n\n// 2. Define configuration with secrets\nconst DatabaseConfig = Schema.Struct({\n  host: Schema.String,\n  port: Schema.Number,\n  username: Schema.String,\n  password: SecretSchema,\n})\n\nconst ApiConfig = Schema.Struct({\n  url: Schema.String,\n  apiKey: SecretSchema,\n  secret: SecretSchema,\n})\n\ntype ApiConfig = typeof ApiConfig.Type\n\n// 3. Redaction pattern\nclass RedactionPattern {\n  constructor(readonly pattern: RegExp, readonly replacement: string) {}\n}\n\nconst redactionPatterns: RedactionPattern[] = [\n  // Bearer tokens\n  new RedactionPattern(/Bearer\\s+[A-Za-z0-9\\-._~+/]+=*/gi, \"Bearer [REDACTED]\"),\n  // API keys (common formats)\n  new RedactionPattern(/api[_-]?key[\"\\']?\\s*[:=]\\s*[\"\\']?[A-Za-z0-9\\-._~+/]+=*[\"\\']?/gi, \"apiKey: [REDACTED]\"),\n  // Passwords\n  new RedactionPattern(/password[\"\\']?\\s*[:=]\\s*[\"\\']?[^\"\\s,}]+[\"\\']?/gi, \"password: [REDACTED]\"),\n  // Database credentials\n  new RedactionPattern(/postgresql:\\/\\/[^@]+@/gi, \"postgresql://[USER]:[PASSWORD]@\"),\n  // URLs with auth\n  new RedactionPattern(/https?:\\/\\/[^:]+:[^@]+@/gi, \"https://[USER]:[PASSWORD]@\"),\n]\n\n// 4. Secret tracking metadata\nclass SecretMetadata {\n  constructor(readonly fieldName: string, readonly isSensitive: boolean) {}\n}\n\nconst isSensitiveField = (fieldName: string): boolean => {\n  const lower = fieldName.toLowerCase()\n  return SensitiveFields.some((f) => lower.includes(f))\n}\n\n// 5. Redaction function\nconst redactString = (value: string): string => {\n  let redacted = value\n\n  for (const pattern of redactionPatterns) {\n    redacted = redacted.replace(pattern.pattern, pattern.replacement)\n  }\n\n  return redacted\n}\n\n// 6. Deep redaction for objects\nconst redactObject = (\n  obj: any,\n  depth: number = 0,\n  maxDepth: number = 10,\n): any => {\n  if (depth > maxDepth) return \"[DEPTH_LIMIT]\"\n\n  if (obj === null || obj === undefined) return obj\n  if (typeof obj === \"string\") return redactString(obj)\n  if (typeof obj !== \"object\") return obj\n\n  if (Array.isArray(obj)) {\n    return obj.map((item) => redactObject(item, depth + 1, maxDepth))\n  }\n\n  const redacted: any = {}\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (isSensitiveField(key)) {\n      redacted[key] = \"[REDACTED]\"\n    } else if (typeof value === \"object\") {\n      redacted[key] = redactObject(value, depth + 1, maxDepth)\n    } else if (typeof value === \"string\") {\n      redacted[key] = redactString(value)\n    } else {\n      redacted[key] = value\n    }\n  }\n\n  return redacted\n}\n\n// 7. Safe error with redaction\nclass RedactedError extends Data.TaggedError(\"RedactedError\") {\n  constructor(\n    readonly message: string,\n    readonly originalError: Error,\n  ) {\n    super()\n  }\n\n  toString(): string {\n    const safeMessage = redactString(this.message)\n    const safeStack = this.originalError.stack\n      ? redactString(this.originalError.stack)\n      : \"[NO_STACK]\"\n\n    return `${safeMessage}\\n${safeStack}`\n  }\n}\n\n// 8. Safe logger\nclass SafeLogger {\n  private static formatValue(value: any): string {\n    if (typeof value === \"string\") {\n      return redactString(value)\n    }\n    return JSON.stringify(redactObject(value), null, 2)\n  }\n\n  static debug(message: string, ...args: any[]): void {\n    const redacted = args.map((arg) => this.formatValue(arg))\n    console.debug(message, ...redacted)\n  }\n\n  static info(message: string, ...args: any[]): void {\n    const redacted = args.map((arg) => this.formatValue(arg))\n    console.info(message, ...redacted)\n  }\n\n  static warn(message: string, ...args: any[]): void {\n    const redacted = args.map((arg) => this.formatValue(arg))\n    console.warn(message, ...redacted)\n  }\n\n  static error(message: string, ...args: any[]): void {\n    const redacted = args.map((arg) => this.formatValue(arg))\n    console.error(message, ...redacted)\n  }\n}\n\n// 9. Safe config service\nclass ConfigService {\n  constructor(readonly config: ApiConfig) {}\n\n  getConfig(): ApiConfig {\n    return this.config\n  }\n\n  getRedactedConfig(): any {\n    return redactObject(this.config)\n  }\n\n  toString(): string {\n    return JSON.stringify(this.getRedactedConfig(), null, 2)\n  }\n}\n\n// 10. Load and validate config with redaction\nconst loadConfig = (rawConfig: any): Effect.Effect<ConfigService, Error> =>\n  Effect.gen(function* () {\n    const validated = yield* Effect.tryPromise({\n      try: () => Schema.decodeUnknown(ApiConfig)(rawConfig),\n      catch: (error) => {\n        const msg = error instanceof Error ? error.message : String(error)\n        return new Error(`Config validation failed: ${msg}`)\n      },\n    })\n\n    SafeLogger.info(\"Configuration loaded successfully\", {\n      config: redactObject(validated),\n    })\n\n    return new ConfigService(validated)\n  })\n\n// Usage example\nconst apiConfig = {\n  url: \"https://api.example.com\",\n  apiKey: \"pk_test_xxxxxxxxxxxxxxxxxxxx\",\n  secret: \"test_secret_key_xxxxx\",\n}\n\n// Application logic\nconst appLogic = Effect.gen(function* () {\n  const configService = yield* loadConfig(apiConfig)\n\n  // Safe to log - secrets are redacted\n  SafeLogger.info(\"Config initialized\", configService.getRedactedConfig())\n\n  // Access actual secrets when needed (internal only)\n  const actualConfig = configService.getConfig()\n  console.log(`Real API key (not logged): ${actualConfig.apiKey.slice(0, 10)}...`)\n\n  // Simulate error with secrets in stack trace\n  try {\n    throw new Error(`Failed to connect to ${actualConfig.url} with key ${actualConfig.apiKey}`)\n  } catch (originalError) {\n    const safeError = new RedactedError(\n      (originalError as Error).message,\n      originalError as Error\n    )\n    SafeLogger.error(\"Connection failed\", safeError.toString())\n  }\n\n  return configService\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then((service) => {\n    console.log(\"\\n\u2705 Application initialized\")\n    console.log(\"Full config:\", service.toString())\n  })\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Secrets Redaction and Masking using Schema."
            },
            "created_at": "2026-02-16T21:39:17.991126",
            "updated_at": "2026-02-20T23:09:40.810449"
        },
        {
            "id": "4037785c-77a4-4398-a9af-21f7a648d1f9",
            "slug": "error-handling-pattern-accumulation",
            "title": "Error Handling Pattern 1: Accumulating Multiple Errors",
            "summary": "Collect multiple errors across operations instead of failing on first error, enabling comprehensive error reporting and validation.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "error-handling",
                "validation",
                "error-accumulation",
                "fault-tolerance",
                "batch-processing",
                "diagnostics"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data, Cause } from \"effect\";\n\ninterface ValidationError {\n  field: string;\n  message: string;\n  value?: unknown;\n}\n\ninterface ProcessingResult<T> {\n  successes: T[];\n  errors: ValidationError[];\n}\n\n// Example 1: Form validation with error accumulation\nconst program = Effect.gen(function* () {\n  console.log(`\\n[ERROR ACCUMULATION] Collecting multiple errors\\n`);\n\n  // Form data\n  interface FormData {\n    name: string;\n    email: string;\n    age: number;\n    phone: string;\n  }\n\n  const validateForm = (data: FormData): ValidationError[] => {\n    const errors: ValidationError[] = [];\n\n    // Validation 1: Name\n    if (!data.name || data.name.trim().length === 0) {\n      errors.push({\n        field: \"name\",\n        message: \"Name is required\",\n        value: data.name,\n      });\n    } else if (data.name.length < 2) {\n      errors.push({\n        field: \"name\",\n        message: \"Name must be at least 2 characters\",\n        value: data.name,\n      });\n    }\n\n    // Validation 2: Email\n    if (!data.email) {\n      errors.push({\n        field: \"email\",\n        message: \"Email is required\",\n        value: data.email,\n      });\n    } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\n      errors.push({\n        field: \"email\",\n        message: \"Email format invalid\",\n        value: data.email,\n      });\n    }\n\n    // Validation 3: Age\n    if (data.age < 0 || data.age > 150) {\n      errors.push({\n        field: \"age\",\n        message: \"Age must be between 0 and 150\",\n        value: data.age,\n      });\n    }\n\n    // Validation 4: Phone\n    if (data.phone && !/^\\d{3}-\\d{3}-\\d{4}$/.test(data.phone)) {\n      errors.push({\n        field: \"phone\",\n        message: \"Phone must be in format XXX-XXX-XXXX\",\n        value: data.phone,\n      });\n    }\n\n    return errors;\n  };\n\n  // Example 1: Form with multiple errors\n  console.log(`[1] Form validation with multiple errors:\\n`);\n\n  const invalidForm: FormData = {\n    name: \"\",\n    email: \"not-an-email\",\n    age: 200,\n    phone: \"invalid\",\n  };\n\n  const validationErrors = validateForm(invalidForm);\n\n  yield* Effect.log(`[VALIDATION] Found ${validationErrors.length} errors:\\n`);\n\n  for (const error of validationErrors) {\n    yield* Effect.log(`  \u2717 ${error.field}: ${error.message}`);\n  }\n\n  // Example 2: Batch processing with partial success\n  console.log(`\\n[2] Batch processing (accumulate successes and failures):\\n`);\n\n  interface Record {\n    id: string;\n    data: string;\n  }\n\n  const processRecord = (record: Record): Result<string> => {\n    if (record.id.length === 0) {\n      return { success: false, error: \"Missing ID\" };\n    }\n\n    if (record.data.includes(\"ERROR\")) {\n      return { success: false, error: \"Invalid data\" };\n    }\n\n    return { success: true, value: `processed-${record.id}` };\n  };\n\n  interface Result<T> {\n    success: boolean;\n    value?: T;\n    error?: string;\n  }\n\n  const records: Record[] = [\n    { id: \"rec1\", data: \"ok\" },\n    { id: \"\", data: \"ok\" }, // Error: missing ID\n    { id: \"rec3\", data: \"ok\" },\n    { id: \"rec4\", data: \"ERROR\" }, // Error: invalid data\n    { id: \"rec5\", data: \"ok\" },\n  ];\n\n  const results: ProcessingResult<string> = {\n    successes: [],\n    errors: [],\n  };\n\n  for (const record of records) {\n    const result = processRecord(record);\n\n    if (result.success) {\n      results.successes.push(result.value!);\n    } else {\n      results.errors.push({\n        field: record.id || \"unknown\",\n        message: result.error!,\n      });\n    }\n  }\n\n  yield* Effect.log(\n    `[BATCH] Processed ${records.length} records`\n  );\n  yield* Effect.log(`[BATCH] \u2713 ${results.successes.length} succeeded`);\n  yield* Effect.log(`[BATCH] \u2717 ${results.errors.length} failed\\n`);\n\n  for (const success of results.successes) {\n    yield* Effect.log(`  \u2713 ${success}`);\n  }\n\n  for (const error of results.errors) {\n    yield* Effect.log(`  \u2717 [${error.field}] ${error.message}`);\n  }\n\n  // Example 3: Multi-step validation with error accumulation\n  console.log(`\\n[3] Multi-step validation (all checks run):\\n`);\n\n  interface ServiceHealth {\n    diskSpace: boolean;\n    memory: boolean;\n    network: boolean;\n    database: boolean;\n  }\n\n  const diagnostics: ValidationError[] = [];\n\n  // Check 1: Disk space\n  const diskFree = 50; // MB\n\n  if (diskFree < 100) {\n    diagnostics.push({\n      field: \"disk-space\",\n      message: `Only ${diskFree}MB free (need 100MB)`,\n      value: diskFree,\n    });\n  }\n\n  // Check 2: Memory\n  const memUsage = 95; // percent\n\n  if (memUsage > 85) {\n    diagnostics.push({\n      field: \"memory\",\n      message: `Using ${memUsage}% (threshold: 85%)`,\n      value: memUsage,\n    });\n  }\n\n  // Check 3: Network\n  const latency = 500; // ms\n\n  if (latency > 200) {\n    diagnostics.push({\n      field: \"network\",\n      message: `Latency ${latency}ms (threshold: 200ms)`,\n      value: latency,\n    });\n  }\n\n  // Check 4: Database\n  const dbConnections = 95;\n  const dbMax = 100;\n\n  if (dbConnections > dbMax * 0.8) {\n    diagnostics.push({\n      field: \"database\",\n      message: `${dbConnections}/${dbMax} connections (80% threshold)`,\n      value: dbConnections,\n    });\n  }\n\n  if (diagnostics.length === 0) {\n    yield* Effect.log(`[HEALTH] \u2713 All systems normal\\n`);\n  } else {\n    yield* Effect.log(\n      `[HEALTH] \u2717 ${diagnostics.length} issue(s) detected:\\n`\n    );\n\n    for (const diag of diagnostics) {\n      yield* Effect.log(`  \u26a0 ${diag.field}: ${diag.message}`);\n    }\n  }\n\n  // Example 4: Error collection with retry decisions\n  console.log(`\\n[4] Error collection for retry strategy:\\n`);\n\n  interface ErrorWithContext {\n    operation: string;\n    error: string;\n    retryable: boolean;\n    timestamp: Date;\n  }\n\n  const operationErrors: ErrorWithContext[] = [];\n\n  const operations = [\n    { name: \"fetch-config\", fail: false },\n    { name: \"connect-db\", fail: true },\n    { name: \"load-cache\", fail: true },\n    { name: \"start-server\", fail: false },\n  ];\n\n  for (const op of operations) {\n    if (op.fail) {\n      operationErrors.push({\n        operation: op.name,\n        error: \"Operation failed\",\n        retryable: op.name !== \"fetch-config\",\n        timestamp: new Date(),\n      });\n    }\n  }\n\n  yield* Effect.log(`[OPERATIONS] ${operationErrors.length} errors:\\n`);\n\n  for (const err of operationErrors) {\n    const status = err.retryable ? \"\ud83d\udd04 retryable\" : \"\u274c non-retryable\";\n    yield* Effect.log(`  ${status}: ${err.operation}`);\n  }\n\n  if (operationErrors.every((e) => e.retryable)) {\n    yield* Effect.log(`\\n[DECISION] All errors retryable, will retry\\n`);\n  } else {\n    yield* Effect.log(`\\n[DECISION] Some non-retryable errors, manual intervention needed\\n`);\n  }\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use error accumulation to report all problems at once rather than failing early, critical for validation and batch operations."
            },
            "created_at": "2026-02-16T21:39:22.454817",
            "updated_at": "2026-02-20T23:09:41.987342"
        },
        {
            "id": "e14b8a08-0872-4720-8749-487143426821",
            "slug": "error-handling-user-friendly-messages",
            "title": "User-Friendly Error Messages",
            "summary": "Internal error: \"TypeError: Cannot read property 'value' of undefined at line 342\". Users see this and think the app is broken. Developers see it in logs and can debug. But showing technical errors...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "error-handling",
                "user-experience",
                "error-messages",
                "localization",
                "logging"
            ],
            "examples": [
                {
                    "code": "import { Data, Effect } from \"effect\"\n\n// ============================================\n// 1. Define errors with multiple representations\n// ============================================\n\nclass ValidationError extends Data.TaggedError(\"ValidationError\") {\n  constructor(\n    readonly field: string,\n    readonly value: any,\n    readonly reason: string\n  ) {\n    super()\n  }\n\n  userMessage(): string {\n    const fieldLabel = this.field\n      .replace(/([A-Z])/g, \" $1\")\n      .toLowerCase()\n      .trim()\n\n    return `Invalid ${fieldLabel}: ${this.reason}`\n  }\n\n  techMessage(): string {\n    return `[ValidationError] Field '${this.field}' failed validation. Value: ${JSON.stringify(this.value)}. Reason: ${this.reason}`\n  }\n\n  loggingInfo(): Record<string, any> {\n    return {\n      type: \"ValidationError\",\n      field: this.field,\n      value: this.redactSensitive(this.value),\n      reason: this.reason,\n      timestamp: new Date().toISOString(),\n    }\n  }\n\n  private redactSensitive(value: any): any {\n    if (typeof value === \"string\") {\n      if (\n        this.field.toLowerCase().includes(\"password\") ||\n        this.field.toLowerCase().includes(\"token\") ||\n        this.field.toLowerCase().includes(\"secret\")\n      ) {\n        return \"[REDACTED]\"\n      }\n      if (this.field.toLowerCase().includes(\"email\")) {\n        return value.replace(/(.{2})(.*)(@.*)/, \"$1***$3\")\n      }\n    }\n    return value\n  }\n}\n\nclass NetworkError extends Data.TaggedError(\"NetworkError\") {\n  constructor(\n    readonly statusCode: number,\n    readonly endpoint: string,\n    readonly originalError: Error\n  ) {\n    super()\n  }\n\n  userMessage(): string {\n    switch (this.statusCode) {\n      case 500:\n      case 502:\n      case 503:\n        return \"The service is temporarily unavailable. Please try again in a few moments.\"\n      case 404:\n        return \"The resource you requested could not be found.\"\n      case 401:\n        return \"Your session has expired. Please log in again.\"\n      case 403:\n        return \"You don't have permission to access this resource.\"\n      case 429:\n        return \"Too many requests. Please wait a moment before trying again.\"\n      default:\n        return \"A network error occurred. Please check your connection and try again.\"\n    }\n  }\n\n  techMessage(): string {\n    return `[NetworkError] HTTP ${this.statusCode} from ${this.endpoint}. Cause: ${this.originalError.message}`\n  }\n\n  loggingInfo(): Record<string, any> {\n    return {\n      type: \"NetworkError\",\n      statusCode: this.statusCode,\n      endpoint: this.endpoint,\n      errorMessage: this.originalError.message,\n      stack: this.originalError.stack,\n      timestamp: new Date().toISOString(),\n    }\n  }\n}\n\nclass PaymentError extends Data.TaggedError(\"PaymentError\") {\n  constructor(\n    readonly reason: string,\n    readonly transactionId: string,\n    readonly attemptCount: number\n  ) {\n    super()\n  }\n\n  userMessage(): string {\n    if (this.reason.includes(\"insufficient\")) {\n      return \"Your account has insufficient funds. Please add funds and try again.\"\n    }\n    if (this.reason.includes(\"expired\")) {\n      return \"Your payment method has expired. Please update it.\"\n    }\n    if (this.reason.includes(\"declined\")) {\n      return \"Your payment was declined. Please check your details and try again.\"\n    }\n    return \"Payment processing failed. Please try again or contact support.\"\n  }\n\n  techMessage(): string {\n    return `[PaymentError] Transaction ${this.transactionId} failed after ${this.attemptCount} attempts. Reason: ${this.reason}`\n  }\n\n  loggingInfo(): Record<string, any> {\n    return {\n      type: \"PaymentError\",\n      transactionId: this.transactionId,\n      reason: this.reason,\n      attempts: this.attemptCount,\n      timestamp: new Date().toISOString(),\n    }\n  }\n}\n\n// ============================================\n// 2. Error context for HTTP responses\n// ============================================\n\ntype ErrorResponse = {\n  message: string\n  code: string\n  details?: Record<string, any>\n}\n\nconst toErrorResponse = (\n  error: ValidationError | NetworkError | PaymentError\n): ErrorResponse => {\n  return {\n    message: error.userMessage(),\n    code: error._tag,\n    details: error._tag === \"ValidationError\" ? { field: error.field } : undefined,\n  }\n}\n\n// ============================================\n// 3. Logger service\n// ============================================\n\nclass Logger {\n  static error(\n    error: ValidationError | NetworkError | PaymentError,\n    context?: Record<string, any>\n  ): void {\n    const logData = {\n      ...error.loggingInfo(),\n      ...(context && { context }),\n    }\n\n    console.error(\"[ERROR LOG]\", JSON.stringify(logData, null, 2))\n\n    // In production, this would send to external logging service\n    // e.g., Sentry, DataDog, CloudWatch\n  }\n\n  static techDebug(\n    error: ValidationError | NetworkError | PaymentError\n  ): void {\n    console.debug(\"[TECH DEBUG]\", error.techMessage())\n  }\n}\n\n// ============================================\n// 4. Simulate domain operations\n// ============================================\n\nconst validateEmail = (email: string): Effect.Effect<string, ValidationError> =>\n  Effect.gen(function* () {\n    if (!email.includes(\"@\")) {\n      return yield* Effect.fail(\n        new ValidationError(\"email\", email, \"Must contain @ symbol\")\n      )\n    }\n    return email\n  })\n\nconst processPayment = (\n  amount: number\n): Effect.Effect<{ success: boolean }, PaymentError> =>\n  Effect.gen(function* () {\n    if (amount > 10000) {\n      return yield* Effect.fail(\n        new PaymentError(\n          \"insufficient_balance\",\n          \"txn_12345\",\n          1\n        )\n      )\n    }\n    return { success: true }\n  })\n\nconst fetchUserData = (): Effect.Effect<any, NetworkError> =>\n  Effect.gen(function* () {\n    return yield* Effect.fail(\n      new NetworkError(503, \"https://api.example.com/users\", new Error(\"Service unavailable\"))\n    )\n  })\n\n// ============================================\n// 5. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Scenario 1: Validation Error ===\\n\")\n\n  const validationResult = yield* validateEmail(\"invalid-email\").pipe(\n    Effect.either\n  )\n\n  if (validationResult._tag === \"Left\") {\n    const error = validationResult.left\n    console.log(\"\ud83d\udce7 User sees:\", error.userMessage())\n    console.log(\"\ud83d\udd27 Dev sees:\", error.techMessage())\n    Logger.error(error, { context: \"email_validation\" })\n    console.log()\n  }\n\n  console.log(\"=== Scenario 2: Network Error ===\\n\")\n\n  const networkResult = yield* fetchUserData().pipe(\n    Effect.either\n  )\n\n  if (networkResult._tag === \"Left\") {\n    const error = networkResult.left\n    console.log(\"\ud83d\udc64 User sees:\", error.userMessage())\n    console.log(\"\ud83d\udd27 Dev sees:\", error.techMessage())\n    Logger.error(error, { context: \"user_data_fetch\" })\n    console.log()\n  }\n\n  console.log(\"=== Scenario 3: Payment Error ===\\n\")\n\n  const paymentResult = yield* processPayment(50000).pipe(\n    Effect.either\n  )\n\n  if (paymentResult._tag === \"Left\") {\n    const error = paymentResult.left\n    console.log(\"\ud83d\udcb3 User sees:\", error.userMessage())\n    console.log(\"\ud83d\udd27 Dev sees:\", error.techMessage())\n    Logger.error(error, { context: \"payment_processing\", userId: \"user_123\" })\n    console.log()\n  }\n\n  console.log(\"=== Scenario 4: API Response ===\\n\")\n\n  const errors: (ValidationError | NetworkError | PaymentError)[] = []\n\n  const emailErr = yield* validateEmail(\"bad\").pipe(Effect.either)\n  if (emailErr._tag === \"Left\") errors.push(emailErr.left)\n\n  const paymentErr = yield* processPayment(15000).pipe(Effect.either)\n  if (paymentErr._tag === \"Left\") errors.push(paymentErr.left)\n\n  console.log(\"\ud83d\udce4 API Response to client:\")\n  console.log(\n    JSON.stringify(\n      {\n        success: false,\n        errors: errors.map(toErrorResponse),\n      },\n      null,\n      2\n    )\n  )\n\n  console.log(\"\\n\ud83d\udccb Log entries for monitoring:\")\n  for (const error of errors) {\n    console.log(JSON.stringify(error.loggingInfo()))\n  }\n\n  return errors\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Error messaging complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "User-Friendly Error Messages using Schema."
            },
            "created_at": "2026-02-16T21:39:16.401016",
            "updated_at": "2026-02-20T23:09:40.391083"
        },
        {
            "id": "df01fc39-4d67-4feb-aa04-8f461ce27cd9",
            "slug": "schema-polymorphic-apis",
            "title": "Polymorphic API Responses and Data Shaping",
            "summary": "Your API returns different response shapes for different endpoints. Search returns paginated results; detail returns single object; batch returns array. Each endpoint has its own shape. Without...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "polymorphic",
                "api-design",
                "response-shapes",
                "data-variants"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Define polymorphic API response types\n// ============================================\n\n// Paginated list response\nconst PaginatedResponse = Schema.Struct({\n  _type: Schema.Literal(\"paginated\"),\n  items: Schema.Array(\n    Schema.Struct({\n      id: Schema.String,\n      name: Schema.String,\n      createdAt: Schema.Date,\n    })\n  ),\n  page: Schema.Number,\n  pageSize: Schema.Number,\n  total: Schema.Number,\n  hasMore: Schema.Boolean,\n})\n\n// Single item response\nconst SingleItemResponse = Schema.Struct({\n  _type: Schema.Literal(\"single\"),\n  id: Schema.String,\n  name: Schema.String,\n  description: Schema.String,\n  createdAt: Schema.Date,\n  updatedAt: Schema.Date,\n  tags: Schema.Array(Schema.String),\n})\n\n// Batch/array response\nconst BatchResponse = Schema.Struct({\n  _type: Schema.Literal(\"batch\"),\n  items: Schema.Array(\n    Schema.Struct({\n      id: Schema.String,\n      status: Schema.Enum({\n        success: \"success\" as const,\n        failed: \"failed\" as const,\n        pending: \"pending\" as const,\n      }),\n      data: Schema.Any,\n    })\n  ),\n  processedAt: Schema.Date,\n  failureCount: Schema.Number,\n})\n\n// Error response\nconst ErrorResponse = Schema.Struct({\n  _type: Schema.Literal(\"error\"),\n  status: Schema.Number,\n  message: Schema.String,\n  details: Schema.Optional(Schema.Record(Schema.String, Schema.Any)),\n  requestId: Schema.String,\n  timestamp: Schema.Date,\n})\n\n// Unified polymorphic API response\nconst ApiResponse = Schema.Union(\n  PaginatedResponse,\n  SingleItemResponse,\n  BatchResponse,\n  ErrorResponse\n)\n\ntype ApiResponse = typeof ApiResponse.Type\n\n// ============================================\n// 2. Search API: returns paginated results\n// ============================================\n\nconst fetchSearchResults = (\n  query: string,\n  page: number\n): Effect.Effect<ApiResponse, Error> =>\n  Effect.gen(function* () {\n    // Simulate API call\n    const response: ApiResponse = {\n      _type: \"paginated\",\n      items: [\n        {\n          id: \"item_1\",\n          name: `Result for \"${query}\" 1`,\n          createdAt: new Date(\"2025-12-01\"),\n        },\n        {\n          id: \"item_2\",\n          name: `Result for \"${query}\" 2`,\n          createdAt: new Date(\"2025-12-02\"),\n        },\n      ],\n      page,\n      pageSize: 10,\n      total: 42,\n      hasMore: page * 10 < 42,\n    }\n\n    return yield* Effect.tryPromise({\n      try: () => Schema.decodeUnknown(ApiResponse)(response),\n      catch: (error) => {\n        const msg = error instanceof Error ? error.message : String(error)\n        return new Error(`Search API error: ${msg}`)\n      },\n    })\n  })\n\n// ============================================\n// 3. Detail API: returns single item\n// ============================================\n\nconst fetchItemDetail = (id: string): Effect.Effect<ApiResponse, Error> =>\n  Effect.gen(function* () {\n    // Simulate API call\n    const response: ApiResponse = {\n      _type: \"single\",\n      id,\n      name: \"Detailed Item\",\n      description:\n        \"This is a detailed description of the item including all metadata\",\n      createdAt: new Date(\"2025-11-01\"),\n      updatedAt: new Date(\"2025-12-10\"),\n      tags: [\"important\", \"featured\", \"new\"],\n    }\n\n    return yield* Effect.tryPromise({\n      try: () => Schema.decodeUnknown(ApiResponse)(response),\n      catch: (error) => {\n        const msg = error instanceof Error ? error.message : String(error)\n        return new Error(`Detail API error: ${msg}`)\n      },\n    })\n  })\n\n// ============================================\n// 4. Batch API: processes multiple items\n// ============================================\n\nconst processBatch = (\n  itemIds: string[]\n): Effect.Effect<ApiResponse, Error> =>\n  Effect.gen(function* () {\n    // Simulate batch processing\n    const response: ApiResponse = {\n      _type: \"batch\",\n      items: itemIds.map((id, idx) => ({\n        id,\n        status: idx % 3 === 0 ? \"failed\" : idx % 3 === 1 ? \"pending\" : \"success\",\n        data: { processed: true, timestamp: new Date() },\n      })),\n      processedAt: new Date(),\n      failureCount: Math.floor(itemIds.length / 3),\n    }\n\n    return yield* Effect.tryPromise({\n      try: () => Schema.decodeUnknown(ApiResponse)(response),\n      catch: (error) => {\n        const msg = error instanceof Error ? error.message : String(error)\n        return new Error(`Batch API error: ${msg}`)\n      },\n    })\n  })\n\n// ============================================\n// 5. Error response handler\n// ============================================\n\nconst handleApiError = (\n  response: ErrorResponse\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    yield* Effect.logError(`API Error [${response.status}]: ${response.message}`)\n\n    if (response.details) {\n      yield* Effect.logDebug(`Details: ${JSON.stringify(response.details)}`)\n    }\n\n    yield* Effect.logDebug(`Request ID: ${response.requestId}`)\n  })\n\n// ============================================\n// 6. Polymorphic response handler\n// ============================================\n\nconst handleApiResponse = (response: ApiResponse): Effect.Effect<string> =>\n  Effect.gen(function* () {\n    switch (response._type) {\n      case \"paginated\":\n        const summary = `Found ${response.total} results (page ${response.page}/${Math.ceil(response.total / response.pageSize)})`\n        yield* Effect.log(summary)\n        for (const item of response.items) {\n          yield* Effect.log(`  - ${item.name} (${item.id})`)\n        }\n        return summary\n\n      case \"single\":\n        yield* Effect.log(`Details for ${response.id}:`)\n        yield* Effect.log(`  Name: ${response.name}`)\n        yield* Effect.log(`  Description: ${response.description}`)\n        yield* Effect.log(`  Tags: ${response.tags.join(\", \")}`)\n        yield* Effect.log(`  Created: ${response.createdAt.toISOString()}`)\n        yield* Effect.log(`  Updated: ${response.updatedAt.toISOString()}`)\n        return `Single item: ${response.name}`\n\n      case \"batch\":\n        const successCount = response.items.filter((i) => i.status === \"success\")\n          .length\n        const summary2 = `Batch processed: ${successCount}/${response.items.length} succeeded`\n        yield* Effect.log(summary2)\n        for (const item of response.items) {\n          const emoji =\n            item.status === \"success\"\n              ? \"\u2705\"\n              : item.status === \"failed\"\n                ? \"\u274c\"\n                : \"\u23f3\"\n          yield* Effect.log(`  ${emoji} ${item.id}: ${item.status}`)\n        }\n        return summary2\n\n      case \"error\":\n        yield* handleApiError(response)\n        return `Error: ${response.message}`\n    }\n  })\n\n// ============================================\n// 7. Client that works with all response types\n// ============================================\n\nclass PolymorphicApiClient {\n  async search(query: string, page: number = 1): Promise<ApiResponse> {\n    return Effect.runPromise(fetchSearchResults(query, page))\n  }\n\n  async detail(id: string): Promise<ApiResponse> {\n    return Effect.runPromise(fetchItemDetail(id))\n  }\n\n  async batch(itemIds: string[]): Promise<ApiResponse> {\n    return Effect.runPromise(processBatch(itemIds))\n  }\n\n  async handleResponse(response: ApiResponse): Promise<string> {\n    return Effect.runPromise(handleApiResponse(response))\n  }\n}\n\n// ============================================\n// 8. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  const client = new PolymorphicApiClient()\n\n  console.log(\"=== Search API (Paginated Response) ===\\n\")\n  const searchResponse = yield* fetchSearchResults(\"effect\", 1)\n  yield* handleApiResponse(searchResponse)\n\n  console.log(\"\\n=== Detail API (Single Item Response) ===\\n\")\n  const detailResponse = yield* fetchItemDetail(\"item_123\")\n  yield* handleApiResponse(detailResponse)\n\n  console.log(\"\\n=== Batch API (Batch Response) ===\\n\")\n  const batchResponse = yield* processBatch([\n    \"item_1\",\n    \"item_2\",\n    \"item_3\",\n    \"item_4\",\n  ])\n  yield* handleApiResponse(batchResponse)\n\n  console.log(\"\\n=== Type-safe response handling ===\\n\")\n\n  // Compiler ensures we handle all response types\n  const responses: ApiResponse[] = [\n    searchResponse,\n    detailResponse,\n    batchResponse,\n  ]\n\n  for (const response of responses) {\n    yield* Effect.log(`\\nResponse type: ${response._type}`)\n    yield* handleApiResponse(response)\n  }\n\n  return responses\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Polymorphic API handling complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Polymorphic API Responses and Data Shaping using Schema."
            },
            "created_at": "2026-02-16T21:39:16.923663",
            "updated_at": "2026-02-20T23:09:40.538438"
        },
        {
            "id": "6e36cb36-79f7-4841-8e75-9bc78d02e34b",
            "slug": "schema-exhaustive-matching",
            "title": "Exhaustive Pattern Matching and Never Types",
            "summary": "A union has 5 variants. Developer writes a switch with 4 cases and forgets one. Code compiles. Six months later, a user hits the missing case and the app crashes. Without compiler checks,...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "exhaustive-matching",
                "pattern-matching",
                "type-safety",
                "never-types"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Define comprehensive union\n// ============================================\n\nconst OrderStatusEvent = Schema.Union(\n  Schema.Struct({\n    _tag: Schema.Literal(\"OrderCreated\"),\n    orderId: Schema.String,\n    customerId: Schema.String,\n  }),\n  Schema.Struct({\n    _tag: Schema.Literal(\"OrderConfirmed\"),\n    orderId: Schema.String,\n    confirmationCode: Schema.String,\n  }),\n  Schema.Struct({\n    _tag: Schema.Literal(\"OrderShipped\"),\n    orderId: Schema.String,\n    trackingNumber: Schema.String,\n  }),\n  Schema.Struct({\n    _tag: Schema.Literal(\"OrderDelivered\"),\n    orderId: Schema.String,\n    deliveryDate: Schema.Date,\n  }),\n  Schema.Struct({\n    _tag: Schema.Literal(\"OrderCancelled\"),\n    orderId: Schema.String,\n    reason: Schema.String,\n  })\n)\n\ntype OrderStatusEvent = typeof OrderStatusEvent.Type\n\n// ============================================\n// 2. Exhaustive handler pattern - requires all cases\n// ============================================\n\n// This function MUST handle all OrderStatusEvent variants\n// Missing a case = TypeScript error\nconst handleOrderEvent = (event: OrderStatusEvent): string => {\n  // TypeScript ensures we handle every case\n  const result: string = (() => {\n    switch (event._tag) {\n      case \"OrderCreated\":\n        return `\ud83d\udcdd Order created: ${event.orderId} for customer ${event.customerId}`\n\n      case \"OrderConfirmed\":\n        return `\u2705 Order confirmed: ${event.confirmationCode}`\n\n      case \"OrderShipped\":\n        return `\ud83d\ude9a Shipped with tracking: ${event.trackingNumber}`\n\n      case \"OrderDelivered\":\n        return `\ud83d\udce6 Delivered on ${event.deliveryDate.toDateString()}`\n\n      case \"OrderCancelled\":\n        return `\u274c Cancelled: ${event.reason}`\n\n      // If we forgot a case above, this exhaustion check catches it:\n      // (This will be unreachable if all cases are handled)\n      default:\n        const _exhaustive: never = event\n        return _exhaustive\n    }\n  })()\n\n  return result\n}\n\n// ============================================\n// 3. Effect-based exhaustive handler\n// ============================================\n\nconst processOrderEventEffect = (\n  event: OrderStatusEvent\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    // Exhaustive match ensures all cases handled\n    switch (event._tag) {\n      case \"OrderCreated\": {\n        yield* Effect.log(`Recording order creation`)\n        yield* Effect.log(`Customer: ${event.customerId}`)\n        break\n      }\n\n      case \"OrderConfirmed\": {\n        yield* Effect.log(`Sending confirmation email`)\n        yield* Effect.log(`Confirmation code: ${event.confirmationCode}`)\n        break\n      }\n\n      case \"OrderShipped\": {\n        yield* Effect.log(`Updating shipping status`)\n        yield* Effect.log(`Notifying customer of tracking number`)\n        break\n      }\n\n      case \"OrderDelivered\": {\n        yield* Effect.log(`Recording delivery`)\n        yield* Effect.log(`Delivery date: ${event.deliveryDate.toISOString()}`)\n        break\n      }\n\n      case \"OrderCancelled\": {\n        yield* Effect.log(`Processing cancellation`)\n        yield* Effect.log(`Reason: ${event.reason}`)\n        break\n      }\n\n      // TypeScript ensures this never executes if all cases handled:\n      default:\n        const _exhaustive: never = event\n        yield* Effect.fail(_exhaustive)\n    }\n  })\n\n// ============================================\n// 4. Exhaustiveness helper function\n// ============================================\n\n// This function only accepts \"never\" type\n// If you pass anything else, it's a compile error\nconst assertNever = (value: never): never => {\n  throw new Error(`Unhandled value: ${value}`)\n}\n\n// Alternative exhaustive handler using assertNever\nconst handleWithAssertNever = (event: OrderStatusEvent): string => {\n  switch (event._tag) {\n    case \"OrderCreated\":\n      return `Order created: ${event.orderId}`\n\n    case \"OrderConfirmed\":\n      return `Order confirmed: ${event.confirmationCode}`\n\n    case \"OrderShipped\":\n      return `Order shipped: ${event.trackingNumber}`\n\n    case \"OrderDelivered\":\n      return `Order delivered: ${event.deliveryDate.toDateString()}`\n\n    case \"OrderCancelled\":\n      return `Order cancelled: ${event.reason}`\n\n    default:\n      // If a new variant is added and we don't handle it,\n      // TypeScript error: \"Type '...' is not assignable to type 'never'\"\n      return assertNever(event)\n  }\n}\n\n// ============================================\n// 5. Pattern matching with Effect.match\n// ============================================\n\nconst orderEventMatcher = (event: OrderStatusEvent): string =>\n  Effect.match(event, {\n    onOrderCreated: (e) => `Created: ${e.orderId}`,\n    onOrderConfirmed: (e) => `Confirmed: ${e.confirmationCode}`,\n    onOrderShipped: (e) => `Shipped: ${e.trackingNumber}`,\n    onOrderDelivered: (e) => `Delivered: ${e.deliveryDate.toDateString()}`,\n    onOrderCancelled: (e) => `Cancelled: ${e.reason}`,\n  })\n\n// ============================================\n// 6. Stateful event processor\n// ============================================\n\nclass OrderProcessor {\n  private states = new Map<string, OrderStatusEvent[]>()\n\n  process(event: OrderStatusEvent): void {\n    const orderId = (() => {\n      // Exhaustive access to orderId from all variants\n      switch (event._tag) {\n        case \"OrderCreated\":\n          return event.orderId\n        case \"OrderConfirmed\":\n          return event.orderId\n        case \"OrderShipped\":\n          return event.orderId\n        case \"OrderDelivered\":\n          return event.orderId\n        case \"OrderCancelled\":\n          return event.orderId\n        default:\n          const _: never = event\n          return _\n      }\n    })()\n\n    if (!this.states.has(orderId)) {\n      this.states.set(orderId, [])\n    }\n\n    this.states.get(orderId)!.push(event)\n    console.log(handleOrderEvent(event))\n  }\n\n  getHistory(orderId: string): OrderStatusEvent[] {\n    return this.states.get(orderId) || []\n  }\n}\n\n// ============================================\n// 7. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Exhaustive Pattern Matching ===\\n\")\n\n  const processor = new OrderProcessor()\n\n  // All possible variants\n  const events: OrderStatusEvent[] = [\n    {\n      _tag: \"OrderCreated\",\n      orderId: \"ord_123\",\n      customerId: \"cust_456\",\n    },\n    {\n      _tag: \"OrderConfirmed\",\n      orderId: \"ord_123\",\n      confirmationCode: \"CONF_ABC123\",\n    },\n    {\n      _tag: \"OrderShipped\",\n      orderId: \"ord_123\",\n      trackingNumber: \"1Z999AA10123456784\",\n    },\n    {\n      _tag: \"OrderDelivered\",\n      orderId: \"ord_123\",\n      deliveryDate: new Date(\"2025-12-20\"),\n    },\n  ]\n\n  console.log(\"Processing events with exhaustive matching:\\n\")\n\n  for (const event of events) {\n    processor.process(event)\n    // All these functions enforce exhaustiveness:\n    yield* Effect.log(`Handler: ${handleOrderEvent(event)}`)\n    yield* Effect.log(`AssertNever: ${handleWithAssertNever(event)}`)\n    yield* processOrderEventEffect(event)\n  }\n\n  console.log(\"\\n=== Order History ===\\n\")\n\n  const history = processor.getHistory(\"ord_123\")\n  console.log(`${history.length} events for order ord_123:`)\n  for (const event of history) {\n    console.log(`  ${event._tag}`)\n  }\n\n  // Show what happens if we add a new variant:\n  console.log(\"\\n=== Adding New Variant ===\")\n  console.log(\"If you add a new _tag to OrderStatusEvent:\")\n  console.log(\"- TypeScript ERROR in handleOrderEvent (missing case)\")\n  console.log(\"- TypeScript ERROR in handleWithAssertNever (missing case)\")\n  console.log(\"- TypeScript ERROR in processOrderEventEffect (missing case)\")\n  console.log(\"- COMPILE FAILS until all handlers updated \u2705\")\n\n  return history\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Exhaustive matching complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Exhaustive Pattern Matching and Never Types using Schema."
            },
            "created_at": "2026-02-16T21:39:17.44429",
            "updated_at": "2026-02-20T23:09:40.678758"
        },
        {
            "id": "f24f6c9e-b133-46fe-b73b-c3b6ce2f936f",
            "slug": "organize-layers-into-composable-modules",
            "title": "Organize Layers into Composable Modules",
            "summary": "Structure a large application by grouping related services into 'module' layers, which are then composed together with a shared base layer.",
            "skill_level": "advanced",
            "category": "testing",
            "difficulty": "advanced",
            "tags": [
                "layer",
                "dependency-injection",
                "architecture",
                "modules",
                "composition",
                "scalability"
            ],
            "examples": [
                {
                    "code": "// src/core/Logger.ts\nimport { Effect } from \"effect\";\n\nexport class Logger extends Effect.Service<Logger>()(\"App/Core/Logger\", {\n  sync: () => ({\n    log: (msg: string) => Effect.log(`[LOG] ${msg}`),\n  }),\n}) {}\n\n// src/features/User/UserRepository.ts\nexport class UserRepository extends Effect.Service<UserRepository>()(\n  \"App/User/UserRepository\",\n  {\n    // Define implementation that uses Logger\n    effect: Effect.gen(function* () {\n      const logger = yield* Logger;\n      return {\n        findById: (id: number) =>\n          Effect.gen(function* () {\n            yield* logger.log(`Finding user ${id}`);\n            return { id, name: `User ${id}` };\n          }),\n      };\n    }),\n    // Declare Logger dependency\n    dependencies: [Logger.Default],\n  }\n) {}\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const repo = yield* UserRepository;\n  const user = yield* repo.findById(1);\n  return user;\n});\n\n// Run with default implementations\nEffect.runPromise(Effect.provide(program, UserRepository.Default));\n\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Program result: ${JSON.stringify(result)}`);\n  return result;\n});\n\nEffect.runPromise(Effect.provide(programWithLogging, UserRepository.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Organize services into modular Layers that are composed hierarchically to manage complexity in large applications."
            },
            "created_at": "2026-02-15T21:22:28.691625",
            "updated_at": "2026-02-20T23:09:41.31412"
        },
        {
            "id": "0e7f76ed-7ede-4b93-ba57-c0cb1c0ee665",
            "slug": "error-handling-pattern-custom-strategies",
            "title": "Error Handling Pattern 3: Custom Error Strategies",
            "summary": "Build domain-specific error types and recovery strategies that align with business logic and provide actionable error information.",
            "skill_level": "advanced",
            "category": "error-management",
            "difficulty": "advanced",
            "tags": [
                "error-handling",
                "custom-errors",
                "error-classification",
                "domain-errors",
                "recovery-strategies",
                "error-semantics"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data, Schedule } from \"effect\";\n\n// Custom domain errors\nclass NetworkError extends Data.TaggedError(\"NetworkError\")<{\n  endpoint: string;\n  statusCode?: number;\n  retryable: boolean;\n}> {}\n\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  field: string;\n  reason: string;\n}> {}\n\nclass AuthenticationError extends Data.TaggedError(\"AuthenticationError\")<{\n  reason: \"invalid-token\" | \"expired-token\" | \"missing-token\";\n}> {}\n\nclass PermissionError extends Data.TaggedError(\"PermissionError\")<{\n  resource: string;\n  action: string;\n}> {}\n\nclass RateLimitError extends Data.TaggedError(\"RateLimitError\")<{\n  retryAfter: number; // milliseconds\n}> {}\n\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{\n  resource: string;\n  id: string;\n}> {}\n\n// Recovery strategy selector\nconst selectRecoveryStrategy = (\n  error: Error\n): \"retry\" | \"fallback\" | \"fail\" | \"user-message\" => {\n  if (error instanceof NetworkError && error.retryable) {\n    return \"retry\";\n  }\n\n  if (error instanceof RateLimitError) {\n    return \"retry\"; // With backoff\n  }\n\n  if (error instanceof ValidationError) {\n    return \"user-message\"; // User can fix\n  }\n\n  if (error instanceof NotFoundError) {\n    return \"fallback\"; // Use empty result\n  }\n\n  if (\n    error instanceof AuthenticationError &&\n    error.reason === \"expired-token\"\n  ) {\n    return \"retry\"; // Refresh token\n  }\n\n  if (error instanceof PermissionError) {\n    return \"fail\"; // Don't retry\n  }\n\n  return \"fail\"; // Default: don't retry\n};\n\nconst program = Effect.gen(function* () {\n  console.log(\n    `\\n[CUSTOM ERROR STRATEGIES] Domain-aware error handling\\n`\n  );\n\n  // Example 1: Type-safe error handling\n  console.log(`[1] Type-safe error catching:\\n`);\n\n  const operation1 = Effect.fail(\n    new ValidationError({\n      field: \"email\",\n      reason: \"Invalid format\",\n    })\n  );\n\n  const handled1 = operation1.pipe(\n    Effect.catchTag(\"ValidationError\", (error) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[CAUGHT] Validation error`);\n        yield* Effect.log(`  Field: ${error.field}`);\n        yield* Effect.log(`  Reason: ${error.reason}\\n`);\n\n        return \"validation-failed\";\n      })\n    )\n  );\n\n  yield* handled1;\n\n  // Example 2: Multiple error types with different recovery\n  console.log(`[2] Different recovery per error type:\\n`);\n\n  interface ApiResponse {\n    status: number;\n    body?: unknown;\n  }\n\n  const callApi = (shouldFail: \"network\" | \"validation\" | \"ratelimit\" | \"success\") =>\n    Effect.gen(function* () {\n      switch (shouldFail) {\n        case \"network\":\n          yield* Effect.fail(\n            new NetworkError({\n              endpoint: \"https://api.example.com/data\",\n              statusCode: 503,\n              retryable: true,\n            })\n          );\n\n        case \"validation\":\n          yield* Effect.fail(\n            new ValidationError({\n              field: \"id\",\n              reason: \"Must be numeric\",\n            })\n          );\n\n        case \"ratelimit\":\n          yield* Effect.fail(\n            new RateLimitError({\n              retryAfter: 5000,\n            })\n          );\n\n        case \"success\":\n          return { status: 200, body: { id: 123 } };\n      }\n    });\n\n  // Test each error type\n  const testCases = [\"network\", \"validation\", \"ratelimit\", \"success\"] as const;\n\n  for (const testCase of testCases) {\n    const strategy = yield* callApi(testCase).pipe(\n      Effect.catchTag(\"NetworkError\", (error) =>\n        Effect.gen(function* () {\n          yield* Effect.log(\n            `[NETWORK] Retryable: ${error.retryable}, Status: ${error.statusCode}`\n          );\n\n          return \"will-retry\";\n        })\n      ),\n      Effect.catchTag(\"ValidationError\", (error) =>\n        Effect.gen(function* () {\n          yield* Effect.log(\n            `[VALIDATION] ${error.field}: ${error.reason} (no retry)`\n          );\n\n          return \"user-must-fix\";\n        })\n      ),\n      Effect.catchTag(\"RateLimitError\", (error) =>\n        Effect.gen(function* () {\n          yield* Effect.log(\n            `[RATE-LIMIT] Retry after ${error.retryAfter}ms`\n          );\n\n          return \"retry-with-backoff\";\n        })\n      ),\n      Effect.catchAll((error) =>\n        Effect.gen(function* () {\n          yield* Effect.log(`[SUCCESS] Got response`);\n\n          return \"completed\";\n        })\n      )\n    );\n\n    yield* Effect.log(`  Strategy: ${strategy}\\n`);\n  }\n\n  // Example 3: Custom retry strategy based on error\n  console.log(`[3] Error-specific retry strategies:\\n`);\n\n  let attemptCount = 0;\n\n  const networkOperation = Effect.gen(function* () {\n    attemptCount++;\n\n    yield* Effect.log(`[ATTEMPT] ${attemptCount}`);\n\n    if (attemptCount === 1) {\n      yield* Effect.fail(\n        new NetworkError({\n          endpoint: \"api.example.com\",\n          statusCode: 502,\n          retryable: true,\n        })\n      );\n    }\n\n    if (attemptCount === 2) {\n      yield* Effect.fail(\n        new RateLimitError({\n          retryAfter: 100,\n        })\n      );\n    }\n\n    return \"success\";\n  });\n\n  // Type-safe retry with error classification\n  let result3: string | null = null;\n\n  for (let i = 0; i < 3; i++) {\n    result3 = yield* networkOperation.pipe(\n      Effect.catchTag(\"NetworkError\", (error) =>\n        Effect.gen(function* () {\n          if (error.retryable && i < 2) {\n            yield* Effect.log(`[RETRY] Network error is retryable`);\n\n            return null; // Signal to retry\n          }\n\n          yield* Effect.log(`[FAIL] Network error not retryable`);\n\n          return Effect.fail(error);\n        })\n      ),\n      Effect.catchTag(\"RateLimitError\", (error) =>\n        Effect.gen(function* () {\n          yield* Effect.log(\n            `[BACKOFF] Rate limited, waiting ${error.retryAfter}ms`\n          );\n\n          yield* Effect.sleep(`${error.retryAfter} millis`);\n\n          return null; // Signal to retry\n        })\n      ),\n      Effect.catchAll((error) =>\n        Effect.gen(function* () {\n          yield* Effect.log(`[ERROR] Unhandled: ${error}`);\n\n          return Effect.fail(error);\n        })\n      )\n    ).pipe(\n      Effect.catchAll(() => Effect.succeed(null))\n    );\n\n    if (result3 !== null) {\n      break;\n    }\n  }\n\n  yield* Effect.log(`\\n[RESULT] ${result3}\\n`);\n\n  // Example 4: Error-aware business logic\n  console.log(`[4] Business logic with error handling:\\n`);\n\n  interface User {\n    id: string;\n    email: string;\n  }\n\n  const loadUser = (id: string): Effect.Effect<User, NetworkError | NotFoundError> =>\n    Effect.gen(function* () {\n      if (id === \"invalid\") {\n        yield* Effect.fail(\n          new NotFoundError({\n            resource: \"user\",\n            id,\n          })\n        );\n      }\n\n      if (id === \"network-error\") {\n        yield* Effect.fail(\n          new NetworkError({\n            endpoint: \"/api/users\",\n            retryable: true,\n          })\n        );\n      }\n\n      return { id, email: `user-${id}@example.com` };\n    });\n\n  const processUser = (id: string) =>\n    loadUser(id).pipe(\n      Effect.catchTag(\"NotFoundError\", (error) =>\n        Effect.gen(function* () {\n          yield* Effect.log(\n            `[BUSINESS] User not found: ${error.id}`\n          );\n\n          // Return default/empty user\n          return { id: \"\", email: \"\" };\n        })\n      ),\n      Effect.catchTag(\"NetworkError\", (error) =>\n        Effect.gen(function* () {\n          yield* Effect.log(\n            `[BUSINESS] Network error, will retry from cache`\n          );\n\n          return { id, email: \"cached@example.com\" };\n        })\n      )\n    );\n\n  yield* processUser(\"valid-id\");\n\n  yield* processUser(\"invalid\");\n\n  yield* processUser(\"network-error\");\n\n  // Example 5: Discriminated union for exhaustiveness\n  console.log(`\\n[5] Exhaustiveness checking (compile-time safety):\\n`);\n\n  const classifyError = (\n    error: NetworkError | ValidationError | AuthenticationError | PermissionError\n  ): string => {\n    switch (error._tag) {\n      case \"NetworkError\":\n        return `network: ${error.statusCode}`;\n\n      case \"ValidationError\":\n        return `validation: ${error.field}`;\n\n      case \"AuthenticationError\":\n        return `auth: ${error.reason}`;\n\n      case \"PermissionError\":\n        return `permission: ${error.action}`;\n\n      // TypeScript ensures all cases covered\n      default:\n        const _exhaustive: never = error;\n        return _exhaustive;\n    }\n  };\n\n  const testError = new ValidationError({\n    field: \"age\",\n    reason: \"Must be >= 18\",\n  });\n\n  const classification = classifyError(testError);\n\n  yield* Effect.log(`[CLASSIFY] ${classification}`);\n\n  // Example 6: Recovery strategy chains\n  console.log(`\\n[6] Chained recovery strategies:\\n`);\n\n  const resilientOperation = Effect.gen(function* () {\n    yield* Effect.fail(\n      new RateLimitError({\n        retryAfter: 50,\n      })\n    );\n  });\n\n  const withRecovery = resilientOperation.pipe(\n    Effect.catchTag(\"RateLimitError\", (error) =>\n      Effect.gen(function* () {\n        yield* Effect.log(\n          `[STEP 1] Caught rate limit, waiting ${error.retryAfter}ms`\n        );\n\n        yield* Effect.sleep(`${error.retryAfter} millis`);\n\n        // Try again\n        return yield* Effect.succeed(\"recovered\");\n      })\n    ),\n    Effect.catchTag(\"NetworkError\", (error) =>\n      Effect.gen(function* () {\n        if (error.retryable) {\n          yield* Effect.log(`[STEP 2] Network error, retrying...`);\n\n          return \"retry\";\n        }\n\n        return yield* Effect.fail(error);\n      })\n    ),\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[STEP 3] Final fallback`);\n\n        return \"fallback\";\n      })\n    )\n  );\n\n  yield* withRecovery;\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use tagged errors and custom error types to enable type-safe error handling and business-logic-aware recovery strategies."
            },
            "created_at": "2026-02-16T21:39:20.413069",
            "updated_at": "2026-02-20T23:09:41.45103"
        },
        {
            "id": "33ed36e6-b323-444a-aea5-50aaffeb0355",
            "slug": "config-layers-schema",
            "title": "Composable Configuration Layers",
            "summary": "Real applications need configuration from multiple sources: default values, environment variables, config files, runtime overrides. Loading config becomes scattered across the codebase. Layers...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "environment",
                "config",
                "layers",
                "composition",
                "schema",
                "dependency-injection"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect, Record as R } from \"effect\"\nimport * as fs from \"fs\"\n\n// 1. Define configuration schema\nconst DatabaseConfig = Schema.Struct({\n  host: Schema.String,\n  port: Schema.pipe(Schema.Number, Schema.int(), Schema.between(1024, 65535)),\n  database: Schema.String,\n  maxConnections: Schema.pipe(Schema.Number, Schema.int(), Schema.between(1, 1000)),\n})\n\nconst CacheConfig = Schema.Struct({\n  ttl: Schema.pipe(Schema.Number, Schema.int(), Schema.between(0, 86400)),\n  enabled: Schema.Boolean,\n})\n\nconst AppConfig = Schema.Struct({\n  database: DatabaseConfig,\n  cache: CacheConfig,\n  debug: Schema.Boolean,\n})\n\ntype AppConfig = typeof AppConfig.Type\n\n// 2. Define default configuration\nconst defaultConfig: AppConfig = {\n  database: {\n    host: \"localhost\",\n    port: 5432,\n    database: \"app_db\",\n    maxConnections: 10,\n  },\n  cache: {\n    ttl: 3600,\n    enabled: true,\n  },\n  debug: false,\n}\n\n// 3. Load from config file\nconst loadConfigFile = (path: string): Effect.Effect<Partial<AppConfig>, Error> =>\n  Effect.gen(function* () {\n    return yield* Effect.tryPromise({\n      try: async () => {\n        const content = await fs.promises.readFile(path, \"utf-8\")\n        return JSON.parse(content)\n      },\n      catch: (error) => {\n        const msg = error instanceof Error ? error.message : String(error)\n        return new Error(`Failed to load config file: ${msg}`)\n      },\n    })\n  })\n\n// 4. Override with environment variables\nconst loadEnvOverrides = (): Partial<AppConfig> => {\n  const overrides: Partial<AppConfig> = {}\n\n  if (process.env.DB_HOST) {\n    overrides.database ??= {}\n    overrides.database.host = process.env.DB_HOST\n  }\n\n  if (process.env.DB_PORT) {\n    overrides.database ??= {}\n    overrides.database.port = parseInt(process.env.DB_PORT, 10)\n  }\n\n  if (process.env.CACHE_TTL) {\n    overrides.cache ??= {}\n    overrides.cache.ttl = parseInt(process.env.CACHE_TTL, 10)\n  }\n\n  if (process.env.DEBUG) {\n    overrides.debug = process.env.DEBUG === \"true\"\n  }\n\n  return overrides\n}\n\n// 5. Deep merge configuration layers\nconst mergeConfigs = (\n  base: AppConfig,\n  fileConfig: Partial<AppConfig>,\n  envConfig: Partial<AppConfig>,\n): AppConfig => {\n  const merged = structuredClone(base)\n\n  // Merge file config\n  if (fileConfig.database) {\n    merged.database = { ...merged.database, ...fileConfig.database }\n  }\n  if (fileConfig.cache) {\n    merged.cache = { ...merged.cache, ...fileConfig.cache }\n  }\n  if (fileConfig.debug !== undefined) {\n    merged.debug = fileConfig.debug\n  }\n\n  // Merge env overrides (highest priority)\n  if (envConfig.database) {\n    merged.database = { ...merged.database, ...envConfig.database }\n  }\n  if (envConfig.cache) {\n    merged.cache = { ...merged.cache, ...envConfig.cache }\n  }\n  if (envConfig.debug !== undefined) {\n    merged.debug = envConfig.debug\n  }\n\n  return merged\n}\n\n// 6. Load and validate complete configuration\nconst loadConfig = (configFilePath?: string): Effect.Effect<AppConfig, Error> =>\n  Effect.gen(function* () {\n    // Load file config (if provided)\n    const fileConfig = configFilePath\n      ? yield* loadConfigFile(configFilePath)\n      : {}\n\n    // Load env overrides\n    const envConfig = loadEnvOverrides()\n\n    // Merge all layers\n    const merged = mergeConfigs(defaultConfig, fileConfig, envConfig)\n\n    // Validate merged config\n    const validated = yield* Effect.tryPromise({\n      try: () => Schema.decodeUnknown(AppConfig)(merged),\n      catch: (error) => {\n        const msg = error instanceof Error ? error.message : String(error)\n        return new Error(`Config validation failed: ${msg}`)\n      },\n    })\n\n    // Log configuration layers\n    console.log(\"Configuration loaded:\")\n    console.log(`  Defaults: \u2713`)\n    if (configFilePath) console.log(`  File: \u2713`)\n    if (Object.keys(envConfig).length > 0) console.log(`  Env: \u2713`)\n\n    return validated\n  })\n\n// 7. Configuration service\nclass ConfigService {\n  constructor(readonly config: AppConfig) {}\n\n  getDatabase = () => this.config.database\n  getCache = () => this.config.cache\n  isDebug = () => this.config.debug\n}\n\nconst ConfigServiceLive = (configPath?: string) =>\n  Effect.gen(function* () {\n    const config = yield* loadConfig(configPath)\n    return new ConfigService(config)\n  }).pipe(Effect.layer)\n\n// Usage\nconst appLogic = Effect.gen(function* () {\n  const configService = yield* Effect.service(ConfigService)\n\n  const db = configService.getDatabase()\n  console.log(`Database: ${db.host}:${db.port}/${db.database}`)\n  console.log(`Max connections: ${db.maxConnections}`)\n\n  const cache = configService.getCache()\n  console.log(`Cache enabled: ${cache.enabled}, TTL: ${cache.ttl}s`)\n\n  console.log(`Debug mode: ${configService.isDebug()}`)\n\n  return configService.config\n})\n\n// Run with explicit config file path\nEffect.runPromise(\n  appLogic.pipe(\n    Effect.provide(ConfigServiceLive(\"./config.json\"))\n  )\n)\n  .then((config) => console.log(\"App initialized successfully\"))\n  .catch((error) => console.error(`Configuration error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Composable Configuration Layers using Schema."
            },
            "created_at": "2026-02-16T21:39:17.636818",
            "updated_at": "2026-02-20T23:09:40.722324"
        },
        {
            "id": "c194dd66-8c09-448a-bc96-15bcf6b20b5e",
            "slug": "env-variables-schema-validation",
            "title": "Environment Variables with Schema Validation",
            "summary": "Environment variables power your application\u2014database URLs, API keys, ports. But they're just strings. You load them with `process.env.DATABASE_URL`, hoping it exists and is valid. No type safety, no...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "environment",
                "config",
                "schema",
                "validation",
                "dotenv"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. Define environment schema\nconst EnvironmentSchema = Schema.Struct({\n\tDATABASE_URL: Schema.String.pipe(\n\t\tSchema.annotations({ description: 'PostgreSQL connection string' }),\n\t),\n\tAPI_KEY: Schema.String.pipe(\n\t\tSchema.minLength(32),\n\t\tSchema.annotations({\n\t\t\tdescription: 'API authentication key (min 32 chars)',\n\t\t}),\n\t),\n\tPORT: Schema.String.pipe(\n\t\tSchema.parseNumber,\n\t\tSchema.int(),\n\t\tSchema.between(1024, 65535),\n\t\tSchema.annotations({ description: 'Server port (1024-65535)' }),\n\t),\n\tLOG_LEVEL: Schema.Literal('debug', 'info', 'warn', 'error').pipe(\n\t\tSchema.annotations({ description: 'Logging level' }),\n\t),\n\tNODE_ENV: Schema.Literal('development', 'staging', 'production').pipe(\n\t\tSchema.annotations({ description: 'Deployment environment' }),\n\t),\n})\n\ntype Environment = typeof EnvironmentSchema.Type\n\n// 2. Create validator\nconst validateEnv = Schema.decodeUnknown(EnvironmentSchema)\n\n// 3. Load and validate environment\nconst loadEnvironment = Effect.fn(function* () {\n\tconst validated = yield* validateEnv(process.env)\n\n\tconsole.log(`\u2705 Environment loaded: NODE_ENV=${validated.NODE_ENV}`)\n\treturn validated\n})\n\n// 4. Create service to provide environment\nexport class EnvironmentService extends Context.Tag('@app/EnvironmentService')<\n\tEnvironmentService,\n\tEnvironment & {\n\t\tisDev: () => boolean\n\t\tisStaging: () => boolean\n\t\tisProd: () => boolean\n\t}\n>() {\n\tstatic layer = Layer.effect(\n\t\tthis,\n\t\tEffect.gen(function* () {\n\t\t\tconst env = yield* loadEnvironment()\n\t\t\treturn {\n\t\t\t\t...env,\n\t\t\t\tisDev: () => env.NODE_ENV === 'development',\n\t\t\t\tisStaging: () => env.NODE_ENV === 'staging',\n\t\t\t\tisProd: () => env.NODE_ENV === 'production',\n\t\t\t}\n\t\t}),\n\t)\n}\n\n// Usage\nconst program = Effect.gen(function* () {\n\tconst envService = yield* EnvironmentService\n\n\tconsole.log(`Database: ${envService.DATABASE_URL}`)\n\tconsole.log(`Port: ${envService.PORT}`)\n\tconsole.log(`Log level: ${envService.LOG_LEVEL}`)\n\tconsole.log(`Is production: ${envService.isProd()}`)\n\n\treturn envService.PORT\n})\n\n// Run with environment layer\nEffect.runPromise(program.pipe(Effect.provide(EnvironmentService.layer)))\n\t.then((port) => console.log(`Server starting on port ${port}`))\n\t.catch((error) => console.error(`Failed to start: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Environment Variables with Schema Validation."
            },
            "created_at": "2026-02-16T21:39:18.155634",
            "updated_at": "2026-02-20T23:09:40.853642"
        },
        {
            "id": "088f18ff-b416-4538-a70c-02a42a0f2e0c",
            "slug": "scheduling-pattern-exponential-backoff",
            "title": "Scheduling Pattern 2: Implement Exponential Backoff for Retries",
            "summary": "Use exponential backoff with jitter to retry failed operations with increasing delays, preventing resource exhaustion and cascade failures in distributed systems.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "scheduling",
                "retry",
                "backoff",
                "resilience",
                "failure-recovery",
                "jitter"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule } from \"effect\";\n\ninterface RetryStats {\n  readonly attempt: number;\n  readonly delay: number;\n  readonly lastError?: Error;\n}\n\n// Simulate flaky API that fails first 3 times, succeeds on 4th\nlet attemptCount = 0;\n\nconst flakyApiCall = (): Effect.Effect<{ status: string }> =>\n  Effect.gen(function* () {\n    attemptCount++;\n    yield* Effect.log(`[API] Attempt ${attemptCount}`);\n\n    if (attemptCount < 4) {\n      yield* Effect.fail(new Error(\"Service temporarily unavailable (503)\"));\n    }\n\n    return { status: \"ok\" };\n  });\n\n// Calculate exponential backoff with jitter\ninterface BackoffConfig {\n  readonly baseDelayMs: number;\n  readonly maxDelayMs: number;\n  readonly maxRetries: number;\n}\n\nconst exponentialBackoffWithJitter = (config: BackoffConfig) => {\n  let attempt = 0;\n\n  // Calculate delay for this attempt\n  const calculateDelay = (): number => {\n    const exponential = config.baseDelayMs * Math.pow(2, attempt);\n    const withJitter = exponential * (0.5 + Math.random() * 0.5); // \u00b150% jitter\n    const capped = Math.min(withJitter, config.maxDelayMs);\n\n    console.log(\n      `[BACKOFF] Attempt ${attempt + 1}: ${Math.round(capped)}ms delay`\n    );\n\n    return Math.round(capped);\n  };\n\n  return Effect.gen(function* () {\n    const effect = flakyApiCall();\n\n    let lastError: Error | undefined;\n\n    for (attempt = 0; attempt < config.maxRetries; attempt++) {\n      const result = yield* effect.pipe(Effect.either);\n\n      if (result._tag === \"Right\") {\n        yield* Effect.log(`[SUCCESS] Succeeded on attempt ${attempt + 1}`);\n        return result.right;\n      }\n\n      lastError = result.left;\n\n      if (attempt < config.maxRetries - 1) {\n        const delay = calculateDelay();\n        yield* Effect.sleep(`${delay} millis`);\n      }\n    }\n\n    yield* Effect.log(\n      `[FAILURE] All ${config.maxRetries} attempts exhausted`\n    );\n    yield* Effect.fail(lastError);\n  });\n};\n\n// Run with exponential backoff\nconst program = exponentialBackoffWithJitter({\n  baseDelayMs: 100,\n  maxDelayMs: 5000,\n  maxRetries: 5,\n});\n\nconsole.log(\n  `\\n[START] Retrying flaky API with exponential backoff\\n`\n);\n\nEffect.runPromise(program).then(\n  (result) => console.log(`\\n[RESULT] ${JSON.stringify(result)}\\n`),\n  (error) => console.error(`\\n[ERROR] ${error.message}\\n`)\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use exponential backoff with jitter for retries to prevent overwhelming failing services and improve success likelihood through smart timing."
            },
            "created_at": "2026-02-16T21:39:20.780032",
            "updated_at": "2026-02-20T23:09:41.535506"
        },
        {
            "id": "cce29db0-2b96-4bc1-a6c8-0e41d577a7f7",
            "slug": "handle-flaky-operations-with-retry-timeout",
            "title": "Handle Flaky Operations with Retries and Timeouts",
            "summary": "Use Effect.retry and Effect.timeout to build resilience against slow or intermittently failing operations, such as network requests.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "retry",
                "timeout",
                "resilience",
                "error-handling",
                "schedule",
                "policy"
            ],
            "examples": [
                {
                    "code": "import { Data, Duration, Effect, Schedule } from \"effect\";\n\n// Define domain types\ninterface ApiResponse {\n  readonly data: string;\n}\n\n// Define error types\nclass ApiError extends Data.TaggedError(\"ApiError\")<{\n  readonly message: string;\n  readonly attempt: number;\n}> {}\n\nclass TimeoutError extends Data.TaggedError(\"TimeoutError\")<{\n  readonly duration: string;\n  readonly attempt: number;\n}> {}\n\n// Define API service\nclass ApiService extends Effect.Service<ApiService>()(\"ApiService\", {\n  sync: () => ({\n    // Flaky API call that might fail or be slow\n    fetchData: (): Effect.Effect<ApiResponse, ApiError | TimeoutError> =>\n      Effect.gen(function* () {\n        const attempt = Math.floor(Math.random() * 5) + 1;\n        yield* Effect.logInfo(`Attempt ${attempt}: Making API call...`);\n\n        if (Math.random() > 0.3) {\n          yield* Effect.logWarning(`Attempt ${attempt}: API call failed`);\n          return yield* Effect.fail(\n            new ApiError({\n              message: \"API Error\",\n              attempt,\n            })\n          );\n        }\n\n        const delay = Math.random() * 3000;\n        yield* Effect.logInfo(\n          `Attempt ${attempt}: API call will take ${delay.toFixed(0)}ms`\n        );\n\n        yield* Effect.sleep(Duration.millis(delay));\n\n        const response = { data: \"some important data\" };\n        yield* Effect.logInfo(\n          `Attempt ${attempt}: API call succeeded with data: ${JSON.stringify(response)}`\n        );\n        return response;\n      }),\n  }),\n}) {}\n\n// Define retry policy: exponential backoff, up to 3 retries\nconst retryPolicy = Schedule.exponential(Duration.millis(100)).pipe(\n  Schedule.compose(Schedule.recurs(3)),\n  Schedule.tapInput((error: ApiError | TimeoutError) =>\n    Effect.logWarning(\n      `Retrying after error: ${error._tag} (Attempt ${error.attempt})`\n    )\n  )\n);\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const api = yield* ApiService;\n\n  yield* Effect.logInfo(\"=== Starting API calls with retry and timeout ===\");\n\n  // Make multiple test calls\n  for (let i = 1; i <= 3; i++) {\n    yield* Effect.logInfo(`\\n--- Test Call ${i} ---`);\n\n    const result = yield* api.fetchData().pipe(\n      Effect.timeout(Duration.seconds(2)),\n      Effect.catchTag(\"TimeoutException\", () =>\n        Effect.fail(new TimeoutError({ duration: \"2 seconds\", attempt: i }))\n      ),\n      Effect.retry(retryPolicy),\n      Effect.catchTags({\n        ApiError: (error) =>\n          Effect.gen(function* () {\n            yield* Effect.logError(\n              `All retries failed: ${error.message} (Last attempt: ${error.attempt})`\n            );\n            return { data: \"fallback data due to API error\" } as ApiResponse;\n          }),\n        TimeoutError: (error) =>\n          Effect.gen(function* () {\n            yield* Effect.logError(\n              `All retries timed out after ${error.duration} (Last attempt: ${error.attempt})`\n            );\n            return { data: \"fallback data due to timeout\" } as ApiResponse;\n          }),\n      })\n    );\n\n    yield* Effect.logInfo(`Result: ${JSON.stringify(result)}`);\n  }\n\n  yield* Effect.logInfo(\"\\n=== API calls complete ===\");\n});\n\n// Run the program\nEffect.runPromise(Effect.provide(program, ApiService.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.retry and Effect.timeout to build resilience against slow or intermittently failing effects."
            },
            "created_at": "2026-02-15T21:22:17.695463",
            "updated_at": "2026-02-20T23:09:41.584097"
        },
        {
            "id": "f3afacd0-3474-4168-a686-f10554f2b841",
            "slug": "error-handling-pattern-propagation",
            "title": "Error Handling Pattern 2: Error Propagation and Chains",
            "summary": "Propagate errors through effect chains with context, preserving error information and enabling recovery at appropriate layers.",
            "skill_level": "advanced",
            "category": "error-management",
            "difficulty": "advanced",
            "tags": [
                "error-handling",
                "error-propagation",
                "error-chains",
                "context-preservation",
                "debugging",
                "stack-traces"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data, Cause } from \"effect\";\n\n// Domain-specific errors with context\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\")<{\n  query: string;\n  parameters: unknown[];\n  cause: Error;\n}> {}\n\nclass NetworkError extends Data.TaggedError(\"NetworkError\")<{\n  endpoint: string;\n  method: string;\n  statusCode?: number;\n  cause: Error;\n}> {}\n\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  field: string;\n  value: unknown;\n  reason: string;\n}> {}\n\nclass BusinessLogicError extends Data.TaggedError(\"BusinessLogicError\")<{\n  operation: string;\n  context: Record<string, unknown>;\n  originalError: Error;\n}> {}\n\nconst program = Effect.gen(function* () {\n  console.log(`\\n[ERROR PROPAGATION] Error chains with context\\n`);\n\n  // Example 1: Simple error propagation\n  console.log(`[1] Error propagation through layers:\\n`);\n\n  const lowLevelOperation = Effect.gen(function* () {\n    yield* Effect.log(`[LAYER 1] Low-level operation starting`);\n\n    yield* Effect.fail(new Error(\"File not found\"));\n  });\n\n  const midLevelOperation = lowLevelOperation.pipe(\n    Effect.mapError((error) =>\n      new DatabaseError({\n        query: \"SELECT * FROM users\",\n        parameters: [\"id=123\"],\n        cause: error instanceof Error ? error : new Error(String(error)),\n      })\n    )\n  );\n\n  const highLevelOperation = midLevelOperation.pipe(\n    Effect.catchTag(\"DatabaseError\", (dbError) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[LAYER 3] Caught database error`);\n        yield* Effect.log(`[LAYER 3]   Query: ${dbError.query}`);\n        yield* Effect.log(`[LAYER 3]   Cause: ${dbError.cause.message}`);\n\n        // Recovery decision\n        return \"fallback-value\";\n      })\n    )\n  );\n\n  const result1 = yield* highLevelOperation;\n\n  yield* Effect.log(`[RESULT] Recovered with: ${result1}\\n`);\n\n  // Example 2: Error context accumulation\n  console.log(`[2] Accumulating context through layers:\\n`);\n\n  interface ErrorContext {\n    timestamp: Date;\n    operation: string;\n    userId?: string;\n    requestId: string;\n  }\n\n  const errorWithContext = (context: ErrorContext) =>\n    Effect.fail(\n      new BusinessLogicError({\n        operation: context.operation,\n        context: {\n          userId: context.userId,\n          timestamp: context.timestamp.toISOString(),\n          requestId: context.requestId,\n        },\n        originalError: new Error(\"Operation failed\"),\n      })\n    );\n\n  const myContext: ErrorContext = {\n    timestamp: new Date(),\n    operation: \"process-payment\",\n    userId: \"user-123\",\n    requestId: \"req-abc-def\",\n  };\n\n  const withContextRecovery = errorWithContext(myContext).pipe(\n    Effect.mapError((error) => {\n      // Log complete context\n      return {\n        ...error,\n        enriched: true,\n        additionalInfo: {\n          serviceName: \"payment-service\",\n          environment: \"production\",\n          version: \"1.2.3\",\n        },\n      };\n    }),\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[ERROR CAUGHT] ${error.operation}`);\n        yield* Effect.log(`[CONTEXT] ${JSON.stringify(error.context, null, 2)}`);\n        return \"recovered\";\n      })\n    )\n  );\n\n  yield* withContextRecovery;\n\n  // Example 3: Network error with retry context\n  console.log(`\\n[3] Network errors with retry context:\\n`);\n\n  interface RetryContext {\n    attempt: number;\n    maxAttempts: number;\n    delay: number;\n  }\n\n  let attemptCount = 0;\n\n  const networkCall = Effect.gen(function* () {\n    attemptCount++;\n\n    yield* Effect.log(`[ATTEMPT] ${attemptCount}/3`);\n\n    if (attemptCount < 3) {\n      yield* Effect.fail(\n        new NetworkError({\n          endpoint: \"https://api.example.com/data\",\n          method: \"GET\",\n          statusCode: 503,\n          cause: new Error(\"Service Unavailable\"),\n        })\n      );\n    }\n\n    return \"success\";\n  });\n\n  const withRetryContext = Effect.gen(function* () {\n    let lastError: NetworkError | null = null;\n\n    for (let i = 1; i <= 3; i++) {\n      const result = yield* networkCall.pipe(\n        Effect.catchTag(\"NetworkError\", (error) =>\n          Effect.gen(function* () {\n            lastError = error;\n\n            yield* Effect.log(\n              `[RETRY] Attempt ${i} failed: ${error.statusCode}`\n            );\n\n            if (i < 3) {\n              yield* Effect.log(`[RETRY] Waiting before retry...`);\n            }\n\n            return yield* Effect.fail(error);\n          })\n        )\n      ).pipe(\n        Effect.tap(() => Effect.log(`[SUCCESS] Connected on attempt ${i}`))\n      ).pipe(\n        Effect.catchAll(() => Effect.succeed(null))\n      );\n\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    if (lastError) {\n      yield* Effect.fail(lastError);\n    }\n\n    return null;\n  });\n\n  const networkResult = yield* withRetryContext.pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[EXHAUSTED] All retries failed`);\n        return \"fallback\";\n      })\n    )\n  );\n\n  yield* Effect.log(`\\n`);\n\n  // Example 4: Multi-layer error transformation\n  console.log(`[4] Error transformation between layers:\\n`);\n\n  const layer1Error = Effect.gen(function* () {\n    yield* Effect.fail(new Error(\"Raw system error\"));\n  });\n\n  // Layer 2: Convert to domain error\n  const layer2 = layer1Error.pipe(\n    Effect.mapError((error) =>\n      new DatabaseError({\n        query: \"SELECT ...\",\n        parameters: [],\n        cause: error instanceof Error ? error : new Error(String(error)),\n      })\n    )\n  );\n\n  // Layer 3: Convert to business error\n  const layer3 = layer2.pipe(\n    Effect.mapError((dbError) =>\n      new BusinessLogicError({\n        operation: \"fetch-user-profile\",\n        context: {\n          dbError: dbError.query,\n        },\n        originalError: dbError.cause,\n      })\n    )\n  );\n\n  // Layer 4: Return user-friendly error\n  const userFacingError = layer3.pipe(\n    Effect.mapError((bizError) => ({\n      message: \"Unable to load profile\",\n      code: \"PROFILE_LOAD_FAILED\",\n      originalError: bizError.originalError.message,\n    })),\n    Effect.catchAll((userError) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[USER MESSAGE] ${userError.message}`);\n        yield* Effect.log(`[CODE] ${userError.code}`);\n        yield* Effect.log(`[DEBUG] ${userError.originalError}`);\n        return null;\n      })\n    )\n  );\n\n  yield* userFacingError;\n\n  // Example 5: Error aggregation in concurrent operations\n  console.log(`\\n[5] Error propagation in concurrent operations:\\n`);\n\n  const operation = (id: number, shouldFail: boolean) =>\n    Effect.gen(function* () {\n      if (shouldFail) {\n        yield* Effect.fail(\n          new Error(`Operation ${id} failed`)\n        );\n      }\n\n      return `result-${id}`;\n    });\n\n  const concurrent = Effect.gen(function* () {\n    const results = yield* Effect.all(\n      [\n        operation(1, false),\n        operation(2, true),\n        operation(3, false),\n      ],\n      { concurrency: 3 }\n    ).pipe(\n      Effect.catchAll((errors) =>\n        Effect.gen(function* () {\n          yield* Effect.log(`[CONCURRENT] Caught aggregated errors`);\n\n          // In real code, Cause provides error details\n          yield* Effect.log(`[ERROR] Errors encountered during concurrent execution`);\n\n          return [];\n        })\n      )\n    );\n\n    return results;\n  });\n\n  yield* concurrent;\n\n  yield* Effect.log(`\\n[DEMO] Error propagation complete`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use error propagation to preserve context through effect chains, enabling debugging and recovery at the right abstraction level."
            },
            "created_at": "2026-02-16T21:39:21.951967",
            "updated_at": "2026-02-20T23:09:41.851631"
        },
        {
            "id": "5fd5129e-f67c-43ab-8533-d03ccff7db17",
            "slug": "stream-collect-results",
            "title": "Collect All Results into a List",
            "summary": "Run a pipeline and gather all of its results into an in-memory array.",
            "skill_level": "beginner",
            "category": "building-data-pipelines",
            "difficulty": "beginner",
            "tags": [
                "stream",
                "run",
                "collect",
                "sink",
                "array",
                "chunk"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Chunk } from \"effect\";\n\nconst program = Stream.range(1, 10).pipe(\n  // Find all the even numbers\n  Stream.filter((n) => n % 2 === 0),\n  // Transform them into strings\n  Stream.map((n) => `Even number: ${n}`),\n  // Run the stream and collect the results\n  Stream.runCollect\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  const results = yield* program;\n  yield* Effect.log(\n    `Collected results: ${JSON.stringify(Chunk.toArray(results))}`\n  );\n  return results;\n});\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\nCollected results: [\n  'Even number: 2',\n  'Even number: 4',\n  'Even number: 6',\n  'Even number: 8',\n  'Even number: 10'\n]\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream.runCollect to execute a stream and collect all its emitted values into a Chunk."
            },
            "created_at": "2026-02-15T21:22:26.173419",
            "updated_at": "2026-02-20T23:09:43.310859"
        },
        {
            "id": "39249efc-8cc8-44d0-b1e9-6f51aa3316fd",
            "slug": "use-default-layer-for-tests",
            "title": "Use the Auto-Generated .Default Layer in Tests",
            "summary": "When testing, always use the MyService.Default layer that is automatically generated by the Effect.Service class for dependency injection.",
            "skill_level": "intermediate",
            "category": "testing",
            "difficulty": "intermediate",
            "tags": [
                "testing",
                "service",
                "layers",
                "dependency-injection"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Define MyService using Effect.Service pattern\nclass MyService extends Effect.Service<MyService>()(\"MyService\", {\n  sync: () => ({\n    doSomething: () =>\n      Effect.succeed(\"done\").pipe(\n        Effect.tap(() => Effect.log(\"MyService did something!\"))\n      ),\n  }),\n}) {}\n\n// Create a program that uses MyService\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Getting MyService...\");\n  const service = yield* MyService;\n\n  yield* Effect.log(\"Calling doSomething()...\");\n  const result = yield* service.doSomething();\n\n  yield* Effect.log(`Result: ${result}`);\n});\n\n// Run the program with default service implementation\nEffect.runPromise(Effect.provide(program, MyService.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use the auto-generated .Default layer in tests."
            },
            "created_at": "2026-02-15T21:22:28.510654",
            "updated_at": "2026-02-20T23:09:41.027115"
        },
        {
            "id": "4715d547-4047-4afa-9715-ec3977b4db6c",
            "slug": "tooling-hello-world",
            "title": "Set Up Your Effect Development Environment",
            "summary": "Configure your editor and tools for the best Effect development experience.",
            "skill_level": "beginner",
            "category": "tooling-and-debugging",
            "difficulty": "beginner",
            "tags": [
                "tooling",
                "setup",
                "vscode",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "# Using Bun (recommended)\nbun add effect\n\n# Or npm\nnpm install effect\n\n# Or pnpm\npnpm add effect",
                    "language": "bash",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Install the Effect extension and configure TypeScript for optimal Effect development."
            },
            "created_at": "2026-02-15T21:22:30.212553",
            "updated_at": "2026-02-20T23:09:42.206233"
        },
        {
            "id": "ff8be911-e30b-45d5-9a0f-0a88412d5006",
            "slug": "tooling-type-errors",
            "title": "Read Effect Type Errors",
            "summary": "Learn how to read and understand Effect's TypeScript error messages.",
            "skill_level": "beginner",
            "category": "tooling-and-debugging",
            "difficulty": "beginner",
            "tags": [
                "tooling",
                "debugging",
                "typescript",
                "errors",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "Type 'Effect<User, never, UserService>' is not assignable to type 'Effect<User, never, never>'.\n  Type 'UserService' is not assignable to type 'never'.",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Effect errors are verbose but structured - learn to extract the key information."
            },
            "created_at": "2026-02-15T21:22:30.132225",
            "updated_at": "2026-02-20T23:09:42.367562"
        },
        {
            "id": "6cd09b8b-9d33-44cb-a70b-082f0727cb77",
            "slug": "platform-environment-variables",
            "title": "Access Environment Variables",
            "summary": "Read environment variables safely with Effect Platform, handling missing values gracefully.",
            "skill_level": "beginner",
            "category": "platform",
            "difficulty": "beginner",
            "tags": [
                "platform",
                "environment",
                "config",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Config, Option } from \"effect\"\n\n// ============================================\n// BASIC: Read required variable\n// ============================================\n\nconst getApiKey = Config.string(\"API_KEY\")\n\nconst program1 = Effect.gen(function* () {\n  const apiKey = yield* getApiKey\n  yield* Effect.log(`API Key: ${apiKey.slice(0, 4)}...`)\n})\n\n// ============================================\n// OPTIONAL: With default value\n// ============================================\n\nconst getPort = Config.number(\"PORT\").pipe(\n  Config.withDefault(3000)\n)\n\nconst program2 = Effect.gen(function* () {\n  const port = yield* getPort\n  yield* Effect.log(`Server will run on port ${port}`)\n})\n\n// ============================================\n// OPTIONAL: Return Option instead of failing\n// ============================================\n\nconst getOptionalFeature = Config.string(\"FEATURE_FLAG\").pipe(\n  Config.option\n)\n\nconst program3 = Effect.gen(function* () {\n  const feature = yield* getOptionalFeature\n  \n  if (Option.isSome(feature)) {\n    yield* Effect.log(`Feature enabled: ${feature.value}`)\n  } else {\n    yield* Effect.log(\"Feature flag not set\")\n  }\n})\n\n// ============================================\n// COMBINED: Multiple variables as config object\n// ============================================\n\nconst AppConfig = Config.all({\n  apiKey: Config.string(\"API_KEY\"),\n  apiUrl: Config.string(\"API_URL\"),\n  port: Config.number(\"PORT\").pipe(Config.withDefault(3000)),\n  debug: Config.boolean(\"DEBUG\").pipe(Config.withDefault(false)),\n})\n\nconst program4 = Effect.gen(function* () {\n  const config = yield* AppConfig\n  \n  yield* Effect.log(`API URL: ${config.apiUrl}`)\n  yield* Effect.log(`Port: ${config.port}`)\n  yield* Effect.log(`Debug: ${config.debug}`)\n})\n\n// ============================================\n// RUN: Will fail if required vars missing\n// ============================================\n\nEffect.runPromise(program4).catch((error) => {\n  console.error(\"Missing required environment variables\")\n  console.error(error)\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect to access environment variables with proper error handling."
            },
            "created_at": "2026-02-15T21:22:22.52916",
            "updated_at": "2026-02-20T23:09:44.054814"
        },
        {
            "id": "57e43010-7715-4fc6-add0-20dd4604e3e0",
            "slug": "stream-pattern-stateful-operations",
            "title": "Stream Pattern 4: Stateful Operations with Scan and Fold",
            "summary": "Use Stream.scan and Stream.fold to maintain state across stream elements, enabling cumulative operations, counters, aggregations, and stateful transformations.",
            "skill_level": "intermediate",
            "category": "streams",
            "difficulty": "intermediate",
            "tags": [
                "streams",
                "state",
                "scan",
                "fold",
                "aggregation",
                "stateful-processing"
            ],
            "examples": [
                {
                    "code": "import { Stream, Effect, Chunk } from \"effect\";\n\ninterface Measurement {\n  readonly id: number;\n  readonly value: number;\n  readonly timestamp: Date;\n}\n\ninterface RunningStats {\n  readonly count: number;\n  readonly sum: number;\n  readonly min: number;\n  readonly max: number;\n  readonly average: number;\n  readonly variance: number;\n  readonly lastValue: number;\n}\n\n// Create stream of measurements\nconst createMeasurementStream = (): Stream.Stream<Measurement> =>\n  Stream.fromIterable([\n    { id: 1, value: 10, timestamp: new Date() },\n    { id: 2, value: 20, timestamp: new Date() },\n    { id: 3, value: 15, timestamp: new Date() },\n    { id: 4, value: 25, timestamp: new Date() },\n    { id: 5, value: 30, timestamp: new Date() },\n    { id: 6, value: 22, timestamp: new Date() },\n  ]);\n\n// Initial statistics state\nconst initialStats: RunningStats = {\n  count: 0,\n  sum: 0,\n  min: Infinity,\n  max: -Infinity,\n  average: 0,\n  variance: 0,\n  lastValue: 0,\n};\n\n// Reducer: update stats for each measurement\nconst updateStats = (\n  stats: RunningStats,\n  measurement: Measurement\n): RunningStats => {\n  const newCount = stats.count + 1;\n  const newSum = stats.sum + measurement.value;\n  const newAverage = newSum / newCount;\n\n  // Calculate variance incrementally\n  const delta = measurement.value - stats.average;\n  const delta2 = measurement.value - newAverage;\n  const newVariance = stats.variance + delta * delta2;\n\n  return {\n    count: newCount,\n    sum: newSum,\n    min: Math.min(stats.min, measurement.value),\n    max: Math.max(stats.max, measurement.value),\n    average: newAverage,\n    variance: newVariance / newCount,\n    lastValue: measurement.value,\n  };\n};\n\n// Main: demonstrate scan with statistics\nconst program = Effect.gen(function* () {\n  console.log(`\\n[SCAN] Running statistics stream:\\n`);\n\n  // Use scan to emit intermediate statistics\n  const statsStream = createMeasurementStream().pipe(\n    Stream.scan(initialStats, (stats, measurement) => {\n      const newStats = updateStats(stats, measurement);\n\n      console.log(\n        `[MEASUREMENT ${measurement.id}] Value: ${measurement.value}`\n      );\n      console.log(\n        `  Count: ${newStats.count}, Avg: ${newStats.average.toFixed(2)}, ` +\n        `Min: ${newStats.min}, Max: ${newStats.max}, ` +\n        `Variance: ${newStats.variance.toFixed(2)}`\n      );\n\n      return newStats;\n    })\n  );\n\n  // Collect all intermediate stats\n  const allStats = yield* statsStream.pipe(Stream.runCollect);\n\n  // Final statistics\n  const finalStats = Chunk.last(allStats);\n\n  if (finalStats._tag === \"Some\") {\n    console.log(`\\n[FINAL STATISTICS]`);\n    console.log(`  Total measurements: ${finalStats.value.count}`);\n    console.log(`  Average: ${finalStats.value.average.toFixed(2)}`);\n    console.log(`  Min: ${finalStats.value.min}`);\n    console.log(`  Max: ${finalStats.value.max}`);\n    console.log(\n      `  Std Dev: ${Math.sqrt(finalStats.value.variance).toFixed(2)}`\n    );\n  }\n\n  // Compare with fold (emit only final result)\n  console.log(`\\n[FOLD] Final statistics only:\\n`);\n\n  const finalResult = yield* createMeasurementStream().pipe(\n    Stream.fold(initialStats, updateStats),\n    Stream.tap((stats) =>\n      Effect.log(`Final: Count=${stats.count}, Avg=${stats.average.toFixed(2)}`)\n    )\n  );\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use scan for stateful element-by-element processing and fold for final aggregation, enabling complex stream analytics without buffering entire stream."
            },
            "created_at": "2026-02-15T21:22:22.117707",
            "updated_at": "2026-02-20T23:09:44.234063"
        },
        {
            "id": "142f0bea-89d6-464a-a2ae-d8dc3356c094",
            "slug": "accessing-current-time-with-clock",
            "title": "Accessing the Current Time with Clock",
            "summary": "Use the Clock service to access the current time in a testable, deterministic way, avoiding direct calls to Date.now().",
            "skill_level": "intermediate",
            "category": "testing",
            "difficulty": "intermediate",
            "tags": [
                "clock",
                "test-clock",
                "time",
                "testing",
                "dependency-injection"
            ],
            "examples": [
                {
                    "code": "import { Effect, Clock, Duration } from \"effect\";\n\ninterface Token {\n  readonly value: string;\n  readonly expiresAt: number; // UTC milliseconds\n}\n\n// This function is pure and testable because it depends on Clock\nconst isTokenExpired = (\n  token: Token\n): Effect.Effect<boolean, never, Clock.Clock> =>\n  Clock.currentTimeMillis.pipe(\n    Effect.map((now) => now > token.expiresAt),\n    Effect.tap((expired) =>\n      Clock.currentTimeMillis.pipe(\n        Effect.flatMap((currentTime) =>\n          Effect.log(\n            `Token expired? ${expired} (current time: ${new Date(currentTime).toISOString()})`\n          )\n        )\n      )\n    )\n  );\n\n// Create a test clock service that advances time\nconst makeTestClock = (timeMs: number): Clock.Clock => ({\n  currentTimeMillis: Effect.succeed(timeMs),\n  currentTimeNanos: Effect.succeed(BigInt(timeMs * 1_000_000)),\n  sleep: (duration: Duration.Duration) => Effect.succeed(void 0),\n  unsafeCurrentTimeMillis: () => timeMs,\n  unsafeCurrentTimeNanos: () => BigInt(timeMs * 1_000_000),\n  [Clock.ClockTypeId]: Clock.ClockTypeId,\n});\n\n// Create a token that expires in 1 second\nconst token = { value: \"abc\", expiresAt: Date.now() + 1000 };\n\n// Check token expiry with different clocks\nconst program = Effect.gen(function* () {\n  // Check with current time\n  yield* Effect.log(\"Checking with current time...\");\n  yield* isTokenExpired(token);\n\n  // Check with past time\n  yield* Effect.log(\"\\nChecking with past time (1 minute ago)...\");\n  const pastClock = makeTestClock(Date.now() - 60_000);\n  yield* isTokenExpired(token).pipe(\n    Effect.provideService(Clock.Clock, pastClock)\n  );\n\n  // Check with future time\n  yield* Effect.log(\"\\nChecking with future time (1 hour ahead)...\");\n  const futureClock = makeTestClock(Date.now() + 3600_000);\n  yield* isTokenExpired(token).pipe(\n    Effect.provideService(Clock.Clock, futureClock)\n  );\n});\n\n// Run the program with default clock\nEffect.runPromise(\n  program.pipe(Effect.provideService(Clock.Clock, makeTestClock(Date.now())))\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use the Clock service to get the current time, enabling deterministic testing with TestClock."
            },
            "created_at": "2026-02-15T21:22:28.339162",
            "updated_at": "2026-02-20T23:09:41.165434"
        },
        {
            "id": "7cedd156-6451-4c76-ae51-f0484aa55fef",
            "slug": "supercharge-your-editor-with-the-effect-lsp",
            "title": "Supercharge Your Editor with the Effect LSP",
            "summary": "Install the Effect Language Server (LSP) extension for your editor to get rich, inline type information and enhanced error checking for your Effect code.",
            "skill_level": "intermediate",
            "category": "tooling-and-debugging",
            "difficulty": "intermediate",
            "tags": [
                "lsp",
                "editor-setup",
                "tooling",
                "vscode",
                "developer-experience"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Define Logger service using Effect.Service pattern\nclass Logger extends Effect.Service<Logger>()(\"Logger\", {\n  sync: () => ({\n    log: (msg: string) => Effect.log(`LOG: ${msg}`),\n  }),\n}) {}\n\nconst program = Effect.succeed(42).pipe(\n  Effect.map((n) => n.toString()),\n  Effect.flatMap((s) => Effect.log(s)),\n  Effect.provide(Logger.Default)\n);\n\n// Run the program\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Install and use the Effect LSP extension for enhanced type information and error checking in your editor."
            },
            "created_at": "2026-02-15T21:22:30.479738",
            "updated_at": "2026-02-20T23:09:42.505886"
        },
        {
            "id": "72240346-7572-408a-a475-7bf0165e9972",
            "slug": "stream-run-for-effects",
            "title": "Run a Pipeline for its Side Effects",
            "summary": "Execute a pipeline for its effects without collecting the results, saving memory.",
            "skill_level": "beginner",
            "category": "building-data-pipelines",
            "difficulty": "beginner",
            "tags": [
                "stream",
                "run",
                "drain",
                "sink",
                "effects",
                "performance",
                "memory"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream } from \"effect\";\n\nconst tasks = [\"task 1\", \"task 2\", \"task 3\"];\n\n// A function that performs a side effect for a task\nconst completeTask = (task: string): Effect.Effect<void, never> =>\n  Effect.log(`Completing ${task}`);\n\nconst program = Stream.fromIterable(tasks).pipe(\n  // For each task, run the side-effectful operation\n  Stream.mapEffect(completeTask, { concurrency: 1 }),\n  // Run the stream for its effects, discarding the `void` results\n  Stream.runDrain\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  yield* program;\n  yield* Effect.log(\"\\nAll tasks have been processed.\");\n});\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\n... level=INFO msg=\"Completing task 1\"\n... level=INFO msg=\"Completing task 2\"\n... level=INFO msg=\"Completing task 3\"\n\nAll tasks have been processed.\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream.runDrain to execute a stream for its side effects when you don't need the final values."
            },
            "created_at": "2026-02-15T21:22:26.324041",
            "updated_at": "2026-02-20T23:09:43.442354"
        },
        {
            "id": "e6e17cc6-b159-42c3-a7c5-aebd47450587",
            "slug": "pattern-catchtag",
            "title": "Handling Specific Errors with catchTag and catchTags",
            "summary": "Use catchTag and catchTags to recover from or handle specific error types in the Effect failure channel, enabling precise and type-safe error recovery.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "catchTag",
                "catchTags",
                "pattern-matching",
                "effect",
                "error-handling",
                "tagged-union"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data } from \"effect\";\n\n// Define tagged error types\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{}> {}\nclass ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  message: string;\n}> {}\n\ntype MyError = NotFoundError | ValidationError;\n\n// Effect: Handle only ValidationError, let others propagate\nconst effect = Effect.fail(\n  new ValidationError({ message: \"Invalid input\" }) as MyError\n).pipe(\n  Effect.catchTag(\"ValidationError\", (err) =>\n    Effect.succeed(`Recovered from validation error: ${err.message}`)\n  )\n); // Effect<string>\n\n// Effect: Handle multiple error tags\nconst effect2 = Effect.fail(new NotFoundError() as MyError).pipe(\n  Effect.catchTags({\n    NotFoundError: () => Effect.succeed(\"Handled not found!\"),\n    ValidationError: (err) =>\n      Effect.succeed(`Handled validation: ${err.message}`),\n  })\n); // Effect<string>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use catchTag and catchTags to handle specific tagged error types in the Effect failure channel, providing targeted recovery logic."
            },
            "created_at": "2026-02-15T21:22:17.779853",
            "updated_at": "2026-02-20T23:09:41.628025"
        },
        {
            "id": "4d966b18-bcf5-4337-a216-a65bac777b1d",
            "slug": "observability-dashboards",
            "title": "Create Observability Dashboards",
            "summary": "Design effective dashboards to visualize your Effect application metrics.",
            "skill_level": "advanced",
            "category": "observability",
            "difficulty": "advanced",
            "tags": [
                "observability",
                "dashboards",
                "grafana",
                "visualization"
            ],
            "examples": [
                {
                    "code": "import { Effect, Metric } from \"effect\"\n\n// ============================================\n// Key metrics for overview dashboard\n// ============================================\n\n// RED metrics (Rate, Errors, Duration)\nconst requestRate = Metric.counter(\"http_requests_total\")\nconst errorRate = Metric.counter(\"http_errors_total\")\nconst requestDuration = Metric.histogram(\"http_request_duration_seconds\", {\n  boundaries: [0.01, 0.05, 0.1, 0.5, 1, 5],\n})\n\n// USE metrics (Utilization, Saturation, Errors)\nconst cpuUtilization = Metric.gauge(\"cpu_utilization_percent\")\nconst memoryUsage = Metric.gauge(\"memory_usage_bytes\")\nconst connectionPoolSize = Metric.gauge(\"connection_pool_active\")\n\n// Business metrics\nconst ordersProcessed = Metric.counter(\"orders_processed_total\")\nconst revenueTotal = Metric.counter(\"revenue_dollars_total\")",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Create focused dashboards that answer specific questions about system health."
            },
            "created_at": "2026-02-15T21:22:29.704671",
            "updated_at": "2026-02-20T23:09:42.999955"
        },
        {
            "id": "232ecc90-a23c-4944-a776-13999862e664",
            "slug": "stream-retry-on-failure",
            "title": "Automatically Retry Failed Operations",
            "summary": "Build a self-healing pipeline that can automatically retry failed processing steps using a configurable backoff strategy.",
            "skill_level": "intermediate",
            "category": "building-data-pipelines",
            "difficulty": "intermediate",
            "tags": [
                "stream",
                "retry",
                "resilience",
                "error-handling",
                "schedule"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Schedule } from \"effect\";\n\n// A mock function that simulates a flaky API call\nconst processItem = (id: number): Effect.Effect<string, Error> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`Attempting to process item ${id}...`);\n\n    // Item 2 fails on first attempt but succeeds on retry\n    if (id === 2) {\n      const random = Math.random();\n      if (random < 0.5) {\n        // 50% chance of failure for demonstration\n        yield* Effect.log(`Item ${id} failed, will retry...`);\n        return yield* Effect.fail(new Error(\"API is temporarily down\"));\n      }\n    }\n\n    yield* Effect.log(`\u2705 Successfully processed item ${id}`);\n    return `Processed item ${id}`;\n  });\n\nconst ids = [1, 2, 3];\n\n// Define a retry policy: 3 attempts with a fixed 100ms delay\nconst retryPolicy = Schedule.recurs(3).pipe(\n  Schedule.addDelay(() => \"100 millis\")\n);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Stream Retry on Failure Demo ===\");\n  yield* Effect.log(\n    \"Processing items with retry policy (3 attempts, 100ms delay)\"\n  );\n\n  // Process each item individually with retry\n  const results = yield* Effect.forEach(\n    ids,\n    (id) =>\n      processItem(id).pipe(\n        Effect.retry(retryPolicy),\n        Effect.catchAll((error) =>\n          Effect.gen(function* () {\n            yield* Effect.log(\n              `\u274c Item ${id} failed after all retries: ${error.message}`\n            );\n            return `Failed: item ${id}`;\n          })\n        )\n      ),\n    { concurrency: 1 }\n  );\n\n  yield* Effect.log(\"=== Results ===\");\n  for (let index = 0; index < results.length; index++) {\n    yield* Effect.log(`Item ${ids[index]}: ${results[index]}`);\n  }\n\n  yield* Effect.log(\"\u2705 Stream processing completed\");\n});\n\nEffect.runPromise(program).catch((error) => {\n  Effect.runSync(Effect.logError(\"Unexpected error: \" + error));\n});\n/*\nOutput:\n... level=INFO msg=\"Attempting to process item 1...\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Item 2 failed, attempt 1.\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Item 2 failed, attempt 2.\"\n... level=INFO msg=\"Attempting to process item 2...\"\n... level=INFO msg=\"Attempting to process item 3...\"\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Compose a Stream with the .retry(Schedule) operator to automatically recover from transient failures."
            },
            "created_at": "2026-02-15T21:22:26.406333",
            "updated_at": "2026-02-20T23:09:43.157549"
        },
        {
            "id": "78418d40-1e4b-47bb-a78e-c5e45a467a0b",
            "slug": "conditionally-branching-workflows",
            "title": "Conditionally Branching Workflows",
            "summary": "Use predicate-based operators like Effect.filter and Effect.if to make decisions and control the flow of your application based on runtime values.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "predicate",
                "filter",
                "if",
                "validation",
                "control-flow",
                "conditional"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\ninterface User {\n  id: number;\n  status: \"active\" | \"inactive\";\n  roles: string[];\n}\n\ntype UserError = \"DbError\" | \"UserIsInactive\" | \"UserIsNotAdmin\";\n\nconst findUser = (id: number): Effect.Effect<User, \"DbError\"> =>\n  Effect.succeed({ id, status: \"active\", roles: [\"admin\"] });\n\n// Reusable, testable predicates that document business rules.\nconst isActive = (user: User): boolean => user.status === \"active\";\n\nconst isAdmin = (user: User): boolean => user.roles.includes(\"admin\");\n\nconst program = (id: number): Effect.Effect<string, UserError> =>\n  findUser(id).pipe(\n    // Validate user is active using Effect.filterOrFail\n    Effect.filterOrFail(isActive, () => \"UserIsInactive\" as const),\n    // Validate user is admin using Effect.filterOrFail\n    Effect.filterOrFail(isAdmin, () => \"UserIsNotAdmin\" as const),\n    // Success case\n    Effect.map((user) => `Welcome, admin user #${user.id}!`)\n  );\n\n// We can then handle the specific failures in a type-safe way.\nconst handled = program(123).pipe(\n  Effect.match({\n    onFailure: (error) => {\n      switch (error) {\n        case \"UserIsNotAdmin\":\n          return \"Access denied: requires admin role.\";\n        case \"UserIsInactive\":\n          return \"Access denied: user is not active.\";\n        case \"DbError\":\n          return \"Error: could not find user.\";\n        default:\n          return `Unknown error: ${error}`;\n      }\n    },\n    onSuccess: (result) => result,\n  })\n);\n\n// Run the program\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* handled;\n  yield* Effect.log(result);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use predicate-based operators like Effect.filter and Effect.if to declaratively control workflow branching."
            },
            "created_at": "2026-02-15T21:22:17.362793",
            "updated_at": "2026-02-20T23:09:41.756205"
        },
        {
            "id": "ffefe697-95f1-4dcb-9501-4fe4810e7a4b",
            "slug": "platform-pattern-path-manipulation",
            "title": "Platform Pattern 5: Cross-Platform Path Manipulation",
            "summary": "Use platform-aware path operations to handle file system paths correctly across Windows, macOS, and Linux with proper resolution and normalization.",
            "skill_level": "intermediate",
            "category": "platform",
            "difficulty": "intermediate",
            "tags": [
                "platform",
                "path-manipulation",
                "filesystem",
                "cross-platform",
                "path-resolution",
                "environment-variables"
            ],
            "examples": [
                {
                    "code": "import { Effect, FileSystem } from \"@effect/platform\";\nimport * as Path from \"node:path\";\nimport * as OS from \"node:os\";\n\ninterface PathOperation {\n  readonly input: string;\n  readonly description: string;\n}\n\n// Platform info\nconst getPlatformInfo = () =>\n  Effect.gen(function* () {\n    const platform = process.platform;\n    const separator = Path.sep;\n    const delimiter = Path.delimiter;\n    const homeDir = OS.homedir();\n\n    yield* Effect.log(\n      `[PLATFORM] OS: ${platform}, Separator: \"${separator}\", Home: ${homeDir}`\n    );\n\n    return { platform, separator, delimiter, homeDir };\n  });\n\nconst program = Effect.gen(function* () {\n  console.log(`\\n[PATH MANIPULATION] Cross-platform path operations\\n`);\n\n  const platformInfo = yield* getPlatformInfo();\n\n  // Example 1: Path joining (handles separators)\n  console.log(`\\n[1] Joining paths (handles separators automatically):\\n`);\n\n  const segments = [\"data\", \"reports\", \"2024\"];\n\n  const joinedPath = Path.join(...segments);\n\n  yield* Effect.log(`[JOIN] Input: ${segments.join(\" + \")}`);\n  yield* Effect.log(`[JOIN] Output: ${joinedPath}`);\n\n  // Example 2: Resolving to absolute paths\n  console.log(`\\n[2] Resolving relative \u2192 absolute:\\n`);\n\n  const relativePath = \"./config/settings.json\";\n\n  const absolutePath = Path.resolve(relativePath);\n\n  yield* Effect.log(`[RESOLVE] Relative: ${relativePath}`);\n  yield* Effect.log(`[RESOLVE] Absolute: ${absolutePath}`);\n\n  // Example 3: Path parsing\n  console.log(`\\n[3] Parsing path components:\\n`);\n\n  const filePath = \"/home/user/documents/report.pdf\";\n\n  const parsed = Path.parse(filePath);\n\n  yield* Effect.log(`[PARSE] Input: ${filePath}`);\n  yield* Effect.log(`  root: ${parsed.root}`);\n  yield* Effect.log(`  dir: ${parsed.dir}`);\n  yield* Effect.log(`  base: ${parsed.base}`);\n  yield* Effect.log(`  name: ${parsed.name}`);\n  yield* Effect.log(`  ext: ${parsed.ext}`);\n\n  // Example 4: Environment variable expansion\n  console.log(`\\n[4] Environment variable expansion:\\n`);\n\n  const expandPath = (pathStr: string): string => {\n    let result = pathStr;\n\n    // Expand common variables\n    result = result.replace(\"$HOME\", OS.homedir());\n    result = result.replace(\"~\", OS.homedir());\n    result = result.replace(\"$USER\", process.env.USER || \"user\");\n    result = result.replace(\"$PWD\", process.cwd());\n\n    // Handle Windows-style env vars\n    result = result.replace(/%USERPROFILE%/g, OS.homedir());\n    result = result.replace(/%USERNAME%/g, process.env.USERNAME || \"user\");\n    result = result.replace(/%TEMP%/g, OS.tmpdir());\n\n    return result;\n  };\n\n  const envPaths = [\n    \"$HOME/myapp/data\",\n    \"~/documents/file.txt\",\n    \"$PWD/config\",\n    \"/var/log/app.log\",\n  ];\n\n  for (const envPath of envPaths) {\n    const expanded = expandPath(envPath);\n\n    yield* Effect.log(\n      `[EXPAND] ${envPath} \u2192 ${expanded}`\n    );\n  }\n\n  // Example 5: Path normalization (remove redundant separators)\n  console.log(`\\n[5] Path normalization:\\n`);\n\n  const messyPaths = [\n    \"/home//user///documents\",\n    \"C:\\\\Users\\\\\\\\documents\\\\\\\\file.txt\",\n    \"./config/../config/./settings\",\n    \"../data/../../root\",\n  ];\n\n  for (const messy of messyPaths) {\n    const normalized = Path.normalize(messy);\n\n    yield* Effect.log(\n      `[NORMALIZE] ${messy}`\n    );\n    yield* Effect.log(\n      `[NORMALIZE]   \u2192 ${normalized}`\n    );\n  }\n\n  // Example 6: Safe path construction with base directory\n  console.log(`\\n[6] Safe path construction (path traversal prevention):\\n`);\n\n  const baseDir = \"/var/app/data\";\n\n  const safeJoin = (base: string, userPath: string): Result<string> => {\n    // Reject absolute paths from untrusted input\n    if (Path.isAbsolute(userPath)) {\n      return { success: false, reason: \"Absolute paths not allowed\" };\n    }\n\n    // Reject paths with ..\n    if (userPath.includes(\"..\")) {\n      return { success: false, reason: \"Path traversal attempt detected\" };\n    }\n\n    // Resolve and verify within base\n    const fullPath = Path.resolve(base, userPath);\n\n    if (!fullPath.startsWith(base)) {\n      return { success: false, reason: \"Path escapes base directory\" };\n    }\n\n    return { success: true, path: fullPath };\n  };\n\n  interface Result<T> {\n    success: boolean;\n    reason?: string;\n    path?: T;\n  }\n\n  const testPaths = [\n    \"reports/2024.json\",\n    \"/etc/passwd\",\n    \"../../../root\",\n    \"data/file.txt\",\n  ];\n\n  for (const test of testPaths) {\n    const result = safeJoin(baseDir, test);\n\n    if (result.success) {\n      yield* Effect.log(`[SAFE] \u2713 ${test} \u2192 ${result.path}`);\n    } else {\n      yield* Effect.log(`[SAFE] \u2717 ${test} (${result.reason})`);\n    }\n  }\n\n  // Example 7: Relative path calculation\n  console.log(`\\n[7] Computing relative paths:\\n`);\n\n  const fromDir = \"/home/user/projects/myapp\";\n  const toPath = \"/home/user/data/config.json\";\n\n  const relativePath2 = Path.relative(fromDir, toPath);\n\n  yield* Effect.log(`[RELATIVE] From: ${fromDir}`);\n  yield* Effect.log(`[RELATIVE] To: ${toPath}`);\n  yield* Effect.log(`[RELATIVE] Relative: ${relativePath2}`);\n\n  // Example 8: Common path patterns\n  console.log(`\\n[8] Common patterns:\\n`);\n\n  // Get file extension\n  const fileName = \"document.tar.gz\";\n  const ext = Path.extname(fileName);\n  const baseName = Path.basename(fileName);\n  const dirName = Path.dirname(\"/home/user/file.txt\");\n\n  yield* Effect.log(`[PATTERNS] File: ${fileName}`);\n  yield* Effect.log(`  basename: ${baseName}`);\n  yield* Effect.log(`  dirname: ${dirName}`);\n  yield* Effect.log(`  extname: ${ext}`);\n\n  // Example 9: Path segments array\n  console.log(`\\n[9] Path segments:\\n`);\n\n  const segmentPath = \"/home/user/documents/report.pdf\";\n\n  const segments2 = segmentPath.split(Path.sep).filter((s) => s);\n\n  yield* Effect.log(`[SEGMENTS] ${segmentPath}`);\n  yield* Effect.log(`[SEGMENTS] \u2192 [${segments2.map((s) => `\"${s}\"`).join(\", \")}]`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect's platform-aware path utilities to handle separators, absolute/relative paths, and environment variables consistently."
            },
            "created_at": "2026-02-15T21:22:23.009026",
            "updated_at": "2026-02-20T23:09:43.806209"
        },
        {
            "id": "b9cac317-dff2-4150-9baf-b8485943a100",
            "slug": "platform-pattern-advanced-filesystem",
            "title": "Platform Pattern 6: Advanced FileSystem Operations",
            "summary": "Handle complex file system scenarios including watching files, recursive operations, atomic writes, and efficient bulk operations.",
            "skill_level": "advanced",
            "category": "platform",
            "difficulty": "advanced",
            "tags": [
                "platform",
                "filesystem",
                "file-watching",
                "atomic-operations",
                "bulk-operations",
                "efficient-io"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Ref, FileSystem } from \"@effect/platform\";\nimport * as Path from \"node:path\";\nimport * as FS from \"node:fs\";\nimport * as PromiseFS from \"node:fs/promises\";\n\nconst program = Effect.gen(function* () {\n  console.log(`\\n[ADVANCED FILESYSTEM] Complex file operations\\n`);\n\n  // Example 1: Atomic file write with temporary file\n  console.log(`[1] Atomic write (crash-safe):\\n`);\n\n  const atomicWrite = (\n    filePath: string,\n    content: string\n  ): Effect.Effect<void> =>\n    Effect.gen(function* () {\n      const tempPath = `${filePath}.tmp`;\n\n      try {\n        // Step 1: Write to temporary file\n        yield* Effect.promise(() =>\n          PromiseFS.writeFile(tempPath, content, \"utf-8\")\n        );\n\n        yield* Effect.log(`[WRITE] Wrote to temporary file`);\n\n        // Step 2: Ensure on disk (fsync)\n        yield* Effect.promise(() =>\n          PromiseFS.writeFile(tempPath, content, \"utf-8\")\n        );\n\n        yield* Effect.log(`[FSYNC] Data on disk`);\n\n        // Step 3: Atomic rename\n        yield* Effect.promise(() =>\n          PromiseFS.rename(tempPath, filePath)\n        );\n\n        yield* Effect.log(`[RENAME] Atomic rename complete`);\n      } catch (error) {\n        // Cleanup on failure\n        try {\n          yield* Effect.promise(() => PromiseFS.unlink(tempPath));\n        } catch {\n          // Ignore cleanup errors\n        }\n\n        yield* Effect.fail(error);\n      }\n    });\n\n  // Test atomic write\n  const testFile = \"./test-file.txt\";\n\n  yield* atomicWrite(testFile, \"Important configuration\\n\");\n\n  // Verify file\n  const content = yield* Effect.promise(() =>\n    PromiseFS.readFile(testFile, \"utf-8\")\n  );\n\n  yield* Effect.log(`[READ] Got: \"${content.trim()}\"\\n`);\n\n  // Example 2: Streaming read (memory efficient)\n  console.log(`[2] Streaming read (handle large files):\\n`);\n\n  const streamingRead = (filePath: string) =>\n    Effect.gen(function* () {\n      let byteCount = 0;\n      let lineCount = 0;\n\n      const readStream = FS.createReadStream(filePath, {\n        encoding: \"utf-8\",\n        highWaterMark: 64 * 1024, // 64KB chunks\n      });\n\n      yield* Effect.log(`[STREAM] Starting read with 64KB chunks`);\n\n      const processLine = (line: string) =>\n        Effect.gen(function* () {\n          byteCount += line.length;\n          lineCount++;\n\n          if (lineCount <= 2 || lineCount % 1000 === 0) {\n            yield* Effect.log(\n              `[LINE ${lineCount}] Length: ${line.length} bytes`\n            );\n          }\n        });\n\n      // In real code, process all lines\n      yield* processLine(\"line 1\");\n      yield* processLine(\"line 2\");\n\n      yield* Effect.log(\n        `[TOTAL] Read ${lineCount} lines, ${byteCount} bytes`\n      );\n    });\n\n  yield* streamingRead(testFile);\n\n  // Example 3: Recursive directory listing\n  console.log(`\\n[3] Recursive directory traversal:\\n`);\n\n  const recursiveList = (\n    dir: string,\n    maxDepth: number = 3\n  ): Effect.Effect<Array<{ path: string; type: \"file\" | \"dir\" }>> =>\n    Effect.gen(function* () {\n      const results: Array<{ path: string; type: \"file\" | \"dir\" }> = [];\n\n      const traverse = (currentDir: string, depth: number) =>\n        Effect.gen(function* () {\n          if (depth > maxDepth) {\n            return;\n          }\n\n          const entries = yield* Effect.promise(() =>\n            PromiseFS.readdir(currentDir, { withFileTypes: true })\n          );\n\n          for (const entry of entries) {\n            const fullPath = Path.join(currentDir, entry.name);\n\n            if (entry.isDirectory()) {\n              results.push({ path: fullPath, type: \"dir\" });\n\n              yield* traverse(fullPath, depth + 1);\n            } else {\n              results.push({ path: fullPath, type: \"file\" });\n            }\n          }\n        });\n\n      yield* traverse(dir, 0);\n\n      return results;\n    });\n\n  // List files in current directory\n  const entries = yield* recursiveList(\".\", 1);\n\n  yield* Effect.log(\n    `[ENTRIES] Found ${entries.length} items:`\n  );\n\n  for (const entry of entries.slice(0, 5)) {\n    const type = entry.type === \"file\" ? \"\ud83d\udcc4\" : \"\ud83d\udcc1\";\n\n    yield* Effect.log(`  ${type} ${entry.path}`);\n  }\n\n  // Example 4: Bulk file operations\n  console.log(`\\n[4] Bulk operations (efficient batching):\\n`);\n\n  const bulkCreate = (files: Array<{ name: string; content: string }>) =>\n    Effect.gen(function* () {\n      yield* Effect.log(`[BULK] Creating ${files.length} files...`);\n\n      for (const file of files) {\n        yield* atomicWrite(`./${file.name}`, file.content);\n      }\n\n      yield* Effect.log(`[BULK] Created ${files.length} files`);\n    });\n\n  const testFiles = [\n    { name: \"config1.txt\", content: \"Config 1\" },\n    { name: \"config2.txt\", content: \"Config 2\" },\n    { name: \"config3.txt\", content: \"Config 3\" },\n  ];\n\n  yield* bulkCreate(testFiles);\n\n  // Example 5: File watching (detect changes)\n  console.log(`\\n[5] File watching (react to changes):\\n`);\n\n  const watchFile = (filePath: string) =>\n    Effect.gen(function* () {\n      yield* Effect.log(`[WATCH] Starting to watch: ${filePath}`);\n\n      let changeCount = 0;\n\n      // Simulate file watcher\n      const checkForChanges = () =>\n        Effect.gen(function* () {\n          for (let i = 0; i < 3; i++) {\n            yield* Effect.sleep(\"100 millis\");\n\n            // Check file modification time\n            const stat = yield* Effect.promise(() =>\n              PromiseFS.stat(filePath)\n            );\n\n            // In real implementation, compare previous mtime\n            if (i === 1) {\n              changeCount++;\n\n              yield* Effect.log(\n                `[CHANGE] File modified (${stat.size} bytes)`\n              );\n            }\n          }\n        });\n\n      yield* checkForChanges();\n\n      yield* Effect.log(`[WATCH] Detected ${changeCount} changes`);\n    });\n\n  yield* watchFile(testFile);\n\n  // Example 6: Safe concurrent file operations\n  console.log(`\\n[6] Concurrent file operations with safety:\\n`);\n\n  const lockFile = (filePath: string) =>\n    Effect.gen(function* () {\n      const lockPath = `${filePath}.lock`;\n\n      // Acquire lock\n      yield* atomicWrite(lockPath, \"locked\");\n\n      yield* Effect.log(`[LOCK] Acquired: ${lockPath}`);\n\n      try {\n        // Critical section\n        yield* Effect.sleep(\"50 millis\");\n\n        yield* Effect.log(`[CRITICAL] Operating on locked file`);\n      } finally {\n        // Release lock\n        yield* Effect.promise(() =>\n          PromiseFS.unlink(lockPath)\n        );\n\n        yield* Effect.log(`[UNLOCK] Released: ${lockPath}`);\n      }\n    });\n\n  yield* lockFile(testFile);\n\n  // Example 7: Efficient file copying\n  console.log(`\\n[7] Efficient file copying:\\n`);\n\n  const efficientCopy = (\n    source: string,\n    destination: string\n  ): Effect.Effect<void> =>\n    Effect.gen(function* () {\n      const stat = yield* Effect.promise(() =>\n        PromiseFS.stat(source)\n      );\n\n      yield* Effect.log(\n        `[COPY] Reading ${(stat.size / 1024).toFixed(2)}KB`\n      );\n\n      const content = yield* Effect.promise(() =>\n        PromiseFS.readFile(source)\n      );\n\n      yield* atomicWrite(destination, content.toString());\n\n      yield* Effect.log(`[COPY] Complete: ${destination}`);\n    });\n\n  yield* efficientCopy(testFile, \"./test-file-copy.txt\");\n\n  // Cleanup\n  yield* Effect.log(`\\n[CLEANUP] Removing test files`);\n\n  for (const name of [testFile, \"test-file-copy.txt\", ...testFiles.map((f) => `./${f.name}`)]) {\n    try {\n      yield* Effect.promise(() =>\n        PromiseFS.unlink(name)\n      );\n\n      yield* Effect.log(`[REMOVED] ${name}`);\n    } catch {\n      // File doesn't exist, that's ok\n    }\n  }\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use advanced file system patterns to implement efficient, reliable file operations with proper error handling and resource cleanup."
            },
            "created_at": "2026-02-15T21:22:23.092595",
            "updated_at": "2026-02-20T23:09:43.935975"
        },
        {
            "id": "cf062e01-e092-4bd7-be32-0cf2cfebf09a",
            "slug": "stream-pattern-advanced-transformations",
            "title": "Stream Pattern 8: Advanced Stream Transformations",
            "summary": "Apply complex transformations across streams including custom operators, effect-based transformations, and composition patterns.",
            "skill_level": "advanced",
            "category": "streams",
            "difficulty": "advanced",
            "tags": [
                "streams",
                "transformations",
                "composition",
                "effect-based",
                "advanced-patterns",
                "performance"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Ref, Chunk } from \"effect\";\n\ninterface LogEntry {\n  timestamp: Date;\n  level: \"info\" | \"warn\" | \"error\";\n  message: string;\n  context?: Record<string, unknown>;\n}\n\ninterface Metric {\n  name: string;\n  value: number;\n  tags: Record<string, string>;\n}\n\nconst program = Effect.gen(function* () {\n  console.log(`\\n[ADVANCED STREAM TRANSFORMATIONS] Complex data flows\\n`);\n\n  // Example 1: Custom filter operator\n  console.log(`[1] Custom filter with effect-based logic:\\n`);\n\n  const filterByEffect = <A,>(\n    predicate: (a: A) => Effect.Effect<boolean>\n  ) =>\n    (stream: Stream.Stream<A>) =>\n      stream.pipe(\n        Stream.mapEffect((value) =>\n          predicate(value).pipe(\n            Effect.map((keep) => (keep ? value : null))\n          )\n        ),\n        Stream.filter((value) => value !== null)\n      );\n\n  const isValid = (num: number): Effect.Effect<boolean> =>\n    Effect.gen(function* () {\n      // Simulate validation effect (e.g., API call)\n      return num > 0 && num < 100;\n    });\n\n  const numbers = [50, 150, 25, -10, 75];\n\n  const validNumbers = yield* Stream.fromIterable(numbers).pipe(\n    filterByEffect(isValid),\n    Stream.runCollect\n  );\n\n  yield* Effect.log(`[VALID] ${validNumbers.join(\", \")}\\n`);\n\n  // Example 2: Enrichment transformation\n  console.log(`[2] Enriching records with additional data:\\n`);\n\n  interface RawRecord {\n    id: string;\n    value: number;\n  }\n\n  interface EnrichedRecord {\n    id: string;\n    value: number;\n    validated: boolean;\n    processed: Date;\n    metadata: Record<string, unknown>;\n  }\n\n  const enrich = (record: RawRecord): Effect.Effect<EnrichedRecord> =>\n    Effect.gen(function* () {\n      // Simulate lookup/validation\n      const validated = record.value > 0;\n\n      return {\n        id: record.id,\n        value: record.value,\n        validated,\n        processed: new Date(),\n        metadata: { source: \"stream\" },\n      };\n    });\n\n  const rawData = [\n    { id: \"r1\", value: 10 },\n    { id: \"r2\", value: -5 },\n    { id: \"r3\", value: 20 },\n  ];\n\n  const enriched = yield* Stream.fromIterable(rawData).pipe(\n    Stream.mapEffect((record) => enrich(record)),\n    Stream.runCollect\n  );\n\n  yield* Effect.log(`[ENRICHED] ${enriched.length} records enriched\\n`);\n\n  // Example 3: Demultiplexing (split one stream into multiple)\n  console.log(`[3] Demultiplexing by category:\\n`);\n\n  interface Event {\n    id: string;\n    type: \"click\" | \"view\" | \"purchase\";\n    data: unknown;\n  }\n\n  const events: Event[] = [\n    { id: \"e1\", type: \"click\", data: { x: 100, y: 200 } },\n    { id: \"e2\", type: \"view\", data: { url: \"/\" } },\n    { id: \"e3\", type: \"purchase\", data: { amount: 99.99 } },\n    { id: \"e4\", type: \"click\", data: { x: 50, y: 100 } },\n  ];\n\n  const clicks = yield* Stream.fromIterable(events).pipe(\n    Stream.filter((e) => e.type === \"click\"),\n    Stream.runCollect\n  );\n\n  const views = yield* Stream.fromIterable(events).pipe(\n    Stream.filter((e) => e.type === \"view\"),\n    Stream.runCollect\n  );\n\n  const purchases = yield* Stream.fromIterable(events).pipe(\n    Stream.filter((e) => e.type === \"purchase\"),\n    Stream.runCollect\n  );\n\n  yield* Effect.log(\n    `[DEMUX] Clicks: ${clicks.length}, Views: ${views.length}, Purchases: ${purchases.length}\\n`\n  );\n\n  // Example 4: Chunked processing (batch transformation)\n  console.log(`[4] Chunked processing (batches of N):\\n`);\n\n  const processChunk = (chunk: Array<{ id: string; value: number }>) =>\n    Effect.gen(function* () {\n      const sum = chunk.reduce((s, r) => s + r.value, 0);\n      const avg = sum / chunk.length;\n\n      yield* Effect.log(\n        `[CHUNK] ${chunk.length} items, avg: ${avg.toFixed(2)}`\n      );\n\n      return { size: chunk.length, sum, avg };\n    });\n\n  const data = Array.from({ length: 10 }, (_, i) => ({\n    id: `d${i}`,\n    value: i + 1,\n  }));\n\n  const chunkSize = 3;\n  const chunks = [];\n\n  for (let i = 0; i < data.length; i += chunkSize) {\n    const chunk = data.slice(i, i + chunkSize);\n\n    chunks.push(chunk);\n  }\n\n  const chunkResults = yield* Effect.all(\n    chunks.map((chunk) => processChunk(chunk))\n  );\n\n  yield* Effect.log(\n    `[CHUNKS] Processed ${chunkResults.length} batches\\n`\n  );\n\n  // Example 5: Multi-stage transformation pipeline\n  console.log(`[5] Multi-stage pipeline (parse \u2192 validate \u2192 transform):\\n`);\n\n  const rawStrings = [\"10\", \"twenty\", \"30\", \"-5\", \"50\"];\n\n  // Stage 1: Parse\n  const parsed = yield* Stream.fromIterable(rawStrings).pipe(\n    Stream.mapEffect((s) =>\n      Effect.gen(function* () {\n        try {\n          return parseInt(s);\n        } catch (error) {\n          yield* Effect.fail(\n            new Error(`Failed to parse: ${s}`)\n          );\n        }\n      }).pipe(\n        Effect.catchAll((error) =>\n          Effect.gen(function* () {\n            yield* Effect.log(`[PARSE ERROR] ${error.message}`);\n\n            return null;\n          })\n        )\n      )\n    ),\n    Stream.filter((n) => n !== null),\n    Stream.runCollect\n  );\n\n  yield* Effect.log(`[STAGE 1] Parsed: ${parsed.join(\", \")}`);\n\n  // Stage 2: Validate\n  const validated = parsed.filter((n) => n > 0);\n\n  yield* Effect.log(`[STAGE 2] Validated: ${validated.join(\", \")}`);\n\n  // Stage 3: Transform\n  const transformed = validated.map((n) => n * 2);\n\n  yield* Effect.log(`[STAGE 3] Transformed: ${transformed.join(\", \")}\\n`);\n\n  // Example 6: Composition of custom operators\n  console.log(`[6] Composable transformation pipeline:\\n`);\n\n  // Define custom operator\n  const withLogging = <A,>(label: string) =>\n    (stream: Stream.Stream<A>) =>\n      stream.pipe(\n        Stream.tap((value) =>\n          Effect.log(`[${label}] Processing: ${JSON.stringify(value)}`)\n        )\n      );\n\n  const filterPositive = (stream: Stream.Stream<number>) =>\n    stream.pipe(\n      Stream.filter((n) => n > 0),\n      Stream.tap(() => Effect.log(`[FILTER] Kept positive`))\n    );\n\n  const scaleUp = (factor: number) =>\n    (stream: Stream.Stream<number>) =>\n      stream.pipe(\n        Stream.map((n) => n * factor),\n        Stream.tap((n) =>\n          Effect.log(`[SCALE] Scaled to ${n}`)\n        )\n      );\n\n  const testData = [10, -5, 20, -3, 30];\n\n  const pipeline = yield* Stream.fromIterable(testData).pipe(\n    withLogging(\"INPUT\"),\n    filterPositive,\n    scaleUp(10),\n    Stream.runCollect\n  );\n\n  yield* Effect.log(`[RESULT] Final: ${pipeline.join(\", \")}\\n`);\n\n  // Example 7: Stateful transformation\n  console.log(`[7] Stateful transformation (running total):\\n`);\n\n  const runningTotal = yield* Stream.fromIterable([1, 2, 3, 4, 5]).pipe(\n    Stream.scan(0, (acc, value) => acc + value),\n    Stream.runCollect\n  );\n\n  yield* Effect.log(`[TOTALS] ${runningTotal.join(\", \")}\\n`);\n\n  // Example 8: Conditional transformation\n  console.log(`[8] Conditional transformation (different paths):\\n`);\n\n  interface Item {\n    id: string;\n    priority: \"high\" | \"normal\" | \"low\";\n  }\n\n  const transformByPriority = (item: Item): Effect.Effect<{\n    id: string;\n    processed: string;\n  }> =>\n    Effect.gen(function* () {\n      switch (item.priority) {\n        case \"high\":\n          yield* Effect.log(`[HIGH] Priority processing for ${item.id}`);\n\n          return { id: item.id, processed: \"urgent\" };\n\n        case \"normal\":\n          yield* Effect.log(\n            `[NORMAL] Standard processing for ${item.id}`\n          );\n\n          return { id: item.id, processed: \"standard\" };\n\n        case \"low\":\n          yield* Effect.log(`[LOW] Deferred processing for ${item.id}`);\n\n          return { id: item.id, processed: \"deferred\" };\n      }\n    });\n\n  const items: Item[] = [\n    { id: \"i1\", priority: \"normal\" },\n    { id: \"i2\", priority: \"high\" },\n    { id: \"i3\", priority: \"low\" },\n  ];\n\n  const processed = yield* Stream.fromIterable(items).pipe(\n    Stream.mapEffect((item) => transformByPriority(item)),\n    Stream.runCollect\n  );\n\n  yield* Effect.log(\n    `[CONDITIONAL] Processed ${processed.length} items\\n`\n  );\n\n  // Example 9: Performance-optimized transformation\n  console.log(`[9] Optimized for performance:\\n`);\n\n  const largeDataset = Array.from({ length: 1000 }, (_, i) => i);\n\n  const startTime = Date.now();\n\n  // Use efficient operators\n  const result = yield* Stream.fromIterable(largeDataset).pipe(\n    Stream.filter((n) => n % 2 === 0), // Keep even\n    Stream.take(100), // Limit to first 100\n    Stream.map((n) => n * 2), // Transform\n    Stream.runCollect\n  );\n\n  const elapsed = Date.now() - startTime;\n\n  yield* Effect.log(\n    `[PERF] Processed 1000 items in ${elapsed}ms, kept ${result.length} items`\n  );\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use advanced stream operators to build sophisticated data pipelines that compose elegantly and maintain performance at scale."
            },
            "created_at": "2026-02-15T21:22:22.447495",
            "updated_at": "2026-02-20T23:09:44.148344"
        },
        {
            "id": "0c4512c9-98d8-4d61-8784-de71af67dbc6",
            "slug": "stream-take-drop",
            "title": "Take and Drop Stream Elements",
            "summary": "Control how many stream elements to process using take, drop, takeWhile, and dropWhile.",
            "skill_level": "beginner",
            "category": "streams",
            "difficulty": "beginner",
            "tags": [
                "stream",
                "take",
                "drop",
                "slice",
                "limit"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream } from \"effect\"\n\nconst numbers = Stream.make(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n// ============================================\n// take - Get first N elements\n// ============================================\n\nconst firstThree = numbers.pipe(\n  Stream.take(3),\n  Stream.runCollect\n)\n\nEffect.runPromise(firstThree).then((chunk) => {\n  console.log([...chunk])  // [1, 2, 3]\n})\n\n// ============================================\n// drop - Skip first N elements\n// ============================================\n\nconst skipThree = numbers.pipe(\n  Stream.drop(3),\n  Stream.runCollect\n)\n\nEffect.runPromise(skipThree).then((chunk) => {\n  console.log([...chunk])  // [4, 5, 6, 7, 8, 9, 10]\n})\n\n// ============================================\n// Combine for pagination (skip + limit)\n// ============================================\n\nconst page2 = numbers.pipe(\n  Stream.drop(3),   // Skip first page\n  Stream.take(3),   // Take second page\n  Stream.runCollect\n)\n\nEffect.runPromise(page2).then((chunk) => {\n  console.log([...chunk])  // [4, 5, 6]\n})\n\n// ============================================\n// takeWhile - Take while condition is true\n// ============================================\n\nconst untilFive = numbers.pipe(\n  Stream.takeWhile((n) => n < 5),\n  Stream.runCollect\n)\n\nEffect.runPromise(untilFive).then((chunk) => {\n  console.log([...chunk])  // [1, 2, 3, 4]\n})\n\n// ============================================\n// dropWhile - Skip while condition is true\n// ============================================\n\nconst afterFive = numbers.pipe(\n  Stream.dropWhile((n) => n < 5),\n  Stream.runCollect\n)\n\nEffect.runPromise(afterFive).then((chunk) => {\n  console.log([...chunk])  // [5, 6, 7, 8, 9, 10]\n})\n\n// ============================================\n// takeUntil - Take until condition becomes true\n// ============================================\n\nconst untilSix = numbers.pipe(\n  Stream.takeUntil((n) => n === 6),\n  Stream.runCollect\n)\n\nEffect.runPromise(untilSix).then((chunk) => {\n  console.log([...chunk])  // [1, 2, 3, 4, 5, 6]\n})\n\n// ============================================\n// Practical: Process file with header\n// ============================================\n\nconst fileLines = Stream.make(\n  \"# Header\",\n  \"# Comment\",\n  \"data1\",\n  \"data2\",\n  \"data3\"\n)\n\nconst dataOnly = fileLines.pipe(\n  Stream.dropWhile((line) => line.startsWith(\"#\")),\n  Stream.runCollect\n)\n\nEffect.runPromise(dataOnly).then((chunk) => {\n  console.log([...chunk])  // [\"data1\", \"data2\", \"data3\"]\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use take/drop to control stream size, takeWhile/dropWhile for conditional limits."
            },
            "created_at": "2026-02-15T21:22:21.264138",
            "updated_at": "2026-02-20T23:09:44.525685"
        },
        {
            "id": "85c7c805-3fb9-4fc7-80ba-a240687efcb5",
            "slug": "control-repetition-with-schedule",
            "title": "Control Repetition with Schedule",
            "summary": "Use Schedule to create composable, stateful policies that define precisely how an effect should be repeated or retried.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "schedule",
                "repeat",
                "retry",
                "polling",
                "policy",
                "recurs",
                "exponential"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule, Duration } from \"effect\";\n\n// A simple effect that can fail\nconst flakyEffect = Effect.try({\n  try: () => {\n    if (Math.random() > 0.2) {\n      throw new Error(\"Transient error\");\n    }\n    return \"Operation succeeded!\";\n  },\n  catch: (error: unknown) => {\n    Effect.logInfo(\"Operation failed, retrying...\");\n    return error;\n  },\n});\n\n// --- Building a Composable Schedule ---\n\n// 1. Start with a base exponential backoff (100ms, 200ms, 400ms...)\nconst exponentialBackoff = Schedule.exponential(\"100 millis\");\n\n// 2. Add random jitter to avoid thundering herd problems\nconst withJitter = Schedule.jittered(exponentialBackoff);\n\n// 3. Limit the schedule to a maximum of 5 repetitions\nconst limitedWithJitter = Schedule.compose(withJitter, Schedule.recurs(5));\n\n// --- Using the Schedule ---\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Starting operation...\");\n  const result = yield* Effect.retry(flakyEffect, limitedWithJitter);\n  yield* Effect.logInfo(`Final result: ${result}`);\n});\n\n// Run the program\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Schedule to create composable policies for controlling the repetition and retrying of effects."
            },
            "created_at": "2026-02-15T21:22:17.444874",
            "updated_at": "2026-02-20T23:09:42.026093"
        },
        {
            "id": "5e682c49-3eb5-4fca-b50f-40f8bffc7156",
            "slug": "mapping-errors-to-fit-your-domain",
            "title": "Mapping Errors to Fit Your Domain",
            "summary": "Use Effect.mapError to transform specific, low-level errors into more general domain errors, creating clean architectural boundaries.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "error-handling",
                "mapError",
                "architecture",
                "domain-modeling",
                "errors"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data } from \"effect\";\n\n// Low-level, specific errors from the database layer\nclass ConnectionError extends Data.TaggedError(\"ConnectionError\") {}\nclass QueryError extends Data.TaggedError(\"QueryError\") {}\n\n// A generic error for the repository layer\nclass RepositoryError extends Data.TaggedError(\"RepositoryError\")<{\n  readonly cause: unknown;\n}> {}\n\n// The inner service\nconst dbQuery = (): Effect.Effect<\n  { name: string },\n  ConnectionError | QueryError\n> => Effect.fail(new ConnectionError());\n\n// The outer service uses `mapError` to create a clean boundary.\n// Its public signature only exposes `RepositoryError`.\nconst findUser = (): Effect.Effect<{ name: string }, RepositoryError> =>\n  dbQuery().pipe(\n    Effect.mapError((error) => new RepositoryError({ cause: error }))\n  );\n\n// Demonstrate the error mapping\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Attempting to find user...\");\n\n  try {\n    const user = yield* findUser();\n    yield* Effect.logInfo(`Found user: ${user.name}`);\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      if (error instanceof RepositoryError) {\n        yield* Effect.logInfo(`Repository error occurred: ${error._tag}`);\n        if (\n          error.cause instanceof ConnectionError ||\n          error.cause instanceof QueryError\n        ) {\n          yield* Effect.logInfo(`Original cause: ${error.cause._tag}`);\n        }\n      } else {\n        yield* Effect.logInfo(`Unexpected error: ${error}`);\n      }\n    })\n  )\n);\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.mapError to transform errors and create clean architectural boundaries between layers."
            },
            "created_at": "2026-02-15T21:22:17.959145",
            "updated_at": "2026-02-20T23:09:42.065081"
        },
        {
            "id": "6f1400ba-8118-49d6-98b8-9c5fcd0b266a",
            "slug": "sink-pattern-write-stream-lines-to-file",
            "title": "Sink Pattern 3: Write Stream Lines to File",
            "summary": "Use Sink to write stream data as lines to a file with buffering for efficiency, supporting log files and line-oriented formats.",
            "skill_level": "intermediate",
            "category": "streams",
            "difficulty": "intermediate",
            "tags": [
                "sink",
                "stream",
                "file-io",
                "persistence",
                "logging",
                "buffering"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Sink, Chunk, FileSystem } from \"effect\";\n\ninterface LogEntry {\n  readonly level: \"debug\" | \"info\" | \"warn\" | \"error\";\n  readonly message: string;\n  readonly timestamp: number;\n}\n\n// Format a log entry as a line\nconst formatLogLine = (entry: LogEntry): string => {\n  const iso = new Date(entry.timestamp).toISOString();\n  return `[${iso}] ${entry.level.toUpperCase()}: ${entry.message}`;\n};\n\n// Simulate a stream of log entries\nconst logStream: Stream.Stream<LogEntry> = Stream.fromIterable([\n  { level: \"info\", message: \"Server starting\", timestamp: Date.now() },\n  { level: \"debug\", message: \"Loading config\", timestamp: Date.now() + 100 },\n  { level: \"info\", message: \"Connected to database\", timestamp: Date.now() + 200 },\n  { level: \"warn\", message: \"High memory usage detected\", timestamp: Date.now() + 300 },\n  { level: \"info\", message: \"Processing request\", timestamp: Date.now() + 400 },\n  { level: \"error\", message: \"Connection timeout\", timestamp: Date.now() + 500 },\n  { level: \"info\", message: \"Retrying connection\", timestamp: Date.now() + 600 },\n  { level: \"info\", message: \"Connection restored\", timestamp: Date.now() + 700 },\n]);\n\n// Create a file writer sink with buffering\nconst createFileWriteSink = (\n  filePath: string,\n  bufferSize: number = 100\n): Sink.Sink<number, Error, string> =>\n  Effect.scoped(\n    Effect.gen(function* () {\n      // Open file in append mode\n      const fs = yield* FileSystem.FileSystem;\n      const handle = yield* fs.open(filePath, \"a\");\n\n      let buffer: string[] = [];\n      let lineCount = 0;\n\n      // Flush buffered lines to disk\n      const flush = Effect.gen(function* () {\n        if (buffer.length === 0) return;\n\n        const content = buffer.join(\"\\n\") + \"\\n\";\n        yield* fs.write(handle, content);\n        buffer = [];\n      });\n\n      // Return the sink\n      return Sink.fold(\n        0,\n        (count, line: string) =>\n          Effect.gen(function* () {\n            buffer.push(line);\n            const newCount = count + 1;\n\n            // Flush when buffer reaches size limit\n            if (buffer.length >= bufferSize) {\n              yield* flush;\n            }\n\n            return newCount;\n          }),\n        (count) =>\n          Effect.gen(function* () {\n            // Flush any remaining lines before closing\n            yield* flush;\n            yield* fs.close(handle);\n            return count;\n          })\n      );\n    })\n  ).pipe(\n    Effect.flatten\n  );\n\n// Process the log stream\nconst program = Effect.gen(function* () {\n  const fs = yield* FileSystem.FileSystem;\n  const filePath = \"/tmp/app.log\";\n\n  // Clear the file first\n  yield* fs.writeFileString(filePath, \"\");\n\n  // Stream logs, format them, and write to file\n  const written = yield* logStream.pipe(\n    Stream.map(formatLogLine),\n    Stream.run(createFileWriteSink(filePath, 50)) // Buffer 50 lines before flush\n  );\n\n  console.log(`Wrote ${written} log lines to ${filePath}`);\n\n  // Read back the file to verify\n  const content = yield* fs.readFileString(filePath);\n  console.log(\"\\nFile contents:\");\n  console.log(content);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Write streaming lines to a file efficiently using buffered output and proper resource management."
            },
            "created_at": "2026-02-15T21:22:21.593863",
            "updated_at": "2026-02-20T23:09:44.70274"
        },
        {
            "id": "7f9546e3-9042-474d-829c-3a598288404c",
            "slug": "implement-graceful-shutdown",
            "title": "Implement Graceful Shutdown for Your Application",
            "summary": "Use Effect.runFork and listen for OS signals (SIGINT, SIGTERM) to trigger a Fiber.interrupt, ensuring all resources are safely released.",
            "skill_level": "advanced",
            "category": "concurrency",
            "difficulty": "advanced",
            "tags": [
                "graceful-shutdown",
                "resource-management",
                "server",
                "fiber",
                "runFork",
                "interrupt",
                "finalizer"
            ],
            "examples": [
                {
                    "code": "import { Effect, Layer, Fiber, Context, Scope } from \"effect\";\nimport * as http from \"http\";\n\n// 1. A service with a finalizer for cleanup\nclass Database extends Effect.Service<Database>()(\"Database\", {\n  effect: Effect.gen(function* () {\n    yield* Effect.log(\"Acquiring DB connection\");\n    return {\n      query: () => Effect.succeed(\"data\"),\n    };\n  }),\n}) {}\n\n// 2. The main server logic\nconst server = Effect.gen(function* () {\n  const db = yield* Database;\n\n  // Create server with proper error handling\n  const httpServer = yield* Effect.sync(() => {\n    const server = http.createServer((_req, res) => {\n      Effect.runFork(\n        Effect.provide(\n          db.query().pipe(Effect.map((data) => res.end(data))),\n          Database.Default\n        )\n      );\n    });\n    return server;\n  });\n\n  // Add a finalizer to close the server\n  yield* Effect.addFinalizer(() =>\n    Effect.gen(function* () {\n      httpServer.close();\n      yield* Effect.log(\"Server closed\");\n    })\n  );\n\n  // Start server with error handling\n  yield* Effect.async<void, Error>((resume) => {\n    httpServer.once(\"error\", (err: Error) => {\n      resume(Effect.fail(new Error(`Failed to start server: ${err.message}`)));\n    });\n\n    httpServer.listen(3456, () => {\n      resume(Effect.succeed(void 0));\n    });\n  });\n\n  yield* Effect.log(\"Server started on port 3456. Press Ctrl+C to exit.\");\n\n  // For testing purposes, we'll run for a short time instead of forever\n  yield* Effect.sleep(\"2 seconds\");\n  yield* Effect.log(\"Shutting down gracefully...\");\n});\n\n// 3. Provide the layer and launch with runFork\nconst app = Effect.provide(server.pipe(Effect.scoped), Database.Default);\n\n// 4. Run the app and handle shutdown\nEffect.runPromise(app).catch((error) => {\n  Effect.runSync(Effect.logError(\"Application error: \" + error));\n  process.exit(1);\n});",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.runFork and OS signal listeners to implement graceful shutdown for long-running applications."
            },
            "created_at": "2026-02-15T21:22:20.361733",
            "updated_at": "2026-02-20T23:09:36.64676"
        },
        {
            "id": "4db0934f-6340-4cbe-bb00-52fef4698cc8",
            "slug": "teach-your-ai-agents-effect-with-the-mcp-server",
            "title": "Teach your AI Agents Effect with the MCP Server",
            "summary": "Use the Effect MCP server to provide live, contextual information about your application's structure directly to AI coding agents.",
            "skill_level": "advanced",
            "category": "tooling-and-debugging",
            "difficulty": "advanced",
            "tags": [
                "mcp",
                "ai",
                "tooling",
                "agent",
                "code-generation"
            ],
            "examples": [
                {
                    "code": "npx @effect/mcp-server --layer src/layers.ts:AppLayer\n    ```\n\n2.  **You configure your AI agent** (e.g., Cursor) to use the MCP server's endpoint (`http://localhost:3333`).\n\n3.  **You ask the AI a question** that requires deep context about your app:\n\n    > \"Refactor this code to use the `UserService` to fetch a user by ID and log the result with the `Logger`.\"\n\n4.  **The AI, in the background, queries the MCP server:**\n\n    - It discovers that `UserService` and `Logger` are available in the `AppLayer`.\n    - It retrieves the exact method signature for `UserService.getUser` and `Logger.log`.\n\n5.  **The AI generates correct, context-aware code** because it's not guessing; it's using the live architectural information provided by the MCP server.",
                    "language": "bash",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use the MCP server to provide live application context to AI coding agents, enabling more accurate assistance."
            },
            "created_at": "2026-02-15T21:22:30.720234",
            "updated_at": "2026-02-20T23:09:42.410265"
        },
        {
            "id": "319fffff-7cf1-49fc-8717-178d6e4ab45e",
            "slug": "observability-opentelemetry",
            "title": "Integrate Effect Tracing with OpenTelemetry",
            "summary": "Connect Effect's tracing spans to OpenTelemetry for end-to-end distributed tracing and visualization.",
            "skill_level": "advanced",
            "category": "observability",
            "difficulty": "advanced",
            "tags": [
                "tracing",
                "opentelemetry",
                "observability",
                "effect",
                "distributed-tracing"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n// Pseudocode: Replace with actual OpenTelemetry integration for your stack\nimport { trace, context, SpanStatusCode } from \"@opentelemetry/api\";\n\n// Wrap an Effect.withSpan to export to OpenTelemetry\nfunction withOtelSpan<T>(\n  name: string,\n  effect: Effect.Effect<unknown, T, unknown>\n) {\n  return Effect.gen(function* () {\n    const otelSpan = trace.getTracer(\"default\").startSpan(name);\n    try {\n      const result = yield* effect;\n      otelSpan.setStatus({ code: SpanStatusCode.OK });\n      return result;\n    } catch (err) {\n      otelSpan.setStatus({ code: SpanStatusCode.ERROR, message: String(err) });\n      throw err;\n    } finally {\n      otelSpan.end();\n    }\n  });\n}\n\n// Usage\nconst program = withOtelSpan(\n  \"fetchUser\",\n  Effect.sync(() => {\n    // ...fetch user logic\n    return { id: 1, name: \"Alice\" };\n  })\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Integrate Effect.withSpan with OpenTelemetry to export traces and visualize request flows across services."
            },
            "created_at": "2026-02-15T21:22:29.96386",
            "updated_at": "2026-02-20T23:09:42.640192"
        },
        {
            "id": "04d2f94d-34a1-4c8b-b0f2-e19389c6fb99",
            "slug": "observability-distributed-tracing",
            "title": "Implement Distributed Tracing",
            "summary": "Set up end-to-end distributed tracing across services with trace context propagation.",
            "skill_level": "advanced",
            "category": "observability",
            "difficulty": "advanced",
            "tags": [
                "observability",
                "tracing",
                "distributed-systems",
                "opentelemetry"
            ],
            "examples": [
                {
                    "code": "import { Effect, Context, Layer } from \"effect\"\nimport { HttpClient, HttpClientRequest, HttpServerRequest, HttpServerResponse } from \"@effect/platform\"\n\n// ============================================\n// 1. Define trace context\n// ============================================\n\ninterface TraceContext {\n  readonly traceId: string\n  readonly spanId: string\n  readonly parentSpanId?: string\n  readonly sampled: boolean\n}\n\nclass CurrentTrace extends Context.Tag(\"CurrentTrace\")<\n  CurrentTrace,\n  TraceContext\n>() {}\n\n// W3C Trace Context header names\nconst TRACEPARENT_HEADER = \"traceparent\"\nconst TRACESTATE_HEADER = \"tracestate\"\n\n// ============================================\n// 2. Generate trace IDs\n// ============================================\n\nconst generateTraceId = (): string =>\n  Array.from(crypto.getRandomValues(new Uint8Array(16)))\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\")\n\nconst generateSpanId = (): string =>\n  Array.from(crypto.getRandomValues(new Uint8Array(8)))\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\")\n\n// ============================================\n// 3. Parse and format trace context\n// ============================================\n\nconst parseTraceparent = (header: string): TraceContext | null => {\n  // Format: 00-traceId-spanId-flags\n  const parts = header.split(\"-\")\n  if (parts.length !== 4) return null\n\n  return {\n    traceId: parts[1],\n    spanId: generateSpanId(),  // New span for this service\n    parentSpanId: parts[2],\n    sampled: parts[3] === \"01\",\n  }\n}\n\nconst formatTraceparent = (ctx: TraceContext): string =>\n  `00-${ctx.traceId}-${ctx.spanId}-${ctx.sampled ? \"01\" : \"00\"}`\n\n// ============================================\n// 4. Extract trace from incoming request\n// ============================================\n\nconst extractTraceContext = Effect.gen(function* () {\n  const request = yield* HttpServerRequest.HttpServerRequest\n\n  const traceparent = request.headers[TRACEPARENT_HEADER]\n\n  if (traceparent) {\n    const parsed = parseTraceparent(traceparent)\n    if (parsed) {\n      yield* Effect.log(\"Extracted trace context\").pipe(\n        Effect.annotateLogs({\n          traceId: parsed.traceId,\n          parentSpanId: parsed.parentSpanId,\n        })\n      )\n      return parsed\n    }\n  }\n\n  // No incoming trace - start a new one\n  const newTrace: TraceContext = {\n    traceId: generateTraceId(),\n    spanId: generateSpanId(),\n    sampled: Math.random() < 0.1,  // 10% sampling\n  }\n\n  yield* Effect.log(\"Started new trace\").pipe(\n    Effect.annotateLogs({ traceId: newTrace.traceId })\n  )\n\n  return newTrace\n})\n\n// ============================================\n// 5. Propagate trace to outgoing requests\n// ============================================\n\nconst makeTracedHttpClient = Effect.gen(function* () {\n  const baseClient = yield* HttpClient.HttpClient\n  const trace = yield* CurrentTrace\n\n  return {\n    get: (url: string) =>\n      Effect.gen(function* () {\n        // Create child span for outgoing request\n        const childSpan: TraceContext = {\n          traceId: trace.traceId,\n          spanId: generateSpanId(),\n          parentSpanId: trace.spanId,\n          sampled: trace.sampled,\n        }\n\n        yield* Effect.log(\"Making traced HTTP request\").pipe(\n          Effect.annotateLogs({\n            traceId: childSpan.traceId,\n            spanId: childSpan.spanId,\n            url,\n          })\n        )\n\n        const request = HttpClientRequest.get(url).pipe(\n          HttpClientRequest.setHeader(\n            TRACEPARENT_HEADER,\n            formatTraceparent(childSpan)\n          )\n        )\n\n        return yield* baseClient.execute(request)\n      }),\n  }\n})\n\n// ============================================\n// 6. Tracing middleware for HTTP server\n// ============================================\n\nconst withTracing = <A, E, R>(\n  handler: Effect.Effect<A, E, R | CurrentTrace>\n): Effect.Effect<A, E, R | HttpServerRequest.HttpServerRequest> =>\n  Effect.gen(function* () {\n    const traceContext = yield* extractTraceContext\n\n    return yield* handler.pipe(\n      Effect.provideService(CurrentTrace, traceContext),\n      Effect.withLogSpan(`request-${traceContext.spanId}`),\n      Effect.annotateLogs({\n        \"trace.id\": traceContext.traceId,\n        \"span.id\": traceContext.spanId,\n        \"parent.span.id\": traceContext.parentSpanId ?? \"none\",\n      })\n    )\n  })\n\n// ============================================\n// 7. Example: Service A calls Service B\n// ============================================\n\n// Service B handler\nconst serviceBHandler = withTracing(\n  Effect.gen(function* () {\n    const trace = yield* CurrentTrace\n    yield* Effect.log(\"Service B processing request\")\n\n    // Simulate work\n    yield* Effect.sleep(\"50 millis\")\n\n    return HttpServerResponse.json({\n      message: \"Hello from Service B\",\n      traceId: trace.traceId,\n    })\n  })\n)\n\n// Service A handler (calls Service B)\nconst serviceAHandler = withTracing(\n  Effect.gen(function* () {\n    const trace = yield* CurrentTrace\n    yield* Effect.log(\"Service A processing request\")\n\n    // Call Service B with trace propagation\n    const tracedClient = yield* makeTracedHttpClient\n    const response = yield* tracedClient.get(\"http://service-b/api/data\")\n\n    yield* Effect.log(\"Service A received response from B\")\n\n    return HttpServerResponse.json({\n      message: \"Hello from Service A\",\n      traceId: trace.traceId,\n    })\n  })\n)\n\n// ============================================\n// 8. Run and observe\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Distributed Tracing Demo ===\")\n\n  // Simulate incoming request with trace\n  const incomingTrace: TraceContext = {\n    traceId: generateTraceId(),\n    spanId: generateSpanId(),\n    sampled: true,\n  }\n\n  yield* Effect.log(\"Processing traced request\").pipe(\n    Effect.provideService(CurrentTrace, incomingTrace),\n    Effect.annotateLogs({\n      \"trace.id\": incomingTrace.traceId,\n      \"span.id\": incomingTrace.spanId,\n    })\n  )\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Propagate trace context across service boundaries to correlate requests."
            },
            "created_at": "2026-02-15T21:22:29.875271",
            "updated_at": "2026-02-20T23:09:42.683182"
        },
        {
            "id": "1ebc2f8e-e5b7-47e2-b70f-24a335f2c71d",
            "slug": "add-custom-metrics",
            "title": "Add Custom Metrics to Your Application",
            "summary": "Use Effect's Metric module to instrument your code with counters, gauges, and histograms to track key business and performance indicators.",
            "skill_level": "intermediate",
            "category": "observability",
            "difficulty": "intermediate",
            "tags": [
                "metrics",
                "observability",
                "monitoring",
                "counter",
                "gauge",
                "histogram"
            ],
            "examples": [
                {
                    "code": "import { Effect, Metric, Duration } from \"effect\"; // We don't need MetricBoundaries anymore\n\n// 1. Define your metrics\nconst userRegisteredCounter = Metric.counter(\"users_registered_total\", {\n  description: \"A counter for how many users have been registered.\",\n});\n\nconst dbDurationTimer = Metric.timer(\n  \"db_operation_duration\",\n  \"A timer for DB operation durations\"\n);\n\n// 2. Simulated database call\nconst saveUserToDb = Effect.succeed(\"user saved\").pipe(\n  Effect.delay(Duration.millis(Math.random() * 100))\n);\n\n// 3. Instrument the business logic\nconst createUser = Effect.gen(function* () {\n  // Time the operation\n  yield* saveUserToDb.pipe(Metric.trackDuration(dbDurationTimer));\n\n  // Increment the counter\n  yield* Metric.increment(userRegisteredCounter);\n\n  return { status: \"success\" };\n});\n\n// Run the Effect\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* createUser;\n  yield* Effect.log(`Result: ${JSON.stringify(result)}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Metric.counter, Metric.gauge, and Metric.histogram to instrument code for monitoring."
            },
            "created_at": "2026-02-15T21:22:29.205663",
            "updated_at": "2026-02-20T23:09:42.958573"
        },
        {
            "id": "94126593-6299-42a2-a345-c00f2d9be51d",
            "slug": "avoid-long-andthen-chains",
            "title": "Avoid Long Chains of .andThen; Use Generators Instead",
            "summary": "Prefer Effect.gen over long chains of .andThen for sequential logic to improve readability and maintainability.",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "andThen",
                "generators",
                "readability",
                "composition",
                "anti-pattern"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Define our steps with logging\nconst step1 = (): Effect.Effect<number> =>\n  Effect.succeed(42).pipe(Effect.tap((n) => Effect.log(`Step 1: ${n}`)));\n\nconst step2 = (a: number): Effect.Effect<string> =>\n  Effect.succeed(`Result: ${a * 2}`).pipe(\n    Effect.tap((s) => Effect.log(`Step 2: ${s}`))\n  );\n\n// Using Effect.gen for better readability\nconst program = Effect.gen(function* () {\n  const a = yield* step1();\n  const b = yield* step2(a);\n  return b;\n});\n\n// Run the program\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Final result: ${result}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Prefer generators over long chains of .andThen."
            },
            "created_at": "2026-02-15T21:22:24.028537",
            "updated_at": "2026-02-20T23:09:45.986503"
        },
        {
            "id": "76aa18ad-5fe3-4141-be3e-2a4e84adb928",
            "slug": "representing-time-spans-with-duration",
            "title": "Representing Time Spans with Duration",
            "summary": "Use the Duration data type to represent time intervals in a type-safe, human-readable, and composable way.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "duration",
                "time",
                "schedule",
                "timeout"
            ],
            "examples": [
                {
                    "code": "import { Effect, Duration } from \"effect\";\n\n// Create durations with clear, explicit units\nconst fiveSeconds = Duration.seconds(5);\nconst oneHundredMillis = Duration.millis(100);\n\n// Use them in Effect operators\nconst program = Effect.log(\"Starting...\").pipe(\n  Effect.delay(oneHundredMillis),\n  Effect.flatMap(() => Effect.log(\"Running after 100ms\")),\n  Effect.timeout(fiveSeconds) // This whole operation must complete within 5 seconds\n);\n\n// Durations can also be compared\nconst isLonger = Duration.greaterThan(fiveSeconds, oneHundredMillis); // true\n\n// Demonstrate the duration functionality\nconst demonstration = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Duration Demonstration ===\");\n\n  // Show duration values\n  yield* Effect.logInfo(`Five seconds: ${Duration.toMillis(fiveSeconds)}ms`);\n  yield* Effect.logInfo(\n    `One hundred millis: ${Duration.toMillis(oneHundredMillis)}ms`\n  );\n\n  // Show comparison\n  yield* Effect.logInfo(`Is 5 seconds longer than 100ms? ${isLonger}`);\n\n  // Run the timed program\n  yield* Effect.logInfo(\"Running timed program...\");\n  yield* program;\n\n  // Show more duration operations\n  const combined = Duration.sum(fiveSeconds, oneHundredMillis);\n  yield* Effect.logInfo(`Combined duration: ${Duration.toMillis(combined)}ms`);\n\n  // Show different duration units\n  const oneMinute = Duration.minutes(1);\n  yield* Effect.logInfo(`One minute: ${Duration.toMillis(oneMinute)}ms`);\n\n  const isMinuteLonger = Duration.greaterThan(oneMinute, fiveSeconds);\n  yield* Effect.logInfo(`Is 1 minute longer than 5 seconds? ${isMinuteLonger}`);\n});\n\nEffect.runPromise(demonstration);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use the Duration data type to represent time intervals instead of raw numbers."
            },
            "created_at": "2026-02-15T21:22:16.191404",
            "updated_at": "2026-02-20T23:09:34.439902"
        },
        {
            "id": "4a5ffe7f-ba36-4e94-b156-6d63ef453659",
            "slug": "state-management-pattern-subscription-ref",
            "title": "State Management Pattern 2: Observable State with SubscriptionRef",
            "summary": "Build observable state that notifies subscribers on changes, enabling reactive patterns and state-driven architecture.",
            "skill_level": "advanced",
            "category": "concurrency",
            "difficulty": "advanced",
            "tags": [
                "state-management",
                "reactivity",
                "pub-sub",
                "event-driven",
                "state-binding",
                "reactive-ui"
            ],
            "examples": [
                {
                    "code": "import { Effect, Ref, PubSub, Stream } from \"effect\";\n\ninterface StateChange<T> {\n  readonly previous: T;\n  readonly current: T;\n  readonly timestamp: Date;\n  readonly reason: string;\n}\n\ninterface Observable<T> {\n  readonly get: () => Effect.Effect<T>;\n  readonly set: (value: T, reason: string) => Effect.Effect<void>;\n  readonly subscribe: () => Stream.Stream<StateChange<T>>;\n  readonly modify: (f: (current: T) => T, reason: string) => Effect.Effect<void>;\n}\n\nconst program = Effect.gen(function* () {\n  console.log(\n    `\\n[OBSERVABLE STATE] Reactive state management\\n`\n  );\n\n  // Create observable\n  const createObservable = <T,>(initialValue: T): Effect.Effect<Observable<T>> =>\n    Effect.gen(function* () {\n      const state = yield* Ref.make(initialValue);\n      const changeStream = yield* PubSub.unbounded<StateChange<T>>();\n\n      return {\n        get: () => Ref.get(state),\n\n        set: (value: T, reason: string) =>\n          Effect.gen(function* () {\n            const previous = yield* Ref.get(state);\n\n            if (previous === value) {\n              return; // No change\n            }\n\n            yield* Ref.set(state, value);\n\n            const change: StateChange<T> = {\n              previous,\n              current: value,\n              timestamp: new Date(),\n              reason,\n            };\n\n            yield* PubSub.publish(changeStream, change);\n          }),\n\n        subscribe: () =>\n          PubSub.subscribe(changeStream),\n\n        modify: (f: (current: T) => T, reason: string) =>\n          Effect.gen(function* () {\n            const previous = yield* Ref.get(state);\n            const updated = f(previous);\n\n            if (previous === updated) {\n              return; // No change\n            }\n\n            yield* Ref.set(state, updated);\n\n            const change: StateChange<T> = {\n              previous,\n              current: updated,\n              timestamp: new Date(),\n              reason,\n            };\n\n            yield* PubSub.publish(changeStream, change);\n          }),\n      };\n    });\n\n  // Example 1: Basic observable counter\n  console.log(`[1] Observable counter:\\n`);\n\n  const counter = yield* createObservable(0);\n\n  // Subscribe to changes\n  const printChanges = counter.subscribe().pipe(\n    Stream.tap((change) =>\n      Effect.log(\n        `[CHANGE] ${change.previous} \u2192 ${change.current} (${change.reason})`\n      )\n    ),\n    Stream.take(5), // Limit to 5 changes for demo\n    Stream.runDrain\n  );\n\n  // Make changes\n  yield* counter.set(1, \"increment\");\n  yield* counter.set(2, \"increment\");\n  yield* counter.set(5, \"reset\");\n\n  // Wait for changes to be processed\n  yield* Effect.sleep(\"100 millis\");\n\n  // Example 2: Derived state (computed values)\n  console.log(`\\n[2] Derived state (total from items):\\n`);\n\n  interface ShoppingCart {\n    readonly items: Array<{ id: string; price: number }>;\n    readonly discount: number;\n  }\n\n  const cart = yield* createObservable<ShoppingCart>({\n    items: [],\n    discount: 0,\n  });\n\n  const computeTotal = (state: ShoppingCart): number => {\n    const subtotal = state.items.reduce((sum, item) => sum + item.price, 0);\n    return subtotal * (1 - state.discount);\n  };\n\n  // Create derived observable\n  const total = yield* createObservable(computeTotal(yield* cart.get()));\n\n  // Subscribe to cart changes, update total\n  const updateTotalOnCartChange = cart.subscribe().pipe(\n    Stream.tap((change) =>\n      Effect.gen(function* () {\n        const newTotal = computeTotal(change.current);\n\n        yield* total.set(newTotal, \"recalculated-from-cart\");\n\n        yield* Effect.log(\n          `[TOTAL] Recalculated: $${newTotal.toFixed(2)}`\n        );\n      })\n    ),\n    Stream.take(10),\n    Stream.runDrain\n  );\n\n  // Make cart changes\n  yield* cart.modify(\n    (state) => ({\n      ...state,\n      items: [\n        ...state.items,\n        { id: \"item1\", price: 19.99 },\n      ],\n    }),\n    \"add-item\"\n  );\n\n  yield* cart.modify(\n    (state) => ({\n      ...state,\n      items: [\n        ...state.items,\n        { id: \"item2\", price: 29.99 },\n      ],\n    }),\n    \"add-item\"\n  );\n\n  yield* cart.modify(\n    (state) => ({\n      ...state,\n      discount: 0.1,\n    }),\n    \"apply-discount\"\n  );\n\n  yield* Effect.sleep(\"200 millis\");\n\n  // Example 3: Effect triggering on state change\n  console.log(`\\n[3] Effects triggered by state changes:\\n`);\n\n  type AppStatus = \"idle\" | \"loading\" | \"ready\" | \"error\";\n\n  const appStatus = yield* createObservable<AppStatus>(\"idle\");\n\n  // Define effects for each status\n  const handleStatusChange = appStatus.subscribe().pipe(\n    Stream.tap((change) =>\n      Effect.gen(function* () {\n        yield* Effect.log(\n          `[STATUS] ${change.previous} \u2192 ${change.current}`\n        );\n\n        switch (change.current) {\n          case \"loading\":\n            yield* Effect.log(`[EFFECT] Starting loading animation`);\n            break;\n\n          case \"ready\":\n            yield* Effect.log(`[EFFECT] Hiding spinner, showing content`);\n            break;\n\n          case \"error\":\n            yield* Effect.log(`[EFFECT] Showing error message`);\n            yield* Effect.log(`[TELEMETRY] Logging error event`);\n            break;\n\n          default:\n            yield* Effect.log(`[EFFECT] Resetting UI`);\n        }\n      })\n    ),\n    Stream.take(6),\n    Stream.runDrain\n  );\n\n  // Trigger status changes\n  yield* appStatus.set(\"loading\", \"user-clicked\");\n  yield* appStatus.set(\"ready\", \"data-loaded\");\n  yield* appStatus.set(\"loading\", \"user-refreshed\");\n  yield* appStatus.set(\"error\", \"api-failed\");\n\n  yield* Effect.sleep(\"200 millis\");\n\n  // Example 4: Multi-level state aggregation\n  console.log(`\\n[4] Aggregated state from multiple sources:\\n`);\n\n  interface UserProfile {\n    name: string;\n    email: string;\n    role: string;\n  }\n\n  interface AppState {\n    user: UserProfile | null;\n    notifications: number;\n    theme: \"light\" | \"dark\";\n  }\n\n  const appState = yield* createObservable<AppState>({\n    user: null,\n    notifications: 0,\n    theme: \"light\",\n  });\n\n  // Subscribe to track changes\n  const trackChanges = appState.subscribe().pipe(\n    Stream.tap((change) => {\n      if (change.current.user && !change.previous.user) {\n        return Effect.log(`[EVENT] User logged in: ${change.current.user.name}`);\n      }\n\n      if (!change.current.user && change.previous.user) {\n        return Effect.log(`[EVENT] User logged out`);\n      }\n\n      if (change.current.notifications !== change.previous.notifications) {\n        return Effect.log(\n          `[NOTIFY] ${change.current.notifications} notifications`\n        );\n      }\n\n      if (change.current.theme !== change.previous.theme) {\n        return Effect.log(`[THEME] Switched to ${change.current.theme}`);\n      }\n\n      return Effect.succeed(undefined);\n    }),\n    Stream.take(10),\n    Stream.runDrain\n  );\n\n  // Make changes\n  yield* appState.modify(\n    (state) => ({\n      ...state,\n      user: { name: \"Alice\", email: \"alice@example.com\", role: \"admin\" },\n    }),\n    \"user-login\"\n  );\n\n  yield* appState.modify(\n    (state) => ({\n      ...state,\n      notifications: 5,\n    }),\n    \"new-notifications\"\n  );\n\n  yield* appState.modify(\n    (state) => ({\n      ...state,\n      theme: \"dark\",\n    }),\n    \"user-preference\"\n  );\n\n  yield* Effect.sleep(\"200 millis\");\n\n  // Example 5: State snapshot and history\n  console.log(`\\n[5] State history tracking:\\n`);\n\n  interface HistoryEntry<T> {\n    value: T;\n    timestamp: Date;\n    reason: string;\n  }\n\n  const history = yield* Ref.make<HistoryEntry<number>[]>([]);\n\n  const trackedCounter = yield* createObservable(0);\n\n  const trackHistory = trackedCounter.subscribe().pipe(\n    Stream.tap((change) =>\n      Effect.gen(function* () {\n        yield* Ref.modify(history, (h) => [\n          undefined,\n          [\n            ...h,\n            {\n              value: change.current,\n              timestamp: change.timestamp,\n              reason: change.reason,\n            },\n          ],\n        ]);\n\n        yield* Effect.log(\n          `[HISTORY] Recorded: ${change.current} (${change.reason})`\n        );\n      })\n    ),\n    Stream.take(5),\n    Stream.runDrain\n  );\n\n  // Make changes\n  for (let i = 1; i <= 4; i++) {\n    yield* trackedCounter.set(i, `step-${i}`);\n  }\n\n  yield* Effect.sleep(\"200 millis\");\n\n  // Print history\n  const hist = yield* Ref.get(history);\n\n  yield* Effect.log(`\\n[HISTORY] ${hist.length} entries:`);\n\n  for (const entry of hist) {\n    yield* Effect.log(\n      `  - ${entry.value} (${entry.reason})`\n    );\n  }\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Combine Ref with PubSub to create observable state where changes trigger notifications, enabling reactive state management."
            },
            "created_at": "2026-02-15T21:22:20.847233",
            "updated_at": "2026-02-20T23:09:36.693557"
        },
        {
            "id": "cbc51087-ba5a-4c7c-b9b1-beaf66ebbe8a",
            "slug": "optional-pattern-handling-none-some",
            "title": "Optional Pattern 1: Handling None and Some Values",
            "summary": "Use Effect's Option type to safely handle values that may not exist, avoiding null/undefined bugs and enabling composable error handling.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "optional",
                "null-safety",
                "error-handling",
                "value-handling",
                "pattern-matching",
                "composition"
            ],
            "examples": [
                {
                    "code": "import { Effect, Option } from \"effect\";\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\ninterface Profile {\n  bio: string;\n  website?: string;\n  location?: string;\n}\n\nconst program = Effect.gen(function* () {\n  console.log(\n    `\\n[OPTION HANDLING] None/Some values and pattern matching\\n`\n  );\n\n  // Example 1: Creating Options\n  console.log(`[1] Creating Option values:\\n`);\n\n  const someValue: Option.Option<string> = Option.some(\"data\");\n  const noneValue: Option.Option<string> = Option.none();\n\n  const displayOption = <T,>(opt: Option.Option<T>, label: string) =>\n    Effect.gen(function* () {\n      if (Option.isSome(opt)) {\n        yield* Effect.log(`${label}: Some(${opt.value})`);\n      } else {\n        yield* Effect.log(`${label}: None`);\n      }\n    });\n\n  yield* displayOption(someValue, \"someValue\");\n  yield* displayOption(noneValue, \"noneValue\");\n\n  // Example 2: Creating from nullable values\n  console.log(`\\n[2] Converting nullable to Option:\\n`);\n\n  const possiblyNull = (shouldExist: boolean): string | null =>\n    shouldExist ? \"found\" : null;\n\n  const toOption = (value: string | null | undefined): Option.Option<string> =>\n    value ? Option.some(value) : Option.none();\n\n  const opt1 = toOption(possiblyNull(true));\n  const opt2 = toOption(possiblyNull(false));\n\n  yield* displayOption(opt1, \"toOption(found)\");\n  yield* displayOption(opt2, \"toOption(null)\");\n\n  // Example 3: Pattern matching on Option\n  console.log(`\\n[3] Pattern matching with match():\\n`);\n\n  const userId: Option.Option<string> = Option.some(\"user-123\");\n\n  const message = Option.match(userId, {\n    onSome: (id) => `User ID: ${id}`,\n    onNone: () => \"No user found\",\n  });\n\n  yield* Effect.log(`[MATCH] ${message}`);\n\n  const emptyUserId: Option.Option<string> = Option.none();\n\n  const emptyMessage = Option.match(emptyUserId, {\n    onSome: (id) => `User ID: ${id}`,\n    onNone: () => \"No user found\",\n  });\n\n  yield* Effect.log(`[MATCH] ${emptyMessage}\\n`);\n\n  // Example 4: Transforming with map\n  console.log(`[4] Transforming values with map():\\n`);\n\n  const userCount: Option.Option<number> = Option.some(42);\n\n  const doubled = Option.map(userCount, (count) => count * 2);\n\n  yield* displayOption(doubled, \"doubled\");\n\n  // Chaining maps\n  const email: Option.Option<string> = Option.some(\"user@example.com\");\n\n  const domain = Option.map(email, (e) =>\n    e.split(\"@\")[1] ?? \"unknown\"\n  );\n\n  yield* displayOption(domain, \"email domain\");\n\n  // Example 5: Chaining with flatMap\n  console.log(`\\n[5] Chaining operations with flatMap():\\n`);\n\n  const findUser = (id: string): Option.Option<User> =>\n    id === \"user-1\"\n      ? Option.some({ id, name: \"Alice\", email: \"alice@example.com\" })\n      : Option.none();\n\n  const getProfile = (userId: string): Option.Option<Profile> =>\n    userId === \"user-1\"\n      ? Option.some({ bio: \"Developer\", website: \"alice.dev\" })\n      : Option.none();\n\n  const userId2 = Option.some(\"user-1\");\n\n  // Chained operations: userId -> user -> profile\n  const profileChain = Option.flatMap(userId2, (id) =>\n    Option.flatMap(findUser(id), (user) =>\n      getProfile(user.id)\n    )\n  );\n\n  const profileResult = Option.match(profileChain, {\n    onSome: (profile) => `Bio: ${profile.bio}, Website: ${profile.website}`,\n    onNone: () => \"No profile found\",\n  });\n\n  yield* Effect.log(`[CHAIN] ${profileResult}\\n`);\n\n  // Example 6: Fallback values with getOrElse\n  console.log(`[6] Default values with getOrElse():\\n`);\n\n  const optionalStatus: Option.Option<string> = Option.none();\n\n  const status = Option.getOrElse(optionalStatus, () => \"unknown\");\n\n  yield* Effect.log(`[DEFAULT] Status: ${status}`);\n\n  // Real value\n  const knownStatus: Option.Option<string> = Option.some(\"active\");\n\n  const realStatus = Option.getOrElse(knownStatus, () => \"unknown\");\n\n  yield* Effect.log(`[VALUE] Status: ${realStatus}\\n`);\n\n  // Example 7: Filter with predicate\n  console.log(`[7] Filtering with conditions:\\n`);\n\n  const ageOption: Option.Option<number> = Option.some(25);\n\n  const isAdult = Option.filter(ageOption, (age) => age >= 18);\n\n  yield* displayOption(isAdult, \"Adult check (25)\");\n\n  const ageOption2: Option.Option<number> = Option.some(15);\n\n  const isAdult2 = Option.filter(ageOption2, (age) => age >= 18);\n\n  yield* displayOption(isAdult2, \"Adult check (15)\");\n\n  // Example 8: Multiple Options (all present?)\n  console.log(`\\n[8] Combining multiple Options:\\n`);\n\n  const firstName: Option.Option<string> = Option.some(\"John\");\n  const lastName: Option.Option<string> = Option.some(\"Doe\");\n  const middleName: Option.Option<string> = Option.none();\n\n  // All three present?\n  const allPresent = Option.all([firstName, lastName, middleName]);\n\n  yield* displayOption(allPresent, \"All present\");\n\n  // Just two\n  const twoPresent = Option.all([firstName, lastName]);\n\n  yield* displayOption(twoPresent, \"Two present\");\n\n  // Example 9: Converting Option to Error\n  console.log(`\\n[9] Converting Option to Result/Error:\\n`);\n\n  const optionalConfig: Option.Option<{ apiKey: string }> = Option.none();\n\n  const configOrError = Option.match(optionalConfig, {\n    onSome: (config) => config,\n    onNone: () => {\n      throw new Error(\"Configuration not found\");\n    },\n  });\n\n  // In real code, would catch error\n  const result = Option.match(optionalConfig, {\n    onSome: (config) => ({ success: true, value: config }),\n    onNone: () => ({ success: false, error: \"config-not-found\" }),\n  });\n\n  yield* Effect.log(`[CONVERT] ${JSON.stringify(result)}\\n`);\n\n  // Example 10: Option in business logic\n  console.log(`[10] Practical: Optional user settings:\\n`);\n\n  const userSettings: Option.Option<{\n    theme: string;\n    notifications: boolean;\n  }> = Option.some({\n    theme: \"dark\",\n    notifications: true,\n  });\n\n  const getTheme = Option.map(userSettings, (s) => s.theme);\n  const theme = Option.getOrElse(getTheme, () => \"light\"); // Default\n\n  yield* Effect.log(`[SETTING] Theme: ${theme}`);\n\n  // No settings\n  const noSettings: Option.Option<{ theme: string; notifications: boolean }> =\n    Option.none();\n\n  const noTheme = Option.map(noSettings, (s) => s.theme);\n  const defaultTheme = Option.getOrElse(noTheme, () => \"light\");\n\n  yield* Effect.log(`[DEFAULT] Theme: ${defaultTheme}`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Option to represent values that may not exist, replacing null/undefined with type-safe Option that forces explicit handling."
            },
            "created_at": "2026-02-16T21:38:56.432608",
            "updated_at": "2026-02-20T23:09:34.924519"
        },
        {
            "id": "82c8b5c7-c4b6-4730-9f26-0da79429d270",
            "slug": "combinator-sequencing",
            "title": "Sequencing with andThen, tap, and flatten",
            "summary": "Use andThen, tap, and flatten to sequence computations, run side effects, and flatten nested structures in Effect, Stream, Option, and Either.",
            "skill_level": "intermediate",
            "category": "core-concepts",
            "difficulty": "intermediate",
            "tags": [
                "sequencing",
                "andThen",
                "tap",
                "flatten",
                "combinator",
                "effect",
                "stream",
                "option",
                "either"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Option, Either } from \"effect\";\n\n// andThen: Run one effect, then another, ignore the first result\nconst logThenCompute = Effect.log(\"Starting...\").pipe(\n  Effect.andThen(Effect.succeed(42))\n); // Effect<number>\n\n// tap: Log the result of an effect, but keep the value\nconst computeAndLog = Effect.succeed(42).pipe(\n  Effect.tap((n) => Effect.log(`Result is ${n}`))\n); // Effect<number>\n\n// flatten: Remove one level of nesting\nconst nestedOption = Option.some(Option.some(1));\nconst flatOption = Option.flatten(nestedOption); // Option<number>\n\nconst nestedEffect = Effect.succeed(Effect.succeed(1));\nconst flatEffect = Effect.flatten(nestedEffect); // Effect<number>\n\n// tapError: Log errors without handling them\nconst mightFail = Effect.fail(\"fail!\").pipe(\n  Effect.tapError((err) => Effect.logError(`Error: ${err}`))\n); // Effect<never>\n\n// Stream: tap for side effects on each element\nconst stream = Stream.fromIterable([1, 2, 3]).pipe(\n  Stream.tap((n) => Effect.log(`Saw: ${n}`))\n); // Stream<number>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use sequencing combinators to run computations in order, perform side effects, or flatten nested structures, while preserving error and context handling."
            },
            "created_at": "2026-02-15T21:22:16.277761",
            "updated_at": "2026-02-20T23:09:34.966888"
        },
        {
            "id": "7abcbf8b-25b1-4b0e-8495-cb6be4081a06",
            "slug": "comparing-data-by-value-with-structural-equality",
            "title": "Comparing Data by Value with Structural Equality",
            "summary": "Use Data.struct and Equal.equals to safely compare objects by their value instead of their reference, avoiding common JavaScript pitfalls.",
            "skill_level": "beginner",
            "category": "core-concepts",
            "difficulty": "beginner",
            "tags": [
                "equality",
                "equal",
                "data",
                "struct",
                "value-equality",
                "structural-equality"
            ],
            "examples": [
                {
                    "code": "import { Data, Equal, Effect } from \"effect\";\n\n// Define a Point type with structural equality\ninterface Point {\n  readonly _tag: \"Point\";\n  readonly x: number;\n  readonly y: number;\n}\n\nconst Point = Data.tagged<Point>(\"Point\");\n\n// Create a program to demonstrate structural equality\nconst program = Effect.gen(function* () {\n  const p1 = Point({ x: 1, y: 2 });\n  const p2 = Point({ x: 1, y: 2 });\n  const p3 = Point({ x: 3, y: 4 });\n\n  // Standard reference equality fails\n  yield* Effect.log(\"Comparing points with reference equality (===):\");\n  yield* Effect.log(`p1 === p2: ${p1 === p2}`);\n\n  // Structural equality works as expected\n  yield* Effect.log(\"\\nComparing points with structural equality:\");\n  yield* Effect.log(`p1 equals p2: ${Equal.equals(p1, p2)}`);\n  yield* Effect.log(`p1 equals p3: ${Equal.equals(p1, p3)}`);\n\n  // Show the actual points\n  yield* Effect.log(\"\\nPoint values:\");\n  yield* Effect.log(`p1: ${JSON.stringify(p1)}`);\n  yield* Effect.log(`p2: ${JSON.stringify(p2)}`);\n  yield* Effect.log(`p3: ${JSON.stringify(p3)}`);\n});\n\n// Run the program\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Data.struct or implement the Equal interface for value-based comparison of objects and classes."
            },
            "created_at": "2026-02-15T21:22:13.211244",
            "updated_at": "2026-02-20T23:09:35.059471"
        },
        {
            "id": "bde60cd4-2b81-4d9e-83ec-5690f2e2bf2f",
            "slug": "getting-started-effect-vs-promise",
            "title": "Why Effect? Comparing Effect to Promise",
            "summary": "Understand what Effect gives you that Promise doesn't: type-safe errors, dependency injection, and composability.",
            "skill_level": "beginner",
            "category": "getting-started",
            "difficulty": "beginner",
            "tags": [
                "getting-started",
                "comparison",
                "promise",
                "motivation",
                "type-safety"
            ],
            "examples": [
                {
                    "code": "// With Promises, errors are invisible in the type system\nasync function fetchUser(id: string): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  if (!response.ok) throw new Error(\"Failed to fetch\"); // What errors can happen?\n  return response.json();\n}\n\n// The type says Promise<User>, but it might throw anything!",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Understand why Effect is better than raw Promises."
            },
            "created_at": "2026-02-15T21:22:12.325709",
            "updated_at": "2026-02-20T23:09:35.301079"
        },
        {
            "id": "b225697f-dc92-4937-8709-f055b4448ce3",
            "slug": "schema-json-db-postgres-jsonb",
            "title": "PostgreSQL JSONB Validation",
            "summary": "PostgreSQL JSONB columns are powerful and flexible, but that flexibility is dangerous. You can store any JSON, but your application expects specific fields with specific types. When you query JSONB...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "database",
                "postgresql",
                "jsonb",
                "validation"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\";\n\n// 1. Define schema for JSONB document\nconst OrderMetadata = Schema.Struct({\n  // Required fields\n  orderId: Schema.String,\n  customerId: Schema.String,\n  status: Schema.Literal(\n    \"pending\",\n    \"processing\",\n    \"shipped\",\n    \"delivered\",\n    \"cancelled\"\n  ),\n\n  // Optional tracking data\n  trackingNumber: Schema.String.pipe(Schema.optional),\n  estimatedDelivery: Schema.String.pipe(\n    Schema.pattern(/^\\d{4}-\\d{2}-\\d{2}$/)\n  ).pipe(Schema.optional),\n\n  // Nested JSONB structure\n  items: Schema.Array(\n    Schema.Struct({\n      productId: Schema.String,\n      quantity: Schema.Number.pipe(\n        Schema.int(),\n        Schema.positive()\n      ),\n      price: Schema.Number.pipe(Schema.positive()),\n    })\n  ).pipe(Schema.minItems(1)),\n\n  // Metadata with defaults\n  source: Schema.Literal(\"web\", \"mobile\", \"api\").pipe(\n    Schema.optionalWith({ default: () => \"web\" })\n  ),\n  notes: Schema.String.pipe(Schema.optional),\n});\n\ntype OrderMetadata = typeof OrderMetadata.Type;\n\n// 2. Validate JSONB before INSERT\nconst validateForInsert = (data: unknown) =>\n  Effect.gen(function* () {\n    const order = yield* Schema.decodeUnknown(OrderMetadata)(\n      data\n    ).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"InsertValidationError\" as const,\n        message: `Order data invalid: ${error.message}`,\n      }))\n    );\n\n    // Additional business logic validation\n    if (order.items.length === 0) {\n      return yield* Effect.fail({\n        _tag: \"BusinessLogicError\" as const,\n        message: \"Order must have at least one item\",\n      });\n    }\n\n    return order;\n  });\n\n// 3. Validate JSONB after SELECT\nconst validateFromPostgres = (\n  jsonbData: unknown\n) =>\n  Effect.gen(function* () {\n    const order = yield* Schema.decodeUnknown(OrderMetadata)(\n      jsonbData\n    ).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"SelectValidationError\" as const,\n        message: `Retrieved JSONB invalid: ${error.message}`,\n      }))\n    );\n\n    return order;\n  });\n\n// 4. Handle PostgreSQL JSONB operators\nconst queryOrdersByStatus = (status: string) =>\n  Effect.gen(function* () {\n    // Simulates: SELECT data FROM orders WHERE data->>'status' = ?\n    const mockDbResults: unknown[] = [\n      {\n        orderId: \"ORD-001\",\n        customerId: \"CUST-123\",\n        status: \"shipped\",\n        trackingNumber: \"ABC123XYZ\",\n        items: [\n          { productId: \"PROD-1\", quantity: 2, price: 29.99 },\n        ],\n        source: \"web\",\n      },\n      {\n        orderId: \"ORD-002\",\n        customerId: \"CUST-456\",\n        status: \"shipped\",\n        items: [\n          { productId: \"PROD-2\", quantity: 1, price: 49.99 },\n          { productId: \"PROD-3\", quantity: 3, price: 15.99 },\n        ],\n      },\n    ];\n\n    // Validate all results\n    const orders = yield* Effect.all(\n      mockDbResults.map((result) =>\n        validateFromPostgres(result)\n      )\n    );\n\n    return orders.filter((o) => o.status === status);\n  });\n\n// 5. Safe JSONB field extraction\nconst extractOrderAmount = (\n  order: OrderMetadata\n): number => {\n  // Calculate from validated items (guaranteed to exist)\n  return order.items.reduce(\n    (sum, item) => sum + item.price * item.quantity,\n    0\n  );\n};\n\n// 6. JSONB update pattern with validation\nconst updateOrderStatus = (\n  orderId: string,\n  newStatus: OrderMetadata[\"status\"],\n  trackingNumber?: string\n) =>\n  Effect.gen(function* () {\n    // Build JSONB update payload\n    const updatePayload: unknown = {\n      orderId,\n      status: newStatus,\n      ...(trackingNumber && {\n        trackingNumber,\n      }),\n    };\n\n    // Validate before sending to DB\n    const validated = yield* Schema.decodeUnknown(\n      Schema.Struct({\n        orderId: Schema.String,\n        status: OrderMetadata.fields.status,\n        trackingNumber: Schema.String.pipe(Schema.optional),\n      })\n    )(updatePayload);\n\n    // Simulates: UPDATE orders SET data = jsonb_set(data, ...)\n    console.log(`\u2705 Would update order with:`, validated);\n\n    return validated;\n  });\n\n// 7. Usage\nEffect.runPromise(\n  Effect.gen(function* () {\n    console.log(\"\ud83d\udce6 PostgreSQL JSONB Validation\\n\");\n\n    // Query by status\n    const shippedOrders = yield* queryOrdersByStatus(\n      \"shipped\"\n    );\n    console.log(\n      `\u2705 Found ${shippedOrders.length} shipped orders`\n    );\n\n    for (const order of shippedOrders) {\n      const amount = extractOrderAmount(order);\n      console.log(\n        `  Order ${order.orderId}: $${amount.toFixed(2)}`\n      );\n    }\n\n    // Update order status\n    yield* updateOrderStatus(\n      \"ORD-001\",\n      \"delivered\",\n      \"ABC123XYZ-DELIVERED\"\n    );\n\n    // Insert new order\n    const newOrder = yield* validateForInsert({\n      orderId: \"ORD-999\",\n      customerId: \"CUST-789\",\n      status: \"pending\",\n      items: [\n        { productId: \"PROD-X\", quantity: 1, price: 99.99 },\n      ],\n    });\n\n    console.log(`\u2705 New order validated: ${newOrder.orderId}`);\n  })\n)\n  .catch((error) => {\n    console.error(`\u274c ${error._tag}: ${error.message}`);\n  });",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "PostgreSQL JSONB Validation using Schema."
            },
            "created_at": "2026-02-16T21:39:14.851148",
            "updated_at": "2026-02-20T23:09:39.929941"
        },
        {
            "id": "a79855c4-e3cf-4ab3-affb-2830512ba823",
            "slug": "getting-started-handle-errors",
            "title": "Handle Your First Error with Effect.fail and catchAll",
            "summary": "Learn how to create Effects that can fail and how to recover from those failures using Effect.fail and Effect.catchAll.",
            "skill_level": "beginner",
            "category": "getting-started",
            "difficulty": "beginner",
            "tags": [
                "getting-started",
                "error-handling",
                "fail",
                "catchAll",
                "beginner"
            ],
            "examples": [
                {
                    "code": "import { Effect, pipe } from \"effect\";\n\nclass UserNotFound {\n  readonly _tag = \"UserNotFound\";\n  constructor(readonly id: string) {}\n}\n\nconst findUser = (id: string) =>\n  id === \"123\"\n    ? Effect.succeed({ id, name: \"Alice\" })\n    : Effect.fail(new UserNotFound(id));\n\nconst program = pipe(\n  findUser(\"456\"),\n  Effect.catchTag(\"UserNotFound\", (e) =>\n    Effect.succeed({ id: e.id, name: \"Guest\" })\n  ),\n  Effect.map((user) => `Hello, ${user.name}!`)\n);\n\nconst result = Effect.runSync(program);\nconsole.log(result); // \"Hello, Guest!\"",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Handle errors with Effect.fail and catchAll."
            },
            "created_at": "2026-02-15T21:22:12.598245",
            "updated_at": "2026-02-20T23:09:35.402868"
        },
        {
            "id": "689742b7-a06f-4945-a9f3-c5d1846ecd86",
            "slug": "launch-http-server",
            "title": "Create a Basic HTTP Server",
            "summary": "Launch a simple, effect-native HTTP server to respond to incoming requests.",
            "skill_level": "beginner",
            "category": "building-apis",
            "difficulty": "beginner",
            "tags": [
                "http",
                "server",
                "platform",
                "node"
            ],
            "examples": [
                {
                    "code": "import { Effect, Duration } from \"effect\";\nimport * as http from \"http\";\n\n// Create HTTP server service\nclass HttpServer extends Effect.Service<HttpServer>()(\"HttpServer\", {\n  sync: () => ({\n    start: () =>\n      Effect.gen(function* () {\n        const server = http.createServer(\n          (req: http.IncomingMessage, res: http.ServerResponse) => {\n            res.writeHead(200, { \"Content-Type\": \"text/plain\" });\n            res.end(\"Hello, World!\");\n          }\n        );\n\n        // Add cleanup finalizer\n        yield* Effect.addFinalizer(() =>\n          Effect.gen(function* () {\n            yield* Effect.sync(() => server.close());\n            yield* Effect.logInfo(\"Server shut down\");\n          })\n        );\n\n        // Start server with timeout\n        yield* Effect.async<void, Error>((resume) => {\n          server.on(\"error\", (error) => resume(Effect.fail(error)));\n          server.listen(3456, \"localhost\", () => {\n            resume(Effect.succeed(void 0));\n          });\n        }).pipe(\n          Effect.timeout(Duration.seconds(5)),\n          Effect.catchAll((error) =>\n            Effect.gen(function* () {\n              yield* Effect.logError(`Failed to start server: ${error}`);\n              return yield* Effect.fail(error);\n            })\n          )\n        );\n\n        yield* Effect.logInfo(\"Server running at http://localhost:3456/\");\n\n        // Run for a short duration to demonstrate the server is working\n        yield* Effect.sleep(Duration.seconds(3));\n        yield* Effect.logInfo(\"Server demonstration complete\");\n      }),\n  }),\n}) {}\n\n// Create program with proper error handling\nconst program = Effect.gen(function* () {\n  const server = yield* HttpServer;\n\n  yield* Effect.logInfo(\"Starting HTTP server...\");\n\n  yield* server.start();\n}).pipe(\n  Effect.scoped // Ensure server is cleaned up properly\n);\n\n// Run the server with proper error handling\nconst programWithErrorHandling = Effect.provide(\n  program,\n  HttpServer.Default\n).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program failed: ${error}`);\n      return yield* Effect.fail(error);\n    })\n  )\n);\n\nEffect.runPromise(programWithErrorHandling).catch(() => {\n  process.exit(1);\n});\n\n/*\nTo test:\n1. Server will timeout after 5 seconds if it can't start\n2. Server runs on port 3456 to avoid conflicts\n3. Proper cleanup on shutdown\n4. Demonstrates server lifecycle: start -> run -> shutdown\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Http.server.serve with a platform-specific layer to run an HTTP application."
            },
            "created_at": "2026-02-15T21:22:25.027956",
            "updated_at": "2026-02-20T23:09:35.594108"
        },
        {
            "id": "17794fe6-abdf-463a-a83e-b2e5c4bc4774",
            "slug": "make-http-client-request",
            "title": "Make an Outgoing HTTP Client Request",
            "summary": "Use the built-in Effect HTTP client to make safe and composable requests to external services from within your API.",
            "skill_level": "intermediate",
            "category": "building-apis",
            "difficulty": "intermediate",
            "tags": [
                "http",
                "client",
                "api",
                "fetch",
                "request"
            ],
            "examples": [
                {
                    "code": "import { NodeHttpServer, NodeRuntime } from \"@effect/platform-node\";\nimport * as HttpRouter from \"@effect/platform/HttpRouter\";\nimport * as HttpServer from \"@effect/platform/HttpServer\";\nimport * as HttpResponse from \"@effect/platform/HttpServerResponse\";\nimport { Console, Data, Duration, Effect, Fiber, Layer } from \"effect\";\n\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\")<{\n  id: string;\n}> {}\n\nexport class Database extends Effect.Service<Database>()(\"Database\", {\n  sync: () => ({\n    getUser: (id: string) =>\n      id === \"123\"\n        ? Effect.succeed({ name: \"Paul\" })\n        : Effect.fail(new UserNotFoundError({ id })),\n  }),\n}) {}\n\nconst userHandler = Effect.flatMap(HttpRouter.params, (p) =>\n  Effect.flatMap(Database, (db) => db.getUser(p[\"userId\"] ?? \"\")).pipe(\n    Effect.flatMap(HttpResponse.json)\n  )\n);\n\nconst app = HttpRouter.empty.pipe(\n  HttpRouter.get(\"/users/:userId\", userHandler)\n);\n\nconst server = NodeHttpServer.layer(() => require(\"node:http\").createServer(), {\n  port: 3457,\n});\n\nconst serverLayer = HttpServer.serve(app);\n\nconst mainLayer = Layer.merge(Database.Default, server);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Server started on http://localhost:3457\");\n  const layer = Layer.provide(serverLayer, mainLayer);\n\n  // Launch server and run for a short duration to demonstrate\n  const serverFiber = yield* Layer.launch(layer).pipe(Effect.fork);\n\n  // Wait a moment for server to start\n  yield* Effect.sleep(Duration.seconds(1));\n\n  // Simulate some server activity\n  yield* Effect.log(\"Server is running and ready to handle requests\");\n  yield* Effect.sleep(Duration.seconds(2));\n\n  // Shutdown gracefully\n  yield* Fiber.interrupt(serverFiber);\n  yield* Effect.log(\"Server shutdown complete\");\n});\n\nNodeRuntime.runMain(\n  Effect.provide(\n    program,\n    Layer.provide(serverLayer, Layer.merge(Database.Default, server))\n  ) as Effect.Effect<void, unknown, never>\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use the Http.client module to make outgoing requests to keep the entire operation within the Effect ecosystem."
            },
            "created_at": "2026-02-15T21:22:25.810794",
            "updated_at": "2026-02-20T23:09:35.637313"
        },
        {
            "id": "6851f4c0-79fc-4916-988c-e2a15a9c15e5",
            "slug": "api-authentication",
            "title": "Implement API Authentication",
            "summary": "Add JWT or session-based authentication to protect your API endpoints.",
            "skill_level": "intermediate",
            "category": "building-apis",
            "difficulty": "intermediate",
            "tags": [
                "building-apis",
                "authentication",
                "jwt",
                "security"
            ],
            "examples": [
                {
                    "code": "import { Effect, Context, Layer, Data } from \"effect\"\nimport { HttpServer, HttpServerRequest, HttpServerResponse } from \"@effect/platform\"\n\n// ============================================\n// 1. Define authentication types\n// ============================================\n\ninterface User {\n  readonly id: string\n  readonly email: string\n  readonly roles: ReadonlyArray<string>\n}\n\nclass AuthenticatedUser extends Context.Tag(\"AuthenticatedUser\")<\n  AuthenticatedUser,\n  User\n>() {}\n\nclass UnauthorizedError extends Data.TaggedError(\"UnauthorizedError\")<{\n  readonly reason: string\n}> {}\n\nclass ForbiddenError extends Data.TaggedError(\"ForbiddenError\")<{\n  readonly requiredRole: string\n}> {}\n\n// ============================================\n// 2. JWT validation service\n// ============================================\n\ninterface JwtService {\n  readonly verify: (token: string) => Effect.Effect<User, UnauthorizedError>\n}\n\nclass Jwt extends Context.Tag(\"Jwt\")<Jwt, JwtService>() {}\n\nconst JwtLive = Layer.succeed(Jwt, {\n  verify: (token) =>\n    Effect.gen(function* () {\n      // In production: use a real JWT library\n      if (!token || token === \"invalid\") {\n        return yield* Effect.fail(new UnauthorizedError({ \n          reason: \"Invalid or expired token\" \n        }))\n      }\n\n      // Decode token (simplified)\n      if (token.startsWith(\"user-\")) {\n        return {\n          id: token.replace(\"user-\", \"\"),\n          email: \"user@example.com\",\n          roles: [\"user\"],\n        }\n      }\n\n      if (token.startsWith(\"admin-\")) {\n        return {\n          id: token.replace(\"admin-\", \"\"),\n          email: \"admin@example.com\",\n          roles: [\"user\", \"admin\"],\n        }\n      }\n\n      return yield* Effect.fail(new UnauthorizedError({ \n        reason: \"Malformed token\" \n      }))\n    }),\n})\n\n// ============================================\n// 3. Authentication middleware\n// ============================================\n\nconst extractBearerToken = (header: string | undefined): string | null => {\n  if (!header?.startsWith(\"Bearer \")) return null\n  return header.slice(7)\n}\n\nconst authenticate = <A, E, R>(\n  handler: Effect.Effect<A, E, R | AuthenticatedUser>\n): Effect.Effect<A, E | UnauthorizedError, R | Jwt | HttpServerRequest.HttpServerRequest> =>\n  Effect.gen(function* () {\n    const request = yield* HttpServerRequest.HttpServerRequest\n    const jwt = yield* Jwt\n\n    const authHeader = request.headers[\"authorization\"]\n    const token = extractBearerToken(authHeader)\n\n    if (!token) {\n      return yield* Effect.fail(new UnauthorizedError({ \n        reason: \"Missing Authorization header\" \n      }))\n    }\n\n    const user = yield* jwt.verify(token)\n\n    return yield* handler.pipe(\n      Effect.provideService(AuthenticatedUser, user)\n    )\n  })\n\n// ============================================\n// 4. Role-based authorization\n// ============================================\n\nconst requireRole = (role: string) =>\n  <A, E, R>(handler: Effect.Effect<A, E, R | AuthenticatedUser>) =>\n    Effect.gen(function* () {\n      const user = yield* AuthenticatedUser\n\n      if (!user.roles.includes(role)) {\n        return yield* Effect.fail(new ForbiddenError({ requiredRole: role }))\n      }\n\n      return yield* handler\n    })\n\n// ============================================\n// 5. Protected routes\n// ============================================\n\nconst getProfile = authenticate(\n  Effect.gen(function* () {\n    const user = yield* AuthenticatedUser\n    return HttpServerResponse.json({\n      id: user.id,\n      email: user.email,\n      roles: user.roles,\n    })\n  })\n)\n\nconst adminOnly = authenticate(\n  requireRole(\"admin\")(\n    Effect.gen(function* () {\n      const user = yield* AuthenticatedUser\n      return HttpServerResponse.json({\n        message: `Welcome admin ${user.email}`,\n        users: [\"user1\", \"user2\", \"user3\"],\n      })\n    })\n  )\n)\n\n// ============================================\n// 6. Error handling\n// ============================================\n\nconst handleAuthErrors = <A, E, R>(effect: Effect.Effect<A, E, R>) =>\n  effect.pipe(\n    Effect.catchTag(\"UnauthorizedError\", (e) =>\n      Effect.succeed(\n        HttpServerResponse.json({ error: e.reason }, { status: 401 })\n      )\n    ),\n    Effect.catchTag(\"ForbiddenError\", (e) =>\n      Effect.succeed(\n        HttpServerResponse.json(\n          { error: `Requires role: ${e.requiredRole}` },\n          { status: 403 }\n        )\n      )\n    )\n  )",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use middleware to validate authentication tokens before handling requests."
            },
            "created_at": "2026-02-15T21:22:25.732383",
            "updated_at": "2026-02-20T23:09:35.725318"
        },
        {
            "id": "58c53adf-318a-4245-b6e6-f334e15b7b09",
            "slug": "understand-fibers-as-lightweight-threads",
            "title": "Understand Fibers as Lightweight Threads",
            "summary": "A Fiber is a lightweight, virtual thread managed by the Effect runtime, enabling massive concurrency on a single OS thread without the overhead of traditional threading.",
            "skill_level": "advanced",
            "category": "concurrency",
            "difficulty": "advanced",
            "tags": [
                "fiber",
                "concurrency",
                "virtual-thread",
                "lightweight-thread",
                "performance",
                "runtime"
            ],
            "examples": [
                {
                    "code": "import { Effect, Fiber } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  // Demonstrate the lightweight nature of fibers by creating 100,000 of them\n  // This would be impossible with OS threads due to memory and context switching overhead\n  const fiberCount = 100_000;\n  yield* Effect.log(`Forking ${fiberCount} fibers...`);\n\n  // Create an array of 100,000 simple effects\n  // Each effect sleeps for 1 second and then returns its index\n  // This simulates lightweight concurrent tasks\n  const tasks = Array.from({ length: fiberCount }, (_, i) =>\n    Effect.sleep(\"1 second\").pipe(Effect.as(i))\n  );\n\n  // Fork all of them into background fibers\n  // Effect.fork creates a new fiber for each task without blocking\n  // This demonstrates fiber creation scalability - 100k fibers created almost instantly\n  // Each fiber is much lighter than an OS thread (typically ~1KB vs ~8MB per thread)\n  const fibers = yield* Effect.forEach(tasks, Effect.fork);\n\n  yield* Effect.log(\n    \"All fibers have been forked. Now waiting for them to complete...\"\n  );\n\n  // Wait for all fibers to finish their work\n  // Fiber.joinAll waits for all fibers to complete and collects their results\n  // This demonstrates fiber coordination - managing thousands of concurrent operations\n  // The runtime efficiently schedules these fibers using a work-stealing thread pool\n  const results = yield* Fiber.joinAll(fibers);\n\n  yield* Effect.log(`All ${results.length} fibers have completed.`);\n\n  // Key insights from this example:\n  // 1. Fibers are extremely lightweight - 100k fibers use minimal memory\n  // 2. Fiber creation is fast - no expensive OS thread allocation\n  // 3. The Effect runtime efficiently schedules fibers across available CPU cores\n  // 4. Fibers can be suspended and resumed without blocking OS threads\n  // 5. This enables massive concurrency for I/O-bound operations\n});\n\n// This program runs successfully, demonstrating the low overhead of fibers.\n// Try running this with OS threads - you'd likely hit system limits around 1000-10000 threads\n// With fibers, 100k+ concurrent operations are easily achievable\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Understand that a Fiber is a lightweight, virtual thread managed by the Effect runtime for massive concurrency."
            },
            "created_at": "2026-02-15T21:22:20.926576",
            "updated_at": "2026-02-20T23:09:36.274145"
        },
        {
            "id": "00cca229-8539-4787-916d-94aff00b2f61",
            "slug": "concurrency-pattern-race-timeout",
            "title": "Concurrency Pattern 6: Race and Timeout Competing Effects",
            "summary": "Use race and timeout to compete multiple effects and enforce deadlines, enabling timeout handling and choosing fastest result.",
            "skill_level": "intermediate",
            "category": "concurrency",
            "difficulty": "intermediate",
            "tags": [
                "concurrency",
                "race",
                "timeout",
                "deadline",
                "competing-effects",
                "cancellation"
            ],
            "examples": [
                {
                    "code": "import { Effect, Fiber } from \"effect\";\n\ninterface DataSource {\n  readonly name: string;\n  readonly latencyMs: number;\n}\n\n// Simulate fetching from different sources\nconst fetchFromSource = (source: DataSource): Effect.Effect<string> =>\n  Effect.gen(function* () {\n    yield* Effect.log(\n      `[${source.name}] Starting fetch (latency: ${source.latencyMs}ms)`\n    );\n\n    yield* Effect.sleep(`${source.latencyMs} millis`);\n\n    const result = `Data from ${source.name}`;\n\n    yield* Effect.log(`[${source.name}] \u2713 Completed`);\n\n    return result;\n  });\n\n// Main: demonstrate race patterns\nconst program = Effect.gen(function* () {\n  console.log(`\\n[RACE] Competing effects with race and timeout\\n`);\n\n  // Example 1: Simple race (fastest wins)\n  console.log(`[1] Racing 3 data sources:\\n`);\n\n  const sources: DataSource[] = [\n    { name: \"Primary DC\", latencyMs: 200 },\n    { name: \"Backup DC\", latencyMs: 150 },\n    { name: \"Cache\", latencyMs: 50 },\n  ];\n\n  const raceResult = yield* Effect.race(\n    fetchFromSource(sources[0]),\n    Effect.race(fetchFromSource(sources[1]), fetchFromSource(sources[2]))\n  );\n\n  console.log(`\\nWinner: ${raceResult}\\n`);\n\n  // Example 2: Timeout - succeed within deadline\n  console.log(`[2] Timeout with fast operation:\\n`);\n\n  const fastOp = fetchFromSource({ name: \"Fast Op\", latencyMs: 100 }).pipe(\n    Effect.timeout(\"500 millis\")\n  );\n\n  const fastResult = yield* fastOp;\n\n  console.log(`\u2713 Completed within timeout: ${fastResult}\\n`);\n\n  // Example 3: Timeout - exceed deadline\n  console.log(`[3] Timeout with slow operation:\\n`);\n\n  const slowOp = fetchFromSource({ name: \"Slow Op\", latencyMs: 2000 }).pipe(\n    Effect.timeout(\"500 millis\"),\n    Effect.either\n  );\n\n  const timeoutResult = yield* slowOp;\n\n  if (timeoutResult._tag === \"Left\") {\n    console.log(`\u2717 Operation timed out after 500ms\\n`);\n  }\n\n  // Example 4: Race with timeout fallback\n  console.log(`[4] Race with fallback on timeout:\\n`);\n\n  const primary = fetchFromSource({ name: \"Primary\", latencyMs: 300 });\n\n  const fallback = fetchFromSource({ name: \"Fallback\", latencyMs: 100 });\n\n  const raceWithFallback = primary.pipe(\n    Effect.timeout(\"150 millis\"),\n    Effect.catchAll(() =>\n      Effect.gen(function* () {\n        yield* Effect.log(`[PRIMARY] Timed out, using fallback`);\n        return yield* fallback;\n      })\n    )\n  );\n\n  const fallbackResult = yield* raceWithFallback;\n\n  console.log(`Result: ${fallbackResult}\\n`);\n\n  // Example 5: Race all (collect all winners)\n  console.log(`[5] Race all - multiple sources:\\n`);\n\n  const raceAllResult = yield* Effect.raceAll(\n    sources.map((s) =>\n      fetchFromSource(s).pipe(\n        Effect.map((data) => ({ source: s.name, data }))\n      )\n    )\n  );\n\n  console.log(`First to complete: ${raceAllResult.source}\\n`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use race to compete effects and timeout to enforce deadlines, enabling cancellation when operations exceed time limits or complete."
            },
            "created_at": "2026-02-15T21:22:19.685582",
            "updated_at": "2026-02-20T23:09:36.414189"
        },
        {
            "id": "cc4656d5-cec6-4f47-a1fe-b7aa54d9b696",
            "slug": "concurrency-pattern-pubsub-event-broadcast",
            "title": "Concurrency Pattern 5: Broadcast Events with PubSub",
            "summary": "Use PubSub to broadcast events to multiple subscribers, enabling event-driven architectures and fan-out patterns without direct coupling.",
            "skill_level": "intermediate",
            "category": "concurrency",
            "difficulty": "intermediate",
            "tags": [
                "concurrency",
                "pubsub",
                "event-broadcast",
                "publish-subscribe",
                "fan-out",
                "decoupling"
            ],
            "examples": [
                {
                    "code": "import { Effect, PubSub, Fiber, Ref } from \"effect\";\n\ninterface StateChangeEvent {\n  readonly id: string;\n  readonly oldValue: string;\n  readonly newValue: string;\n  readonly timestamp: number;\n}\n\ninterface Subscriber {\n  readonly name: string;\n  readonly events: StateChangeEvent[];\n}\n\n// Create subscribers that react to events\nconst createSubscriber = (\n  name: string,\n  pubsub: PubSub.PubSub<StateChangeEvent>,\n  events: Ref.Ref<StateChangeEvent[]>\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`[${name}] \u2713 Subscribed`);\n\n    // Get subscriber handle\n    const subscription = yield* PubSub.subscribe(pubsub);\n\n    // Listen for events indefinitely\n    while (true) {\n      const event = yield* subscription.take();\n\n      yield* Effect.log(\n        `[${name}] Received event: ${event.oldValue} \u2192 ${event.newValue}`\n      );\n\n      // Simulate processing\n      yield* Effect.sleep(\"50 millis\");\n\n      // Store event (example action)\n      yield* Ref.update(events, (es) => [...es, event]);\n\n      yield* Effect.log(`[${name}] \u2713 Processed event`);\n    }\n  });\n\n// Publisher that broadcasts events\nconst publisher = (\n  pubsub: PubSub.PubSub<StateChangeEvent>,\n  eventCount: number\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`[PUBLISHER] Starting, publishing ${eventCount} events`);\n\n    for (let i = 1; i <= eventCount; i++) {\n      const event: StateChangeEvent = {\n        id: `event-${i}`,\n        oldValue: `state-${i - 1}`,\n        newValue: `state-${i}`,\n        timestamp: Date.now(),\n      };\n\n      // Publish to all subscribers\n      const size = yield* PubSub.publish(pubsub, event);\n\n      yield* Effect.log(\n        `[PUBLISHER] Published event to ${size} subscribers`\n      );\n\n      // Simulate delay between events\n      yield* Effect.sleep(\"200 millis\");\n    }\n\n    yield* Effect.log(`[PUBLISHER] \u2713 All events published`);\n  });\n\n// Main: coordinate publisher and multiple subscribers\nconst program = Effect.gen(function* () {\n  // Create PubSub with bounded capacity\n  const pubsub = yield* PubSub.bounded<StateChangeEvent>(5);\n\n  // Create storage for each subscriber's events\n  const subscriber1Events = yield* Ref.make<StateChangeEvent[]>([]);\n  const subscriber2Events = yield* Ref.make<StateChangeEvent[]>([]);\n  const subscriber3Events = yield* Ref.make<StateChangeEvent[]>([]);\n\n  console.log(`\\n[MAIN] Starting PubSub event broadcast system\\n`);\n\n  // Subscribe 3 independent subscribers\n  const sub1Fiber = yield* createSubscriber(\n    \"SUBSCRIBER-1\",\n    pubsub,\n    subscriber1Events\n  ).pipe(Effect.fork);\n\n  const sub2Fiber = yield* createSubscriber(\n    \"SUBSCRIBER-2\",\n    pubsub,\n    subscriber2Events\n  ).pipe(Effect.fork);\n\n  const sub3Fiber = yield* createSubscriber(\n    \"SUBSCRIBER-3\",\n    pubsub,\n    subscriber3Events\n  ).pipe(Effect.fork);\n\n  // Wait for subscriptions to establish\n  yield* Effect.sleep(\"100 millis\");\n\n  // Start publisher\n  const publisherFiber = yield* publisher(pubsub, 5).pipe(Effect.fork);\n\n  // Wait for publisher to finish\n  yield* Fiber.join(publisherFiber);\n\n  // Wait a bit for subscribers to process last events\n  yield* Effect.sleep(\"1 second\");\n\n  // Shut down\n  yield* PubSub.shutdown(pubsub);\n  yield* Fiber.join(sub1Fiber).pipe(Effect.catchAll(() => Effect.void));\n  yield* Fiber.join(sub2Fiber).pipe(Effect.catchAll(() => Effect.void));\n  yield* Fiber.join(sub3Fiber).pipe(Effect.catchAll(() => Effect.void));\n\n  // Print summary\n  const events1 = yield* Ref.get(subscriber1Events);\n  const events2 = yield* Ref.get(subscriber2Events);\n  const events3 = yield* Ref.get(subscriber3Events);\n\n  console.log(`\\n[SUMMARY]`);\n  console.log(`  Subscriber 1 received: ${events1.length} events`);\n  console.log(`  Subscriber 2 received: ${events2.length} events`);\n  console.log(`  Subscriber 3 received: ${events3.length} events`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use PubSub to broadcast events to multiple subscribers, enabling event-driven architectures where publishers and subscribers are loosely coupled."
            },
            "created_at": "2026-02-15T21:22:19.603079",
            "updated_at": "2026-02-20T23:09:36.49482"
        },
        {
            "id": "a543d584-a45c-4128-9be0-72cdf937e736",
            "slug": "testing-property-based",
            "title": "Property-Based Testing with Effect",
            "summary": "Use fast-check with Effect for property-based testing of pure functions and effects.",
            "skill_level": "advanced",
            "category": "testing",
            "difficulty": "advanced",
            "tags": [
                "testing",
                "property-based",
                "fast-check",
                "generators"
            ],
            "examples": [
                {
                    "code": "import { describe, it, expect } from \"vitest\"\nimport { Effect, Option, Either, Schema } from \"effect\"\nimport * as fc from \"fast-check\"\n\ndescribe(\"Property-Based Testing with Effect\", () => {\n  // ============================================\n  // 1. Test pure function properties\n  // ============================================\n\n  it(\"should satisfy array reverse properties\", () => {\n    fc.assert(\n      fc.property(fc.array(fc.integer()), (arr) => {\n        // Reversing twice returns original\n        const reversed = arr.slice().reverse()\n        const doubleReversed = reversed.slice().reverse()\n\n        return JSON.stringify(arr) === JSON.stringify(doubleReversed)\n      })\n    )\n  })\n\n  it(\"should satisfy sort idempotence\", () => {\n    fc.assert(\n      fc.property(fc.array(fc.integer()), (arr) => {\n        const sorted = arr.slice().sort((a, b) => a - b)\n        const sortedTwice = sorted.slice().sort((a, b) => a - b)\n\n        return JSON.stringify(sorted) === JSON.stringify(sortedTwice)\n      })\n    )\n  })\n\n  // ============================================\n  // 2. Test Effect operations\n  // ============================================\n\n  it(\"should map then flatMap equals flatMap with mapping\", async () => {\n    await fc.assert(\n      fc.asyncProperty(fc.integer(), async (n) => {\n        const f = (x: number) => x * 2\n        const g = (x: number) => Effect.succeed(x + 1)\n\n        // map then flatMap\n        const result1 = await Effect.runPromise(\n          Effect.succeed(n).pipe(\n            Effect.map(f),\n            Effect.flatMap(g)\n          )\n        )\n\n        // flatMap with mapping inside\n        const result2 = await Effect.runPromise(\n          Effect.succeed(n).pipe(\n            Effect.flatMap((x) => g(f(x)))\n          )\n        )\n\n        return result1 === result2\n      })\n    )\n  })\n\n  // ============================================\n  // 3. Test Option properties\n  // ============================================\n\n  it(\"should satisfy Option map identity\", () => {\n    fc.assert(\n      fc.property(fc.option(fc.integer(), { nil: undefined }), (maybeN) => {\n        const option = maybeN === undefined ? Option.none() : Option.some(maybeN)\n\n        // Mapping identity function returns same Option\n        const mapped = Option.map(option, (x) => x)\n\n        return Option.getOrElse(option, () => -1) ===\n               Option.getOrElse(mapped, () => -1)\n      })\n    )\n  })\n\n  // ============================================\n  // 4. Test Schema encode/decode roundtrip\n  // ============================================\n\n  it(\"should roundtrip through Schema\", async () => {\n    const UserSchema = Schema.Struct({\n      name: Schema.String,\n      age: Schema.Number.pipe(Schema.int(), Schema.positive()),\n    })\n\n    const userArbitrary = fc.record({\n      name: fc.string({ minLength: 1 }),\n      age: fc.integer({ min: 1, max: 120 }),\n    })\n\n    await fc.assert(\n      fc.asyncProperty(userArbitrary, async (user) => {\n        const encode = Schema.encode(UserSchema)\n        const decode = Schema.decode(UserSchema)\n\n        // Encode then decode should return equivalent value\n        const encoded = await Effect.runPromise(encode(user))\n        const decoded = await Effect.runPromise(decode(encoded))\n\n        return decoded.name === user.name && decoded.age === user.age\n      })\n    )\n  })\n\n  // ============================================\n  // 5. Test error handling properties\n  // ============================================\n\n  it(\"should recover from any error\", async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.string(),\n        fc.string(),\n        async (errorMsg, fallback) => {\n          const failing = Effect.fail(new Error(errorMsg))\n\n          const result = await Effect.runPromise(\n            failing.pipe(\n              Effect.catchAll(() => Effect.succeed(fallback))\n            )\n          )\n\n          return result === fallback\n        }\n      )\n    )\n  })\n\n  // ============================================\n  // 6. Custom generators for domain types\n  // ============================================\n\n  interface Email {\n    readonly _tag: \"Email\"\n    readonly value: string\n  }\n\n  const emailArbitrary = fc.emailAddress().map((value): Email => ({\n    _tag: \"Email\",\n    value,\n  }))\n\n  interface UserId {\n    readonly _tag: \"UserId\"\n    readonly value: string\n  }\n\n  const userIdArbitrary = fc.uuid().map((value): UserId => ({\n    _tag: \"UserId\",\n    value,\n  }))\n\n  it(\"should handle domain types correctly\", () => {\n    fc.assert(\n      fc.property(emailArbitrary, userIdArbitrary, (email, userId) => {\n        // Test your domain functions with generated domain types\n        return email.value.includes(\"@\") && userId.value.length > 0\n      })\n    )\n  })\n\n  // ============================================\n  // 7. Test algebraic properties\n  // ============================================\n\n  it(\"should satisfy monoid properties for string concat\", () => {\n    const empty = \"\"\n    const concat = (a: string, b: string) => a + b\n\n    fc.assert(\n      fc.property(fc.string(), fc.string(), fc.string(), (a, b, c) => {\n        // Identity: empty + a = a = a + empty\n        const leftIdentity = concat(empty, a) === a\n        const rightIdentity = concat(a, empty) === a\n\n        // Associativity: (a + b) + c = a + (b + c)\n        const associative = concat(concat(a, b), c) === concat(a, concat(b, c))\n\n        return leftIdentity && rightIdentity && associative\n      })\n    )\n  })\n\n  // ============================================\n  // 8. Test with constraints\n  // ============================================\n\n  it(\"should handle positive numbers\", () => {\n    fc.assert(\n      fc.property(\n        fc.integer({ min: 1, max: 1000000 }),\n        fc.integer({ min: 1, max: 1000000 }),\n        (a, b) => {\n          // Division of positives is positive\n          const result = a / b\n          return result > 0\n        }\n      )\n    )\n  })\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use property-based testing to find edge cases your example-based tests miss."
            },
            "created_at": "2026-02-15T21:22:28.774863",
            "updated_at": "2026-02-20T23:09:40.983226"
        },
        {
            "id": "c098862a-c7a2-4361-bec2-6f7b2e4077b5",
            "slug": "manage-shared-state-with-ref",
            "title": "Manage Shared State Safely with Ref",
            "summary": "Use Ref<A> to model shared, mutable state in a concurrent environment, ensuring all updates are atomic and free of race conditions.",
            "skill_level": "intermediate",
            "category": "concurrency",
            "difficulty": "intermediate",
            "tags": [
                "ref",
                "state-management",
                "concurrency",
                "atomic",
                "mutable-state"
            ],
            "examples": [
                {
                    "code": "import { Effect, Ref } from \"effect\";\n\nconst program = Effect.gen(function* () {\n  // Create a new Ref with an initial value of 0\n  const ref = yield* Ref.make(0);\n\n  // Define an effect that increments the counter by 1\n  const increment = Ref.update(ref, (n) => n + 1);\n\n  // Create an array of 1,000 increment effects\n  const tasks = Array.from({ length: 1000 }, () => increment);\n\n  // Run all 1,000 effects concurrently\n  yield* Effect.all(tasks, { concurrency: \"unbounded\" });\n\n  // Get the final value of the counter\n  return yield* Ref.get(ref);\n});\n\n// The result will always be 1000\nconst programWithLogging = Effect.gen(function* () {\n  const result = yield* program;\n  yield* Effect.log(`Final counter value: ${result}`);\n  return result;\n});\n\nEffect.runPromise(programWithLogging);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Ref to manage shared, mutable state concurrently, ensuring atomicity."
            },
            "created_at": "2026-02-15T21:22:19.77232",
            "updated_at": "2026-02-20T23:09:36.837532"
        },
        {
            "id": "03079e6b-70b1-4f98-b62d-9017564077cc",
            "slug": "manage-resource-lifecycles-with-scope",
            "title": "Manage Resource Lifecycles with Scope",
            "summary": "Use Scope for fine-grained, manual control over resource lifecycles, ensuring cleanup logic (finalizers) is always executed.",
            "skill_level": "advanced",
            "category": "concurrency",
            "difficulty": "advanced",
            "tags": [
                "scope",
                "resource-management",
                "finalizer",
                "acquire-release",
                "memory-safety"
            ],
            "examples": [
                {
                    "code": "import { Effect, Scope } from \"effect\";\n\n// Simulate acquiring and releasing a resource\nconst acquireFile = Effect.log(\"File opened\").pipe(\n  Effect.as({ write: (data: string) => Effect.log(`Wrote: ${data}`) })\n);\nconst releaseFile = Effect.log(\"File closed.\");\n\n// Create a \"scoped\" effect. This effect, when used, will acquire the\n// resource and register its release action with the current scope.\nconst scopedFile = Effect.acquireRelease(acquireFile, () => releaseFile);\n\n// The main program that uses the scoped resource\nconst program = Effect.gen(function* () {\n  // Effect.scoped \"uses\" the resource. It runs the acquire effect,\n  // provides the resource to the inner effect, and ensures the\n  // release effect is run when this block completes.\n  const file = yield* Effect.scoped(scopedFile);\n\n  yield* file.write(\"hello\");\n  yield* file.write(\"world\");\n\n  // The file will be automatically closed here.\n});\n\nEffect.runPromise(program);\n/*\nOutput:\nFile opened\nWrote: hello\nWrote: world\nFile closed\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Scope for fine-grained, manual control over resource lifecycles and cleanup guarantees."
            },
            "created_at": "2026-02-15T21:22:20.445549",
            "updated_at": "2026-02-20T23:09:36.973942"
        },
        {
            "id": "ebf43469-080e-49b4-a5fd-85d9d253fc58",
            "slug": "state-management-pattern-synchronized-ref",
            "title": "State Management Pattern 1: Synchronized Reference with SynchronizedRef",
            "summary": "Use SynchronizedRef to safely share mutable state across concurrent fibers, with atomic updates and guaranteed consistency.",
            "skill_level": "advanced",
            "category": "concurrency",
            "difficulty": "advanced",
            "tags": [
                "state-management",
                "concurrency",
                "shared-state",
                "atomic-operations",
                "thread-safety",
                "fiber-coordination"
            ],
            "examples": [
                {
                    "code": "import { Effect, Ref, Fiber, Deferred } from \"effect\";\n\ninterface Counter {\n  readonly value: number;\n  readonly updates: number;\n}\n\ninterface Account {\n  readonly balance: number;\n  readonly transactions: string[];\n}\n\nconst program = Effect.gen(function* () {\n  console.log(\n    `\\n[SYNCHRONIZED REFERENCES] Concurrent state management\\n`\n  );\n\n  // Example 1: Basic counter with atomic updates\n  console.log(`[1] Atomic counter increments:\\n`);\n\n  const counter = yield* Ref.make<Counter>({\n    value: 0,\n    updates: 0,\n  });\n\n  // Simulate 5 concurrent increments\n  const incrementTasks = Array.from({ length: 5 }, (_, i) =>\n    Effect.gen(function* () {\n      for (let j = 0; j < 20; j++) {\n        yield* Ref.modify(counter, (current) => [\n          undefined,\n          {\n            value: current.value + 1,\n            updates: current.updates + 1,\n          },\n        ]);\n\n        if (j === 0 || j === 19) {\n          yield* Effect.log(\n            `[FIBER ${i}] Increment ${j === 0 ? \"start\" : \"end\"}`\n          );\n        }\n      }\n    })\n  );\n\n  // Run concurrently\n  yield* Effect.all(incrementTasks, { concurrency: \"unbounded\" });\n\n  const finalCounter = yield* Ref.get(counter);\n\n  yield* Effect.log(\n    `[RESULT] Counter: ${finalCounter.value} (expected 100)`\n  );\n  yield* Effect.log(\n    `[RESULT] Updates: ${finalCounter.updates} (expected 100)\\n`\n  );\n\n  // Example 2: Bank account with transaction isolation\n  console.log(`[2] Account with atomic transfers:\\n`);\n\n  const account = yield* Ref.make<Account>({\n    balance: 1000,\n    transactions: [],\n  });\n\n  const transfer = (amount: number, description: string) =>\n    Ref.modify(account, (current) => {\n      if (current.balance < amount) {\n        // Insufficient funds, don't modify\n        return [\n          { success: false, reason: \"insufficient-funds\" },\n          current, // Unchanged\n        ];\n      }\n\n      // Atomic: deduct + record transaction\n      return [\n        { success: true, reason: \"transferred\" },\n        {\n          balance: current.balance - amount,\n          transactions: [\n            ...current.transactions,\n            `${description}: -$${amount}`,\n          ],\n        },\n      ];\n    });\n\n  // Test transfer\n  const t1 = yield* transfer(100, \"Coffee\");\n\n  yield* Effect.log(`[TRANSFER 1] ${t1.success ? \"\u2713\" : \"\u2717\"} ${t1.reason}`);\n\n  const t2 = yield* transfer(2000, \"Electronics\");\n\n  yield* Effect.log(`[TRANSFER 2] ${t2.success ? \"\u2713\" : \"\u2717\"} ${t2.reason}`);\n\n  const t3 = yield* transfer(200, \"Groceries\");\n\n  yield* Effect.log(`[TRANSFER 3] ${t3.success ? \"\u2713\" : \"\u2717\"} ${t3.reason}\\n`);\n\n  // Example 3: Concurrent reads don't block writes\n  console.log(`[3] Concurrent reads and writes:\\n`);\n\n  const state = yield* Ref.make({ value: 0, readers: 0 });\n\n  const read = Effect.gen(function* () {\n    const snapshot = yield* Ref.get(state);\n\n    yield* Effect.log(\n      `[READ] Got value: ${snapshot.value}`\n    );\n\n    return snapshot.value;\n  });\n\n  const write = (newValue: number) =>\n    Ref.set(state, { value: newValue, readers: 0 });\n\n  // Concurrent operations\n  const mixed = Effect.all(\n    [\n      read,\n      write(10),\n      read,\n      write(20),\n      read,\n    ],\n    { concurrency: \"unbounded\" }\n  );\n\n  yield* mixed;\n\n  // Example 4: Compare-and-set pattern (retry on failure)\n  console.log(`\\n[4] Compare-and-set (optimistic updates):\\n`);\n\n  const versionedState = yield* Ref.make({ version: 0, data: \"initial\" });\n\n  const updateWithVersion = (newData: string) =>\n    Effect.gen(function* () {\n      let retries = 0;\n\n      while (retries < 3) {\n        const current = yield* Ref.get(versionedState);\n\n        // Try to update (check-and-set)\n        const result = yield* Ref.modify(versionedState, (s) => {\n          if (s.version === current.version) {\n            // No concurrent update, proceed\n            return [\n              { success: true },\n              {\n                version: s.version + 1,\n                data: newData,\n              },\n            ];\n          }\n\n          // Version changed, conflict\n          return [{ success: false }, s];\n        });\n\n        if (result.success) {\n          yield* Effect.log(\n            `[CAS] Updated on attempt ${retries + 1}`\n          );\n\n          return true;\n        }\n\n        retries++;\n\n        yield* Effect.log(\n          `[CAS] Conflict detected, retrying (attempt ${retries + 1})`\n        );\n      }\n\n      return false;\n    });\n\n  const casResult = yield* updateWithVersion(\"updated-data\");\n\n  yield* Effect.log(`[CAS] Success: ${casResult}\\n`);\n\n  // Example 5: State with subscriptions (notify on change)\n  console.log(`[5] State changes with notification:\\n`);\n\n  interface Notification {\n    oldValue: unknown;\n    newValue: unknown;\n    timestamp: Date;\n  }\n\n  const observedState = yield* Ref.make<{ value: number; lastChange: Date }>({\n    value: 0,\n    lastChange: new Date(),\n  });\n\n  const updateAndNotify = (newValue: number) =>\n    Effect.gen(function* () {\n      const notification = yield* Ref.modify(observedState, (current) => {\n        const n: Notification = {\n          oldValue: current.value,\n          newValue,\n          timestamp: new Date(),\n        };\n        return [\n          n,\n          {\n            value: newValue,\n            lastChange: n.timestamp,\n          },\n        ];\n      });\n\n      yield* Effect.log(\n        `[NOTIFY] ${notification.oldValue} \u2192 ${newValue} at ${notification.timestamp.toISOString()}`\n      );\n\n      return notification;\n    });\n\n  // Trigger changes\n  for (const val of [5, 10, 15]) {\n    yield* updateAndNotify(val);\n  }\n\n  // Example 6: Atomic batch updates\n  console.log(`\\n[6] Batch atomic updates:\\n`);\n\n  interface BatchState {\n    items: string[];\n    locked: boolean;\n    version: number;\n  }\n\n  const batchState = yield* Ref.make<BatchState>({\n    items: [],\n    locked: false,\n    version: 0,\n  });\n\n  const addItems = (newItems: string[]) =>\n    Ref.modify(batchState, (current) => {\n      // All items added atomically\n      return [\n        { added: newItems.length },\n        {\n          items: [...current.items, ...newItems],\n          locked: false,\n          version: current.version + 1,\n        },\n      ];\n    });\n\n  const batch1 = yield* addItems([\"item1\", \"item2\", \"item3\"]);\n\n  yield* Effect.log(\n    `[BATCH 1] Added ${batch1.added} items`\n  );\n\n  const batch2 = yield* addItems([\"item4\", \"item5\"]);\n\n  yield* Effect.log(\n    `[BATCH 2] Added ${batch2.added} items`\n  );\n\n  const finalBatch = yield* Ref.get(batchState);\n\n  yield* Effect.log(\n    `[RESULT] Total items: ${finalBatch.items.length}, Version: ${finalBatch.version}`\n  );\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use SynchronizedRef for thread-safe mutable state that must be updated consistently across concurrent operations, with atomic modifications."
            },
            "created_at": "2026-02-15T21:22:20.749853",
            "updated_at": "2026-02-20T23:09:37.017467"
        },
        {
            "id": "152dd993-329a-4849-9aa9-b4320f8959a1",
            "slug": "concurrency-understanding-fibers",
            "title": "Understanding Fibers",
            "summary": "Learn what fibers are, how they differ from threads, and why they make Effect powerful for concurrent programming.",
            "skill_level": "beginner",
            "category": "concurrency",
            "difficulty": "beginner",
            "tags": [
                "concurrency",
                "fiber",
                "fork",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Fiber } from \"effect\"\n\n// ============================================\n// WHAT IS A FIBER?\n// ============================================\n\n// A fiber is a running effect. When you run an effect,\n// it executes on a fiber.\n\nconst myEffect = Effect.gen(function* () {\n  yield* Effect.log(\"Hello from a fiber!\")\n  yield* Effect.sleep(\"100 millis\")\n  return 42\n})\n\n// This runs myEffect on the \"main\" fiber\nEffect.runPromise(myEffect)\n\n// ============================================\n// FORKING: Create a new fiber\n// ============================================\n\nconst withFork = Effect.gen(function* () {\n  yield* Effect.log(\"Main fiber starting\")\n  \n  // Fork creates a new fiber that runs independently\n  const fiber = yield* Effect.fork(\n    Effect.gen(function* () {\n      yield* Effect.log(\"Child fiber running\")\n      yield* Effect.sleep(\"200 millis\")\n      yield* Effect.log(\"Child fiber done\")\n      return \"child result\"\n    })\n  )\n  \n  yield* Effect.log(\"Main fiber continues immediately\")\n  yield* Effect.sleep(\"100 millis\")\n  yield* Effect.log(\"Main fiber waiting for child...\")\n  \n  // Wait for the forked fiber to complete\n  const result = yield* Fiber.join(fiber)\n  yield* Effect.log(`Got result: ${result}`)\n})\n\nEffect.runPromise(withFork)\n/*\nOutput:\nMain fiber starting\nChild fiber running\nMain fiber continues immediately\nMain fiber waiting for child...\nChild fiber done\nGot result: child result\n*/\n\n// ============================================\n// FIBER OPERATIONS\n// ============================================\n\nconst fiberOps = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(\n    Effect.gen(function* () {\n      yield* Effect.sleep(\"1 second\")\n      return \"done\"\n    })\n  )\n  \n  // Check if fiber is done (non-blocking)\n  const poll = yield* Fiber.poll(fiber)\n  yield* Effect.log(`Poll result: ${poll}`) // None (still running)\n  \n  // Wait for completion\n  const result = yield* Fiber.join(fiber)\n  yield* Effect.log(`Join result: ${result}`)\n  \n  // Or interrupt if taking too long\n  // yield* Fiber.interrupt(fiber)\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Fibers are lightweight threads managed by Effect, enabling efficient concurrency without OS thread overhead."
            },
            "created_at": "2026-02-15T21:22:19.105747",
            "updated_at": "2026-02-20T23:09:37.194604"
        },
        {
            "id": "3e5c253d-1a23-442a-a28b-5f09189948e4",
            "slug": "schema-api-response-union",
            "title": "Handling Union/Discriminated Responses",
            "summary": "APIs often return different response shapes based on success or failure. A user creation endpoint might return: - `{ success: true, data: User }` on success - `{ success: false, error: string }` on...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "api",
                "union-types",
                "discriminated-unions",
                "polymorphism"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema } from \"effect\"\n\n// Define each response variant as a separate schema\n\nconst SuccessResponse = Schema.Struct({\n  status: Schema.Literal(\"success\"),\n  data: Schema.Struct({\n    id: Schema.Number,\n    name: Schema.String,\n    email: Schema.String,\n  }),\n})\n\nconst ErrorResponse = Schema.Struct({\n  status: Schema.Literal(\"error\"),\n  code: Schema.Number,\n  message: Schema.String,\n})\n\nconst PendingResponse = Schema.Struct({\n  status: Schema.Literal(\"pending\"),\n  jobId: Schema.String,\n  checkAfterSeconds: Schema.Number,\n})\n\n// Union: Response is one of these three shapes\nconst Response = Schema.Union(\n  SuccessResponse,\n  ErrorResponse,\n  PendingResponse\n)\n\ntype Response = typeof Response.Type\n\nconst parseResponse = Schema.decodeUnknown(Response)\n\n// Use in a pipeline with pattern matching\nconst createUser = (name: string, email: string) =>\n  Effect.gen(function* () {\n    const response = yield* Effect.tryPromise(() =>\n      fetch(\"https://api.example.com/users\", {\n        method: \"POST\",\n        body: JSON.stringify({ name, email }),\n      }).then((r) => r.json())\n    )\n\n    const result = yield* parseResponse(response)\n\n    // Pattern match on the discriminator\n    if (result.status === \"success\") {\n      yield* Effect.log(`User created: ${result.data.name}`)\n      return { ok: true as const, user: result.data }\n    }\n\n    if (result.status === \"error\") {\n      yield* Effect.log(\n        `API error (${result.code}): ${result.message}`\n      )\n      return { ok: false as const, error: result.message }\n    }\n\n    if (result.status === \"pending\") {\n      yield* Effect.log(\n        `Processing: check back in ${result.checkAfterSeconds}s (job: ${result.jobId})`\n      )\n      return { ok: false as const, pending: result.jobId }\n    }\n\n    // TypeScript: impossible branch (exhaustive check)\n    const _exhaustive: never = result\n    return _exhaustive\n  })\n\n// Alternative: Use Schema.match for cleaner code\nconst createUserWithMatch = (name: string, email: string) =>\n  Effect.gen(function* () {\n    const response = yield* Effect.tryPromise(() =>\n      fetch(\"https://api.example.com/users\", {\n        method: \"POST\",\n        body: JSON.stringify({ name, email }),\n      }).then((r) => r.json())\n    )\n\n    const result = yield* parseResponse(response)\n\n    // More idiomatic Effect approach\n    return yield* Effect.cond(\n      () => result.status === \"success\",\n      () =>\n        Effect.succeed({\n          ok: true as const,\n          user: (result as typeof SuccessResponse.Type).data,\n        }),\n      () => {\n        if (result.status === \"error\") {\n          return Effect.fail(\n            new Error((result as typeof ErrorResponse.Type).message)\n          )\n        }\n\n        return Effect.succeed({\n          ok: false as const,\n          pending: (result as typeof PendingResponse.Type).jobId,\n        })\n      }\n    )\n  })\n\n// Handling discriminated unions with explicit discriminator\nconst PaymentResult = Schema.Union(\n  Schema.Struct({\n    type: Schema.Literal(\"approved\"),\n    transactionId: Schema.String,\n    amount: Schema.Number,\n  }),\n  Schema.Struct({\n    type: Schema.Literal(\"declined\"),\n    reason: Schema.String,\n  }),\n  Schema.Struct({\n    type: Schema.Literal(\"requires-auth\"),\n    authUrl: Schema.String,\n  })\n)\n\ntype PaymentResult = typeof PaymentResult.Type\n\nconst parsePayment = Schema.decodeUnknown(PaymentResult)\n\nconst processPayment = (amount: number) =>\n  Effect.gen(function* () {\n    const response = yield* Effect.tryPromise(() =>\n      fetch(\"https://api.example.com/pay\", {\n        method: \"POST\",\n        body: JSON.stringify({ amount }),\n      }).then((r) => r.json())\n    )\n\n    const result = yield* parsePayment(response)\n\n    // Discriminated union: type field guides the match\n    switch (result.type) {\n      case \"approved\":\n        yield* Effect.log(`Payment approved: ${result.transactionId}`)\n        return { success: true, transactionId: result.transactionId }\n\n      case \"declined\":\n        yield* Effect.log(`Payment declined: ${result.reason}`)\n        return { success: false, reason: result.reason }\n\n      case \"requires-auth\":\n        yield* Effect.log(`Redirect to: ${result.authUrl}`)\n        return { success: false, authRequired: true, url: result.authUrl }\n    }\n  })\n\n// Execute example\nconst main = Effect.gen(function* () {\n  const result = yield* createUser(\"Alice\", \"alice@example.com\")\n\n  if (result.ok) {\n    yield* Effect.log(`Welcome, ${result.user.name}!`)\n  } else {\n    yield* Effect.log(`Failed: ${result.error}`)\n  }\n})\n\nawait Effect.runPromise(main)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Handle Union/Discriminated Responses using Schema."
            },
            "created_at": "2026-02-16T21:39:05.271393",
            "updated_at": "2026-02-20T23:09:37.373638"
        },
        {
            "id": "8e07bae6-b0b6-4038-b8b4-9a1b76e8a35f",
            "slug": "schema-ai-output-enums-and-literals",
            "title": "Enums and Literal Types",
            "summary": "You need the LLM to pick from a specific set of values\u2014like priority levels, categories, or statuses. Without constraints, the LLM might output variations (\"high\", \"HIGH\", \"urgent\", \"priority:...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "ai",
                "enums",
                "literals",
                "constraints"
            ],
            "examples": [
                {
                    "code": "import { Schema, JSONSchema, Effect } from \"effect\"\nimport { Anthropic } from \"@anthropic-ai/sdk\"\n\n// 1. Define literal and enum types\nconst Priority = Schema.Literal(\"critical\", \"high\", \"medium\", \"low\").pipe(\n  Schema.description(\n    \"Task priority: critical (fix immediately), high (this sprint), \" +\n    \"medium (next sprint), low (backlog)\"\n  )\n)\n\nconst Status = Schema.Enum({\n  TODO: \"todo\",\n  IN_PROGRESS: \"in_progress\",\n  BLOCKED: \"blocked\",\n  DONE: \"done\",\n  CANCELLED: \"cancelled\",\n})\n\nconst Category = Schema.Union(\n  Schema.Literal(\"bug\"),\n  Schema.Literal(\"feature\"),\n  Schema.Literal(\"documentation\"),\n  Schema.Literal(\"refactor\"),\n  Schema.Literal(\"test\")\n).pipe(\n  Schema.description(\"Categorize the work type\")\n)\n\n// 2. Compose into task schema\nconst Task = Schema.Struct({\n  title: Schema.String,\n  description: Schema.String,\n  priority: Priority,\n  status: Status,\n  category: Category,\n  estimatedHours: Schema.Number.pipe(\n    Schema.int(),\n    Schema.between(1, 40),\n    Schema.description(\"Estimate in hours: 1-40 range\")\n  ),\n  labels: Schema.Array(Schema.String).pipe(\n    Schema.description(\n      \"Free-form labels. Can include any string\"\n    )\n  ),\n})\n\ntype Task = typeof Task.Type\n\n// 3. Generate JSON Schema (shows enum values)\nconst jsonSchema = JSONSchema.make(Task)\n// Schema shows: priority: { enum: [\"critical\", \"high\", \"medium\", \"low\"] }\n\n// 4. Use in LLM call\nconst extractTask = (userInput: string) =>\n  Effect.gen(function* () {\n    const client = new Anthropic()\n\n    const response = yield* Effect.tryPromise({\n      try: () =>\n        client.messages.create({\n          model: \"claude-3-5-sonnet-20241022\",\n          max_tokens: 1024,\n          messages: [\n            {\n              role: \"user\",\n              content: `Extract task details:\\n\\n${userInput}`,\n            },\n          ],\n          tools: [\n            {\n              name: \"extract_task\",\n              description: \"Extract task with category and priority\",\n              input_schema: jsonSchema as any,\n            },\n          ],\n        }),\n      catch: (error) => new Error(`API call failed: ${error}`),\n    })\n\n    const toolUse = response.content.find(\n      (block) => block.type === \"tool_use\"\n    ) as any\n\n    if (!toolUse) {\n      return yield* Effect.fail(new Error(\"No tool use in response\"))\n    }\n\n    // Validation enforces literal values\n    const task = yield* Effect.tryPromise({\n      try: () => Schema.decodeUnknownSync(Task)(toolUse.input),\n      catch: (error) => new Error(`Invalid task data: ${error}`),\n    })\n\n    return task\n  })\n\n// 5. Type-safe pattern matching on enum values\nconst getSeverityColor = (task: Task): string => {\n  switch (task.priority) {\n    case \"critical\":\n      return \"#FF0000\" // red\n    case \"high\":\n      return \"#FF8800\" // orange\n    case \"medium\":\n      return \"#FFFF00\" // yellow\n    case \"low\":\n      return \"#00FF00\" // green\n  }\n}\n\nconst getStatusEmoji = (task: Task): string => {\n  switch (task.status) {\n    case \"todo\":\n      return \"\ud83d\udccb\"\n    case \"in_progress\":\n      return \"\ud83d\ude80\"\n    case \"blocked\":\n      return \"\ud83d\udeab\"\n    case \"done\":\n      return \"\u2705\"\n    case \"cancelled\":\n      return \"\u274c\"\n  }\n}\n\n// Usage\nconst userInput =\n  \"We need to fix the critical login bug ASAP. \" +\n  \"It's preventing users from accessing the app. Estimate 3 hours.\"\n\nEffect.runPromise(extractTask(userInput))\n  .then((task) => {\n    console.log(`${getStatusEmoji(task)} ${task.title}`)\n    console.log(`Priority: ${task.priority}`)\n    console.log(`Category: ${task.category}`)\n    console.log(`Hours: ${task.estimatedHours}`)\n  })",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Enums and Literal Types using Schema."
            },
            "created_at": "2026-02-16T21:39:06.09521",
            "updated_at": "2026-02-20T23:09:37.592838"
        },
        {
            "id": "90d280e3-8470-409a-8f38-dfab8bd54297",
            "slug": "schema-ai-parsing-partial-responses",
            "title": "Parsing Partial/Incomplete Responses",
            "summary": "An LLM streaming response gets cut off mid-generation, or the user cancels before completion. You receive incomplete JSON with missing closing braces or truncated fields. Standard parsing fails. You...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "ai",
                "partial-data",
                "optional-fields",
                "streaming",
                "graceful-degradation"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema, Option } from \"effect\"\n\n// 1. Define schema with optional fields\nconst StreamedAnalysis = Schema.Struct({\n  title: Schema.String,\n  sections: Schema.Array(\n    Schema.Struct({\n      heading: Schema.String,\n      content: Schema.String,\n    })\n  ).pipe(Schema.optional),\n  conclusion: Schema.String.pipe(Schema.optional),\n  isComplete: Schema.Boolean.pipe(\n    Schema.optional,\n    Schema.withDefault(false)\n  ),\n})\n\ntype StreamedAnalysis = typeof StreamedAnalysis.Type\n\n// 2. Detect if response is truncated\nconst isLikelyTruncated = (json: string): boolean => {\n  const trimmed = json.trim()\n  // Missing closing braces, incomplete string, etc.\n  return (\n    !trimmed.endsWith(\"}\") ||\n    (trimmed.match(/{/g) || []).length >\n      (trimmed.match(/}/g) || []).length ||\n    trimmed.endsWith(',') ||\n    trimmed.endsWith('\"') ||\n    trimmed.includes('...')\n  )\n}\n\n// 3. Attempt repair of truncated JSON\nconst repairJSON = (json: string): string => {\n  let repaired = json.trim()\n\n  // Close unclosed objects\n  const openBraces =\n    (repaired.match(/{/g) || []).length -\n    (repaired.match(/}/g) || []).length\n  repaired += \"}\".repeat(Math.max(0, openBraces))\n\n  // Close unclosed arrays\n  const openBrackets =\n    (repaired.match(/\\[/g) || []).length -\n    (repaired.match(/\\]/g) || []).length\n  repaired += \"]\".repeat(Math.max(0, openBrackets))\n\n  // Handle trailing comma before close\n  repaired = repaired.replace(/,\\s*}/, \"}\")\n  repaired = repaired.replace(/,\\s*]/, \"]\")\n\n  return repaired\n}\n\n// 4. Parse with truncation awareness\nconst parseStreamed = (json: string) =>\n  Effect.gen(function* () {\n    const truncated = isLikelyTruncated(json)\n\n    // Try exact parse first\n    let data: unknown\n    try {\n      data = JSON.parse(json)\n    } catch {\n      if (truncated) {\n        // Attempt repair\n        const repaired = repairJSON(json)\n        try {\n          data = JSON.parse(repaired)\n        } catch (e) {\n          return yield* Effect.fail(\n            new Error(\n              `Cannot parse even after repair: ${e}`\n            )\n          )\n        }\n      } else {\n        return yield* Effect.fail(\n          new Error(`Invalid JSON: ${json}`)\n        )\n      }\n    }\n\n    // Validate against schema\n    const parsed = yield* Schema.decodeUnknown(\n      StreamedAnalysis\n    )(data).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ValidationError\" as const,\n        message: `Schema validation failed: ${error.message}`,\n        truncated,\n      }))\n    )\n\n    return {\n      ...parsed,\n      isComplete: !truncated && parsed.isComplete !== false,\n    }\n  })\n\n// 5. Handle streaming data\nconst handleStream = (chunks: AsyncIterable<string>) =>\n  Effect.tryPromise(async () => {\n    let accumulated = \"\"\n    const results: StreamedAnalysis[] = []\n\n    for await (const chunk of chunks) {\n      accumulated += chunk\n\n      // Try parse on each chunk\n      const attempt = await Effect.runPromise(\n        parseStreamed(accumulated).pipe(\n          Effect.option\n        )\n      )\n\n      if (Option.isSome(attempt)) {\n        console.log(\n          \"Got complete analysis at\",\n          accumulated.length,\n          \"bytes\"\n        )\n        results.push(attempt.value)\n        accumulated = \"\" // Reset for next response\n      }\n    }\n\n    // Handle final partial data if streaming ended\n    if (accumulated.length > 0) {\n      const final = await Effect.runPromise(\n        parseStreamed(accumulated).pipe(\n          Effect.orElse(() =>\n            Effect.succeed({\n              title: \"Incomplete\",\n              sections: undefined,\n              conclusion: undefined,\n              isComplete: false,\n            } as StreamedAnalysis)\n          )\n        )\n      )\n\n      results.push(final)\n    }\n\n    return results\n  })\n\n// 6. Usage example\nconst exampleStreamData = [\n  '{\"title\": \"Effect Guide\", \"sections\": [',\n  '{\"heading\": \"Basics\", \"content\": \"Effect is...\",},',\n  '{\"heading\": \"Advanced\", \"content\": \"Use layers...',\n  // Streaming cut off here\n]\n\n// Simulate incomplete JSON\nconst truncatedJSON = `{\n  \"title\": \"Incomplete Analysis\",\n  \"sections\": [\n    {\"heading\": \"Section 1\", \"content\": \"Text here\"},\n    {\"heading\": \"Section 2\", \"content\": \"More te`\n\nEffect.runPromise(parseStreamed(truncatedJSON))\n  .then((result) => {\n    console.log(\"Parsed despite truncation:\")\n    console.log(\n      `Title: ${result.title} (complete: ${result.isComplete})`\n    )\n    console.log(`Sections: ${result.sections?.length || 0}`)\n  })\n  .catch((error) => {\n    console.error(\"Failed to parse:\", error.message)\n  })",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Parse Partial/Incomplete Responses using Schema."
            },
            "created_at": "2026-02-16T21:39:07.258216",
            "updated_at": "2026-02-20T23:09:37.903064"
        },
        {
            "id": "8e390380-b893-4fb6-baf2-40320785b262",
            "slug": "schema-ai-parsing-streaming-validation",
            "title": "Validating Streaming AI Responses",
            "summary": "An LLM streams JSON responses back in chunks. You need to validate incrementally as data arrives\u2014catching schema violations early without waiting for the full response, updating UI in real-time, and...",
            "skill_level": "advanced",
            "category": "schema",
            "difficulty": "advanced",
            "tags": [
                "schema",
                "ai",
                "streaming",
                "validation",
                "real-time",
                "incremental"
            ],
            "examples": [
                {
                    "code": "import {\n  Effect,\n  Schema,\n  Stream,\n  Channel,\n} from \"effect\"\nimport { Anthropic } from \"@anthropic-ai/sdk\"\n\n// 1. Define the streamed data type\nconst StreamedThought = Schema.Struct({\n  id: Schema.String,\n  content: Schema.String,\n  completed: Schema.Boolean.pipe(Schema.withDefault(false)),\n})\n\ntype StreamedThought = typeof StreamedThought.Type\n\n// 2. JSON stream parser\nconst jsonStreamParser = (\n  chunks: AsyncIterable<string>\n): Stream.Stream<unknown> =>\n  Stream.fromAsyncIterable(chunks, (e) =>\n    new Error(String(e))\n  ).pipe(\n    Stream.fold(\n      { buffer: \"\", depth: 0, bracketStack: [] },\n      (state, chunk) => {\n        state.buffer += chunk\n\n        const results: unknown[] = []\n        let i = 0\n\n        while (i < state.buffer.length) {\n          const char = state.buffer[i]\n\n          if (char === \"{\") {\n            state.depth++\n            state.bracketStack.push(\"}\")\n          } else if (char === \"}\") {\n            state.depth--\n            state.bracketStack.pop()\n\n            if (state.depth === 0) {\n              // Found complete object\n              const jsonStr = state.buffer.substring(\n                0,\n                i + 1\n              )\n\n              try {\n                results.push(JSON.parse(jsonStr))\n              } catch (e) {\n                console.warn(\n                  `Malformed JSON at position ${i}: ${e}`\n                )\n              }\n\n              state.buffer = state.buffer.substring(\n                i + 1\n              )\n              i = -1 // Reset counter\n            }\n          }\n\n          i++\n        }\n\n        return {\n          state,\n          emitted: results,\n        }\n      },\n      (state) => {\n        // Handle any remaining data on stream end\n        if (\n          state.buffer.trim().length > 0 &&\n          state.depth === 0\n        ) {\n          try {\n            return [JSON.parse(state.buffer)]\n          } catch (e) {\n            console.warn(\n              `Final buffer not valid JSON: ${state.buffer}`\n            )\n            return []\n          }\n        }\n        return []\n      }\n    )\n  )\n\n// 3. Incremental validator\nconst validateStreamed = (object: unknown) =>\n  Effect.gen(function* () {\n    const decoder = Schema.decodeUnknown(StreamedThought)\n\n    const result = yield* decoder(object).pipe(\n      Effect.mapError((error) => ({\n        _tag: \"ValidationError\" as const,\n        message: `Invalid thought: ${error.message}`,\n        raw: object,\n      }))\n    )\n\n    return result\n  })\n\n// 4. Stream handler with live updates\nconst handleStreamedThoughts = (\n  chunks: AsyncIterable<string>,\n  onThought: (thought: StreamedThought) => void,\n  onError: (error: Error) => void\n) =>\n  Effect.gen(function* () {\n    const stream = jsonStreamParser(chunks)\n\n    yield* stream.pipe(\n      Stream.mapEffect((json) =>\n        validateStreamed(json).pipe(\n          Effect.tap((thought) =>\n            Effect.sync(() => onThought(thought))\n          ),\n          Effect.catchTag(\"ValidationError\", (error) =>\n            Effect.sync(() => {\n              console.warn(\n                `Validation warning: ${error.message}`\n              )\n              // Continue stream on validation error\n            })\n          )\n        )\n      ),\n      Stream.catchAll((error) =>\n        Effect.sync(() => onError(error))\n      ),\n      Stream.runDrain\n    )\n  })\n\n// 5. Streaming with chunked validation\nconst callLLMStreaming = (\n  prompt: string,\n  onChunk: (chunk: StreamedThought) => void\n) =>\n  Effect.gen(function* () {\n    const client = new Anthropic()\n\n    const stream = yield* Effect.tryPromise(() =>\n      client.messages.stream({\n        model: \"claude-3-5-sonnet-20241022\",\n        max_tokens: 2048,\n        messages: [\n          { role: \"user\", content: prompt },\n        ],\n      })\n    )\n\n    // Convert to async iterable of text chunks\n    const textStream = async function* () {\n      for await (const event of stream) {\n        if (\n          event.type === \"content_block_delta\" &&\n          event.delta.type === \"text_delta\"\n        ) {\n          yield event.delta.text\n        }\n      }\n    }\n\n    yield* handleStreamedThoughts(\n      textStream(),\n      onChunk,\n      (error) => {\n        console.error(\n          \"Stream error:\",\n          error.message\n        )\n      }\n    )\n  })\n\n// 6. Real-time UI updates (conceptual)\ninterface UIState {\n  thoughts: StreamedThought[]\n  isStreaming: boolean\n  errorCount: number\n}\n\nconst streamUI = (prompt: string) =>\n  Effect.gen(function* () {\n    const state: UIState = {\n      thoughts: [],\n      isStreaming: true,\n      errorCount: 0,\n    }\n\n    yield* callLLMStreaming(prompt, (thought) => {\n      // Update UI in real-time\n      state.thoughts.push(thought)\n      console.log(`[${thought.id}] ${thought.content}`)\n\n      if (thought.completed) {\n        console.log(\"\u2705 Thought complete\")\n      }\n    })\n\n    state.isStreaming = false\n    return state\n  })\n\n// 7. Usage\nconst examplePrompt =\n  'Think step-by-step about how Effect types work'\n\nEffect.runPromise(streamUI(examplePrompt))\n  .then((finalState) => {\n    console.log(\n      `Collected ${finalState.thoughts.length} thoughts`\n    )\n    console.log(\n      `Stream finished. Errors: ${finalState.errorCount}`\n    )\n  })\n  .catch((error) => {\n    console.error(\"Stream failed:\", error.message)\n  })",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Validate Streaming AI Responses using Schema."
            },
            "created_at": "2026-02-16T21:39:07.441579",
            "updated_at": "2026-02-20T23:09:37.975276"
        },
        {
            "id": "8738b919-97ba-41b5-b612-03182e7d4ee8",
            "slug": "schema-decode-encode",
            "title": "Decode and Encode Data",
            "summary": "You receive data as JSON and need to convert it to typed objects. Later, you need to serialize those objects back to JSON for storage or API responses. Without a consistent approach, you write...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "decode",
                "encode",
                "parsing",
                "serialization"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// Define schema once\u2014use for both decode and encode\nconst Product = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  price: Schema.Number,\n  inStock: Schema.Boolean,\n})\n\ntype Product = typeof Product.Type\n\n// Create decoder and encoder from same schema\nconst decode = Schema.decodeUnknownSync(Product)\nconst encode = Schema.encodeSync(Product)\n\n// DECODE: unknown \u2192 typed Product\nconst rawJson = {\n  id: \"prod_123\",\n  name: \"Widget\",\n  price: 29.99,\n  inStock: true\n}\n\nconst product: Product = decode(rawJson)\nconsole.log(`Decoded: ${product.name} - $${product.price}`)\n// Output: Decoded: Widget - $29.99\n\n// Use the typed product in your code\nif (product.inStock) {\n  console.log(\"\u2705 Available for purchase\")\n}\n\n// ENCODE: typed Product \u2192 unknown (for JSON serialization)\nconst jsonOutput = encode(product)\nconsole.log(`Encoded: ${JSON.stringify(jsonOutput)}`)\n// Output: Encoded: {\"id\":\"prod_123\",\"name\":\"Widget\",\"price\":29.99,\"inStock\":true}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Decode and Encode Data using Schema."
            },
            "created_at": "2026-02-16T21:39:08.457247",
            "updated_at": "2026-02-20T23:09:38.244629"
        },
        {
            "id": "92706d8c-dc02-4d77-b451-d3ac5e46e03e",
            "slug": "schema-handling-errors",
            "title": "Handling Parse Errors",
            "summary": "When validation fails, you need to know what went wrong. The default parse error is detailed but hard to read. You need to extract useful error messages for logging, displaying to users, or debugging.",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "errors",
                "validation",
                "error-handling"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect, ParseResult } from \"effect\"\n\nconst User = Schema.Struct({\n  name: Schema.String,\n  age: Schema.Number,\n  email: Schema.String,\n})\n\n// Three ways to handle parse errors:\n\n// 1. SYNC WITH TRY/CATCH\nconst decodeSync = Schema.decodeUnknownSync(User)\n\nfunction parseUserSync(data: unknown) {\n  try {\n    return decodeSync(data)\n  } catch (error) {\n    if (ParseResult.isParseError(error)) {\n      console.log(\"Parse error:\", ParseResult.TreeFormatter.formatErrorSync(error))\n    }\n    throw error\n  }\n}\n\n// 2. SYNC RETURNING EITHER (no exceptions)\nconst decodeEither = Schema.decodeUnknownEither(User)\n\nfunction parseUserSafe(data: unknown) {\n  const result = decodeEither(data)\n  \n  if (result._tag === \"Left\") {\n    const message = ParseResult.TreeFormatter.formatErrorSync(result.left)\n    return { success: false, error: message }\n  }\n  \n  return { success: true, user: result.right }\n}\n\n// 3. ASYNC WITH EFFECT (recommended)\nconst decodeEffect = Schema.decodeUnknown(User)\n\nconst parseUserEffect = (data: unknown) =>\n  decodeEffect(data).pipe(\n    Effect.mapError((error) => ({\n      _tag: \"ValidationError\" as const,\n      message: ParseResult.TreeFormatter.formatErrorSync(error),\n    }))\n  )\n\n// Demo all three approaches\nconsole.log(\"=== Sync with try/catch ===\")\ntry {\n  parseUserSync({ name: \"Alice\", age: \"thirty\", email: \"a@b.com\" })\n} catch {\n  // Error already logged\n}\n\nconsole.log(\"\\n=== Sync returning Either ===\")\nconst result = parseUserSafe({ name: 123, age: 30, email: \"a@b.com\" })\nif (!result.success) {\n  console.log(\"Validation failed:\", result.error)\n}\n\nconsole.log(\"\\n=== Async with Effect ===\")\nEffect.runPromise(\n  parseUserEffect({ name: \"Alice\", age: 30 }).pipe(  // Missing email\n    Effect.match({\n      onFailure: (err) => console.log(\"Failed:\", err.message),\n      onSuccess: (user) => console.log(\"Success:\", user.name),\n    })\n  )\n)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Handle Parse Errors using Schema."
            },
            "created_at": "2026-02-16T21:39:08.79185",
            "updated_at": "2026-02-20T23:09:38.337271"
        },
        {
            "id": "569f0b8c-f7da-48ea-b9ff-39cbb6067a69",
            "slug": "schema-string-validation",
            "title": "String Validation and Refinements",
            "summary": "Raw strings need constraints: minimum length for passwords, maximum length for tweets, email format, URL format. Without validation, invalid strings propagate through your system causing errors far...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "string",
                "validation",
                "refinements"
            ],
            "examples": [
                {
                    "code": "import { Schema } from \"effect\"\n\n// ============================================\n// BUILT-IN STRING REFINEMENTS\n// ============================================\n\n// Non-empty string\nconst NonEmpty = Schema.NonEmptyString\n// \u2705 \"hello\" \u2192 \"hello\"\n// \u274c \"\"      \u2192 ParseError\n\n// Trimmed (no leading/trailing whitespace)  \nconst Trimmed = Schema.Trimmed\n// \u2705 \"hello\"    \u2192 \"hello\"\n// \u274c \"  hello \" \u2192 ParseError\n\n// Min/max length\nconst Username = Schema.String.pipe(\n  Schema.minLength(3),\n  Schema.maxLength(20)\n)\n\n// Exact length\nconst ZipCode = Schema.String.pipe(Schema.length(5))\n\n// ============================================\n// PATTERN MATCHING (REGEX)\n// ============================================\n\nconst Email = Schema.String.pipe(\n  Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/, {\n    message: () => \"Invalid email format\"\n  })\n)\n\nconst PhoneUS = Schema.String.pipe(\n  Schema.pattern(/^\\d{3}-\\d{3}-\\d{4}$/, {\n    message: () => \"Phone must be XXX-XXX-XXXX\"\n  })\n)\n\nconst Slug = Schema.String.pipe(\n  Schema.pattern(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, {\n    message: () => \"Slug must be lowercase with hyphens\"\n  })\n)\n\n// ============================================\n// COMBINING REFINEMENTS\n// ============================================\n\nconst Password = Schema.String.pipe(\n  Schema.minLength(8, { message: () => \"Password must be at least 8 characters\" }),\n  Schema.maxLength(100),\n  Schema.pattern(/[A-Z]/, { message: () => \"Must contain uppercase letter\" }),\n  Schema.pattern(/[a-z]/, { message: () => \"Must contain lowercase letter\" }),\n  Schema.pattern(/[0-9]/, { message: () => \"Must contain a number\" })\n)\n\n// ============================================\n// USING IN STRUCTS\n// ============================================\n\nconst UserRegistration = Schema.Struct({\n  username: Username,\n  email: Email,\n  password: Password,\n  phone: Schema.optional(PhoneUS),\n})\n\n// Decode and validate\nconst decode = Schema.decodeUnknownSync(UserRegistration)\n\n// Valid input\nconst validUser = decode({\n  username: \"alice123\",\n  email: \"alice@example.com\",\n  password: \"SecurePass1\",\n})\nconsole.log(\"\u2705 Valid:\", validUser.username)\n\n// Invalid input - shows specific error\ntry {\n  decode({\n    username: \"ab\",  // Too short\n    email: \"not-an-email\",\n    password: \"weak\",\n  })\n} catch (error) {\n  console.log(\"\u274c Validation failed\")\n}",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "String Validation and Refinements using Schema."
            },
            "created_at": "2026-02-16T21:39:09.28849",
            "updated_at": "2026-02-20T23:09:38.472034"
        },
        {
            "id": "f42171fe-1c13-4da9-9b0c-df7a862a10fc",
            "slug": "schema-pick-omit",
            "title": "Pick and Omit - Selecting and Excluding Fields",
            "summary": "You have a comprehensive User schema with 15 fields. For the public profile API, you only need 5 fields. For the admin export, you need everything except passwords and tokens. Writing three separate...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "composition",
                "pick",
                "omit",
                "field-selection"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Comprehensive schema\n// ============================================\n\nconst User = Schema.Struct({\n  id: Schema.String,\n  username: Schema.String,\n  email: Schema.String,\n  password: Schema.String,\n  bio: Schema.Optional(Schema.String),\n  avatar: Schema.Optional(Schema.String),\n  role: Schema.String,\n  createdAt: Schema.Date,\n  updatedAt: Schema.Date,\n  lastLogin: Schema.Optional(Schema.Date),\n  emailVerified: Schema.Boolean,\n  phoneVerified: Schema.Boolean,\n  twoFactorSecret: Schema.Optional(Schema.String),\n  apiToken: Schema.Optional(Schema.String),\n  preferences: Schema.Struct({\n    theme: Schema.Enum({ light: \"light\", dark: \"dark\" }),\n    language: Schema.String,\n    notifications: Schema.Boolean,\n  }),\n})\n\ntype User = typeof User.Type\n\n// ============================================\n// 2. Pick - select specific fields\n// ============================================\n\n// Public profile - only certain fields\nconst PublicProfile = Schema.pick(User, [\"id\", \"username\", \"bio\", \"avatar\", \"createdAt\"])\n\ntype PublicProfile = typeof PublicProfile.Type\n\n// Admin view - most fields\nconst AdminView = Schema.pick(User, [\n  \"id\",\n  \"username\",\n  \"email\",\n  \"role\",\n  \"createdAt\",\n  \"updatedAt\",\n  \"emailVerified\",\n  \"phoneVerified\",\n  \"lastLogin\",\n])\n\ntype AdminView = typeof AdminView.Type\n\n// API key response\nconst ApiTokenResponse = Schema.pick(User, [\"id\", \"username\", \"apiToken\", \"createdAt\"])\n\ntype ApiTokenResponse = typeof ApiTokenResponse.Type\n\n// ============================================\n// 3. Omit - exclude specific fields\n// ============================================\n\n// Sanitized for export (remove sensitive data)\nconst UserForExport = Schema.omit(User, [\n  \"password\",\n  \"twoFactorSecret\",\n  \"apiToken\",\n])\n\ntype UserForExport = typeof UserForExport.Type\n\n// User update input (exclude immutable fields)\nconst UpdateUserInput = Schema.omit(User, [\n  \"id\",\n  \"createdAt\",\n  \"updatedAt\",\n  \"role\",\n])\n\ntype UpdateUserInput = typeof UpdateUserInput.Type\n\n// ============================================\n// 4. Combination patterns\n// ============================================\n\n// User with credentials for login\nconst UserCredentials = Schema.pick(User, [\"email\", \"password\"])\n\ntype UserCredentials = typeof UserCredentials.Type\n\n// Minimal info for list views\nconst UserListItem = Schema.pick(User, [\"id\", \"username\", \"role\", \"lastLogin\"])\n\ntype UserListItem = typeof UserListItem.Type\n\n// ============================================\n// 5. Processing picked/omitted schemas\n// ============================================\n\nconst sanitizeForPublic = (user: User): PublicProfile => ({\n  id: user.id,\n  username: user.username,\n  bio: user.bio,\n  avatar: user.avatar,\n  createdAt: user.createdAt,\n})\n\nconst sanitizeForExport = (user: User): UserForExport => {\n  const { password, twoFactorSecret, apiToken, ...rest } = user\n  return rest\n}\n\nconst parsePublicProfile = (raw: unknown): Effect.Effect<PublicProfile, Error> =>\n  Effect.tryPromise({\n    try: () => Schema.decodeUnknown(PublicProfile)(raw),\n    catch: (error) => new Error(String(error)),\n  })\n\n// ============================================\n// 6. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Pick and Omit Patterns ===\\n\")\n\n  // Full user with all sensitive data\n  const fullUser: User = {\n    id: \"user_123\",\n    username: \"alice\",\n    email: \"alice@example.com\",\n    password: \"$2b$10$...\",\n    bio: \"Developer and open source enthusiast\",\n    avatar: \"https://example.com/alice.png\",\n    role: \"user\",\n    createdAt: new Date(\"2025-01-01\"),\n    updatedAt: new Date(\"2025-12-17\"),\n    lastLogin: new Date(\"2025-12-16\"),\n    emailVerified: true,\n    phoneVerified: false,\n    twoFactorSecret: \"test_2fa_secret_xxxxx\",\n    apiToken: \"pk_test_xxxxxxxxxxxxxxxxxxxx\",\n    preferences: {\n      theme: \"dark\",\n      language: \"en\",\n      notifications: true,\n    },\n  }\n\n  console.log(\"1. Full User (all fields):\")\n  console.log(Object.keys(fullUser).join(\", \"))\n\n  console.log(\"\\n2. Public Profile (picked fields):\")\n  const publicProfile = sanitizeForPublic(fullUser)\n  console.log(Object.keys(publicProfile).join(\", \"))\n  console.log(`  - ${publicProfile.username}: ${publicProfile.bio}`)\n\n  console.log(\"\\n3. Admin View (picked fields):\")\n  const adminView = Schema.pick(User, [\n    \"id\",\n    \"username\",\n    \"email\",\n    \"role\",\n    \"emailVerified\",\n  ]) as unknown as typeof AdminView\n  const admin = (({ id, username, email, role, emailVerified }) => ({\n    id,\n    username,\n    email,\n    role,\n    emailVerified,\n  }))(fullUser as any)\n  console.log(Object.keys(admin).join(\", \"))\n\n  console.log(\"\\n4. User For Export (omitted fields):\")\n  const exported = sanitizeForExport(fullUser)\n  console.log(Object.keys(exported).join(\", \"))\n  console.log(`  \u2717 Removed: password, twoFactorSecret, apiToken`)\n\n  console.log(\"\\n5. List View (picked for tables):\")\n  const listItem: UserListItem = {\n    id: fullUser.id,\n    username: fullUser.username,\n    role: fullUser.role,\n    lastLogin: fullUser.lastLogin,\n  }\n  console.log(Object.keys(listItem).join(\", \"))\n\n  console.log(\"\\n6. API Response (minimal for clients):\")\n  const apiResponse: ApiTokenResponse = {\n    id: fullUser.id,\n    username: fullUser.username,\n    apiToken: fullUser.apiToken,\n    createdAt: fullUser.createdAt,\n  }\n  console.log(Object.keys(apiResponse).join(\", \"))\n\n  console.log(\"\\n7. Update Input (exclude immutable):\")\n  console.log(\"Allowed fields:\")\n  console.log([\n    \"username\",\n    \"email\",\n    \"bio\",\n    \"avatar\",\n    \"preferences\",\n  ].join(\", \"))\n  console.log(`  \u2717 Cannot update: id, createdAt, updatedAt, role`)\n\n  console.log(\"\\n8. Type Safety Example:\")\n  console.log(\"All derived schemas are fully typed at compile time\")\n  console.log(\"Missing fields \u2192 TypeScript error\")\n  console.log(\"Extra fields \u2192 TypeScript error\")\n\n  return { fullUser, publicProfile, exported }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Pick/Omit patterns complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Pick and Omit - Selecting and Excluding Fields using Schema."
            },
            "created_at": "2026-02-16T21:39:09.821809",
            "updated_at": "2026-02-20T23:09:38.629781"
        },
        {
            "id": "c1b24786-f532-42e0-ab54-322704cdc2fb",
            "slug": "schema-inheritance-patterns",
            "title": "Schema Inheritance and Specialization",
            "summary": "Your domain has a base entity (Product) with common fields and many specializations (PhysicalProduct, DigitalProduct, ServiceProduct). Each has unique fields. You need a type hierarchy where...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "composition",
                "inheritance",
                "specialization",
                "polymorphism"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Base schema\n// ============================================\n\nconst BaseProduct = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  description: Schema.String,\n  price: Schema.Number,\n  currency: Schema.Enum({ usd: \"USD\", eur: \"EUR\", gbp: \"GBP\" }),\n  createdAt: Schema.Date,\n  tags: Schema.Array(Schema.String),\n})\n\ntype BaseProduct = typeof BaseProduct.Type\n\n// ============================================\n// 2. Specializations with inheritance\n// ============================================\n\nconst PhysicalProduct = Schema.extend(\n  BaseProduct,\n  Schema.Struct({\n    type: Schema.Literal(\"physical\"),\n    weight: Schema.Number,\n    dimensions: Schema.Struct({\n      length: Schema.Number,\n      width: Schema.Number,\n      height: Schema.Number,\n    }),\n    warehouse: Schema.String,\n    stock: Schema.Number,\n  })\n)\n\ntype PhysicalProduct = typeof PhysicalProduct.Type\n\nconst DigitalProduct = Schema.extend(\n  BaseProduct,\n  Schema.Struct({\n    type: Schema.Literal(\"digital\"),\n    downloadUrl: Schema.String,\n    fileSize: Schema.Number,\n    licenseType: Schema.Enum({\n      single: \"single\",\n      site: \"site\",\n      enterprise: \"enterprise\",\n    }),\n    deliveryMethod: Schema.Enum({\n      email: \"email\",\n      download: \"download\",\n      cloud: \"cloud\",\n    }),\n  })\n)\n\ntype DigitalProduct = typeof DigitalProduct.Type\n\nconst ServiceProduct = Schema.extend(\n  BaseProduct,\n  Schema.Struct({\n    type: Schema.Literal(\"service\"),\n    duration: Schema.Number, // in minutes\n    serviceCategory: Schema.String,\n    includesSupport: Schema.Boolean,\n    maxParticipants: Schema.Optional(Schema.Number),\n  })\n)\n\ntype ServiceProduct = typeof ServiceProduct.Type\n\n// ============================================\n// 3. Union of specializations\n// ============================================\n\nconst Product = Schema.Union(PhysicalProduct, DigitalProduct, ServiceProduct)\n\ntype Product = typeof Product.Type\n\n// ============================================\n// 4. Utility functions\n// ============================================\n\nconst getProductDescription = (product: Product): string => {\n  const base = `${product.name} - $${product.price}${product.currency}`\n\n  switch (product.type) {\n    case \"physical\":\n      return `${base} (Physical: ${product.weight}kg, Stock: ${product.stock})`\n\n    case \"digital\":\n      return `${base} (Digital: ${product.fileSize}MB, ${product.licenseType})`\n\n    case \"service\":\n      return `${base} (Service: ${product.duration}min, Support: ${product.includesSupport ? \"Yes\" : \"No\"})`\n  }\n}\n\nconst calculateTax = (product: Product, taxRate: number): number => {\n  // Different tax rules for different product types\n  switch (product.type) {\n    case \"physical\":\n      return product.price * taxRate\n\n    case \"digital\":\n      // Digital products may have different tax\n      return product.price * (taxRate * 0.5)\n\n    case \"service\":\n      // Services might be tax-exempt in some regions\n      return product.price * (taxRate * 0.7)\n  }\n}\n\nconst validateInventory = (product: Product): boolean => {\n  // Only physical products need inventory checks\n  if (product.type === \"physical\") {\n    return product.stock > 0\n  }\n  // Digital and services always available\n  return true\n}\n\n// ============================================\n// 5. Processing specializations\n// ============================================\n\nconst parseProduct = (raw: unknown): Effect.Effect<Product, Error> =>\n  Effect.tryPromise({\n    try: () => Schema.decodeUnknown(Product)(raw),\n    catch: (error) => new Error(String(error)),\n  })\n\nconst processProductEffect = (product: Product): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    yield* Effect.log(`Product: ${getProductDescription(product)}`)\n\n    const tax = calculateTax(product, 0.1)\n    yield* Effect.log(`Tax (10%): $${tax.toFixed(2)}`)\n\n    const inStock = validateInventory(product)\n    yield* Effect.log(`Available: ${inStock ? \"Yes\" : \"No\"}`)\n\n    switch (product.type) {\n      case \"physical\":\n        yield* Effect.log(`Warehouse: ${product.warehouse}`)\n        break\n\n      case \"digital\":\n        yield* Effect.log(\n          `License: ${product.licenseType}, Delivery: ${product.deliveryMethod}`\n        )\n        break\n\n      case \"service\":\n        yield* Effect.log(`Duration: ${product.duration} minutes`)\n        break\n    }\n  })\n\n// ============================================\n// 6. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Schema Inheritance ===\\n\")\n\n  const products: Product[] = [\n    {\n      id: \"prod_1\",\n      type: \"physical\",\n      name: \"Laptop Stand\",\n      description: \"Ergonomic aluminum laptop stand\",\n      price: 49.99,\n      currency: \"USD\",\n      createdAt: new Date(\"2025-01-01\"),\n      tags: [\"office\", \"electronics\"],\n      weight: 0.5,\n      dimensions: { length: 30, width: 25, height: 10 },\n      warehouse: \"US-East\",\n      stock: 150,\n    },\n    {\n      id: \"prod_2\",\n      type: \"digital\",\n      name: \"Effect-TS eBook\",\n      description: \"Comprehensive guide to Effect-TS\",\n      price: 29.99,\n      currency: \"USD\",\n      createdAt: new Date(\"2025-02-01\"),\n      tags: [\"ebook\", \"programming\"],\n      downloadUrl: \"https://example.com/effect-ebook.pdf\",\n      fileSize: 15,\n      licenseType: \"single\",\n      deliveryMethod: \"email\",\n    },\n    {\n      id: \"prod_3\",\n      type: \"service\",\n      name: \"Consulting Session\",\n      description: \"1-on-1 Effect-TS consulting\",\n      price: 199.99,\n      currency: \"USD\",\n      createdAt: new Date(\"2025-03-01\"),\n      tags: [\"consulting\", \"training\"],\n      duration: 60,\n      serviceCategory: \"consulting\",\n      includesSupport: true,\n      maxParticipants: 1,\n    },\n  ]\n\n  console.log(\"Processing product specializations:\\n\")\n\n  for (const product of products) {\n    yield* processProductEffect(product)\n    yield* Effect.log(\"\")\n  }\n\n  console.log(\"=== Summary ===\\n\")\n  console.log(\"Base fields shared by all specializations:\")\n  console.log([\n    \"id\",\n    \"name\",\n    \"description\",\n    \"price\",\n    \"currency\",\n    \"createdAt\",\n    \"tags\",\n  ].join(\", \"))\n\n  console.log(\"\\nSpecialization-specific fields:\")\n  console.log(\"Physical: weight, dimensions, warehouse, stock\")\n  console.log(\"Digital: downloadUrl, fileSize, licenseType, deliveryMethod\")\n  console.log(\"Service: duration, serviceCategory, includesSupport, maxParticipants\")\n\n  return products\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\u2705 Inheritance patterns complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Schema Inheritance and Specialization."
            },
            "created_at": "2026-02-16T21:39:10.174805",
            "updated_at": "2026-02-20T23:09:38.720341"
        },
        {
            "id": "bc5fbf74-8ff2-40ec-a414-f1e60cbc7495",
            "slug": "schema-basic-recursive",
            "title": "Basic Recursive Schemas with Schema.suspend",
            "summary": "You need to validate tree-like data: a node with children that are also nodes. Or linked lists where each item points to the next. Without recursion support, you can't express these structures\u2014the...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "recursive",
                "self-referencing",
                "trees",
                "linked-lists"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Basic recursive structure: LinkedList\n// ============================================\n\n// Forward declare the schema (will be defined below)\nconst LinkedListNode: Schema.Schema<LinkedListNode> = Schema.suspend(() =>\n  Schema.Union(\n    // Base case: End of list\n    Schema.Struct({\n      type: Schema.Literal(\"empty\"),\n    }),\n    // Recursive case: Node with value and next\n    Schema.Struct({\n      type: Schema.Literal(\"node\"),\n      value: Schema.Number,\n      next: LinkedListNode,\n    })\n  )\n)\n\ntype LinkedListNode = {\n  type: \"empty\"\n} | {\n  type: \"node\"\n  value: number\n  next: LinkedListNode\n}\n\n// ============================================\n// 2. Tree structure\n// ============================================\n\nconst TreeNode: Schema.Schema<TreeNode> = Schema.suspend(() =>\n  Schema.Struct({\n    id: Schema.String,\n    value: Schema.Number,\n    children: Schema.Array(TreeNode),\n  })\n)\n\ntype TreeNode = {\n  id: string\n  value: number\n  children: TreeNode[]\n}\n\n// ============================================\n// 3. Nested menu structure\n// ============================================\n\nconst MenuItem: Schema.Schema<MenuItem> = Schema.suspend(() =>\n  Schema.Struct({\n    label: Schema.String,\n    action: Schema.Optional(Schema.String),\n    submenu: Schema.Optional(Schema.Array(MenuItem)),\n  })\n)\n\ntype MenuItem = {\n  label: string\n  action?: string\n  submenu?: MenuItem[]\n}\n\n// ============================================\n// 4. Parse and validate recursive structures\n// ============================================\n\nconst parseLinkedList = (raw: unknown): Effect.Effect<LinkedListNode, Error> =>\n  Effect.tryPromise({\n    try: () => Schema.decodeUnknown(LinkedListNode)(raw),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Invalid linked list: ${msg}`)\n    },\n  })\n\nconst parseTree = (raw: unknown): Effect.Effect<TreeNode, Error> =>\n  Effect.tryPromise({\n    try: () => Schema.decodeUnknown(TreeNode)(raw),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Invalid tree: ${msg}`)\n    },\n  })\n\nconst parseMenu = (raw: unknown): Effect.Effect<MenuItem, Error> =>\n  Effect.tryPromise({\n    try: () => Schema.decodeUnknown(MenuItem)(raw),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Invalid menu: ${msg}`)\n    },\n  })\n\n// ============================================\n// 5. Utilities for recursive structures\n// ============================================\n\nconst listToArray = (list: LinkedListNode): number[] => {\n  if (list.type === \"empty\") {\n    return []\n  }\n  return [list.value, ...listToArray(list.next)]\n}\n\nconst treeDepth = (node: TreeNode): number => {\n  if (node.children.length === 0) {\n    return 1\n  }\n  return 1 + Math.max(...node.children.map(treeDepth))\n}\n\nconst countNodes = (node: TreeNode): number => {\n  return 1 + node.children.reduce((sum, child) => sum + countNodes(child), 0)\n}\n\nconst flattenTree = (node: TreeNode): TreeNode[] => {\n  return [node, ...node.children.flatMap(flattenTree)]\n}\n\n// ============================================\n// 6. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Linked List ===\\n\")\n\n  // Valid linked list: 1 -> 2 -> 3 -> empty\n  const listData = {\n    type: \"node\",\n    value: 1,\n    next: {\n      type: \"node\",\n      value: 2,\n      next: {\n        type: \"node\",\n        value: 3,\n        next: { type: \"empty\" },\n      },\n    },\n  }\n\n  const list = yield* parseLinkedList(listData)\n  const array = listToArray(list)\n  console.log(`List: ${array.join(\" -> \")}`)\n\n  console.log(\"\\n=== Tree Structure ===\\n\")\n\n  const treeData = {\n    id: \"root\",\n    value: 1,\n    children: [\n      {\n        id: \"child1\",\n        value: 2,\n        children: [\n          {\n            id: \"grandchild1\",\n            value: 4,\n            children: [],\n          },\n        ],\n      },\n      {\n        id: \"child2\",\n        value: 3,\n        children: [\n          {\n            id: \"grandchild2\",\n            value: 5,\n            children: [],\n          },\n          {\n            id: \"grandchild3\",\n            value: 6,\n            children: [],\n          },\n        ],\n      },\n    ],\n  }\n\n  const tree = yield* parseTree(treeData)\n  console.log(`Tree structure:`)\n  console.log(`  Total nodes: ${countNodes(tree)}`)\n  console.log(`  Tree depth: ${treeDepth(tree)}`)\n  console.log(`  Flattened: ${flattenTree(tree).map((n) => n.id).join(\", \")}`)\n\n  console.log(\"\\n=== Menu ===\\n\")\n\n  const menuData = {\n    label: \"File\",\n    action: \"file-menu\",\n    submenu: [\n      { label: \"New\", action: \"new-file\" },\n      { label: \"Open\", action: \"open-file\" },\n      {\n        label: \"Recent\",\n        submenu: [\n          { label: \"document1.txt\", action: \"open-recent-1\" },\n          { label: \"document2.txt\", action: \"open-recent-2\" },\n        ],\n      },\n      { label: \"Exit\", action: \"exit\" },\n    ],\n  }\n\n  const menu = yield* parseMenu(menuData)\n  console.log(`Menu: ${menu.label}`)\n  if (menu.submenu) {\n    for (const item of menu.submenu) {\n      console.log(`  - ${item.label}${item.action ? ` (${item.action})` : \"\"}`)\n      if (item.submenu) {\n        for (const subitem of item.submenu) {\n          console.log(\n            `    - ${subitem.label}${subitem.action ? ` (${subitem.action})` : \"\"}`\n          )\n        }\n      }\n    }\n  }\n\n  return { list, tree, menu }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Recursive parsing complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Basic Recursive Schemas with Schema.suspend."
            },
            "created_at": "2026-02-16T21:39:11.010802",
            "updated_at": "2026-02-20T23:09:38.944188"
        },
        {
            "id": "a1ac60d4-e3ae-4819-9025-3e8246616821",
            "slug": "schema-form-basic",
            "title": "Basic Form Validation",
            "summary": "You have a form with multiple fields\u2014name, email, age. Validation is scattered everywhere: inline JavaScript, backend checks, error messages don't match. You need a single source of truth for form...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "form",
                "validation",
                "user-input",
                "web-forms"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// 1. Define form schema\nconst SignUpForm = Schema.Struct({\n  username: Schema.String.pipe(\n    Schema.trimmed(),\n    Schema.minLength(3),\n    Schema.maxLength(20),\n    Schema.pattern(/^[a-zA-Z0-9_-]+$/)\n  ),\n  email: Schema.String.pipe(\n    Schema.trimmed(),\n    Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)\n  ),\n  age: Schema.Number.pipe(\n    Schema.int(),\n    Schema.between(13, 120)\n  ),\n  password: Schema.String.pipe(\n    Schema.minLength(8)\n  ),\n})\n\ntype SignUpForm = typeof SignUpForm.Type\n\n// 2. Create validator\nconst validateForm = Schema.decodeUnknown(SignUpForm)\n\n// 3. Format errors for UI\nconst getErrorMessage = (error: any): string => {\n  const msg = error.message || String(error)\n\n  // Map validation error messages to user-friendly text\n  if (msg.includes(\"minLength\")) {\n    return \"Field is too short\"\n  }\n  if (msg.includes(\"maxLength\")) {\n    return \"Field is too long\"\n  }\n  if (msg.includes(\"pattern\")) {\n    return \"Invalid format\"\n  }\n  if (msg.includes(\"between\")) {\n    return \"Value out of range\"\n  }\n\n  return msg\n}\n\n// 4. Submit handler\nconst submitForm = (formData: unknown) =>\n  Effect.gen(function* () {\n    const validated = yield* Effect.tryPromise({\n      try: () => validateForm(formData),\n      catch: (error) => ({\n        _tag: \"ValidationError\" as const,\n        message: getErrorMessage(error),\n        raw: error,\n      }),\n    })\n\n    console.log(\n      `\u2705 Form valid: ${validated.username} (${validated.email})`\n    )\n    return validated\n  })\n\n// Usage\nconst formData = {\n  username: \"alice_123\",\n  email: \"alice@example.com\",\n  age: 25,\n  password: \"securepass123\",\n}\n\nEffect.runPromise(submitForm(formData))\n  .then((form) => {\n    console.log(`Welcome ${form.username}!`)\n  })\n  .catch((error) => {\n    console.error(`Form error: ${error.message}`)\n  })",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Basic Form Validation using Schema."
            },
            "created_at": "2026-02-16T21:39:12.589986",
            "updated_at": "2026-02-20T23:09:39.326495"
        },
        {
            "id": "d2e40e7f-3abb-43ee-9683-c0716d2c638c",
            "slug": "schema-bidirectional-transforms",
            "title": "Bidirectional API \u2194 Domain \u2194 DB Transformations",
            "summary": "Your application lives in three worlds: API contracts (what clients expect), domain models (your business logic), and database schemas (how data persists). Each world has different requirements. The...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "bidirectional",
                "transformation",
                "api",
                "database",
                "domain-modeling",
                "encode-decode"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Domain Layer (source of truth)\n// ============================================\n\ntype DomainUser = {\n  userId: string\n  email: string\n  fullName: string\n  createdAt: Date\n  updatedAt: Date\n  isActive: boolean\n}\n\n// ============================================\n// 2. API Contract (client-facing)\n// ============================================\n\ntype ApiUserRequest = {\n  email: string\n  full_name: string\n}\n\ntype ApiUserResponse = {\n  user_id: string\n  email: string\n  full_name: string\n  created_at: number // milliseconds\n  updated_at: number // milliseconds\n  is_active: boolean\n}\n\n// ============================================\n// 3. Database Schema (persistence layer)\n// ============================================\n\ntype DbUserRow = {\n  user_id: string\n  email: string\n  full_name: string\n  created_at: string // ISO 8601\n  updated_at: string // ISO 8601\n  is_active: boolean\n}\n\n// ============================================\n// 4. Define transformations: API \u2192 Domain\n// ============================================\n\nconst ApiUserResponseSchema = Schema.Struct({\n  user_id: Schema.String,\n  email: Schema.String.pipe(\n    Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)\n  ),\n  full_name: Schema.String,\n  created_at: Schema.transform(Schema.Number, Schema.Date, {\n    decode: (ms) => new Date(ms),\n    encode: (date) => date.getTime(),\n  }),\n  updated_at: Schema.transform(Schema.Number, Schema.Date, {\n    decode: (ms) => new Date(ms),\n    encode: (date) => date.getTime(),\n  }),\n  is_active: Schema.Boolean,\n}).pipe(\n  Schema.transform(\n    Schema.Struct({\n      user_id: Schema.String,\n      email: Schema.String,\n      full_name: Schema.String,\n      created_at: Schema.Date,\n      updated_at: Schema.Date,\n      is_active: Schema.Boolean,\n    }),\n    Schema.Struct({\n      userId: Schema.String,\n      email: Schema.String,\n      fullName: Schema.String,\n      createdAt: Schema.Date,\n      updatedAt: Schema.Date,\n      isActive: Schema.Boolean,\n    }),\n    {\n      decode: (api) => ({\n        userId: api.user_id,\n        email: api.email,\n        fullName: api.full_name,\n        createdAt: api.created_at,\n        updatedAt: api.updated_at,\n        isActive: api.is_active,\n      }),\n      encode: (domain) => ({\n        user_id: domain.userId,\n        email: domain.email,\n        full_name: domain.fullName,\n        created_at: domain.createdAt,\n        updated_at: domain.updatedAt,\n        is_active: domain.isActive,\n      }),\n    }\n  )\n)\n\n// ============================================\n// 5. Define transformations: DB \u2192 Domain\n// ============================================\n\nconst DbUserRowSchema = Schema.Struct({\n  user_id: Schema.String,\n  email: Schema.String,\n  full_name: Schema.String,\n  created_at: Schema.transform(Schema.String, Schema.Date, {\n    decode: (isoString) => new Date(isoString),\n    encode: (date) => date.toISOString(),\n  }),\n  updated_at: Schema.transform(Schema.String, Schema.Date, {\n    decode: (isoString) => new Date(isoString),\n    encode: (date) => date.toISOString(),\n  }),\n  is_active: Schema.Boolean,\n}).pipe(\n  Schema.transform(\n    Schema.Struct({\n      user_id: Schema.String,\n      email: Schema.String,\n      full_name: Schema.String,\n      created_at: Schema.Date,\n      updated_at: Schema.Date,\n      is_active: Schema.Boolean,\n    }),\n    Schema.Struct({\n      userId: Schema.String,\n      email: Schema.String,\n      fullName: Schema.String,\n      createdAt: Schema.Date,\n      updatedAt: Schema.Date,\n      isActive: Schema.Boolean,\n    }),\n    {\n      decode: (db) => ({\n        userId: db.user_id,\n        email: db.email,\n        fullName: db.full_name,\n        createdAt: db.created_at,\n        updatedAt: db.updated_at,\n        isActive: db.is_active,\n      }),\n      encode: (domain) => ({\n        user_id: domain.userId,\n        email: domain.email,\n        full_name: domain.fullName,\n        created_at: domain.createdAt,\n        updated_at: domain.updatedAt,\n        is_active: domain.isActive,\n      }),\n    }\n  )\n)\n\n// ============================================\n// 6. Create repositories with transformations\n// ============================================\n\nclass UserRepository {\n  // Decode: DB row \u2192 Domain model\n  async findById(id: string): Promise<DomainUser | null> {\n    // Simulate database query\n    const dbRow: DbUserRow = {\n      user_id: \"user_123\",\n      email: \"alice@example.com\",\n      full_name: \"Alice Smith\",\n      created_at: \"2024-01-15T10:30:00Z\",\n      updated_at: \"2024-12-17T14:22:00Z\",\n      is_active: true,\n    }\n\n    const decoded = await Schema.decodeUnknown(DbUserRowSchema)(dbRow)\n    return decoded\n  }\n\n  // Encode: Domain model \u2192 DB row\n  async save(user: DomainUser): Promise<void> {\n    const dbRow = await Schema.encode(DbUserRowSchema)(user)\n    console.log(\"\ud83d\udce6 Saving to database:\", dbRow)\n  }\n}\n\n// ============================================\n// 7. Create API handlers with transformations\n// ============================================\n\nclass UserApiHandler {\n  private repo = new UserRepository()\n\n  // Receive API response \u2192 Domain \u2192 Store\n  async handleIncomingUser(apiData: unknown): Promise<DomainUser> {\n    const domainUser = await Schema.decodeUnknown(ApiUserResponseSchema)(apiData)\n    await this.repo.save(domainUser)\n    return domainUser\n  }\n\n  // Retrieve Domain \u2192 API response\n  async getUserById(id: string): Promise<ApiUserResponse> {\n    const domainUser = await this.repo.findById(id)\n\n    if (!domainUser) {\n      throw new Error(\"User not found\")\n    }\n\n    const apiResponse = await Schema.encode(ApiUserResponseSchema)(domainUser)\n    return apiResponse\n  }\n}\n\n// ============================================\n// 8. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  const handler = new UserApiHandler()\n\n  // Simulate incoming API response from external service\n  const incomingApiData: ApiUserResponse = {\n    user_id: \"user_123\",\n    email: \"alice@example.com\",\n    full_name: \"Alice Smith\",\n    created_at: 1705317000000, // milliseconds\n    updated_at: 1734443520000, // milliseconds\n    is_active: true,\n  }\n\n  console.log(\"\ud83d\udce5 Incoming API data:\", incomingApiData)\n\n  // Decode: API \u2192 Domain \u2192 Save to DB\n  const domainUser = yield* Effect.tryPromise({\n    try: () => handler.handleIncomingUser(incomingApiData),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Failed to process user: ${msg}`)\n    },\n  })\n\n  console.log(\"\\n\u2705 Domain model:\", {\n    userId: domainUser.userId,\n    email: domainUser.email,\n    fullName: domainUser.fullName,\n    createdAt: domainUser.createdAt.toISOString(),\n    updatedAt: domainUser.updatedAt.toISOString(),\n  })\n\n  // Encode: Domain \u2192 API response for client\n  const apiResponse = yield* Effect.tryPromise({\n    try: () => handler.getUserById(\"user_123\"),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Failed to retrieve user: ${msg}`)\n    },\n  })\n\n  console.log(\"\\n\ud83d\udce4 Outgoing API response:\", apiResponse)\n\n  return { domainUser, apiResponse }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Transformation complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Bidirectional API \u2194 Domain \u2194 DB Transformations using Schema."
            },
            "created_at": "2026-02-16T21:39:13.447245",
            "updated_at": "2026-02-20T23:09:39.559412"
        },
        {
            "id": "19407a3e-0109-4832-bd05-4ecf16751106",
            "slug": "error-handling-aggregation",
            "title": "Error Aggregation and Collection",
            "summary": "Form has 10 fields. User makes mistakes in 5 of them. Current approach: show first error, user fixes it, resubmit, find next error, repeat 5 times. Bad UX. You need to collect all validation errors...",
            "skill_level": "intermediate",
            "category": "schema",
            "difficulty": "intermediate",
            "tags": [
                "error-handling",
                "validation",
                "error-aggregation",
                "batch-validation",
                "error-collection"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect, Data } from \"effect\"\n\n// ============================================\n// 1. Define validation error collection\n// ============================================\n\nclass FieldError extends Data.TaggedError(\"FieldError\") {\n  constructor(readonly field: string, readonly message: string) {\n    super()\n  }\n}\n\ntype ValidationErrors = FieldError[]\n\n// ============================================\n// 2. Define form schema\n// ============================================\n\nconst SignUpForm = Schema.Struct({\n  username: Schema.String.pipe(\n    Schema.minLength(3),\n    Schema.maxLength(20),\n    Schema.pattern(/^[a-zA-Z0-9_-]+$/)\n  ),\n  email: Schema.String.pipe(\n    Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)\n  ),\n  password: Schema.String.pipe(\n    Schema.minLength(8)\n  ),\n  confirmPassword: Schema.String,\n  age: Schema.Number.pipe(\n    Schema.int(),\n    Schema.between(13, 120)\n  ),\n})\n\ntype SignUpForm = typeof SignUpForm.Type\n\n// ============================================\n// 3. Individual field validators\n// ============================================\n\nconst validateUsername = (value: string): Effect.Effect<string, FieldError> =>\n  Effect.gen(function* () {\n    if (!value || value.length < 3) {\n      return yield* Effect.fail(\n        new FieldError(\"username\", \"Must be at least 3 characters\")\n      )\n    }\n    if (value.length > 20) {\n      return yield* Effect.fail(\n        new FieldError(\"username\", \"Must be at most 20 characters\")\n      )\n    }\n    if (!/^[a-zA-Z0-9_-]+$/.test(value)) {\n      return yield* Effect.fail(\n        new FieldError(\"username\", \"Only letters, numbers, hyphens, underscores allowed\")\n      )\n    }\n    return value\n  })\n\nconst validateEmail = (value: string): Effect.Effect<string, FieldError> =>\n  Effect.gen(function* () {\n    if (!value) {\n      return yield* Effect.fail(new FieldError(\"email\", \"Email required\"))\n    }\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)) {\n      return yield* Effect.fail(new FieldError(\"email\", \"Invalid email format\"))\n    }\n    return value\n  })\n\nconst validatePassword = (value: string): Effect.Effect<string, FieldError> =>\n  Effect.gen(function* () {\n    if (!value || value.length < 8) {\n      return yield* Effect.fail(\n        new FieldError(\"password\", \"Password must be at least 8 characters\")\n      )\n    }\n    if (!/[A-Z]/.test(value)) {\n      return yield* Effect.fail(\n        new FieldError(\"password\", \"Must contain uppercase letter\")\n      )\n    }\n    if (!/[0-9]/.test(value)) {\n      return yield* Effect.fail(\n        new FieldError(\"password\", \"Must contain number\")\n      )\n    }\n    return value\n  })\n\nconst validatePasswordMatch = (\n  password: string,\n  confirmPassword: string\n): Effect.Effect<void, FieldError> =>\n  Effect.gen(function* () {\n    if (password !== confirmPassword) {\n      return yield* Effect.fail(\n        new FieldError(\"confirmPassword\", \"Passwords do not match\")\n      )\n    }\n  })\n\nconst validateAge = (value: number): Effect.Effect<number, FieldError> =>\n  Effect.gen(function* () {\n    if (!Number.isInteger(value)) {\n      return yield* Effect.fail(new FieldError(\"age\", \"Age must be a whole number\"))\n    }\n    if (value < 13) {\n      return yield* Effect.fail(\n        new FieldError(\"age\", \"Must be at least 13 years old\")\n      )\n    }\n    if (value > 120) {\n      return yield* Effect.fail(\n        new FieldError(\"age\", \"Age must be realistic\")\n      )\n    }\n    return value\n  })\n\n// ============================================\n// 4. Aggregate all errors\n// ============================================\n\nconst validateFormErrors = (\n  data: unknown\n): Effect.Effect<SignUpForm, ValidationErrors> =>\n  Effect.gen(function* () {\n    const errors: FieldError[] = []\n\n    // Parse input\n    let parsed: any = data\n    if (typeof data === \"string\") {\n      try {\n        parsed = JSON.parse(data)\n      } catch {\n        return yield* Effect.fail([\n          new FieldError(\"_form\", \"Invalid form data\"),\n        ])\n      }\n    }\n\n    // Validate each field and collect errors\n    let username = \"\"\n    const usernameResult = yield* validateUsername(parsed.username).pipe(\n      Effect.either\n    )\n    if (usernameResult._tag === \"Left\") {\n      errors.push(usernameResult.left)\n    } else {\n      username = usernameResult.right\n    }\n\n    let email = \"\"\n    const emailResult = yield* validateEmail(parsed.email).pipe(Effect.either)\n    if (emailResult._tag === \"Left\") {\n      errors.push(emailResult.left)\n    } else {\n      email = emailResult.right\n    }\n\n    let password = \"\"\n    const passwordResult = yield* validatePassword(parsed.password).pipe(\n      Effect.either\n    )\n    if (passwordResult._tag === \"Left\") {\n      errors.push(passwordResult.left)\n    } else {\n      password = passwordResult.right\n    }\n\n    // Validate password match only if both passwords valid\n    if (password) {\n      const matchResult = yield* validatePasswordMatch(\n        password,\n        parsed.confirmPassword\n      ).pipe(Effect.either)\n      if (matchResult._tag === \"Left\") {\n        errors.push(matchResult.left)\n      }\n    }\n\n    let age = 0\n    const ageResult = yield* validateAge(parsed.age).pipe(Effect.either)\n    if (ageResult._tag === \"Left\") {\n      errors.push(ageResult.left)\n    } else {\n      age = ageResult.right\n    }\n\n    // Return all errors if any found\n    if (errors.length > 0) {\n      return yield* Effect.fail(errors)\n    }\n\n    return { username, email, password, confirmPassword: password, age }\n  })\n\n// ============================================\n// 5. Error summary formatter\n// ============================================\n\nconst formatErrorSummary = (errors: ValidationErrors): string => {\n  if (errors.length === 0) return \"No errors\"\n\n  const errorsByField = errors.reduce(\n    (acc, error) => {\n      if (!acc[error.field]) {\n        acc[error.field] = []\n      }\n      acc[error.field].push(error.message)\n      return acc\n    },\n    {} as Record<string, string[]>\n  )\n\n  let summary = `Found ${errors.length} validation error(s):\\n`\n  for (const [field, messages] of Object.entries(errorsByField)) {\n    summary += `  ${field}:\\n`\n    for (const msg of messages) {\n      summary += `    - ${msg}\\n`\n    }\n  }\n  return summary\n}\n\n// ============================================\n// 6. Application logic\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Scenario 1: Form with many errors ===\\n\")\n\n  const badFormData = {\n    username: \"ab\",\n    email: \"not-an-email\",\n    password: \"short\",\n    confirmPassword: \"different\",\n    age: 10,\n  }\n\n  const result1 = yield* validateFormErrors(badFormData).pipe(\n    Effect.either\n  )\n\n  if (result1._tag === \"Left\") {\n    console.log(\"\u274c Validation failed with multiple errors:\\n\")\n    console.log(formatErrorSummary(result1.left))\n  }\n\n  console.log(\"=== Scenario 2: Form with some errors ===\\n\")\n\n  const partialFormData = {\n    username: \"alice_123\",\n    email: \"alice@example.com\",\n    password: \"ValidPass123\",\n    confirmPassword: \"DifferentPass456\",\n    age: 25,\n  }\n\n  const result2 = yield* validateFormErrors(partialFormData).pipe(\n    Effect.either\n  )\n\n  if (result2._tag === \"Left\") {\n    console.log(\"\u274c Validation failed:\\n\")\n    console.log(formatErrorSummary(result2.left))\n  }\n\n  console.log(\"=== Scenario 3: Valid form ===\\n\")\n\n  const goodFormData = {\n    username: \"alice_123\",\n    email: \"alice@example.com\",\n    password: \"ValidPass123\",\n    confirmPassword: \"ValidPass123\",\n    age: 25,\n  }\n\n  const result3 = yield* validateFormErrors(goodFormData).pipe(\n    Effect.either\n  )\n\n  if (result3._tag === \"Right\") {\n    console.log(\"\u2705 Form valid!\")\n    console.log(result3.right)\n  }\n\n  return result3\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Form validation complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Error Aggregation and Collection using Schema."
            },
            "created_at": "2026-02-16T21:39:16.572094",
            "updated_at": "2026-02-20T23:09:40.433237"
        },
        {
            "id": "b76d2a8d-cbc5-4321-9faa-4a91dd4f4ad2",
            "slug": "schema-basic-unions",
            "title": "Basic Union Types and Alternatives",
            "summary": "Your API returns different shapes depending on context. A response could be a user profile OR an error message. A payment could succeed with a transaction ID OR fail with a reason. Without union...",
            "skill_level": "beginner",
            "category": "schema",
            "difficulty": "beginner",
            "tags": [
                "schema",
                "unions",
                "type-alternatives",
                "variants",
                "polymorphism"
            ],
            "examples": [
                {
                    "code": "import { Schema, Effect } from \"effect\"\n\n// ============================================\n// 1. Simple unions: alternatives with different types\n// ============================================\n\n// A response is either a number or a string\nconst NumberOrString = Schema.Union(\n  Schema.Number,\n  Schema.String\n)\n\ntype NumberOrString = typeof NumberOrString.Type\n\n// ============================================\n// 2. Union of structs: different shaped objects\n// ============================================\n\n// User can be authenticated or guest\nconst AuthenticatedUser = Schema.Struct({\n  type: Schema.Literal(\"authenticated\"),\n  id: Schema.String,\n  name: Schema.String,\n  email: Schema.String,\n})\n\nconst GuestUser = Schema.Struct({\n  type: Schema.Literal(\"guest\"),\n  sessionId: Schema.String,\n})\n\nconst User = Schema.Union(AuthenticatedUser, GuestUser)\n\ntype User = typeof User.Type\n\n// ============================================\n// 3. Payment result union\n// ============================================\n\nconst PaymentSuccess = Schema.Struct({\n  status: Schema.Literal(\"success\"),\n  transactionId: Schema.String,\n  amount: Schema.Number,\n  timestamp: Schema.Date,\n})\n\nconst PaymentFailure = Schema.Struct({\n  status: Schema.Literal(\"failed\"),\n  reason: Schema.String,\n  retryable: Schema.Boolean,\n})\n\nconst PaymentResult = Schema.Union(PaymentSuccess, PaymentFailure)\n\ntype PaymentResult = typeof PaymentResult.Type\n\n// ============================================\n// 4. API response union\n// ============================================\n\nconst SuccessResponse = Schema.Struct({\n  ok: Schema.Literal(true),\n  data: Schema.Any,\n})\n\nconst ErrorResponse = Schema.Struct({\n  ok: Schema.Literal(false),\n  error: Schema.String,\n  code: Schema.Number,\n})\n\nconst ApiResponse = Schema.Union(SuccessResponse, ErrorResponse)\n\ntype ApiResponse = typeof ApiResponse.Type\n\n// ============================================\n// 5. Pattern matching on unions\n// ============================================\n\nconst describeUser = (user: User): string => {\n  // Type narrowing with if/else\n  if (user.type === \"authenticated\") {\n    return `Authenticated: ${user.name} (${user.email})`\n  } else {\n    return `Guest: ${user.sessionId}`\n  }\n}\n\nconst describePayment = (result: PaymentResult): string => {\n  // Pattern matching approach\n  switch (result.status) {\n    case \"success\":\n      return `\u2705 Payment of $${result.amount} processed. ID: ${result.transactionId}`\n    case \"failed\":\n      const retry = result.retryable ? \"Retryable\" : \"Non-retryable\"\n      return `\u274c Payment failed: ${result.reason} (${retry})`\n  }\n}\n\n// ============================================\n// 6. Processing unions in effects\n// ============================================\n\nconst parsePaymentResult = (\n  raw: unknown\n): Effect.Effect<PaymentResult, Error> =>\n  Effect.tryPromise({\n    try: () => Schema.decodeUnknown(PaymentResult)(raw),\n    catch: (error) => {\n      const msg = error instanceof Error ? error.message : String(error)\n      return new Error(`Invalid payment result: ${msg}`)\n    },\n  })\n\nconst processPayment = (\n  result: PaymentResult\n): Effect.Effect<string, Error> =>\n  Effect.gen(function* () {\n    const description = describePayment(result)\n    console.log(description)\n\n    // Type-safe handling: compiler knows all cases covered\n    if (result.status === \"success\") {\n      yield* Effect.log(`Recording transaction: ${result.transactionId}`)\n      return `Recorded: ${result.transactionId}`\n    } else {\n      if (result.retryable) {\n        yield* Effect.log(`Will retry: ${result.reason}`)\n      } else {\n        yield* Effect.log(`Permanent failure: ${result.reason}`)\n      }\n      return `Failed: ${result.reason}`\n    }\n  })\n\n// ============================================\n// 7. Creating and parsing unions\n// ============================================\n\nconst appLogic = Effect.gen(function* () {\n  console.log(\"=== Scenario 1: Parse simple union ===\\n\")\n\n  const value1 = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(NumberOrString)(\"hello\"),\n    catch: (error) => new Error(String(error)),\n  })\n\n  console.log(`Parsed: ${value1} (${typeof value1})`)\n\n  console.log(\"\\n=== Scenario 2: Parse user union ===\\n\")\n\n  const authenticatedData = {\n    type: \"authenticated\",\n    id: \"user_123\",\n    name: \"Alice\",\n    email: \"alice@example.com\",\n  }\n\n  const authenticated = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(User)(authenticatedData),\n    catch: (error) => new Error(String(error)),\n  })\n\n  console.log(`User: ${describeUser(authenticated)}`)\n\n  const guestData = {\n    type: \"guest\",\n    sessionId: \"sess_abc123\",\n  }\n\n  const guest = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(User)(guestData),\n    catch: (error) => new Error(String(error)),\n  })\n\n  console.log(`User: ${describeUser(guest)}`)\n\n  console.log(\"\\n=== Scenario 3: Process payment results ===\\n\")\n\n  const successPayment = {\n    status: \"success\",\n    transactionId: \"txn_12345\",\n    amount: 99.99,\n    timestamp: new Date(),\n  }\n\n  const success = yield* parsePaymentResult(successPayment)\n  yield* processPayment(success)\n\n  const failedPayment = {\n    status: \"failed\",\n    reason: \"Insufficient funds\",\n    retryable: true,\n  }\n\n  const failed = yield* parsePaymentResult(failedPayment)\n  yield* processPayment(failed)\n\n  console.log(\"\\n=== Scenario 4: API response union ===\\n\")\n\n  const okResponse = {\n    ok: true,\n    data: { users: [\"Alice\", \"Bob\"] },\n  }\n\n  const apiOk = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(ApiResponse)(okResponse),\n    catch: (error) => new Error(String(error)),\n  })\n\n  if (apiOk.ok) {\n    console.log(`API Success:`, apiOk.data)\n  }\n\n  const errorResponse = {\n    ok: false,\n    error: \"Not found\",\n    code: 404,\n  }\n\n  const apiError = yield* Effect.tryPromise({\n    try: () => Schema.decodeUnknown(ApiResponse)(errorResponse),\n    catch: (error) => new Error(String(error)),\n  })\n\n  if (!apiError.ok) {\n    console.log(`API Error: [${apiError.code}] ${apiError.error}`)\n  }\n\n  return { authenticated, guest, success, failed, apiOk, apiError }\n})\n\n// Run application\nEffect.runPromise(appLogic)\n  .then(() => console.log(\"\\n\u2705 Union parsing complete\"))\n  .catch((error) => console.error(`Error: ${error.message}`))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Basic Union Types and Alternatives using Schema."
            },
            "created_at": "2026-02-16T21:39:17.105532",
            "updated_at": "2026-02-20T23:09:40.581613"
        },
        {
            "id": "bef6bc05-dc5b-4cde-b142-0b6aeb2eb9ec",
            "slug": "mocking-dependencies-in-tests",
            "title": "Mocking Dependencies in Tests",
            "summary": "Use a test-specific Layer to provide mock implementations of services your code depends on, enabling isolated and deterministic unit tests.",
            "skill_level": "intermediate",
            "category": "testing",
            "difficulty": "intermediate",
            "tags": [
                "testing",
                "mocking",
                "dependency-injection",
                "layer",
                "service",
                "unit-test"
            ],
            "examples": [
                {
                    "code": "import { Effect, Layer } from \"effect\";\n\n// --- The Services ---\ninterface EmailClientService {\n  send: (address: string, body: string) => Effect.Effect<void>;\n}\n\nclass EmailClient extends Effect.Service<EmailClientService>()(\"EmailClient\", {\n  sync: () => ({\n    send: (address: string, body: string) =>\n      Effect.sync(() => Effect.log(`Sending email to ${address}: ${body}`)),\n  }),\n}) {}\n\ninterface NotifierService {\n  notifyUser: (userId: number, message: string) => Effect.Effect<void>;\n}\n\nclass Notifier extends Effect.Service<NotifierService>()(\"Notifier\", {\n  effect: Effect.gen(function* () {\n    const emailClient = yield* EmailClient;\n    return {\n      notifyUser: (userId: number, message: string) =>\n        emailClient.send(`user-${userId}@example.com`, message),\n    };\n  }),\n  dependencies: [EmailClient.Default],\n}) {}\n\n// Create a program that uses the Notifier service\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Using default EmailClient implementation...\");\n  const notifier = yield* Notifier;\n  yield* notifier.notifyUser(123, \"Your invoice is ready.\");\n\n  // Create mock EmailClient that logs differently\n  yield* Effect.log(\"\\nUsing mock EmailClient implementation...\");\n  const mockEmailClient = Layer.succeed(EmailClient, {\n    send: (address: string, body: string) =>\n      // Directly return the Effect.log without nesting it in Effect.sync\n      Effect.log(`MOCK: Would send to ${address} with body: ${body}`),\n  } as EmailClientService);\n\n  // Run the same notification with mock client\n  yield* Effect.gen(function* () {\n    const notifier = yield* Notifier;\n    yield* notifier.notifyUser(123, \"Your invoice is ready.\");\n  }).pipe(Effect.provide(mockEmailClient));\n});\n\n// Run the program\nEffect.runPromise(Effect.provide(program, Notifier.Default));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Provide mock service implementations via a test-specific Layer to isolate the unit under test."
            },
            "created_at": "2026-02-15T21:22:28.41904",
            "updated_at": "2026-02-20T23:09:40.896097"
        },
        {
            "id": "157eb2fc-02c7-4c87-bded-30c2313bc820",
            "slug": "testing-with-services",
            "title": "Test Effects with Services",
            "summary": "Learn how to test Effect programs that depend on services by providing test implementations.",
            "skill_level": "beginner",
            "category": "testing",
            "difficulty": "beginner",
            "tags": [
                "testing",
                "services",
                "dependency-injection",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { describe, it, expect } from \"vitest\"\nimport { Effect, Context } from \"effect\"\n\n// ============================================\n// 1. Define a service\n// ============================================\n\nclass UserRepository extends Context.Tag(\"UserRepository\")<\n  UserRepository,\n  {\n    readonly findById: (id: string) => Effect.Effect<User | null>\n    readonly save: (user: User) => Effect.Effect<void>\n  }\n>() {}\n\ninterface User {\n  id: string\n  name: string\n  email: string\n}\n\n// ============================================\n// 2. Code that uses the service\n// ============================================\n\nconst getUser = (id: string) =>\n  Effect.gen(function* () {\n    const repo = yield* UserRepository\n    const user = yield* repo.findById(id)\n    \n    if (!user) {\n      return yield* Effect.fail(new Error(`User ${id} not found`))\n    }\n    \n    return user\n  })\n\nconst createUser = (name: string, email: string) =>\n  Effect.gen(function* () {\n    const repo = yield* UserRepository\n    \n    const user: User = {\n      id: crypto.randomUUID(),\n      name,\n      email,\n    }\n    \n    yield* repo.save(user)\n    return user\n  })\n\n// ============================================\n// 3. Create a test implementation\n// ============================================\n\nconst makeTestUserRepository = (initialUsers: User[] = []) => {\n  const users = new Map(initialUsers.map(u => [u.id, u]))\n  \n  return UserRepository.of({\n    findById: (id) => Effect.succeed(users.get(id) ?? null),\n    save: (user) => Effect.sync(() => { users.set(user.id, user) }),\n  })\n}\n\n// ============================================\n// 4. Write tests\n// ============================================\n\ndescribe(\"User Service Tests\", () => {\n  it(\"should find an existing user\", async () => {\n    const testUser: User = {\n      id: \"123\",\n      name: \"Alice\",\n      email: \"alice@example.com\",\n    }\n    \n    const testRepo = makeTestUserRepository([testUser])\n    \n    const result = await Effect.runPromise(\n      getUser(\"123\").pipe(\n        Effect.provideService(UserRepository, testRepo)\n      )\n    )\n    \n    expect(result).toEqual(testUser)\n  })\n\n  it(\"should fail when user not found\", async () => {\n    const testRepo = makeTestUserRepository([])\n    \n    await expect(\n      Effect.runPromise(\n        getUser(\"999\").pipe(\n          Effect.provideService(UserRepository, testRepo)\n        )\n      )\n    ).rejects.toThrow(\"User 999 not found\")\n  })\n\n  it(\"should create and save a user\", async () => {\n    const savedUsers: User[] = []\n    \n    const trackingRepo = UserRepository.of({\n      findById: () => Effect.succeed(null),\n      save: (user) => Effect.sync(() => { savedUsers.push(user) }),\n    })\n    \n    const result = await Effect.runPromise(\n      createUser(\"Bob\", \"bob@example.com\").pipe(\n        Effect.provideService(UserRepository, trackingRepo)\n      )\n    )\n    \n    expect(result.name).toBe(\"Bob\")\n    expect(result.email).toBe(\"bob@example.com\")\n    expect(savedUsers).toHaveLength(1)\n    expect(savedUsers[0].name).toBe(\"Bob\")\n  })\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Provide test implementations of services to make Effect programs testable."
            },
            "created_at": "2026-02-15T21:22:28.169274",
            "updated_at": "2026-02-20T23:09:40.93829"
        },
        {
            "id": "9647d0ae-6f3d-4b91-836e-da4c2f222e1b",
            "slug": "testing-hello-world",
            "title": "Your First Effect Test",
            "summary": "Write your first test for an Effect program using Vitest and Effect's testing utilities.",
            "skill_level": "beginner",
            "category": "testing",
            "difficulty": "beginner",
            "tags": [
                "testing",
                "vitest",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { describe, it, expect } from \"vitest\"\nimport { Effect } from \"effect\"\n\n// ============================================\n// Code to test\n// ============================================\n\nconst add = (a: number, b: number): Effect.Effect<number> =>\n  Effect.succeed(a + b)\n\nconst divide = (a: number, b: number): Effect.Effect<number, Error> =>\n  b === 0\n    ? Effect.fail(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\nconst fetchUser = (id: string): Effect.Effect<{ id: string; name: string }> =>\n  Effect.succeed({ id, name: `User ${id}` })\n\n// ============================================\n// Tests\n// ============================================\n\ndescribe(\"Basic Effect Tests\", () => {\n  it(\"should add two numbers\", async () => {\n    const result = await Effect.runPromise(add(2, 3))\n    expect(result).toBe(5)\n  })\n\n  it(\"should divide numbers\", async () => {\n    const result = await Effect.runPromise(divide(10, 2))\n    expect(result).toBe(5)\n  })\n\n  it(\"should fail on divide by zero\", async () => {\n    await expect(Effect.runPromise(divide(10, 0))).rejects.toThrow(\n      \"Cannot divide by zero\"\n    )\n  })\n\n  it(\"should fetch a user\", async () => {\n    const user = await Effect.runPromise(fetchUser(\"123\"))\n    \n    expect(user).toEqual({\n      id: \"123\",\n      name: \"User 123\",\n    })\n  })\n})\n\n// ============================================\n// Testing Effect.gen programs\n// ============================================\n\nconst calculateDiscount = (price: number, quantity: number) =>\n  Effect.gen(function* () {\n    if (price <= 0) {\n      return yield* Effect.fail(new Error(\"Invalid price\"))\n    }\n    \n    const subtotal = price * quantity\n    const discount = quantity >= 10 ? 0.1 : 0\n    const total = subtotal * (1 - discount)\n    \n    return { subtotal, discount, total }\n  })\n\ndescribe(\"Effect.gen Tests\", () => {\n  it(\"should calculate without discount\", async () => {\n    const result = await Effect.runPromise(calculateDiscount(10, 5))\n    \n    expect(result.subtotal).toBe(50)\n    expect(result.discount).toBe(0)\n    expect(result.total).toBe(50)\n  })\n\n  it(\"should apply bulk discount\", async () => {\n    const result = await Effect.runPromise(calculateDiscount(10, 10))\n    \n    expect(result.subtotal).toBe(100)\n    expect(result.discount).toBe(0.1)\n    expect(result.total).toBe(90)\n  })\n\n  it(\"should fail for invalid price\", async () => {\n    await expect(\n      Effect.runPromise(calculateDiscount(-5, 10))\n    ).rejects.toThrow(\"Invalid price\")\n  })\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.runPromise in tests to run and assert on Effect results."
            },
            "created_at": "2026-02-15T21:22:28.256019",
            "updated_at": "2026-02-20T23:09:41.209859"
        },
        {
            "id": "dbf2b2a6-cdb2-4ef4-98b6-71cf7b1a75cd",
            "slug": "error-management-extract-cause",
            "title": "Extract Failures and Defects from a Cause",
            "summary": "Use Cause.failures and Cause.defects to inspect a Cause and handle expected failures differently from unexpected defects.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "error management",
                "cause",
                "defects",
                "failures"
            ],
            "examples": [
                {
                    "code": "import { Effect, Cause } from \"effect\"\n\nconst program = Effect.die(\"unexpected bug\").pipe(\n  Effect.catchAllCause((cause) =>\n    Effect.gen(function* () {\n      const defects = Cause.defects(cause)\n      const failures = Cause.failures(cause)\n      yield* Effect.sync(() => {\n        console.log(\"Defects:\", defects)\n        console.log(\"Failures:\", failures)\n      })\n      return \"recovered\"\n    })\n  )\n)\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Inspect Cause to separate expected failures from defects."
            },
            "created_at": "2026-02-15T21:22:31.05614",
            "updated_at": "2026-02-20T23:09:41.368093"
        },
        {
            "id": "3958b243-3823-4572-aa20-f60ef9a29cf2",
            "slug": "pattern-match",
            "title": "Matching on Success and Failure with match",
            "summary": "Use match to handle both success and failure cases in a single, declarative place for Effect, Option, and Either.",
            "skill_level": "beginner",
            "category": "error-management",
            "difficulty": "beginner",
            "tags": [
                "match",
                "pattern-matching",
                "effect",
                "option",
                "either",
                "error-handling",
                "branching"
            ],
            "examples": [
                {
                    "code": "import { Effect, Option, Either } from \"effect\";\n\n// Effect: Handle both success and failure\nconst effect = Effect.fail(\"Oops!\").pipe(\n  Effect.match({\n    onFailure: (err) => `Error: ${err}`,\n    onSuccess: (value) => `Success: ${value}`,\n  })\n); // Effect<string>\n\n// Option: Handle Some and None cases\nconst option = Option.some(42).pipe(\n  Option.match({\n    onNone: () => \"No value\",\n    onSome: (n) => `Value: ${n}`,\n  })\n); // string\n\n// Either: Handle Left and Right cases\nconst either = Either.left(\"fail\").pipe(\n  Either.match({\n    onLeft: (err) => `Error: ${err}`,\n    onRight: (value) => `Value: ${value}`,\n  })\n); // string",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use match to pattern match on the result of an Effect, Option, or Either, handling both success and failure cases declaratively."
            },
            "created_at": "2026-02-15T21:22:17.110529",
            "updated_at": "2026-02-20T23:09:41.496975"
        },
        {
            "id": "bc13a7be-ddb9-4432-ad3a-38b1f0eb1409",
            "slug": "retry-based-on-specific-errors",
            "title": "Retry Operations Based on Specific Errors",
            "summary": "Use Effect.retry and predicate functions to selectively retry an operation only when specific, recoverable errors occur.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "retry",
                "error-handling",
                "predicate",
                "resilience",
                "schedule"
            ],
            "examples": [
                {
                    "code": "import { Data, Effect, Schedule } from \"effect\";\n\n// Define specific, tagged errors for our API client\nclass ServerBusyError extends Data.TaggedError(\"ServerBusyError\") {}\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\") {}\n\nlet attemptCount = 0;\n\n// A flaky API call that can fail in different ways\nconst flakyApiCall = Effect.try({\n  try: () => {\n    attemptCount++;\n    const random = Math.random();\n\n    if (attemptCount <= 2) {\n      // First two attempts fail with ServerBusyError (retryable)\n      console.log(\n        `Attempt ${attemptCount}: API call failed - Server is busy. Retrying...`\n      );\n      throw new ServerBusyError();\n    }\n\n    // Third attempt succeeds\n    console.log(`Attempt ${attemptCount}: API call succeeded!`);\n    return { data: \"success\", attempt: attemptCount };\n  },\n  catch: (e) => e as ServerBusyError | NotFoundError,\n});\n\n// A predicate that returns true only for the error we want to retry\nconst isRetryableError = (e: ServerBusyError | NotFoundError) =>\n  e._tag === \"ServerBusyError\";\n\n// A policy that retries 3 times, but only if the error is retryable\nconst selectiveRetryPolicy = Schedule.recurs(3).pipe(\n  Schedule.whileInput(isRetryableError),\n  Schedule.addDelay(() => \"100 millis\")\n);\n\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Retry Based on Specific Errors Demo ===\");\n\n  try {\n    const result = yield* flakyApiCall.pipe(Effect.retry(selectiveRetryPolicy));\n    yield* Effect.logInfo(`Success: ${JSON.stringify(result)}`);\n    return result;\n  } catch (error) {\n    yield* Effect.logInfo(\"This won't be reached due to Effect error handling\");\n    return null;\n  }\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      if (error instanceof NotFoundError) {\n        yield* Effect.logInfo(\"Failed with NotFoundError - not retrying\");\n      } else if (error instanceof ServerBusyError) {\n        yield* Effect.logInfo(\"Failed with ServerBusyError after all retries\");\n      } else {\n        yield* Effect.logInfo(`Failed with unexpected error: ${error}`);\n      }\n      return null;\n    })\n  )\n);\n\n// Also demonstrate a case where NotFoundError is not retried\nconst demonstrateNotFound = Effect.gen(function* () {\n  yield* Effect.logInfo(\"\\n=== Demonstrating Non-Retryable Error ===\");\n\n  const alwaysNotFound = Effect.fail(new NotFoundError());\n\n  const result = yield* alwaysNotFound.pipe(\n    Effect.retry(selectiveRetryPolicy),\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Effect.logInfo(`NotFoundError was not retried: ${error._tag}`);\n        return null;\n      })\n    )\n  );\n\n  return result;\n});\n\nEffect.runPromise(program.pipe(Effect.flatMap(() => demonstrateNotFound)));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use predicate-based retry policies to retry an operation only for specific, recoverable errors."
            },
            "created_at": "2026-02-15T21:22:18.11845",
            "updated_at": "2026-02-20T23:09:41.672283"
        },
        {
            "id": "792d41d4-87dd-4868-a2c9-40b59a6cf8a5",
            "slug": "pattern-matcheffect",
            "title": "Effectful Pattern Matching with matchEffect",
            "summary": "Use matchEffect to perform effectful branching based on success or failure, enabling rich workflows in the Effect world.",
            "skill_level": "intermediate",
            "category": "error-management",
            "difficulty": "intermediate",
            "tags": [
                "matchEffect",
                "pattern-matching",
                "effect",
                "branching",
                "error-handling"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Effect: Run different Effects on success or failure\nconst effect = Effect.fail(\"Oops!\").pipe(\n  Effect.matchEffect({\n    onFailure: (err) => Effect.logError(`Error: ${err}`),\n    onSuccess: (value) => Effect.log(`Success: ${value}`),\n  })\n); // Effect<void>",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use matchEffect to pattern match on the result of an Effect, running effectful logic for both success and failure cases."
            },
            "created_at": "2026-02-15T21:22:17.527092",
            "updated_at": "2026-02-20T23:09:41.714731"
        },
        {
            "id": "b4ccdb9d-d7a9-4d00-986c-7e8d03476635",
            "slug": "error-management-hello-world",
            "title": "Your First Error Handler",
            "summary": "Learn the basics of handling errors in Effect with catchAll and catchTag.",
            "skill_level": "beginner",
            "category": "error-management",
            "difficulty": "beginner",
            "tags": [
                "error-handling",
                "catchAll",
                "catchTag",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data } from \"effect\"\n\n// ============================================\n// 1. Define typed errors\n// ============================================\n\nclass NetworkError extends Data.TaggedError(\"NetworkError\")<{\n  readonly url: string\n}> {}\n\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{\n  readonly resource: string\n}> {}\n\n// ============================================\n// 2. Functions that can fail\n// ============================================\n\nconst fetchData = (url: string): Effect.Effect<string, NetworkError> =>\n  url.startsWith(\"http\")\n    ? Effect.succeed(`Data from ${url}`)\n    : Effect.fail(new NetworkError({ url }))\n\nconst findUser = (id: string): Effect.Effect<{ id: string; name: string }, NotFoundError> =>\n  id === \"123\"\n    ? Effect.succeed({ id, name: \"Alice\" })\n    : Effect.fail(new NotFoundError({ resource: `user:${id}` }))\n\n// ============================================\n// 3. Handle ALL errors with catchAll\n// ============================================\n\nconst withFallback = fetchData(\"invalid-url\").pipe(\n  Effect.catchAll((error) => {\n    console.log(`Failed: ${error.url}, using fallback`)\n    return Effect.succeed(\"Fallback data\")\n  })\n)\n\n// Result: \"Fallback data\"\n\n// ============================================\n// 4. Handle SPECIFIC errors with catchTag\n// ============================================\n\nconst findUserOrDefault = (id: string) =>\n  findUser(id).pipe(\n    Effect.catchTag(\"NotFoundError\", (error) => {\n      console.log(`User not found: ${error.resource}`)\n      return Effect.succeed({ id: \"guest\", name: \"Guest User\" })\n    })\n  )\n\n// ============================================\n// 5. Handle MULTIPLE error types\n// ============================================\n\nconst fetchUser = (url: string, id: string) =>\n  Effect.gen(function* () {\n    yield* fetchData(url)\n    return yield* findUser(id)\n  })\n\nconst robustFetchUser = (url: string, id: string) =>\n  fetchUser(url, id).pipe(\n    Effect.catchTags({\n      NetworkError: (e) => Effect.succeed({ id: \"offline\", name: `Offline (${e.url})` }),\n      NotFoundError: (e) => Effect.succeed({ id: \"unknown\", name: `Unknown (${e.resource})` }),\n    })\n  )\n\n// ============================================\n// 6. Run the examples\n// ============================================\n\nconst program = Effect.gen(function* () {\n  // catchAll example\n  const data = yield* withFallback\n  yield* Effect.log(`Got data: ${data}`)\n\n  // catchTag example\n  const user = yield* findUserOrDefault(\"999\")\n  yield* Effect.log(`Got user: ${user.name}`)\n\n  // Multiple error types\n  const result = yield* robustFetchUser(\"invalid\", \"999\")\n  yield* Effect.log(`Robust result: ${result.name}`)\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use catchAll or catchTag to recover from errors and keep your program running."
            },
            "created_at": "2026-02-15T21:22:17.27517",
            "updated_at": "2026-02-20T23:09:41.890907"
        },
        {
            "id": "2ff97b06-cd98-4aa7-98d9-57d3b5498e17",
            "slug": "tooling-linting",
            "title": "Configure Linting for Effect",
            "summary": "Set up Biome or ESLint with Effect-specific rules for code quality.",
            "skill_level": "intermediate",
            "category": "tooling-and-debugging",
            "difficulty": "intermediate",
            "tags": [
                "tooling",
                "linting",
                "biome",
                "eslint"
            ],
            "examples": [
                {
                    "code": "// biome.json\n{\n  \"$schema\": \"https://biomejs.dev/schemas/1.8.0/schema.json\",\n  \"organizeImports\": {\n    \"enabled\": true\n  },\n  \"linter\": {\n    \"enabled\": true,\n    \"rules\": {\n      \"recommended\": true,\n      \"complexity\": {\n        \"noExcessiveCognitiveComplexity\": \"warn\",\n        \"noForEach\": \"off\",  // Effect uses forEach patterns\n        \"useLiteralKeys\": \"off\"  // Effect uses computed keys\n      },\n      \"correctness\": {\n        \"noUnusedVariables\": \"error\",\n        \"noUnusedImports\": \"error\",\n        \"useExhaustiveDependencies\": \"warn\"\n      },\n      \"style\": {\n        \"noNonNullAssertion\": \"warn\",\n        \"useConst\": \"error\",\n        \"noParameterAssign\": \"error\"\n      },\n      \"suspicious\": {\n        \"noExplicitAny\": \"warn\",\n        \"noConfusingVoidType\": \"off\"  // Effect uses void\n      },\n      \"nursery\": {\n        \"noRestrictedImports\": {\n          \"level\": \"error\",\n          \"options\": {\n            \"paths\": {\n              \"lodash\": \"Use Effect functions instead\",\n              \"ramda\": \"Use Effect functions instead\"\n            }\n          }\n        }\n      }\n    }\n  },\n  \"formatter\": {\n    \"enabled\": true,\n    \"indentStyle\": \"space\",\n    \"indentWidth\": 2,\n    \"lineWidth\": 100\n  },\n  \"javascript\": {\n    \"formatter\": {\n      \"semicolons\": \"asNeeded\",\n      \"quoteStyle\": \"double\",\n      \"trailingComma\": \"es5\"\n    }\n  },\n  \"files\": {\n    \"ignore\": [\n      \"node_modules\",\n      \"dist\",\n      \"coverage\",\n      \"*.gen.ts\"\n    ]\n  }\n}",
                    "language": "json",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Biome for fast linting with Effect-friendly configuration."
            },
            "created_at": "2026-02-15T21:22:30.292606",
            "updated_at": "2026-02-20T23:09:42.299547"
        },
        {
            "id": "5e15253d-b4ef-448b-9fee-405065b6e2cd",
            "slug": "observability-hello-world",
            "title": "Your First Logs",
            "summary": "Learn the basics of logging in Effect using the built-in structured logging system.",
            "skill_level": "beginner",
            "category": "observability",
            "difficulty": "beginner",
            "tags": [
                "observability",
                "logging",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Logger, LogLevel } from \"effect\"\n\n// ============================================\n// 1. Basic logging\n// ============================================\n\nconst basicLogging = Effect.gen(function* () {\n  // Different log levels\n  yield* Effect.logDebug(\"Debug message - for development\")\n  yield* Effect.logInfo(\"Info message - normal operation\")\n  yield* Effect.log(\"Default log - same as logInfo\")\n  yield* Effect.logWarning(\"Warning - something unusual\")\n  yield* Effect.logError(\"Error - something went wrong\")\n})\n\n// ============================================\n// 2. Logging with context\n// ============================================\n\nconst withContext = Effect.gen(function* () {\n  // Add structured data to logs\n  yield* Effect.log(\"User logged in\").pipe(\n    Effect.annotateLogs({\n      userId: \"user-123\",\n      action: \"login\",\n      ipAddress: \"192.168.1.1\",\n    })\n  )\n\n  // Add a single annotation\n  yield* Effect.log(\"Processing request\").pipe(\n    Effect.annotateLogs(\"requestId\", \"req-456\")\n  )\n})\n\n// ============================================\n// 3. Log spans for timing\n// ============================================\n\nconst withTiming = Effect.gen(function* () {\n  yield* Effect.log(\"Starting operation\")\n\n  // withLogSpan adds timing information\n  yield* Effect.sleep(\"100 millis\").pipe(\n    Effect.withLogSpan(\"database-query\")\n  )\n\n  yield* Effect.log(\"Operation complete\")\n})\n\n// ============================================\n// 4. Practical example\n// ============================================\n\ninterface User {\n  id: string\n  email: string\n}\n\nconst processOrder = (orderId: string, userId: string) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"Processing order\").pipe(\n      Effect.annotateLogs({ orderId, userId })\n    )\n\n    // Simulate work\n    yield* Effect.sleep(\"50 millis\")\n\n    yield* Effect.logInfo(\"Order processed successfully\").pipe(\n      Effect.annotateLogs({ orderId, status: \"completed\" })\n    )\n\n    return { orderId, status: \"completed\" }\n  }).pipe(\n    Effect.withLogSpan(\"processOrder\")\n  )\n\n// ============================================\n// 5. Configure log level\n// ============================================\n\nconst debugProgram = basicLogging.pipe(\n  // Show all logs including debug\n  Logger.withMinimumLogLevel(LogLevel.Debug)\n)\n\nconst productionProgram = basicLogging.pipe(\n  // Only show warnings and errors\n  Logger.withMinimumLogLevel(LogLevel.Warning)\n)\n\n// ============================================\n// 6. Run\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Basic Logging ===\")\n  yield* basicLogging\n\n  yield* Effect.log(\"\\n=== With Context ===\")\n  yield* withContext\n\n  yield* Effect.log(\"\\n=== With Timing ===\")\n  yield* withTiming\n\n  yield* Effect.log(\"\\n=== Process Order ===\")\n  yield* processOrder(\"order-789\", \"user-123\")\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.log and related functions for structured, contextual logging."
            },
            "created_at": "2026-02-15T21:22:29.121428",
            "updated_at": "2026-02-20T23:09:42.598863"
        },
        {
            "id": "53deec9a-6570-482c-b3da-c954b41adeac",
            "slug": "trace-operations-with-spans",
            "title": "Trace Operations Across Services with Spans",
            "summary": "Use Effect.withSpan to create custom tracing spans, providing detailed visibility into the performance and flow of your application's operations.",
            "skill_level": "intermediate",
            "category": "observability",
            "difficulty": "intermediate",
            "tags": [
                "tracing",
                "span",
                "observability",
                "opentelemetry",
                "performance",
                "debugging"
            ],
            "examples": [
                {
                    "code": "import { Effect, Duration } from \"effect\";\n\nconst validateInput = (input: unknown) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"Starting input validation...\");\n    yield* Effect.sleep(Duration.millis(10));\n    const result = { email: \"paul@example.com\" };\n    yield* Effect.logInfo(`\u2705 Input validated: ${result.email}`);\n    return result;\n  }).pipe(\n    // This creates a child span\n    Effect.withSpan(\"validateInput\")\n  );\n\nconst saveToDatabase = (user: { email: string }) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(`Saving user to database: ${user.email}`);\n    yield* Effect.sleep(Duration.millis(50));\n    const result = { id: 123, ...user };\n    yield* Effect.logInfo(`\u2705 User saved with ID: ${result.id}`);\n    return result;\n  }).pipe(\n    // This span includes useful attributes\n    Effect.withSpan(\"saveToDatabase\", {\n      attributes: { \"db.system\": \"postgresql\", \"db.user.email\": user.email },\n    })\n  );\n\nconst createUser = (input: unknown) =>\n  Effect.gen(function* () {\n    yield* Effect.logInfo(\"=== Creating User with Tracing ===\");\n    yield* Effect.logInfo(\n      \"This demonstrates how spans trace operations through the call stack\"\n    );\n\n    const validated = yield* validateInput(input);\n    const user = yield* saveToDatabase(validated);\n\n    yield* Effect.logInfo(\n      `\u2705 User creation completed: ${JSON.stringify(user)}`\n    );\n    yield* Effect.logInfo(\n      \"Note: In production, spans would be sent to a tracing system like Jaeger or Zipkin\"\n    );\n\n    return user;\n  }).pipe(\n    // This is the parent span for the entire operation\n    Effect.withSpan(\"createUserOperation\")\n  );\n\n// Demonstrate the tracing functionality\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"=== Trace Operations with Spans Demo ===\");\n\n  // Create multiple users to show tracing in action\n  const user1 = yield* createUser({ email: \"user1@example.com\" });\n\n  yield* Effect.logInfo(\"\\n--- Creating second user ---\");\n  const user2 = yield* createUser({ email: \"user2@example.com\" });\n\n  yield* Effect.logInfo(\"\\n=== Summary ===\");\n  yield* Effect.logInfo(\"Created users with tracing spans:\");\n  yield* Effect.logInfo(`User 1: ID ${user1.id}, Email: ${user1.email}`);\n  yield* Effect.logInfo(`User 2: ID ${user2.id}, Email: ${user2.email}`);\n});\n\n// When run with a tracing SDK, this will produce traces with root spans\n// \"createUserOperation\" and child spans: \"validateInput\" and \"saveToDatabase\".\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.withSpan to create custom tracing spans for important operations."
            },
            "created_at": "2026-02-15T21:22:29.620338",
            "updated_at": "2026-02-20T23:09:42.773552"
        },
        {
            "id": "def6794f-d4ec-4871-b0f4-f9fafb7f777c",
            "slug": "observability-structured-logging",
            "title": "Leverage Effect's Built-in Structured Logging",
            "summary": "Use Effect's built-in logging functions for structured, configurable, and context-aware logging.",
            "skill_level": "intermediate",
            "category": "observability",
            "difficulty": "intermediate",
            "tags": [
                "logging",
                "observability",
                "debugging",
                "effect",
                "structured-logging"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\";\n\n// Log a simple message\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Starting the application\");\n});\n\n// Log at different levels\nconst infoProgram = Effect.gen(function* () {\n  yield* Effect.logInfo(\"User signed in\");\n});\n\nconst errorProgram = Effect.gen(function* () {\n  yield* Effect.logError(\"Failed to connect to database\");\n});\n\n// Log with dynamic values\nconst userId = 42;\nconst logUserProgram = Effect.gen(function* () {\n  yield* Effect.logInfo(`Processing user: ${userId}`);\n});\n\n// Use logging in a workflow\nconst workflow = Effect.gen(function* () {\n  yield* Effect.log(\"Beginning workflow\");\n  // ... do some work\n  yield* Effect.logInfo(\"Workflow step completed\");\n  // ... handle errors\n  yield* Effect.logError(\"Something went wrong\");\n});",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.log, Effect.logInfo, and Effect.logError to add structured, context-aware logging to your Effect code."
            },
            "created_at": "2026-02-15T21:22:29.454896",
            "updated_at": "2026-02-20T23:09:43.042767"
        },
        {
            "id": "0f180c73-a4a1-48eb-a9c9-41a896022e5a",
            "slug": "stream-from-file",
            "title": "Process a Large File with Constant Memory",
            "summary": "Create a data pipeline from a file on disk, processing it line-by-line without loading the entire file into memory.",
            "skill_level": "intermediate",
            "category": "building-data-pipelines",
            "difficulty": "intermediate",
            "tags": [
                "stream",
                "file",
                "memory",
                "performance",
                "node"
            ],
            "examples": [
                {
                    "code": "import { FileSystem } from \"@effect/platform\";\nimport { NodeFileSystem } from \"@effect/platform-node\";\nimport type { PlatformError } from \"@effect/platform/Error\";\nimport { Effect, Stream } from \"effect\";\nimport * as path from \"node:path\";\n\nconst processFile = (\n  filePath: string,\n  content: string\n): Effect.Effect<void, PlatformError, FileSystem.FileSystem> =>\n  Effect.gen(function* () {\n    const fs = yield* FileSystem.FileSystem;\n\n    // Write content to file\n    yield* fs.writeFileString(filePath, content);\n\n    // Create a STREAMING pipeline - reads file in chunks, not all at once\n    const fileStream = fs.readFile(filePath).pipe(\n      // Decode bytes to text\n      Stream.decodeText(\"utf-8\"),\n      // Split into lines\n      Stream.splitLines,\n      // Process each line\n      Stream.tap((line) => Effect.log(`Processing: ${line}`))\n    );\n\n    // Run the stream to completion\n    yield* Stream.runDrain(fileStream);\n\n    // Clean up file\n    yield* fs.remove(filePath);\n  });\n\nconst program = Effect.gen(function* () {\n  const filePath = path.join(__dirname, \"large-file.txt\");\n\n  yield* processFile(filePath, \"line 1\\nline 2\\nline 3\").pipe(\n    Effect.catchAll((error: PlatformError) =>\n      Effect.logError(`Error processing file: ${error.message}`)\n    )\n  );\n});\n\nEffect.runPromise(program.pipe(Effect.provide(NodeFileSystem.layer)));\n\n/*\nOutput:\n... level=INFO msg=\"Processing: line 1\"\n... level=INFO msg=\"Processing: line 2\"\n... level=INFO msg=\"Processing: line 3\"\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream.fromReadable with a Node.js Readable stream to process files efficiently."
            },
            "created_at": "2026-02-15T21:22:26.560675",
            "updated_at": "2026-02-20T23:09:43.36064"
        },
        {
            "id": "1541ada0-ffd4-4268-afcb-bcb709775f29",
            "slug": "stream-manage-resources",
            "title": "Manage Resources Safely in a Pipeline",
            "summary": "Ensure resources like file handles or connections are safely acquired at the start of a pipeline and always released at the end, even on failure.",
            "skill_level": "advanced",
            "category": "building-data-pipelines",
            "difficulty": "advanced",
            "tags": [
                "stream",
                "resource",
                "scope",
                "acquireRelease",
                "bracket",
                "safety",
                "file"
            ],
            "examples": [
                {
                    "code": "import { Effect, Layer } from \"effect\";\nimport { FileSystem } from \"@effect/platform/FileSystem\";\nimport { NodeFileSystem } from \"@effect/platform-node\";\nimport * as path from \"node:path\";\n\ninterface ProcessError {\n  readonly _tag: \"ProcessError\";\n  readonly message: string;\n}\n\nconst ProcessError = (message: string): ProcessError => ({\n  _tag: \"ProcessError\",\n  message,\n});\n\ninterface FileServiceType {\n  readonly createTempFile: () => Effect.Effect<{ filePath: string }, never>;\n  readonly cleanup: (filePath: string) => Effect.Effect<void, never>;\n  readonly readFile: (filePath: string) => Effect.Effect<string, never>;\n}\n\nexport class FileService extends Effect.Service<FileService>()(\"FileService\", {\n  sync: () => {\n    const filePath = path.join(__dirname, \"temp-resource.txt\");\n    return {\n      createTempFile: () => Effect.succeed({ filePath }),\n      cleanup: (filePath: string) =>\n        Effect.log(\"\u2705 Resource cleaned up successfully\"),\n      readFile: (filePath: string) =>\n        Effect.succeed(\"data 1\\ndata 2\\nFAIL\\ndata 4\"),\n    };\n  },\n}) {}\n\n// Process a single line\nconst processLine = (line: string): Effect.Effect<void, ProcessError> =>\n  line === \"FAIL\"\n    ? Effect.fail(ProcessError(\"Failed to process line\"))\n    : Effect.log(`Processed: ${line}`);\n\n// Create and process the file with proper resource management\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"=== Stream Resource Management Demo ===\");\n  yield* Effect.log(\n    \"This demonstrates proper resource cleanup even when errors occur\"\n  );\n\n  const fileService = yield* FileService;\n  const { filePath } = yield* fileService.createTempFile();\n\n  // Use scoped to ensure cleanup happens even on failure\n  yield* Effect.scoped(\n    Effect.gen(function* () {\n      yield* Effect.addFinalizer(() => fileService.cleanup(filePath));\n\n      const content = yield* fileService.readFile(filePath);\n      const lines = content.split(\"\\n\");\n\n      // Process each line, continuing even if some fail\n      for (const line of lines) {\n        yield* processLine(line).pipe(\n          Effect.catchAll((error) =>\n            Effect.log(`\u26a0\ufe0f  Skipped line due to error: ${error.message}`)\n          )\n        );\n      }\n\n      yield* Effect.log(\n        \"\u2705 Processing completed with proper resource management\"\n      );\n    })\n  );\n});\n\n// Run the program with FileService layer\nEffect.runPromise(Effect.provide(program, FileService.Default)).catch(\n  (error) => {\n    Effect.runSync(Effect.logError(\"Unexpected error: \" + error));\n  }\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream.acquireRelease to safely manage the lifecycle of a resource within a pipeline."
            },
            "created_at": "2026-02-15T21:22:27.242995",
            "updated_at": "2026-02-20T23:09:43.48668"
        },
        {
            "id": "5d924708-897d-4242-8a57-f0706cb20b6c",
            "slug": "stream-process-concurrently",
            "title": "Process Items Concurrently",
            "summary": "Perform an asynchronous action for each item in a stream with controlled parallelism to dramatically improve performance.",
            "skill_level": "intermediate",
            "category": "building-data-pipelines",
            "difficulty": "intermediate",
            "tags": [
                "stream",
                "concurrency",
                "performance",
                "mapEffect",
                "parallelism"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream } from \"effect\";\n\n// A mock function that simulates a slow I/O operation\nconst processItem = (id: number): Effect.Effect<string, Error> =>\n  Effect.log(`Starting item ${id}...`).pipe(\n    Effect.delay(\"1 second\"),\n    Effect.map(() => `Finished item ${id}`),\n    Effect.tap(Effect.log)\n  );\n\nconst ids = [1, 2, 3, 4];\n\nconst program = Stream.fromIterable(ids).pipe(\n  // Process up to 2 items concurrently\n  Stream.mapEffect(processItem, { concurrency: 2 }),\n  Stream.runDrain\n);\n\n// Measure the total time taken\nconst timedProgram = Effect.timed(program);\n\nconst programWithLogging = Effect.gen(function* () {\n  const [duration, _] = yield* timedProgram;\n  const durationMs = Number(duration);\n  yield* Effect.log(`\\nTotal time: ${Math.round(durationMs / 1000)} seconds`);\n  return duration;\n}).pipe(\n  Effect.catchAll((error) =>\n    Effect.gen(function* () {\n      yield* Effect.logError(`Program error: ${error}`);\n      return null;\n    })\n  )\n);\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\n... level=INFO msg=\"Starting item 1...\"\n... level=INFO msg=\"Starting item 2...\"\n... level=INFO msg=\"Finished item 1\"\n... level=INFO msg=\"Starting item 3...\"\n... level=INFO msg=\"Finished item 2\"\n... level=INFO msg=\"Starting item 4...\"\n... level=INFO msg=\"Finished item 3\"\n... level=INFO msg=\"Finished item 4\"\n\nTotal time: 2 seconds\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream.mapEffect with the `concurrency` option to process stream items in parallel."
            },
            "created_at": "2026-02-15T21:22:26.742802",
            "updated_at": "2026-02-20T23:09:43.607595"
        },
        {
            "id": "31f3c98d-cb76-4818-b5df-46ca1520b74c",
            "slug": "stream-pattern-backpressure-control",
            "title": "Stream Pattern 3: Control Backpressure in Streams",
            "summary": "Use Stream throttling, buffering, and chunk operations to manage backpressure, preventing upstream from overwhelming downstream consumers.",
            "skill_level": "intermediate",
            "category": "streams",
            "difficulty": "intermediate",
            "tags": [
                "streams",
                "backpressure",
                "buffering",
                "throttling",
                "flow-control",
                "performance"
            ],
            "examples": [
                {
                    "code": "import { Stream, Effect, Chunk } from \"effect\";\n\ninterface DataPoint {\n  readonly id: number;\n  readonly value: number;\n}\n\n// Fast producer: generates 100 items per second\nconst fastProducer = (): Stream.Stream<DataPoint> =>\n  Stream.fromIterable(Array.from({ length: 100 }, (_, i) => ({ id: i, value: Math.random() }))).pipe(\n    Stream.tap(() => Effect.sleep(\"10 millis\")) // 10ms per item = 100/sec\n  );\n\n// Slow consumer: processes 10 items per second\nconst slowConsumer = (item: DataPoint): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    yield* Effect.sleep(\"100 millis\"); // 100ms per item = 10/sec\n  });\n\n// Without backpressure (DANGEROUS - queue grows unbounded)\nconst unbufferedStream = (): Stream.Stream<DataPoint> =>\n  fastProducer().pipe(\n    Stream.tap((item) =>\n      Effect.log(`[UNBUFFERED] Produced item ${item.id}`)\n    )\n  );\n\n// With bounded buffer (backpressure kicks in)\nconst bufferedStream = (bufferSize: number): Stream.Stream<DataPoint> =>\n  fastProducer().pipe(\n    // Buffer at most 10 items; if full, producer waits\n    Stream.buffer(bufferSize),\n    Stream.tap((item) =>\n      Effect.log(`[BUFFERED] Consumed item ${item.id}`)\n    )\n  );\n\n// With throttling (rate limit emission)\nconst throttledStream = (): Stream.Stream<DataPoint> =>\n  fastProducer().pipe(\n    // Emit at most 1 item per 50ms (20/sec)\n    Stream.throttle(1, \"50 millis\"),\n    Stream.tap((item) =>\n      Effect.log(`[THROTTLED] Item ${item.id}`)\n    )\n  );\n\n// Main: compare approaches\nconst program = Effect.gen(function* () {\n  console.log(`\\n[START] Demonstrating backpressure management\\n`);\n\n  // Test buffered approach\n  console.log(`[TEST 1] Buffered stream (buffer size 5):\\n`);\n\n  const startBuffer = Date.now();\n\n  yield* bufferedStream(5).pipe(\n    Stream.take(20), // Take only 20 items\n    Stream.runForEach(slowConsumer)\n  );\n\n  const bufferTime = Date.now() - startBuffer;\n  console.log(`\\n[RESULT] Buffered approach took ${bufferTime}ms\\n`);\n\n  // Test throttled approach\n  console.log(`[TEST 2] Throttled stream (1 item per 50ms):\\n`);\n\n  const startThrottle = Date.now();\n\n  yield* throttledStream().pipe(\n    Stream.take(20),\n    Stream.runForEach(slowConsumer)\n  );\n\n  const throttleTime = Date.now() - startThrottle;\n  console.log(`\\n[RESULT] Throttled approach took ${throttleTime}ms\\n`);\n\n  // Summary\n  console.log(`[SUMMARY]`);\n  console.log(`  Without backpressure control:`);\n  console.log(`    - Queue would grow to 100 items (memory risk)`);\n  console.log(`    - Producer/consumer operate independently`);\n  console.log(`  With buffering:`);\n  console.log(`    - Queue bounded to 5 items (safe)`);\n  console.log(`    - Producer waits when buffer full`);\n  console.log(`  With throttling:`);\n  console.log(`    - Production rate limited to 20/sec`);\n  console.log(`    - Smooth controlled flow`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use backpressure control to manage flow between fast producers and slow consumers, preventing memory exhaustion and resource overflow."
            },
            "created_at": "2026-02-15T21:22:22.021199",
            "updated_at": "2026-02-20T23:09:44.273054"
        },
        {
            "id": "cb06ee74-9e17-44b3-ad0e-efe2c76a2bdc",
            "slug": "stream-pattern-merge-combine",
            "title": "Stream Pattern 2: Merge and Combine Multiple Streams",
            "summary": "Use Stream.merge, Stream.concat, and Stream.mergeAll to combine multiple streams into a single stream, enabling multi-source data aggregation.",
            "skill_level": "intermediate",
            "category": "streams",
            "difficulty": "intermediate",
            "tags": [
                "streams",
                "composition",
                "merge",
                "concat",
                "combination",
                "multi-source"
            ],
            "examples": [
                {
                    "code": "import { Stream, Effect, Chunk } from \"effect\";\n\ninterface Event {\n  readonly source: string;\n  readonly type: string;\n  readonly data: string;\n  readonly timestamp: Date;\n}\n\n// Create independent event streams from different sources\nconst createUserEventStream = (): Stream.Stream<Event> =>\n  Stream.fromIterable([\n    { source: \"user-service\", type: \"login\", data: \"user-123\", timestamp: new Date(Date.now() + 0) },\n    { source: \"user-service\", type: \"logout\", data: \"user-123\", timestamp: new Date(Date.now() + 500) },\n  ]).pipe(\n    Stream.tap(() => Effect.sleep(\"500 millis\"))\n  );\n\nconst createPaymentEventStream = (): Stream.Stream<Event> =>\n  Stream.fromIterable([\n    { source: \"payment-service\", type: \"payment-started\", data: \"order-456\", timestamp: new Date(Date.now() + 200) },\n    { source: \"payment-service\", type: \"payment-completed\", data: \"order-456\", timestamp: new Date(Date.now() + 800) },\n  ]).pipe(\n    Stream.tap(() => Effect.sleep(\"600 millis\"))\n  );\n\nconst createAuditEventStream = (): Stream.Stream<Event> =>\n  Stream.fromIterable([\n    { source: \"audit-log\", type: \"access-granted\", data: \"resource-789\", timestamp: new Date(Date.now() + 100) },\n    { source: \"audit-log\", type: \"access-revoked\", data: \"resource-789\", timestamp: new Date(Date.now() + 900) },\n  ]).pipe(\n    Stream.tap(() => Effect.sleep(\"800 millis\"))\n  );\n\n// Merge streams (interleaved, unordered)\nconst mergedEventStream = (): Stream.Stream<Event> => {\n  const userStream = createUserEventStream();\n  const paymentStream = createPaymentEventStream();\n  const auditStream = createAuditEventStream();\n\n  return Stream.merge(userStream, paymentStream, auditStream);\n};\n\n// Concat streams (sequential, ordered)\nconst concatenatedEventStream = (): Stream.Stream<Event> => {\n  return createUserEventStream().pipe(\n    Stream.concat(createPaymentEventStream()),\n    Stream.concat(createAuditEventStream())\n  );\n};\n\n// Main: Compare merge vs concat\nconst program = Effect.gen(function* () {\n  console.log(`\\n[MERGE] Interleaved events from multiple sources:\\n`);\n\n  // Collect merged stream\n  const mergedEvents = yield* mergedEventStream().pipe(\n    Stream.runCollect\n  );\n\n  Chunk.forEach(mergedEvents, (event, idx) => {\n    console.log(\n      `  ${idx + 1}. [${event.source}] ${event.type}: ${event.data}`\n    );\n  });\n\n  console.log(`\\n[CONCAT] Sequential events (user \u2192 payment \u2192 audit):\\n`);\n\n  // Collect concatenated stream\n  const concatEvents = yield* concatenatedEventStream().pipe(\n    Stream.runCollect\n  );\n\n  Chunk.forEach(concatEvents, (event, idx) => {\n    console.log(\n      `  ${idx + 1}. [${event.source}] ${event.type}: ${event.data}`\n    );\n  });\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use merge and concat combinators to combine multiple streams, enabling aggregation of data from multiple independent sources."
            },
            "created_at": "2026-02-15T21:22:21.935636",
            "updated_at": "2026-02-20T23:09:44.318236"
        },
        {
            "id": "9d596a4b-428b-40fe-90a7-60b4745f1bd4",
            "slug": "stream-vs-effect",
            "title": "Stream vs Effect - When to Use Which",
            "summary": "Understand when to use Effect (single value) vs Stream (sequence of values) for your use case.",
            "skill_level": "beginner",
            "category": "streams",
            "difficulty": "beginner",
            "tags": [
                "stream",
                "effect",
                "comparison",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream } from \"effect\"\n\n// ============================================\n// EFFECT: Single result operations\n// ============================================\n\n// Fetch one user - returns Effect<User>\nconst fetchUser = (id: string) =>\n  Effect.tryPromise(() =>\n    fetch(`/api/users/${id}`).then((r) => r.json())\n  )\n\n// Read entire config - returns Effect<Config>\nconst loadConfig = Effect.tryPromise(() =>\n  fetch(\"/config.json\").then((r) => r.json())\n)\n\n// ============================================\n// STREAM: Multiple values operations\n// ============================================\n\n// Process file line by line - returns Stream<string>\nconst fileLines = Stream.fromIterable([\n  \"line 1\",\n  \"line 2\",\n  \"line 3\",\n])\n\n// Generate events over time - returns Stream<Event>\nconst events = Stream.make(\n  { type: \"click\", x: 10 },\n  { type: \"click\", x: 20 },\n  { type: \"scroll\", y: 100 },\n)\n\n// ============================================\n// CONVERTING BETWEEN THEM\n// ============================================\n\n// Effect \u2192 Stream (single value becomes 1-element stream)\nconst effectToStream = Stream.fromEffect(fetchUser(\"123\"))\n\n// Stream \u2192 Effect (collect all values into array)\nconst streamToEffect = Stream.runCollect(fileLines)\n\n// Stream \u2192 Effect (process each value for side effects)\nconst processAll = fileLines.pipe(\n  Stream.runForEach((line) => Effect.log(`Processing: ${line}`))\n)\n\n// ============================================\n// DECISION GUIDE\n// ============================================\n\n// Use Effect when:\n// - Fetching a single resource\n// - Computing a single result\n// - Performing one action\n\n// Use Stream when:\n// - Reading files line by line\n// - Processing paginated API results\n// - Handling real-time events\n// - Processing large datasets\n// - Building data pipelines",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect for single values, Stream for sequences of values."
            },
            "created_at": "2026-02-15T21:22:21.179822",
            "updated_at": "2026-02-20T23:09:44.609548"
        },
        {
            "id": "78f39e37-0872-43ba-a955-34b7d0453274",
            "slug": "sink-pattern-retry-failed-stream-operations",
            "title": "Sink Pattern 6: Retry Failed Stream Operations",
            "summary": "Use Sink with configurable retry policies to automatically retry failed operations with exponential backoff, enabling recovery from transient failures without losing data.",
            "skill_level": "intermediate",
            "category": "streams",
            "difficulty": "intermediate",
            "tags": [
                "sink",
                "stream",
                "error-handling",
                "retry",
                "exponential-backoff",
                "resilience"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Sink, Chunk, Duration, Schedule } from \"effect\";\n\ninterface UserRecord {\n  readonly userId: string;\n  readonly name: string;\n  readonly email: string;\n}\n\nclass WriteError extends Error {\n  readonly isTransient: boolean;\n\n  constructor(message: string, isTransient: boolean = true) {\n    super(message);\n    this.name = \"WriteError\";\n    this.isTransient = isTransient;\n  }\n}\n\n// Mock database that occasionally fails\nconst database = {\n  failureRate: 0.3, // 30% transient failure rate\n  permanentFailureRate: 0.05, // 5% permanent failure rate\n\n  insertUser: (user: UserRecord): Effect.Effect<void, WriteError> =>\n    Effect.gen(function* () {\n      const rand = Math.random();\n\n      // Permanent failure (e.g., constraint violation)\n      if (rand < database.permanentFailureRate) {\n        throw new WriteError(\n          `Permanent: User ${user.userId} already exists`,\n          false\n        );\n      }\n\n      // Transient failure (e.g., connection timeout)\n      if (rand < database.permanentFailureRate + database.failureRate) {\n        throw new WriteError(\n          `Transient: Connection timeout writing ${user.userId}`,\n          true\n        );\n      }\n\n      // Success\n      console.log(`\u2713 Wrote user ${user.userId}`);\n    }),\n};\n\n// Retry configuration\ninterface RetryConfig {\n  readonly maxAttempts: number;\n  readonly initialDelayMs: number;\n  readonly maxDelayMs: number;\n  readonly backoffFactor: number;\n}\n\nconst defaultRetryConfig: RetryConfig = {\n  maxAttempts: 5,\n  initialDelayMs: 100, // Start with 100ms\n  maxDelayMs: 5000, // Cap at 5 seconds\n  backoffFactor: 2, // Double each time\n};\n\n// Result tracking\ninterface OperationResult {\n  readonly succeeded: number;\n  readonly transientFailures: number;\n  readonly permanentFailures: number;\n  readonly detailedStats: Array<{\n    readonly userId: string;\n    readonly attempts: number;\n    readonly status: \"success\" | \"transient-failed\" | \"permanent-failed\";\n  }>;\n}\n\n// Create a sink with retry logic\nconst createRetrySink = (config: RetryConfig): Sink.Sink<OperationResult, never, UserRecord> =>\n  Sink.fold(\n    {\n      succeeded: 0,\n      transientFailures: 0,\n      permanentFailures: 0,\n      detailedStats: [],\n    },\n    (state, user) =>\n      Effect.gen(function* () {\n        let lastError: WriteError | null = null;\n        let attempts = 0;\n\n        // Retry loop\n        for (attempts = 1; attempts <= config.maxAttempts; attempts++) {\n          try {\n            yield* database.insertUser(user);\n\n            // Success!\n            console.log(\n              `[${user.userId}] Success on attempt ${attempts}/${config.maxAttempts}`\n            );\n\n            return {\n              ...state,\n              succeeded: state.succeeded + 1,\n              detailedStats: [\n                ...state.detailedStats,\n                {\n                  userId: user.userId,\n                  attempts,\n                  status: \"success\",\n                },\n              ],\n            };\n          } catch (error) {\n            lastError = error as WriteError;\n\n            if (!lastError.isTransient) {\n              // Permanent failure, don't retry\n              console.log(\n                `[${user.userId}] Permanent failure: ${lastError.message}`\n              );\n\n              return {\n                ...state,\n                permanentFailures: state.permanentFailures + 1,\n                detailedStats: [\n                  ...state.detailedStats,\n                  {\n                    userId: user.userId,\n                    attempts,\n                    status: \"permanent-failed\",\n                  },\n                ],\n              };\n            }\n\n            // Transient failure, retry if attempts remain\n            if (attempts < config.maxAttempts) {\n              // Calculate delay with exponential backoff\n              let delayMs = config.initialDelayMs * Math.pow(config.backoffFactor, attempts - 1);\n              delayMs = Math.min(delayMs, config.maxDelayMs);\n\n              // Add jitter (\u00b110%)\n              const jitter = delayMs * 0.1;\n              delayMs = delayMs + (Math.random() - 0.5) * 2 * jitter;\n\n              console.log(\n                `[${user.userId}] Transient failure (attempt ${attempts}/${config.maxAttempts}): ${lastError.message}`\n              );\n              console.log(`  Retrying in ${Math.round(delayMs)}ms...`);\n\n              yield* Effect.sleep(Duration.millis(Math.round(delayMs)));\n            }\n          }\n        }\n\n        // All retries exhausted\n        console.log(\n          `[${user.userId}] Failed after ${config.maxAttempts} attempts`\n        );\n\n        return {\n          ...state,\n          transientFailures: state.transientFailures + 1,\n          detailedStats: [\n            ...state.detailedStats,\n            {\n              userId: user.userId,\n              attempts: config.maxAttempts,\n              status: \"transient-failed\",\n            },\n          ],\n        };\n      }),\n    (state) =>\n      Effect.gen(function* () {\n        console.log(`\\n[SUMMARY]`);\n        console.log(`  Succeeded:           ${state.succeeded}`);\n        console.log(`  Transient Failures:  ${state.transientFailures}`);\n        console.log(`  Permanent Failures:  ${state.permanentFailures}`);\n        console.log(`  Total:               ${state.detailedStats.length}`);\n\n        // Show detailed stats\n        const failed = state.detailedStats.filter((s) => s.status !== \"success\");\n        if (failed.length > 0) {\n          console.log(`\\n[FAILURES]`);\n          failed.forEach((stat) => {\n            console.log(\n              `  ${stat.userId}: ${stat.attempts} attempts (${stat.status})`\n            );\n          });\n        }\n\n        return state;\n      })\n  );\n\n// Simulate a stream of users to insert\nconst userStream: Stream.Stream<UserRecord> = Stream.fromIterable([\n  { userId: \"user-1\", name: \"Alice\", email: \"alice@example.com\" },\n  { userId: \"user-2\", name: \"Bob\", email: \"bob@example.com\" },\n  { userId: \"user-3\", name: \"Charlie\", email: \"charlie@example.com\" },\n  { userId: \"user-4\", name: \"Diana\", email: \"diana@example.com\" },\n  { userId: \"user-5\", name: \"Eve\", email: \"eve@example.com\" },\n]);\n\n// Run the stream with retry sink\nconst program = Effect.gen(function* () {\n  const result = yield* userStream.pipe(Stream.run(createRetrySink(defaultRetryConfig)));\n  console.log(`\\nProcessing complete.`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Implement retry strategies in sinks to handle transient failures and improve resilience without manual intervention."
            },
            "created_at": "2026-02-15T21:22:21.853841",
            "updated_at": "2026-02-20T23:09:44.754266"
        },
        {
            "id": "7ea19d13-2338-4f3c-ba26-d3202836cc66",
            "slug": "sink-pattern-send-stream-records-to-message-queue",
            "title": "Sink Pattern 4: Send Stream Records to Message Queue",
            "summary": "Use Sink to publish stream records to a message queue with partitioning, batching, and acknowledgment handling for distributed systems.",
            "skill_level": "intermediate",
            "category": "streams",
            "difficulty": "intermediate",
            "tags": [
                "sink",
                "stream",
                "message-queue",
                "persistence",
                "kafka",
                "pubsub",
                "distributed-systems"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Sink, Chunk } from \"effect\";\n\ninterface SensorReading {\n  readonly sensorId: string;\n  readonly location: string;\n  readonly temperature: number;\n  readonly humidity: number;\n  readonly timestamp: number;\n}\n\n// Mock message queue publisher\ninterface QueuePublisher {\n  readonly publish: (\n    topic: string,\n    partition: string,\n    messages: readonly SensorReading[]\n  ) => Effect.Effect<{ acknowledged: number; messageIds: string[] }>;\n}\n\n// Create a mock queue publisher\nconst createMockPublisher = (): QueuePublisher => {\n  const publishedMessages: Record<string, SensorReading[]> = {};\n\n  return {\n    publish: (topic, partition, messages) =>\n      Effect.gen(function* () {\n        const key = `${topic}/${partition}`;\n        publishedMessages[key] = [\n          ...(publishedMessages[key] ?? []),\n          ...messages,\n        ];\n\n        const messageIds = Array.from({ length: messages.length }, (_, i) =>\n          `msg-${Date.now()}-${i}`\n        );\n\n        console.log(\n          `Published ${messages.length} messages to ${key} (batch)`\n        );\n\n        return { acknowledged: messages.length, messageIds };\n      }),\n  };\n};\n\n// Determine the partition key based on sensor location\nconst getPartitionKey = (reading: SensorReading): string =>\n  reading.location; // Route by location for data locality\n\n// Simulate a stream of sensor readings\nconst sensorStream: Stream.Stream<SensorReading> = Stream.fromIterable([\n  {\n    sensorId: \"temp-1\",\n    location: \"warehouse-a\",\n    temperature: 22.5,\n    humidity: 45,\n    timestamp: Date.now(),\n  },\n  {\n    sensorId: \"temp-2\",\n    location: \"warehouse-b\",\n    temperature: 21.0,\n    humidity: 50,\n    timestamp: Date.now() + 100,\n  },\n  {\n    sensorId: \"temp-3\",\n    location: \"warehouse-a\",\n    temperature: 22.8,\n    humidity: 46,\n    timestamp: Date.now() + 200,\n  },\n  {\n    sensorId: \"temp-4\",\n    location: \"warehouse-c\",\n    temperature: 20.5,\n    humidity: 55,\n    timestamp: Date.now() + 300,\n  },\n  {\n    sensorId: \"temp-5\",\n    location: \"warehouse-b\",\n    temperature: 21.2,\n    humidity: 51,\n    timestamp: Date.now() + 400,\n  },\n  {\n    sensorId: \"temp-6\",\n    location: \"warehouse-a\",\n    temperature: 23.0,\n    humidity: 47,\n    timestamp: Date.now() + 500,\n  },\n]);\n\n// Create a sink that batches and publishes to message queue\nconst createQueuePublishSink = (\n  publisher: QueuePublisher,\n  topic: string,\n  batchSize: number = 100\n): Sink.Sink<number, Error, SensorReading> =>\n  Sink.fold(\n    { batches: new Map<string, SensorReading[]>(), totalPublished: 0 },\n    (state, reading) =>\n      Effect.gen(function* () {\n        const partition = getPartitionKey(reading);\n        const batch = state.batches.get(partition) ?? [];\n        const newBatch = [...batch, reading];\n\n        if (newBatch.length >= batchSize) {\n          // Batch is full, publish it\n          const result = yield* publisher.publish(topic, partition, newBatch);\n          const newState = new Map(state.batches);\n          newState.delete(partition);\n\n          return {\n            ...state,\n            batches: newState,\n            totalPublished: state.totalPublished + result.acknowledged,\n          };\n        } else {\n          // Add to batch and continue\n          const newState = new Map(state.batches);\n          newState.set(partition, newBatch);\n\n          return { ...state, batches: newState };\n        }\n      }),\n    (state) =>\n      Effect.gen(function* () {\n        let finalCount = state.totalPublished;\n\n        // Publish any remaining partial batches\n        for (const [partition, batch] of state.batches) {\n          if (batch.length > 0) {\n            const result = yield* publisher.publish(topic, partition, batch);\n            finalCount += result.acknowledged;\n          }\n        }\n\n        return finalCount;\n      })\n  );\n\n// Run the stream and publish to queue\nconst program = Effect.gen(function* () {\n  const publisher = createMockPublisher();\n  const topic = \"sensor-readings\";\n\n  const published = yield* sensorStream.pipe(\n    Stream.run(createQueuePublishSink(publisher, topic, 50)) // Batch size of 50\n  );\n\n  console.log(\n    `\\nTotal messages published to queue: ${published}`\n  );\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Stream records to message queues with proper batching and acknowledgment for reliable distributed data flow."
            },
            "created_at": "2026-02-15T21:22:21.680615",
            "updated_at": "2026-02-20T23:09:44.882121"
        },
        {
            "id": "c71bac23-9276-46b6-b04c-947696778dec",
            "slug": "scheduling-pattern-cron-expressions",
            "title": "Scheduling Pattern 3: Schedule Tasks with Cron Expressions",
            "summary": "Use cron expressions to schedule tasks at specific times and intervals, enabling calendar-based scheduling with timezone support.",
            "skill_level": "intermediate",
            "category": "scheduling",
            "difficulty": "intermediate",
            "tags": [
                "scheduling",
                "cron",
                "periodic-tasks",
                "time-based",
                "background-jobs",
                "timezone"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule, Console } from \"effect\";\nimport { DateTime } from \"luxon\"; // For timezone handling\n\ninterface ReportConfig {\n  readonly cronExpression: string;\n  readonly timezone?: string;\n  readonly jobName: string;\n}\n\ninterface ScheduledReport {\n  readonly timestamp: Date;\n  readonly jobName: string;\n  readonly result: string;\n}\n\n// Simple cron parser (in production, use a library like cron-parser)\nconst parseCronExpression = (\n  expression: string\n): {\n  minute: number[];\n  hour: number[];\n  dayOfMonth: number[];\n  month: number[];\n  dayOfWeek: number[];\n} => {\n  const parts = expression.split(\" \");\n\n  const parseField = (field: string, max: number): number[] => {\n    if (field === \"*\") {\n      return Array.from({ length: max + 1 }, (_, i) => i);\n    }\n\n    if (field.includes(\",\")) {\n      return field.split(\",\").flatMap((part) => parseField(part, max));\n    }\n\n    if (field.includes(\"-\")) {\n      const [start, end] = field.split(\"-\").map(Number);\n      return Array.from({ length: end - start + 1 }, (_, i) => start + i);\n    }\n\n    return [Number(field)];\n  };\n\n  return {\n    minute: parseField(parts[0], 59),\n    hour: parseField(parts[1], 23),\n    dayOfMonth: parseField(parts[2], 31),\n    month: parseField(parts[3], 12),\n    dayOfWeek: parseField(parts[4], 6),\n  };\n};\n\n// Check if current time matches cron expression\nconst shouldRunNow = (parsed: ReturnType<typeof parseCronExpression>): boolean => {\n  const now = new Date();\n\n  return (\n    parsed.minute.includes(now.getUTCMinutes()) &&\n    parsed.hour.includes(now.getUTCHours()) &&\n    parsed.dayOfMonth.includes(now.getUTCDate()) &&\n    parsed.month.includes(now.getUTCMonth() + 1) &&\n    parsed.dayOfWeek.includes(now.getUTCDay())\n  );\n};\n\n// Generate a report\nconst generateReport = (jobName: string): Effect.Effect<ScheduledReport> =>\n  Effect.gen(function* () {\n    yield* Console.log(`[REPORT] Generating ${jobName}...`);\n\n    // Simulate report generation\n    yield* Effect.sleep(\"100 millis\");\n\n    return {\n      timestamp: new Date(),\n      jobName,\n      result: `Report generated at ${new Date().toISOString()}`,\n    };\n  });\n\n// Schedule with cron expression\nconst scheduleWithCron = (config: ReportConfig) =>\n  Effect.gen(function* () {\n    const parsed = parseCronExpression(config.cronExpression);\n\n    yield* Console.log(\n      `[SCHEDULER] Scheduling job: ${config.jobName}`\n    );\n    yield* Console.log(`[SCHEDULER] Cron: ${config.cronExpression}`);\n    yield* Console.log(`[SCHEDULER] Timezone: ${config.timezone || \"UTC\"}\\n`);\n\n    // Create schedule that checks every minute\n    const schedule = Schedule.fixed(\"1 minute\").pipe(\n      Schedule.untilInputEffect((report: ScheduledReport) =>\n        Effect.gen(function* () {\n          const isPastTime = shouldRunNow(parsed);\n\n          if (isPastTime) {\n            yield* Console.log(\n              `[SCHEDULED] \u2713 Running at ${report.timestamp.toISOString()}`\n            );\n            return true; // Stop scheduling\n          }\n\n          return false; // Continue scheduling\n        })\n      )\n    );\n\n    // Generate report with cron schedule\n    yield* generateReport(config.jobName).pipe(\n      Effect.repeat(schedule)\n    );\n  });\n\n// Demonstrate multiple cron schedules\nconst program = Effect.gen(function* () {\n  console.log(\n    `\\n[START] Scheduling multiple jobs with cron expressions\\n`\n  );\n\n  // Schedule examples (note: in real app, these would run at actual times)\n  const jobs = [\n    {\n      cronExpression: \"0 9 * * 1-5\", // 9 AM weekdays\n      jobName: \"Daily Standup Report\",\n      timezone: \"America/New_York\",\n    },\n    {\n      cronExpression: \"0 0 * * *\", // Midnight daily\n      jobName: \"Nightly Backup\",\n      timezone: \"UTC\",\n    },\n    {\n      cronExpression: \"0 0 1 * *\", // Midnight on 1st of month\n      jobName: \"Monthly Summary\",\n      timezone: \"Europe/London\",\n    },\n  ];\n\n  yield* Console.log(\"[JOBS] Scheduled:\");\n  jobs.forEach((job) => {\n    console.log(\n      `  - ${job.jobName}: ${job.cronExpression} (${job.timezone})`\n    );\n  });\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use cron expressions to schedule periodic tasks at specific calendar times, enabling flexible scheduling beyond simple fixed intervals."
            },
            "created_at": "2026-02-15T21:22:23.443161",
            "updated_at": "2026-02-20T23:09:45.147759"
        },
        {
            "id": "93813be8-5825-419c-865f-e19eb63b6fb8",
            "slug": "scheduling-pattern-repeat-effect-on-fixed-interval",
            "title": "Scheduling Pattern 1: Repeat an Effect on a Fixed Interval",
            "summary": "Use Schedule.fixed to repeat an effect at regular intervals, enabling polling, health checks, and periodic background tasks without busy-waiting or manual timing logic.",
            "skill_level": "intermediate",
            "category": "scheduling",
            "difficulty": "intermediate",
            "tags": [
                "scheduling",
                "repetition",
                "polling",
                "health-check",
                "background-task",
                "interval"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule, Duration } from \"effect\";\n\ninterface ServiceStatus {\n  readonly service: string;\n  readonly url: string;\n  readonly isHealthy: boolean;\n  readonly responseTime: number;\n  readonly lastChecked: number;\n}\n\n// Mock health check that calls an endpoint\nconst checkServiceHealth = (\n  url: string,\n  service: string\n): Effect.Effect<ServiceStatus> =>\n  Effect.gen(function* () {\n    const startTime = Date.now();\n\n    // Simulate HTTP call with occasional failures\n    const isHealthy = Math.random() > 0.1; // 90% success rate\n    const responseTime = Math.random() * 500; // 0-500ms\n\n    yield* Effect.sleep(Duration.millis(Math.round(responseTime)));\n\n    if (!isHealthy) {\n      yield* Effect.fail(new Error(`${service} is unhealthy`));\n    }\n\n    return {\n      service,\n      url,\n      isHealthy: true,\n      responseTime: Math.round(Date.now() - startTime),\n      lastChecked: Date.now(),\n    };\n  });\n\n// Health check for multiple services\ninterface HealthCheckConfig {\n  readonly services: Array<{\n    readonly name: string;\n    readonly url: string;\n  }>;\n  readonly intervalSeconds: number;\n}\n\n// Keep track of service status\nconst serviceStatuses = new Map<string, ServiceStatus>();\n\n// Check all services and report status\nconst checkAllServices = (\n  config: HealthCheckConfig\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    for (const service of config.services) {\n      const status = yield* checkServiceHealth(service.url, service.name).pipe(\n        Effect.either\n      );\n\n      if (status._tag === \"Right\") {\n        serviceStatuses.set(service.name, status.right);\n        console.log(\n          `\u2713 ${service.name}: OK (${status.right.responseTime}ms)`\n        );\n      } else {\n        console.log(`\u2717 ${service.name}: FAILED`);\n        // Keep last known status if available\n      }\n    }\n  });\n\n// Create the repeating health check\nconst createHealthCheckScheduler = (\n  config: HealthCheckConfig\n): Effect.Effect<void> =>\n  checkAllServices(config).pipe(\n    // Schedule with fixed interval (fixed = ignore execution time)\n    Effect.repeat(\n      Schedule.fixed(Duration.seconds(config.intervalSeconds))\n    )\n  );\n\n// Report current status\nconst reportStatus = (): Effect.Effect<void> =>\n  Effect.sync(() => {\n    if (serviceStatuses.size === 0) {\n      console.log(\"\\n[STATUS] No services checked yet\");\n      return;\n    }\n\n    console.log(\"\\n[STATUS REPORT]\");\n    for (const [service, status] of serviceStatuses) {\n      const ago = Math.round((Date.now() - status.lastChecked) / 1000);\n      console.log(\n        `  ${service}: ${status.isHealthy ? \"\u2713\" : \"\u2717\"} (checked ${ago}s ago)`\n      );\n    }\n  });\n\n// Run health checker in background and check status periodically\nconst program = Effect.gen(function* () {\n  const config: HealthCheckConfig = {\n    services: [\n      { name: \"API\", url: \"https://api.example.com/health\" },\n      { name: \"Database\", url: \"https://db.example.com/health\" },\n      { name: \"Cache\", url: \"https://cache.example.com/health\" },\n    ],\n    intervalSeconds: 5, // Check every 5 seconds\n  };\n\n  // Fork the health checker to run in background\n  const checker = yield* createHealthCheckScheduler(config).pipe(\n    Effect.fork\n  );\n\n  // Check and report status every 15 seconds for 60 seconds\n  yield* reportStatus().pipe(\n    Effect.repeat(\n      Schedule.addDelay(\n        Schedule.recurs(3), // 3 repetitions = 4 total (initial + 3)\n        () => Duration.seconds(15)\n      )\n    )\n  );\n\n  // Interrupt the background checker\n  yield* checker.interrupt();\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Repeat effects at fixed intervals using Schedule.fixed for steady-state operations and background tasks."
            },
            "created_at": "2026-02-15T21:22:23.351525",
            "updated_at": "2026-02-20T23:09:45.231896"
        },
        {
            "id": "09a26c3b-10d2-4e95-8cde-390cf1bb75e7",
            "slug": "http-rate-limit-handling",
            "title": "Handle Rate Limiting Responses",
            "summary": "Gracefully handle 429 responses and respect API rate limits.",
            "skill_level": "intermediate",
            "category": "making-http-requests",
            "difficulty": "intermediate",
            "tags": [
                "http",
                "rate-limiting",
                429,
                "resilience"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule, Duration, Data, Ref } from \"effect\"\nimport { HttpClient, HttpClientResponse } from \"@effect/platform\"\n\n// ============================================\n// 1. Rate limit error type\n// ============================================\n\nclass RateLimitedError extends Data.TaggedError(\"RateLimitedError\")<{\n  readonly retryAfter: number\n  readonly limit: number | undefined\n  readonly remaining: number | undefined\n  readonly reset: number | undefined\n}> {}\n\n// ============================================\n// 2. Parse rate limit headers\n// ============================================\n\ninterface RateLimitInfo {\n  readonly retryAfter: number\n  readonly limit?: number\n  readonly remaining?: number\n  readonly reset?: number\n}\n\nconst parseRateLimitHeaders = (headers: Record<string, string>): RateLimitInfo => {\n  // Parse Retry-After (seconds or date)\n  const retryAfterHeader = headers[\"retry-after\"]\n  let retryAfter = 60  // Default 60 seconds\n\n  if (retryAfterHeader) {\n    const parsed = parseInt(retryAfterHeader, 10)\n    if (!isNaN(parsed)) {\n      retryAfter = parsed\n    } else {\n      // Try parsing as date\n      const date = Date.parse(retryAfterHeader)\n      if (!isNaN(date)) {\n        retryAfter = Math.max(0, Math.ceil((date - Date.now()) / 1000))\n      }\n    }\n  }\n\n  return {\n    retryAfter,\n    limit: headers[\"x-ratelimit-limit\"] ? parseInt(headers[\"x-ratelimit-limit\"], 10) : undefined,\n    remaining: headers[\"x-ratelimit-remaining\"] ? parseInt(headers[\"x-ratelimit-remaining\"], 10) : undefined,\n    reset: headers[\"x-ratelimit-reset\"] ? parseInt(headers[\"x-ratelimit-reset\"], 10) : undefined,\n  }\n}\n\n// ============================================\n// 3. HTTP client with rate limit handling\n// ============================================\n\nconst makeRateLimitAwareClient = Effect.gen(function* () {\n  const httpClient = yield* HttpClient.HttpClient\n\n  return {\n    get: <T>(url: string) =>\n      Effect.gen(function* () {\n        const response = yield* httpClient.get(url)\n\n        if (response.status === 429) {\n          const rateLimitInfo = parseRateLimitHeaders(response.headers)\n\n          yield* Effect.log(\n            `Rate limited. Retry after ${rateLimitInfo.retryAfter}s`\n          )\n\n          return yield* Effect.fail(new RateLimitedError({\n            retryAfter: rateLimitInfo.retryAfter,\n            limit: rateLimitInfo.limit,\n            remaining: rateLimitInfo.remaining,\n            reset: rateLimitInfo.reset,\n          }))\n        }\n\n        return yield* HttpClientResponse.json(response) as Effect.Effect<T>\n      }).pipe(\n        Effect.retry({\n          schedule: Schedule.recurWhile<RateLimitedError>(\n            (e) => e._tag === \"RateLimitedError\"\n          ).pipe(\n            Schedule.intersect(Schedule.recurs(3)),\n            Schedule.delayed((_, error) =>\n              Duration.seconds(error.retryAfter + 1)  // Add 1s buffer\n            )\n          ),\n          while: (error) => error._tag === \"RateLimitedError\",\n        })\n      ),\n  }\n})\n\n// ============================================\n// 4. Proactive rate limiting (client-side)\n// ============================================\n\ninterface RateLimiter {\n  readonly acquire: () => Effect.Effect<void>\n  readonly release: () => Effect.Effect<void>\n}\n\nconst makeClientRateLimiter = (requestsPerSecond: number) =>\n  Effect.gen(function* () {\n    const tokens = yield* Ref.make(requestsPerSecond)\n    const interval = 1000 / requestsPerSecond\n\n    // Refill tokens periodically\n    yield* Effect.fork(\n      Effect.forever(\n        Effect.gen(function* () {\n          yield* Effect.sleep(Duration.millis(interval))\n          yield* Ref.update(tokens, (n) => Math.min(n + 1, requestsPerSecond))\n        })\n      )\n    )\n\n    const limiter: RateLimiter = {\n      acquire: () =>\n        Effect.gen(function* () {\n          let acquired = false\n          while (!acquired) {\n            const current = yield* Ref.get(tokens)\n            if (current > 0) {\n              yield* Ref.update(tokens, (n) => n - 1)\n              acquired = true\n            } else {\n              yield* Effect.sleep(Duration.millis(interval))\n            }\n          }\n        }),\n\n      release: () => Ref.update(tokens, (n) => Math.min(n + 1, requestsPerSecond)),\n    }\n\n    return limiter\n  })\n\n// ============================================\n// 5. Combined client\n// ============================================\n\nconst makeRobustHttpClient = (requestsPerSecond: number) =>\n  Effect.gen(function* () {\n    const httpClient = yield* HttpClient.HttpClient\n    const rateLimiter = yield* makeClientRateLimiter(requestsPerSecond)\n\n    return {\n      get: <T>(url: string) =>\n        Effect.gen(function* () {\n          // Wait for rate limiter token\n          yield* rateLimiter.acquire()\n\n          const response = yield* httpClient.get(url)\n\n          if (response.status === 429) {\n            const info = parseRateLimitHeaders(response.headers)\n            yield* Effect.log(`Server rate limit hit, waiting ${info.retryAfter}s`)\n            yield* Effect.sleep(Duration.seconds(info.retryAfter))\n            return yield* Effect.fail(new Error(\"Rate limited\"))\n          }\n\n          return yield* HttpClientResponse.json(response) as Effect.Effect<T>\n        }).pipe(\n          Effect.retry(\n            Schedule.exponential(\"1 second\").pipe(\n              Schedule.intersect(Schedule.recurs(3))\n            )\n          )\n        ),\n    }\n  })\n\n// ============================================\n// 6. Batch requests to stay under limits\n// ============================================\n\nconst batchRequests = <T>(\n  urls: string[],\n  requestsPerSecond: number\n) =>\n  Effect.gen(function* () {\n    const httpClient = yield* HttpClient.HttpClient\n    const results: T[] = []\n    const interval = 1000 / requestsPerSecond\n\n    for (const url of urls) {\n      const response = yield* httpClient.get(url)\n      const data = yield* HttpClientResponse.json(response) as Effect.Effect<T>\n      results.push(data)\n\n      // Wait between requests\n      if (urls.indexOf(url) < urls.length - 1) {\n        yield* Effect.sleep(Duration.millis(interval))\n      }\n    }\n\n    return results\n  })\n\n// ============================================\n// 7. Usage\n// ============================================\n\nconst program = Effect.gen(function* () {\n  const client = yield* makeRateLimitAwareClient\n\n  yield* Effect.log(\"Making rate-limited request...\")\n\n  const data = yield* client.get(\"https://api.example.com/data\").pipe(\n    Effect.catchTag(\"RateLimitedError\", (error) =>\n      Effect.gen(function* () {\n        yield* Effect.log(`Gave up after rate limiting. Limit: ${error.limit}`)\n        return { error: \"rate_limited\" }\n      })\n    )\n  )\n\n  yield* Effect.log(`Result: ${JSON.stringify(data)}`)\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Detect 429 responses and automatically retry after the Retry-After period."
            },
            "created_at": "2026-02-15T21:22:27.742983",
            "updated_at": "2026-02-20T23:09:45.36865"
        },
        {
            "id": "a980be06-b2a0-4bee-8197-55c8878a894a",
            "slug": "build-a-basic-http-server",
            "title": "Build a Basic HTTP Server",
            "summary": "Combine Layer, Runtime, and Effect to create a simple, robust HTTP server using Node.js's built-in http module.",
            "skill_level": "advanced",
            "category": "making-http-requests",
            "difficulty": "advanced",
            "tags": [
                "http",
                "server",
                "api",
                "runtime",
                "layer",
                "end-to-end"
            ],
            "examples": [
                {
                    "code": "import { HttpServer, HttpServerResponse } from \"@effect/platform\";\nimport { NodeHttpServer } from \"@effect/platform-node\";\nimport { Duration, Effect, Fiber, Layer } from \"effect\";\nimport { createServer } from \"node:http\";\n\n// Create a server layer using Node's built-in HTTP server\nconst ServerLive = NodeHttpServer.layer(() => createServer(), { port: 3001 });\n\n// Define your HTTP app (here responding \"Hello World\" to every request)\nconst app = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Received HTTP request\");\n  return yield* HttpServerResponse.text(\"Hello World\");\n});\n\nconst serverLayer = HttpServer.serve(app).pipe(Layer.provide(ServerLive));\n\nconst program = Effect.gen(function* () {\n  yield* Effect.logInfo(\"Server starting on http://localhost:3001\");\n  const fiber = yield* Layer.launch(serverLayer).pipe(Effect.fork);\n  yield* Effect.sleep(Duration.seconds(2));\n  yield* Fiber.interrupt(fiber);\n  yield* Effect.logInfo(\"Server shutdown complete\");\n});\n\nEffect.runPromise(program as unknown as Effect.Effect<void, unknown, never>);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use a managed Runtime created from a Layer to handle requests in a Node.js HTTP server."
            },
            "created_at": "2026-02-15T21:22:28.073565",
            "updated_at": "2026-02-20T23:09:45.57262"
        },
        {
            "id": "3d5ac877-a9ad-4dbd-81ff-c92ce313a729",
            "slug": "http-json-responses",
            "title": "Parse JSON Responses Safely",
            "summary": "Use Effect Schema to validate and parse HTTP JSON responses with type safety.",
            "skill_level": "beginner",
            "category": "making-http-requests",
            "difficulty": "beginner",
            "tags": [
                "http",
                "json",
                "schema",
                "validation",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Console } from \"effect\"\nimport { Schema } from \"effect\"\nimport { HttpClient, HttpClientRequest, HttpClientResponse } from \"@effect/platform\"\nimport { NodeHttpClient, NodeRuntime } from \"@effect/platform-node\"\n\n// ============================================\n// 1. Define response schemas\n// ============================================\n\nconst PostSchema = Schema.Struct({\n  id: Schema.Number,\n  title: Schema.String,\n  body: Schema.String,\n  userId: Schema.Number,\n})\n\ntype Post = Schema.Schema.Type<typeof PostSchema>\n\nconst PostArraySchema = Schema.Array(PostSchema)\n\n// ============================================\n// 2. Fetch and validate single item\n// ============================================\n\nconst getPost = (id: number) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    const response = yield* client.get(\n      `https://jsonplaceholder.typicode.com/posts/${id}`\n    )\n    const json = yield* HttpClientResponse.json(response)\n\n    // Validate against schema - fails if data doesn't match\n    const post = yield* Schema.decodeUnknown(PostSchema)(json)\n\n    return post\n  })\n\n// ============================================\n// 3. Fetch and validate array\n// ============================================\n\nconst getPosts = Effect.gen(function* () {\n  const client = yield* HttpClient.HttpClient\n\n  const response = yield* client.get(\n    \"https://jsonplaceholder.typicode.com/posts\"\n  )\n  const json = yield* HttpClientResponse.json(response)\n\n  // Validate array of posts\n  const posts = yield* Schema.decodeUnknown(PostArraySchema)(json)\n\n  return posts\n})\n\n// ============================================\n// 4. Handle validation errors\n// ============================================\n\nconst safeGetPost = (id: number) =>\n  getPost(id).pipe(\n    Effect.catchTag(\"ParseError\", (error) =>\n      Effect.gen(function* () {\n        yield* Console.error(`Invalid response format: ${error.message}`)\n        // Return a default or fail differently\n        return yield* Effect.fail(new Error(`Post ${id} has invalid format`))\n      })\n    )\n  )\n\n// ============================================\n// 5. Schema with optional fields\n// ============================================\n\nconst UserSchema = Schema.Struct({\n  id: Schema.Number,\n  name: Schema.String,\n  email: Schema.String,\n  phone: Schema.optional(Schema.String),        // May not exist\n  website: Schema.optional(Schema.String),\n  company: Schema.optional(\n    Schema.Struct({\n      name: Schema.String,\n      catchPhrase: Schema.optional(Schema.String),\n    })\n  ),\n})\n\nconst getUser = (id: number) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n\n    const response = yield* client.get(\n      `https://jsonplaceholder.typicode.com/users/${id}`\n    )\n    const json = yield* HttpClientResponse.json(response)\n\n    return yield* Schema.decodeUnknown(UserSchema)(json)\n  })\n\n// ============================================\n// 6. Run examples\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Console.log(\"=== Validated Single Post ===\")\n  const post = yield* getPost(1)\n  yield* Console.log(`Title: ${post.title}`)\n\n  yield* Console.log(\"\\n=== Validated Posts Array ===\")\n  const posts = yield* getPosts\n  yield* Console.log(`Fetched ${posts.length} posts`)\n\n  yield* Console.log(\"\\n=== User with Optional Fields ===\")\n  const user = yield* getUser(1)\n  yield* Console.log(`User: ${user.name}`)\n  yield* Console.log(`Company: ${user.company?.name ?? \"N/A\"}`)\n})\n\nprogram.pipe(\n  Effect.provide(NodeHttpClient.layer),\n  NodeRuntime.runMain\n)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Always validate HTTP responses with Schema to catch API changes at runtime."
            },
            "created_at": "2026-02-15T21:22:27.324728",
            "updated_at": "2026-02-20T23:09:45.667125"
        },
        {
            "id": "286794d5-db08-4d55-a5ac-d0361cc18ee8",
            "slug": "distinguish-not-found-from-errors",
            "title": "Distinguish 'Not Found' from Errors",
            "summary": "Use Effect<Option<A>> to clearly distinguish between a recoverable 'not found' case (None) and a true failure (Fail).",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "option",
                "error-management",
                "not-found",
                "effect",
                "composition",
                "data"
            ],
            "examples": [
                {
                    "code": "import { Effect, Option, Data } from \"effect\";\n\ninterface User {\n  id: number;\n  name: string;\n}\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\") {}\n\n// This signature is extremely honest about its possible outcomes.\nconst findUserInDb = (\n  id: number\n): Effect.Effect<Option.Option<User>, DatabaseError> =>\n  Effect.gen(function* () {\n    // This could fail with a DatabaseError\n    const dbResult = yield* Effect.try({\n      try: () => (id === 1 ? { id: 1, name: \"Paul\" } : null),\n      catch: () => new DatabaseError(),\n    });\n\n    // We wrap the potentially null result in an Option\n    return Option.fromNullable(dbResult);\n  });\n\n// The caller can now handle all three cases explicitly.\nconst program = (id: number) =>\n  findUserInDb(id).pipe(\n    Effect.flatMap((maybeUser) =>\n      Option.match(maybeUser, {\n        onNone: () =>\n          Effect.logInfo(`Result: User with ID ${id} was not found.`),\n        onSome: (user) => Effect.logInfo(`Result: Found user ${user.name}.`),\n      })\n    ),\n    Effect.catchAll((error) =>\n      Effect.logInfo(\"Error: Could not connect to the database.\")\n    )\n  );\n\n// Run the program with different IDs\nEffect.runPromise(\n  Effect.gen(function* () {\n    // Try with existing user\n    yield* Effect.logInfo(\"Looking for user with ID 1...\");\n    yield* program(1);\n\n    // Try with non-existent user\n    yield* Effect.logInfo(\"\\nLooking for user with ID 2...\");\n    yield* program(2);\n  })\n);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect<Option<A>> to distinguish between recoverable 'not found' cases and actual failures."
            },
            "created_at": "2026-02-15T21:22:24.272309",
            "updated_at": "2026-02-20T23:09:45.945848"
        },
        {
            "id": "c3bfa84b-4d3f-40b5-b5ea-fc6907afb7f3",
            "slug": "parse-with-schema-decode",
            "title": "Parse and Validate Data with Schema.decode",
            "summary": "Use Schema.decode(schema) to create an Effect that parses and validates unknown data, which integrates seamlessly with Effect's error handling.",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "schema",
                "validation",
                "parsing",
                "data"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schema } from \"effect\";\n\ninterface User {\n  name: string;\n}\n\nconst UserSchema = Schema.Struct({\n  name: Schema.String,\n}) as Schema.Schema<User>;\n\nconst processUserInput = (input: unknown) =>\n  Effect.gen(function* () {\n    const user = yield* Schema.decodeUnknown(UserSchema)(input);\n    return `Welcome, ${user.name}!`;\n  }).pipe(\n    Effect.catchTag(\"ParseError\", () => Effect.succeed(\"Invalid user data.\"))\n  );\n\n// Demonstrate the schema parsing\nconst program = Effect.gen(function* () {\n  // Test with valid input\n  const validInput = { name: \"Paul\" };\n  const validResult = yield* processUserInput(validInput);\n  yield* Effect.logInfo(`Valid input result: ${validResult}`);\n\n  // Test with invalid input\n  const invalidInput = { age: 25 }; // Missing 'name' field\n  const invalidResult = yield* processUserInput(invalidInput);\n  yield* Effect.logInfo(`Invalid input result: ${invalidResult}`);\n\n  // Test with completely invalid input\n  const badInput = \"not an object\";\n  const badResult = yield* processUserInput(badInput);\n  yield* Effect.logInfo(`Bad input result: ${badResult}`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Parse and validate data with Schema.decode."
            },
            "created_at": "2026-02-15T21:22:24.627937",
            "updated_at": "2026-02-20T23:09:46.125451"
        },
        {
            "id": "463e5437-7ae5-483a-bf8f-6327a07dfb52",
            "slug": "domain-modeling-tagged-errors",
            "title": "Create Type-Safe Errors",
            "summary": "Define domain-specific errors using Data.TaggedError for type-safe error handling.",
            "skill_level": "beginner",
            "category": "domain-modeling",
            "difficulty": "beginner",
            "tags": [
                "domain-modeling",
                "errors",
                "tagged-errors",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data } from \"effect\"\n\n// ============================================\n// 1. Define tagged errors for your domain\n// ============================================\n\nclass UserNotFoundError extends Data.TaggedError(\"UserNotFoundError\")<{\n  readonly userId: string\n}> {}\n\nclass InvalidEmailError extends Data.TaggedError(\"InvalidEmailError\")<{\n  readonly email: string\n  readonly reason: string\n}> {}\n\nclass DuplicateUserError extends Data.TaggedError(\"DuplicateUserError\")<{\n  readonly email: string\n}> {}\n\n// ============================================\n// 2. Use in Effect functions\n// ============================================\n\ninterface User {\n  id: string\n  email: string\n  name: string\n}\n\nconst validateEmail = (email: string): Effect.Effect<string, InvalidEmailError> => {\n  if (!email.includes(\"@\")) {\n    return Effect.fail(new InvalidEmailError({\n      email,\n      reason: \"Missing @ symbol\"\n    }))\n  }\n  return Effect.succeed(email)\n}\n\nconst findUser = (id: string): Effect.Effect<User, UserNotFoundError> => {\n  // Simulate database lookup\n  if (id === \"123\") {\n    return Effect.succeed({ id, email: \"alice@example.com\", name: \"Alice\" })\n  }\n  return Effect.fail(new UserNotFoundError({ userId: id }))\n}\n\nconst createUser = (\n  email: string,\n  name: string\n): Effect.Effect<User, InvalidEmailError | DuplicateUserError> =>\n  Effect.gen(function* () {\n    const validEmail = yield* validateEmail(email)\n\n    // Simulate duplicate check\n    if (validEmail === \"taken@example.com\") {\n      return yield* Effect.fail(new DuplicateUserError({ email: validEmail }))\n    }\n\n    return {\n      id: crypto.randomUUID(),\n      email: validEmail,\n      name,\n    }\n  })\n\n// ============================================\n// 3. Handle errors by tag\n// ============================================\n\nconst program = createUser(\"alice@example.com\", \"Alice\").pipe(\n  Effect.catchTag(\"InvalidEmailError\", (error) =>\n    Effect.succeed({\n      id: \"fallback\",\n      email: \"default@example.com\",\n      name: `${error.email} was invalid: ${error.reason}`,\n    })\n  ),\n  Effect.catchTag(\"DuplicateUserError\", (error) =>\n    Effect.fail(new Error(`Email ${error.email} already registered`))\n  )\n)\n\n// ============================================\n// 4. Match on all errors\n// ============================================\n\nconst handleAllErrors = createUser(\"bad-email\", \"Bob\").pipe(\n  Effect.catchTags({\n    InvalidEmailError: (e) => Effect.succeed(`Invalid: ${e.reason}`),\n    DuplicateUserError: (e) => Effect.succeed(`Duplicate: ${e.email}`),\n  })\n)\n\n// ============================================\n// 5. Run and see results\n// ============================================\n\nEffect.runPromise(program)\n  .then((user) => console.log(\"Created:\", user))\n  .catch((error) => console.error(\"Failed:\", error))",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Data.TaggedError to create typed, distinguishable errors for your domain."
            },
            "created_at": "2026-02-15T21:22:23.694858",
            "updated_at": "2026-02-20T23:09:46.471057"
        },
        {
            "id": "8668656a-aa60-4e34-88cd-f3610ee8def5",
            "slug": "process-a-collection-of-data-asynchronously",
            "title": "Process collections of data asynchronously",
            "summary": "Process collections of data asynchronously in a lazy, composable, and resource-safe manner using Effect's Stream.",
            "skill_level": "intermediate",
            "category": "building-data-pipelines",
            "difficulty": "intermediate",
            "tags": [
                "stream",
                "concurrency",
                "asynchronous",
                "performance",
                "resource-management"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Chunk } from \"effect\";\n\n// A mock function that simulates fetching a user from a database\nconst getUserById = (\n  id: number\n): Effect.Effect<{ id: number; name: string }, Error> =>\n  Effect.succeed({ id, name: `User ${id}` }).pipe(\n    Effect.delay(\"100 millis\"),\n    Effect.tap(() => Effect.log(`Fetched user ${id}`))\n  );\n\n// The stream-based program\nconst program = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(\n  // Process each item with an Effect, limiting concurrency to 2\n  Stream.mapEffect(getUserById, { concurrency: 2 }),\n  // Run the stream and collect all results into a Chunk\n  Stream.runCollect\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  const users = yield* program;\n  yield* Effect.log(\n    `All users fetched: ${JSON.stringify(Chunk.toArray(users))}`\n  );\n  return users;\n});\n\nEffect.runPromise(programWithLogging);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Leverage Stream to process collections effectfully with built-in concurrency control and resource safety."
            },
            "created_at": "2026-02-15T21:22:26.646331",
            "updated_at": "2026-02-20T23:09:43.401224"
        },
        {
            "id": "3acd2cc2-8465-4b44-8488-83800b705253",
            "slug": "stream-process-in-batches",
            "title": "Process Items in Batches",
            "summary": "Group items into chunks for efficient bulk operations, like database inserts or batch API calls.",
            "skill_level": "intermediate",
            "category": "building-data-pipelines",
            "difficulty": "intermediate",
            "tags": [
                "stream",
                "batch",
                "chunk",
                "performance",
                "grouped"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Chunk } from \"effect\";\n\n// A mock function that simulates a bulk database insert\nconst saveUsersInBulk = (\n  userBatch: Chunk.Chunk<{ id: number }>\n): Effect.Effect<void, Error> =>\n  Effect.log(\n    `Saving batch of ${userBatch.length} users: ${Chunk.toArray(userBatch)\n      .map((u) => u.id)\n      .join(\", \")}`\n  );\n\nconst userIds = Array.from({ length: 10 }, (_, i) => ({ id: i + 1 }));\n\nconst program = Stream.fromIterable(userIds).pipe(\n  // Group the stream of users into batches of 5\n  Stream.grouped(5),\n  // Process each batch with our bulk save function\n  Stream.mapEffect(saveUsersInBulk, { concurrency: 1 }),\n  Stream.runDrain\n);\n\nEffect.runPromise(program);\n/*\nOutput:\n... level=INFO msg=\"Saving batch of 5 users: 1, 2, 3, 4, 5\"\n... level=INFO msg=\"Saving batch of 5 users: 6, 7, 8, 9, 10\"\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream.grouped(n) to transform a stream of items into a stream of batched chunks."
            },
            "created_at": "2026-02-15T21:22:26.82165",
            "updated_at": "2026-02-20T23:09:43.565375"
        },
        {
            "id": "3185e2fd-0204-4181-9b1d-650ba2680f62",
            "slug": "stream-from-iterable",
            "title": "Create a Stream from a List",
            "summary": "Turn a simple in-memory array or list into a foundational data pipeline using Stream.",
            "skill_level": "beginner",
            "category": "building-data-pipelines",
            "difficulty": "beginner",
            "tags": [
                "stream",
                "iterable",
                "array",
                "list",
                "data-processing"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Chunk } from \"effect\";\n\nconst numbers = [1, 2, 3, 4, 5];\n\n// Create a stream from the array of numbers.\nconst program = Stream.fromIterable(numbers).pipe(\n  // Perform a simple, synchronous transformation on each item.\n  Stream.map((n) => `Item: ${n}`),\n  // Run the stream and collect all the transformed items into a Chunk.\n  Stream.runCollect\n);\n\nconst programWithLogging = Effect.gen(function* () {\n  const processedItems = yield* program;\n  yield* Effect.log(\n    `Processed items: ${JSON.stringify(Chunk.toArray(processedItems))}`\n  );\n  return processedItems;\n});\n\nEffect.runPromise(programWithLogging);\n/*\nOutput:\n[ 'Item: 1', 'Item: 2', 'Item: 3', 'Item: 4', 'Item: 5' ]\n*/",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream.fromIterable to begin a pipeline from an in-memory collection."
            },
            "created_at": "2026-02-15T21:22:26.251621",
            "updated_at": "2026-02-20T23:09:43.739717"
        },
        {
            "id": "f74c6eb3-a6d2-41d1-8f0d-907ce6c22475",
            "slug": "platform-pattern-command-execution",
            "title": "Platform Pattern 1: Execute Shell Commands",
            "summary": "Use Command module to execute shell commands, capture output, and handle exit codes, enabling integration with system tools and external programs.",
            "skill_level": "intermediate",
            "category": "platform",
            "difficulty": "intermediate",
            "tags": [
                "platform",
                "command",
                "shell",
                "subprocess",
                "system-integration",
                "external-process"
            ],
            "examples": [
                {
                    "code": "import { Command, Effect, Chunk } from \"@effect/platform\";\n\n// Simple command execution\nconst program = Effect.gen(function* () {\n  console.log(`\\n[COMMAND] Executing shell commands\\n`);\n\n  // Example 1: List files\n  console.log(`[1] List files in current directory:\\n`);\n\n  const lsResult = yield* Command.make(\"ls\", [\"-la\"]).pipe(\n    Command.string\n  );\n\n  console.log(lsResult);\n\n  // Example 2: Get current date\n  console.log(`\\n[2] Get current date:\\n`);\n\n  const dateResult = yield* Command.make(\"date\", [\"+%Y-%m-%d %H:%M:%S\"]).pipe(\n    Command.string\n  );\n\n  console.log(`Current date: ${dateResult.trim()}`);\n\n  // Example 3: Capture exit code\n  console.log(`\\n[3] Check if file exists:\\n`);\n\n  const fileCheckCmd = yield* Command.make(\"test\", [\n    \"-f\",\n    \"/etc/passwd\",\n  ]).pipe(\n    Command.exitCode,\n    Effect.either\n  );\n\n  if (fileCheckCmd._tag === \"Right\") {\n    console.log(`\u2713 File exists (exit code: 0)`);\n  } else {\n    console.log(`\u2717 File not found (exit code: ${fileCheckCmd.left})`);\n  }\n\n  // Example 4: Execute with custom working directory\n  console.log(`\\n[4] List TypeScript files:\\n`);\n\n  const findResult = yield* Command.make(\"find\", [\n    \".\",\n    \"-name\",\n    \"*.ts\",\n    \"-type\",\n    \"f\",\n  ]).pipe(\n    Command.lines\n  );\n\n  const tsFiles = Chunk.take(findResult, 5); // First 5\n\n  Chunk.forEach(tsFiles, (file) => {\n    console.log(`  - ${file}`);\n  });\n\n  if (Chunk.size(findResult) > 5) {\n    console.log(`  ... and ${Chunk.size(findResult) - 5} more`);\n  }\n\n  // Example 5: Handle command failure\n  console.log(`\\n[5] Handle command failure gracefully:\\n`);\n\n  const failResult = yield* Command.make(\"false\").pipe(\n    Command.exitCode,\n    Effect.catchAll((error) =>\n      Effect.succeed(-1) // Return -1 for any error\n    )\n  );\n\n  console.log(`Exit code: ${failResult}`);\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Command to spawn and manage external processes, capturing output and handling exit codes reliably with proper error handling."
            },
            "created_at": "2026-02-15T21:22:22.844916",
            "updated_at": "2026-02-20T23:09:43.846198"
        },
        {
            "id": "a48da6d3-b02c-4853-ba81-a1d0a9cbc371",
            "slug": "platform-terminal-interactive",
            "title": "Platform Pattern 4: Interactive Terminal I/O",
            "summary": "Use Terminal module to read user input and write formatted output, enabling interactive CLI applications with proper buffering and encoding.",
            "skill_level": "beginner",
            "category": "platform",
            "difficulty": "beginner",
            "tags": [
                "platform",
                "terminal",
                "io",
                "interactive",
                "cli",
                "user-input"
            ],
            "examples": [
                {
                    "code": "import { Terminal, Effect } from \"@effect/platform\";\n\ninterface UserInput {\n  readonly name: string;\n  readonly email: string;\n  readonly age: number;\n}\n\nconst program = Effect.gen(function* () {\n  console.log(`\\n[INTERACTIVE CLI] User Information Form\\n`);\n\n  // Example 1: Simple prompts\n  yield* Terminal.writeLine(`=== User Setup ===`);\n  yield* Terminal.writeLine(``);\n\n  yield* Terminal.write(`What is your name? `);\n  const name = yield* Terminal.readLine();\n\n  yield* Terminal.write(`What is your email? `);\n  const email = yield* Terminal.readLine();\n\n  yield* Terminal.write(`What is your age? `);\n  const ageStr = yield* Terminal.readLine();\n\n  const age = parseInt(ageStr);\n\n  // Example 2: Display collected information\n  yield* Terminal.writeLine(``);\n  yield* Terminal.writeLine(`=== Summary ===`);\n  yield* Terminal.writeLine(`Name: ${name}`);\n  yield* Terminal.writeLine(`Email: ${email}`);\n  yield* Terminal.writeLine(`Age: ${age}`);\n\n  // Example 3: Confirmation\n  yield* Terminal.writeLine(``);\n  yield* Terminal.write(`Confirm information? (yes/no) `);\n  const confirm = yield* Terminal.readLine();\n\n  if (confirm.toLowerCase() === \"yes\") {\n    yield* Terminal.writeLine(`\u2713 Information saved`);\n  } else {\n    yield* Terminal.writeLine(`\u2717 Cancelled`);\n  }\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Terminal for user input/output in CLI applications, providing proper buffering and cross-platform character encoding."
            },
            "created_at": "2026-02-15T21:22:22.688982",
            "updated_at": "2026-02-20T23:09:43.972264"
        },
        {
            "id": "75514013-fda1-4ad2-a333-4206aabd1832",
            "slug": "stream-running-collecting",
            "title": "Running and Collecting Stream Results",
            "summary": "Learn the different ways to run a stream and collect its results: runCollect, runForEach, runDrain, and more.",
            "skill_level": "beginner",
            "category": "streams",
            "difficulty": "beginner",
            "tags": [
                "stream",
                "run",
                "collect",
                "consume",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream, Option } from \"effect\"\n\nconst numbers = Stream.make(1, 2, 3, 4, 5)\n\n// ============================================\n// runCollect - Get all results as a Chunk\n// ============================================\n\nconst collectAll = numbers.pipe(\n  Stream.map((n) => n * 10),\n  Stream.runCollect\n)\n\nEffect.runPromise(collectAll).then((chunk) => {\n  console.log([...chunk])  // [10, 20, 30, 40, 50]\n})\n\n// ============================================\n// runForEach - Process each item\n// ============================================\n\nconst processEach = numbers.pipe(\n  Stream.runForEach((n) =>\n    Effect.log(`Processing: ${n}`)\n  )\n)\n\nEffect.runPromise(processEach)\n// Logs: Processing: 1, Processing: 2, etc.\n\n// ============================================\n// runDrain - Run for side effects only\n// ============================================\n\nconst withSideEffects = numbers.pipe(\n  Stream.tap((n) => Effect.log(`Saw: ${n}`)),\n  Stream.runDrain  // Discard values, just run\n)\n\n// ============================================\n// runHead - Get first value only\n// ============================================\n\nconst getFirst = numbers.pipe(\n  Stream.runHead\n)\n\nEffect.runPromise(getFirst).then((option) => {\n  if (Option.isSome(option)) {\n    console.log(`First: ${option.value}`)  // First: 1\n  }\n})\n\n// ============================================\n// runLast - Get last value only\n// ============================================\n\nconst getLast = numbers.pipe(\n  Stream.runLast\n)\n\nEffect.runPromise(getLast).then((option) => {\n  if (Option.isSome(option)) {\n    console.log(`Last: ${option.value}`)  // Last: 5\n  }\n})\n\n// ============================================\n// runFold - Accumulate into single result\n// ============================================\n\nconst sum = numbers.pipe(\n  Stream.runFold(0, (acc, n) => acc + n)\n)\n\nEffect.runPromise(sum).then((total) => {\n  console.log(`Sum: ${total}`)  // Sum: 15\n})\n\n// ============================================\n// runCount - Count elements\n// ============================================\n\nconst count = numbers.pipe(Stream.runCount)\n\nEffect.runPromise(count).then((n) => {\n  console.log(`Count: ${n}`)  // Count: 5\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Choose the right Stream.run* method based on what you need from the results."
            },
            "created_at": "2026-02-15T21:22:21.011098",
            "updated_at": "2026-02-20T23:09:44.569089"
        },
        {
            "id": "2e47cf59-d607-4220-bed4-182e9b046298",
            "slug": "stream-hello-world",
            "title": "Your First Stream",
            "summary": "Create your first Effect Stream and understand what makes streams different from regular arrays.",
            "skill_level": "beginner",
            "category": "streams",
            "difficulty": "beginner",
            "tags": [
                "stream",
                "getting-started",
                "basics",
                "introduction"
            ],
            "examples": [
                {
                    "code": "import { Effect, Stream } from \"effect\"\n\n// Create a stream from explicit values\nconst numbers = Stream.make(1, 2, 3, 4, 5)\n\n// Create a stream from an array\nconst fromArray = Stream.fromIterable([10, 20, 30])\n\n// Create a single-value stream\nconst single = Stream.succeed(\"hello\")\n\n// Transform and run the stream\nconst program = numbers.pipe(\n  Stream.map((n) => n * 2),           // Double each number\n  Stream.filter((n) => n > 4),        // Keep only > 4\n  Stream.runCollect                    // Collect results\n)\n\nEffect.runPromise(program).then((chunk) => {\n  console.log([...chunk])  // [6, 8, 10]\n})",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Stream to process sequences of data lazily and efficiently."
            },
            "created_at": "2026-02-15T21:22:21.349092",
            "updated_at": "2026-02-20T23:09:44.650193"
        },
        {
            "id": "5788a153-99de-4f1d-9693-d90742c2fe78",
            "slug": "scheduling-hello-world",
            "title": "Your First Schedule",
            "summary": "Learn the basics of scheduling in Effect - retry operations and repeat them on intervals.",
            "skill_level": "beginner",
            "category": "scheduling",
            "difficulty": "beginner",
            "tags": [
                "scheduling",
                "retry",
                "repeat",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule } from \"effect\"\n\n// ============================================\n// 1. Retry a failing operation\n// ============================================\n\nlet attempts = 0\nconst flakyOperation = Effect.gen(function* () {\n  attempts++\n  if (attempts < 3) {\n    yield* Effect.log(`Attempt ${attempts} failed`)\n    return yield* Effect.fail(new Error(\"Temporary failure\"))\n  }\n  return `Success on attempt ${attempts}`\n})\n\n// Retry up to 5 times\nconst withRetry = flakyOperation.pipe(\n  Effect.retry(Schedule.recurs(5))\n)\n\n// ============================================\n// 2. Repeat a successful operation\n// ============================================\n\nconst logTime = Effect.gen(function* () {\n  const now = new Date().toISOString()\n  yield* Effect.log(`Current time: ${now}`)\n  return now\n})\n\n// Repeat 3 times\nconst repeated = logTime.pipe(\n  Effect.repeat(Schedule.recurs(3))\n)\n\n// ============================================\n// 3. Add delays between operations\n// ============================================\n\n// Repeat every second, 5 times\nconst polling = logTime.pipe(\n  Effect.repeat(\n    Schedule.spaced(\"1 second\").pipe(\n      Schedule.intersect(Schedule.recurs(5))\n    )\n  )\n)\n\n// ============================================\n// 4. Common schedule patterns\n// ============================================\n\n// Fixed delay between attempts\nconst fixedDelay = Schedule.spaced(\"500 millis\")\n\n// Increasing delay (1s, 2s, 4s, 8s...)\nconst exponentialBackoff = Schedule.exponential(\"1 second\")\n\n// Maximum number of attempts\nconst limitedAttempts = Schedule.recurs(3)\n\n// Combine: exponential backoff, max 5 attempts\nconst retryPolicy = Schedule.exponential(\"100 millis\").pipe(\n  Schedule.intersect(Schedule.recurs(5))\n)\n\n// ============================================\n// 5. Run examples\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"--- Retry Example ---\")\n  const result = yield* withRetry\n  yield* Effect.log(`Result: ${result}`)\n\n  yield* Effect.log(\"\\n--- Repeat Example ---\")\n  yield* repeated\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Schedule to control when and how often effects run."
            },
            "created_at": "2026-02-15T21:22:23.248852",
            "updated_at": "2026-02-20T23:09:45.050129"
        },
        {
            "id": "c8d269c7-8250-4ca7-9e8b-5b2c46e607bd",
            "slug": "scheduling-retry-basics",
            "title": "Retry Failed Operations",
            "summary": "Use Effect.retry with Schedule to automatically retry operations that fail.",
            "skill_level": "beginner",
            "category": "scheduling",
            "difficulty": "beginner",
            "tags": [
                "scheduling",
                "retry",
                "error-handling",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Schedule, Data } from \"effect\"\n\n// ============================================\n// 1. Define error types\n// ============================================\n\nclass NetworkError extends Data.TaggedError(\"NetworkError\")<{\n  readonly message: string\n}> {}\n\nclass RateLimitError extends Data.TaggedError(\"RateLimitError\")<{\n  readonly retryAfter: number\n}> {}\n\nclass NotFoundError extends Data.TaggedError(\"NotFoundError\")<{\n  readonly resource: string\n}> {}\n\n// ============================================\n// 2. Simulate a flaky API call\n// ============================================\n\nlet callCount = 0\nconst fetchData = Effect.gen(function* () {\n  callCount++\n  yield* Effect.log(`API call attempt ${callCount}`)\n\n  // Simulate intermittent failures\n  if (callCount < 3) {\n    return yield* Effect.fail(new NetworkError({ message: \"Connection timeout\" }))\n  }\n\n  return { data: \"Success!\", attempts: callCount }\n})\n\n// ============================================\n// 3. Basic retry - fixed attempts\n// ============================================\n\nconst withBasicRetry = fetchData.pipe(\n  Effect.retry(Schedule.recurs(5))  // Retry up to 5 times\n)\n\n// ============================================\n// 4. Retry with delay\n// ============================================\n\nconst withDelayedRetry = fetchData.pipe(\n  Effect.retry(\n    Schedule.spaced(\"500 millis\").pipe(\n      Schedule.intersect(Schedule.recurs(5))\n    )\n  )\n)\n\n// ============================================\n// 5. Retry only specific errors\n// ============================================\n\nconst fetchWithErrors = (shouldFail: boolean) =>\n  Effect.gen(function* () {\n    if (shouldFail) {\n      // Randomly fail with different errors\n      const random = Math.random()\n      if (random < 0.5) {\n        return yield* Effect.fail(new NetworkError({ message: \"Timeout\" }))\n      } else if (random < 0.8) {\n        return yield* Effect.fail(new RateLimitError({ retryAfter: 1000 }))\n      } else {\n        return yield* Effect.fail(new NotFoundError({ resource: \"user:123\" }))\n      }\n    }\n    return \"Data fetched!\"\n  })\n\n// Only retry network and rate limit errors, not NotFoundError\nconst retryTransientOnly = fetchWithErrors(true).pipe(\n  Effect.retry({\n    schedule: Schedule.recurs(3),\n    while: (error) =>\n      error._tag === \"NetworkError\" || error._tag === \"RateLimitError\",\n  })\n)\n\n// ============================================\n// 6. Retry with exponential backoff\n// ============================================\n\nconst withExponentialBackoff = fetchData.pipe(\n  Effect.retry(\n    Schedule.exponential(\"100 millis\", 2).pipe(  // 100ms, 200ms, 400ms...\n      Schedule.intersect(Schedule.recurs(5))      // Max 5 retries\n    )\n  )\n)\n\n// ============================================\n// 7. Run and observe\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(\"Starting retry demo...\")\n  \n  // Reset counter\n  callCount = 0\n  \n  const result = yield* withBasicRetry\n  yield* Effect.log(`Final result: ${JSON.stringify(result)}`)\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Effect.retry with a Schedule to handle transient failures gracefully."
            },
            "created_at": "2026-02-15T21:22:23.16892",
            "updated_at": "2026-02-20T23:09:45.190882"
        },
        {
            "id": "a552299a-d664-497f-83ca-d002ce6bc5dd",
            "slug": "http-hello-world",
            "title": "Your First HTTP Request",
            "summary": "Learn how to make HTTP requests using Effect's HttpClient with proper error handling.",
            "skill_level": "beginner",
            "category": "making-http-requests",
            "difficulty": "beginner",
            "tags": [
                "http",
                "client",
                "fetch",
                "getting-started"
            ],
            "examples": [
                {
                    "code": "import { Effect, Console } from \"effect\"\nimport { HttpClient, HttpClientRequest, HttpClientResponse } from \"@effect/platform\"\nimport { NodeHttpClient, NodeRuntime } from \"@effect/platform-node\"\n\n// ============================================\n// 1. Simple GET request\n// ============================================\n\nconst simpleGet = Effect.gen(function* () {\n  const client = yield* HttpClient.HttpClient\n  \n  // Make a GET request\n  const response = yield* client.get(\"https://jsonplaceholder.typicode.com/posts/1\")\n  \n  // Get response as JSON\n  const json = yield* HttpClientResponse.json(response)\n  \n  return json\n})\n\n// ============================================\n// 2. GET with typed response\n// ============================================\n\ninterface Post {\n  id: number\n  title: string\n  body: string\n  userId: number\n}\n\nconst getPost = (id: number) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n    const response = yield* client.get(\n      `https://jsonplaceholder.typicode.com/posts/${id}`\n    )\n    const post = yield* HttpClientResponse.json(response) as Effect.Effect<Post>\n    return post\n  })\n\n// ============================================\n// 3. POST with body\n// ============================================\n\nconst createPost = (title: string, body: string) =>\n  Effect.gen(function* () {\n    const client = yield* HttpClient.HttpClient\n    \n    const request = HttpClientRequest.post(\n      \"https://jsonplaceholder.typicode.com/posts\"\n    ).pipe(\n      HttpClientRequest.jsonBody({ title, body, userId: 1 })\n    )\n    \n    const response = yield* client.execute(yield* request)\n    const created = yield* HttpClientResponse.json(response)\n    \n    return created\n  })\n\n// ============================================\n// 4. Handle errors\n// ============================================\n\nconst safeGetPost = (id: number) =>\n  getPost(id).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Console.error(`Failed to fetch post ${id}: ${error}`)\n        return { id, title: \"Unavailable\", body: \"\", userId: 0 }\n      })\n    )\n  )\n\n// ============================================\n// 5. Run the program\n// ============================================\n\nconst program = Effect.gen(function* () {\n  yield* Console.log(\"=== Simple GET ===\")\n  const data = yield* simpleGet\n  yield* Console.log(JSON.stringify(data, null, 2))\n\n  yield* Console.log(\"\\n=== Typed GET ===\")\n  const post = yield* getPost(1)\n  yield* Console.log(`Post: ${post.title}`)\n\n  yield* Console.log(\"\\n=== POST Request ===\")\n  const created = yield* createPost(\"My New Post\", \"This is the body\")\n  yield* Console.log(`Created: ${JSON.stringify(created)}`)\n})\n\n// Provide the HTTP client implementation\nprogram.pipe(\n  Effect.provide(NodeHttpClient.layer),\n  NodeRuntime.runMain\n)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use @effect/platform HttpClient for type-safe HTTP requests with automatic error handling."
            },
            "created_at": "2026-02-15T21:22:27.409256",
            "updated_at": "2026-02-20T23:09:45.413776"
        },
        {
            "id": "e0f74ecc-7312-464c-939a-eb6383877f71",
            "slug": "create-a-testable-http-client-service",
            "title": "Create a Testable HTTP Client Service",
            "summary": "Define an HttpClient service with separate 'Live' and 'Test' layers to enable robust, testable interactions with external APIs.",
            "skill_level": "intermediate",
            "category": "making-http-requests",
            "difficulty": "intermediate",
            "tags": [
                "http-client",
                "service",
                "testing",
                "dependency-injection",
                "layer",
                "fetch"
            ],
            "examples": [
                {
                    "code": "import { Effect, Data, Layer } from \"effect\";\n\ninterface HttpErrorType {\n  readonly _tag: \"HttpError\";\n  readonly error: unknown;\n}\n\nconst HttpError = Data.tagged<HttpErrorType>(\"HttpError\");\n\ninterface HttpClientType {\n  readonly get: <T>(url: string) => Effect.Effect<T, HttpErrorType>;\n}\n\nclass HttpClient extends Effect.Service<HttpClientType>()(\"HttpClient\", {\n  sync: () => ({\n    get: <T>(url: string): Effect.Effect<T, HttpErrorType> =>\n      Effect.tryPromise<T>(() =>\n        fetch(url).then((res) => res.json() as T)\n      ).pipe(Effect.catchAll((error) => Effect.fail(HttpError({ error })))),\n  }),\n}) {}\n\n// Test implementation\nconst TestLayer = Layer.succeed(\n  HttpClient,\n  HttpClient.of({\n    get: <T>(_url: string) => Effect.succeed({ title: \"Mock Data\" } as T),\n  })\n);\n\n// Example usage\nconst program = Effect.gen(function* () {\n  const client = yield* HttpClient;\n  yield* Effect.logInfo(\"Fetching data...\");\n  const data = yield* client.get<{ title: string }>(\n    \"https://api.example.com/data\"\n  );\n  yield* Effect.logInfo(`Received data: ${JSON.stringify(data)}`);\n});\n\n// Run with test implementation\nEffect.runPromise(Effect.provide(program, TestLayer));",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Define an HttpClient service with distinct Live and Test layers to enable testable API interactions."
            },
            "created_at": "2026-02-15T21:22:27.661328",
            "updated_at": "2026-02-20T23:09:45.455541"
        },
        {
            "id": "31cb1ed6-cc08-4c8f-9e19-3074c6804b7f",
            "slug": "model-validated-domain-types-with-brand",
            "title": "Model Validated Domain Types with Brand",
            "summary": "Use Brand to turn primitive types like string or number into specific, validated domain types like Email or PositiveInt, making illegal states unrepresentable.",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "branded-types",
                "domain-modeling",
                "type-safety",
                "validation",
                "invariants",
                "data"
            ],
            "examples": [
                {
                    "code": "import { Brand, Option } from \"effect\";\n\ntype Email = string & Brand.Brand<\"Email\">;\n\nconst makeEmail = (s: string): Option.Option<Email> =>\n  s.includes(\"@\") ? Option.some(s as Email) : Option.none();\n\n// A function can now trust that its input is a valid email.\nconst sendEmail = (email: Email, body: string) => {\n  /* ... */\n};",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Model validated domain types with Brand."
            },
            "created_at": "2026-02-15T21:22:24.447937",
            "updated_at": "2026-02-20T23:09:45.897918"
        },
        {
            "id": "8cd0fd20-bf74-46bc-84e8-3c1316f728f1",
            "slug": "domain-modeling-hello-world",
            "title": "Your First Domain Model",
            "summary": "Create a simple domain model using TypeScript interfaces and Effect to represent your business entities.",
            "skill_level": "beginner",
            "category": "domain-modeling",
            "difficulty": "beginner",
            "tags": [
                "domain-modeling",
                "getting-started",
                "types",
                "interfaces"
            ],
            "examples": [
                {
                    "code": "import { Effect } from \"effect\"\n\n// ============================================\n// 1. Define domain entities as interfaces\n// ============================================\n\ninterface User {\n  readonly id: string\n  readonly email: string\n  readonly name: string\n  readonly createdAt: Date\n}\n\ninterface Product {\n  readonly sku: string\n  readonly name: string\n  readonly price: number\n  readonly inStock: boolean\n}\n\ninterface Order {\n  readonly id: string\n  readonly userId: string\n  readonly items: ReadonlyArray<OrderItem>\n  readonly total: number\n  readonly status: OrderStatus\n}\n\ninterface OrderItem {\n  readonly productSku: string\n  readonly quantity: number\n  readonly unitPrice: number\n}\n\ntype OrderStatus = \"pending\" | \"confirmed\" | \"shipped\" | \"delivered\"\n\n// ============================================\n// 2. Create domain functions\n// ============================================\n\nconst createUser = (email: string, name: string): User => ({\n  id: crypto.randomUUID(),\n  email,\n  name,\n  createdAt: new Date(),\n})\n\nconst calculateOrderTotal = (items: ReadonlyArray<OrderItem>): number =>\n  items.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0)\n\n// ============================================\n// 3. Use in Effect programs\n// ============================================\n\nconst program = Effect.gen(function* () {\n  const user = createUser(\"alice@example.com\", \"Alice\")\n  yield* Effect.log(`Created user: ${user.name}`)\n\n  const items: OrderItem[] = [\n    { productSku: \"WIDGET-001\", quantity: 2, unitPrice: 29.99 },\n    { productSku: \"GADGET-002\", quantity: 1, unitPrice: 49.99 },\n  ]\n\n  const order: Order = {\n    id: crypto.randomUUID(),\n    userId: user.id,\n    items,\n    total: calculateOrderTotal(items),\n    status: \"pending\",\n  }\n\n  yield* Effect.log(`Order total: $${order.total.toFixed(2)}`)\n  return order\n})\n\nEffect.runPromise(program)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Start domain modeling by defining clear interfaces for your business entities."
            },
            "created_at": "2026-02-15T21:22:23.85973",
            "updated_at": "2026-02-20T23:09:46.072205"
        },
        {
            "id": "3ed53cb4-7064-4154-8bac-046ddae4ccb7",
            "slug": "brand-model-domain-type",
            "title": "Modeling Validated Domain Types with Brand",
            "summary": "Use Brand to create domain-specific types from primitives, making illegal states unrepresentable and preventing accidental misuse.",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "Brand",
                "domain",
                "type-safety",
                "validation",
                "effect"
            ],
            "examples": [
                {
                    "code": "import { Brand } from \"effect\";\n\n// Define a branded type for Email\ntype Email = string & Brand.Brand<\"Email\">;\n\n// Function that only accepts Email, not any string\nfunction sendWelcome(email: Email) {\n  // ...\n}\n\n// Constructing an Email value (unsafe, see next pattern for validation)\nconst email = \"user@example.com\" as Email;\n\nsendWelcome(email); // OK\n// sendWelcome(\"not-an-email\"); // Type error! (commented to allow compilation)",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Brand to define types like Email, UserId, or PositiveInt, ensuring only valid values can be constructed and used."
            },
            "created_at": "2026-02-15T21:22:24.52755",
            "updated_at": "2026-02-20T23:09:46.16681"
        },
        {
            "id": "1e282ab4-4967-4054-a4b1-ce7e73706d6e",
            "slug": "define-tagged-errors",
            "title": "Define Type-Safe Errors with Data.TaggedError",
            "summary": "Create custom, type-safe error classes by extending Data.TaggedError to make error handling robust, predictable, and self-documenting.",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "error-handling",
                "tagged-error",
                "type-safety",
                "Data.TaggedError",
                "errors"
            ],
            "examples": [
                {
                    "code": "import { Data, Effect } from \"effect\";\n\n// Define our tagged error type\nclass DatabaseError extends Data.TaggedError(\"DatabaseError\")<{\n  readonly cause: unknown;\n}> {}\n\n// Function that simulates a database error\nconst findUser = (\n  id: number\n): Effect.Effect<{ id: number; name: string }, DatabaseError> =>\n  Effect.gen(function* () {\n    if (id < 0) {\n      return yield* Effect.fail(new DatabaseError({ cause: \"Invalid ID\" }));\n    }\n    return { id, name: `User ${id}` };\n  });\n\n// Create a program that demonstrates error handling\nconst program = Effect.gen(function* () {\n  // Try to find a valid user\n  yield* Effect.logInfo(\"Looking up user 1...\");\n  yield* Effect.gen(function* () {\n    const user = yield* findUser(1);\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.logInfo(`Error finding user: ${error._tag} - ${error.cause}`)\n    )\n  );\n\n  // Try to find an invalid user\n  yield* Effect.logInfo(\"\\nLooking up user -1...\");\n  yield* Effect.gen(function* () {\n    const user = yield* findUser(-1);\n    yield* Effect.logInfo(`Found user: ${JSON.stringify(user)}`);\n  }).pipe(\n    Effect.catchTag(\"DatabaseError\", (error) =>\n      Effect.logInfo(`Database error: ${error._tag} - ${error.cause}`)\n    )\n  );\n});\n\n// Run the program\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Define type-safe errors with Data.TaggedError."
            },
            "created_at": "2026-02-15T21:22:24.190915",
            "updated_at": "2026-02-20T23:09:46.295965"
        },
        {
            "id": "a3b5b811-8d72-403c-af3f-d57e21ea722f",
            "slug": "model-optional-values-with-option",
            "title": "Model Optional Values Safely with Option",
            "summary": "Use Option<A> to explicitly represent a value that may or may not exist, eliminating null and undefined errors.",
            "skill_level": "intermediate",
            "category": "domain-modeling",
            "difficulty": "intermediate",
            "tags": [
                "option",
                "optional-values",
                "null-handling",
                "domain-modeling",
                "type-safety",
                "data"
            ],
            "examples": [
                {
                    "code": "import { Effect, Option } from \"effect\";\n\ninterface User {\n  id: number;\n  name: string;\n}\n\nconst users: User[] = [\n  { id: 1, name: \"Paul\" },\n  { id: 2, name: \"Alex\" },\n];\n\n// This function safely returns an Option, not a User or null.\nconst findUserById = (id: number): Option.Option<User> => {\n  const user = users.find((u) => u.id === id);\n  return Option.fromNullable(user); // A useful helper for existing APIs\n};\n\n// The caller MUST handle both cases.\nconst greeting = (id: number): string =>\n  findUserById(id).pipe(\n    Option.match({\n      onNone: () => \"User not found.\",\n      onSome: (user) => `Welcome, ${user.name}!`,\n    })\n  );\n\nconst program = Effect.gen(function* () {\n  yield* Effect.log(greeting(1)); // \"Welcome, Paul!\"\n  yield* Effect.log(greeting(3)); // \"User not found.\"\n});\n\nEffect.runPromise(program);",
                    "language": "typescript",
                    "description": "Good Example"
                }
            ],
            "use_cases": [],
            "rule": {
                "description": "Use Option<A> to explicitly model values that may be absent, avoiding null or undefined."
            },
            "created_at": "2026-02-15T21:22:24.361514",
            "updated_at": "2026-02-20T23:09:46.419564"
        }
    ]
}
