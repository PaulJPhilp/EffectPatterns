/**
 * Install Commands
 */

import { Args, Command, Options, Prompt } from "@effect/cli";
import { FileSystem } from "@effect/platform";
import { Console, Effect, Option } from "effect";
import path from "node:path";
import { Display } from "../services/display/index.js";
import { Install, InstalledRule } from "../services/install/index.js";
import { colorize } from "../utils.js";
import { DisabledFeatureError, UnsupportedToolError } from "../errors.js";

/**
 * install:add - Add rules to AI tool configuration
 */
export const installAddCommand = Command.make("add", {
  options: {
    tool: Options.text("tool").pipe(
      Options.withDescription("The AI tool to add rules for (cursor, agents, etc.)")
    ),
    skillLevel: Options.optional(
      Options.text("skill-level").pipe(
        Options.withDescription("Filter rules by skill level")
      )
    ),
    useCase: Options.optional(
      Options.text("use-case").pipe(
        Options.withDescription("Filter rules by use case")
      )
    ),
    interactive: Options.boolean("interactive").pipe(
      Options.withAlias("i"),
      Options.withDescription("Select rules interactively"),
      Options.withDefault(false)
    ),
  },
}).pipe(
  Command.withDescription("Install rules into supported local tool config files."),
  Command.withHandler(({ options }) =>
    Effect.gen(function* () {
      const { loadInstalledRules, saveInstalledRules, searchRules } = yield* Install;
      const fs = yield* FileSystem.FileSystem;

      const installTargetByTool: Record<string, string> = {
        agents: "AGENTS.md",
        cursor: ".cursor/rules.md",
        vscode: ".vscode/rules.md",
        windsurf: ".windsurf/rules.md",
      };

      const targetPath = installTargetByTool[options.tool];
      if (!targetPath) {
        yield* Display.showError(
          `Tool '${options.tool}' is not supported by local file injection yet. Supported: ${Object.keys(installTargetByTool).join(", ")}`
        );
        return yield* Effect.fail(new UnsupportedToolError({
          tool: options.tool,
          supported: Object.keys(installTargetByTool),
        }));
      }

      yield* Console.log(colorize("\nInstalling rules for " + options.tool + "...\n", "CYAN"));

      let rulesToInstall = yield* searchRules({
        skillLevel: Option.getOrUndefined(options.skillLevel),
        useCase: Option.getOrUndefined(options.useCase),
      });

      if (options.interactive) {
        const choices = rulesToInstall.map((rule) => ({
          title: `${rule.title} (${rule.skillLevel || "general"})`,
          value: rule,
          description: rule.description,
        }));

        rulesToInstall = yield* Prompt.multiSelect({
          message: "Select rules to install:",
          choices,
        });
      }

      if (rulesToInstall.length === 0) {
        yield* Display.showWarning("No rules selected or found matching criteria.");
        return;
      }

      const rulesMarkdown = [
        "# Effect Patterns Rules",
        "",
        `Generated by ep on ${new Date().toISOString()}.`,
        "Source: Effect Patterns Database",
        "",
        ...rulesToInstall.flatMap((rule) => [
          `## ${rule.title}`,
          "",
          `- ID: ${rule.id}`,
          `- Skill Level: ${rule.skillLevel ?? "general"}`,
          `- Use Cases: ${(rule.useCase ?? []).join(", ") || "none"}`,
          "",
          rule.description,
          "",
          rule.content,
          "",
        ]),
      ].join("\n");

      if (options.tool === "agents") {
        const startMarker = "<!-- EP_RULES_START -->";
        const endMarker = "<!-- EP_RULES_END -->";
        const managedSection = `${startMarker}\n${rulesMarkdown}\n${endMarker}\n`;

        const exists = yield* fs.exists(targetPath);
        const current = exists ? yield* fs.readFileString(targetPath) : "";
        const nextContent =
          current.includes(startMarker) && current.includes(endMarker)
            ? current.replace(
                /<!-- EP_RULES_START -->[\s\S]*<!-- EP_RULES_END -->\n?/m,
                managedSection
              )
            : `${current}${current.endsWith("\n") ? "" : "\n"}\n${managedSection}`;

        yield* fs.writeFileString(targetPath, nextContent);
      } else {
        yield* fs.makeDirectory(path.dirname(targetPath), { recursive: true });
        yield* fs.writeFileString(targetPath, rulesMarkdown);
      }

      // Save install state
      const current = yield* loadInstalledRules();
      const newRules: InstalledRule[] = rulesToInstall.map((r) => ({
        ...r,
        installedAt: new Date().toISOString(),
        tool: options.tool,
        version: "1.0.0",
      }));
      const merged = [
        ...current.filter((c) => !newRules.find((n) => n.id === c.id && n.tool === c.tool)),
        ...newRules,
      ];
      yield* saveInstalledRules(merged);

      yield* Display.showSuccess(`Installed ${rulesToInstall.length} rule(s) to ${targetPath}`);
    })
  )
);

/**
 * install:remove - Remove installed rules
 */
export const installRemoveCommand = Command.make("remove", {
  args: {
    ruleId: Args.optional(Args.text({ name: "rule-id" }))
  }
}).pipe(
  Command.withDescription("Temporarily disabled until server-backed tool config installation is implemented."),
  Command.withHandler(({ args }) =>
    Effect.gen(function* () {
      yield* Display.showError(
        "The install remove workflow is disabled for launch because tool-file injection is not implemented yet."
      );
      yield* Display.showInfo(
        "Re-enable 'install remove' after server-backed injection and uninstall support is implemented."
      );
      return yield* Effect.fail(new DisabledFeatureError({
        feature: "install remove",
        reason: "Tool-file injection is not implemented yet",
      }));
    })
  )
);

/**
 * install:diff - Compare installed rule with latest
 */
export const installDiffCommand = Command.make("diff", {
  args: {
    ruleId: Args.text({ name: "rule-id" })
  }
}).pipe(
  Command.withDescription("Temporarily disabled until server-backed tool config installation is implemented."),
  Command.withHandler(({ args }) =>
    Effect.gen(function* () {
      yield* Display.showError(
        "The install diff workflow is disabled for launch because tool-file injection is not implemented yet."
      );
      yield* Display.showInfo(
        "Re-enable 'install diff' after server-backed source of truth and file-level diffing are implemented."
      );
      return yield* Effect.fail(new DisabledFeatureError({
        feature: "install diff",
        reason: "Server-backed source of truth and file-level diffing are not implemented yet",
      }));
    })
  )
);

/**
 * Display installed rules or message if none exist
 */
const displayInstalledRules = (
  loadInstalledRules: () => Effect.Effect<InstalledRule[], unknown>
): Effect.Effect<void, unknown> =>
  Effect.gen(function* () {
    const rules = yield* loadInstalledRules();
    if (rules.length === 0) {
      yield* Console.log("No rules installed.");
      return;
    }
    yield* Console.log(colorize("\nðŸ“¦ Installed Rules\n", "BRIGHT"));
    console.table(rules.map(r => ({
      ID: r.id,
      Title: r.title,
      Tool: r.tool,
      Installed: r.installedAt
    })));
  });

/**
 * Display supported AI tools
 */
const displaySupportedTools = (): Effect.Effect<void, unknown> =>
  Effect.gen(function* () {
    yield* Console.log(colorize("\nðŸ“‹ Supported AI Tools\n", "BRIGHT"));
    yield* Console.log("  â€¢ agents");
    yield* Console.log("  â€¢ cursor");
    yield* Console.log("  â€¢ vscode");
    yield* Console.log("  â€¢ windsurf");
  });

/**
 * install:list - List supported tools or installed rules
 */
export const installListCommand = Command.make("list", {
  options: {
    installed: Options.boolean("installed").pipe(
      Options.withDescription("List installed rules"),
      Options.withDefault(false)
    )
  }
}).pipe(
  Command.withDescription("List supported AI tools or installed rules."),
  Command.withHandler(({ options }) =>
    Effect.gen(function* () {
      const { loadInstalledRules } = yield* Install;
      
      if (options.installed) {
        yield* displayInstalledRules(loadInstalledRules);
      } else {
        yield* displaySupportedTools();
      }
    })
  )
);

/**
 * install - Main install command
 */
export const installCommand = Command.make("install").pipe(
  Command.withDescription("Install Effect patterns rules into AI tool configurations"),
  Command.withSubcommands([
    installAddCommand,
    installListCommand,
    installRemoveCommand,
    installDiffCommand
  ])
);
