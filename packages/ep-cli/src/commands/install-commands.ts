/**
 * Install Commands
 */

import { Command, Options, Prompt } from "@effect/cli";
import { FileSystem } from "@effect/platform";
import { Console, Effect, Option } from "effect";
import path from "node:path";
import { Display } from "../services/display/index.js";
import { Install, InstalledRule } from "../services/install/index.js";
import { colorize } from "../utils.js";
import { UnsupportedToolError } from "../errors.js";

type InstallTool = "agent" | "claude" | "cursor" | "vscode" | "windsurf";

const EFFECT_AGENT_START = "<!-- EFFECT_SKILLS_AGENT_START -->";
const EFFECT_AGENT_END = "<!-- EFFECT_SKILLS_AGENT_END -->";
const EFFECT_CLAUDE_START = "<!-- EFFECT_SKILLS_CLAUDE_START -->";
const EFFECT_CLAUDE_END = "<!-- EFFECT_SKILLS_CLAUDE_END -->";

const normalizeTool = (tool: string): InstallTool | null => {
  if (tool === "agents") return "agent";
  if (tool === "agent" || tool === "claude" || tool === "cursor" || tool === "vscode" || tool === "windsurf") {
    return tool;
  }
  return null;
};

const installTargetByTool: Record<InstallTool, string> = {
  agent: "AGENTS.md",
  claude: "CLAUDE.md",
  cursor: ".cursor/rules.md",
  vscode: ".vscode/rules.md",
  windsurf: ".windsurf/rules.md",
};

const markerByTool: Partial<Record<InstallTool, { start: string; end: string }>> = {
  agent: { start: EFFECT_AGENT_START, end: EFFECT_AGENT_END },
  claude: { start: EFFECT_CLAUDE_START, end: EFFECT_CLAUDE_END },
};

const escapeRegex = (value: string) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

const upsertManagedSection = (
  current: string,
  startMarker: string,
  endMarker: string,
  sectionBody: string
): string => {
  const managedSection = `${startMarker}\n${sectionBody}\n${endMarker}\n`;
  const replacePattern = new RegExp(
    `${escapeRegex(startMarker)}[\\s\\S]*?${escapeRegex(endMarker)}\\n?`,
    "m"
  );

  if (current.includes(startMarker) && current.includes(endMarker)) {
    return current.replace(replacePattern, managedSection);
  }

  if (current.trim().length === 0) {
    return managedSection;
  }

  const separator = current.endsWith("\n") ? "\n" : "\n\n";
  return `${current}${separator}${managedSection}`;
};

const buildAgentSection = (
  rules: ReadonlyArray<Pick<InstalledRule, "id" | "title" | "skillLevel" | "useCase" | "description">>,
  generatedAtIso: string
): string =>
  [
    "## Effect Skills",
    "",
    `Generated by ep on ${generatedAtIso}.`,
    "",
    ...rules.flatMap((rule) => [
      `### ${rule.title}`,
      `- ID: ${rule.id}`,
      `- Skill Level: ${rule.skillLevel ?? "general"}`,
      `- Use Cases: ${(rule.useCase ?? []).join(", ") || "none"}`,
      "",
      rule.description,
      "",
    ]),
  ].join("\n");

const buildClaudeSection = (
  rules: ReadonlyArray<Pick<InstalledRule, "title" | "skillLevel" | "useCase" | "description">>,
  generatedAtIso: string
): string =>
  [
    "## Coding Standards (Effect Patterns)",
    "",
    `Updated: ${generatedAtIso}`,
    "",
    "### Guiding Principles",
    "",
    ...rules.map((rule) => {
      const level = rule.skillLevel ?? "general";
      const useCases = (rule.useCase ?? []).slice(0, 3).join(", ");
      const useCaseSuffix = useCases.length > 0 ? ` [${useCases}]` : "";
      return `- **${rule.title}** (${level})${useCaseSuffix}: ${rule.description}`;
    }),
    "",
    "Use these as defaults when making implementation decisions in this repository.",
  ].join("\n");

/**
 * install:add - Add rules to AI tool configuration
 */
export const installAddCommand = Command.make("add", {
  options: {
    tool: Options.text("tool").pipe(
      Options.withDescription("Target tool format (agent, claude, cursor, vscode, windsurf)"),
      Options.withDefault("agent")
    ),
    skillLevel: Options.optional(
      Options.text("skill-level").pipe(
        Options.withDescription("Filter rules by skill level")
      )
    ),
    useCase: Options.optional(
      Options.text("use-case").pipe(
        Options.withDescription("Filter rules by use case")
      )
    ),
    interactive: Options.boolean("interactive").pipe(
      Options.withAlias("i"),
      Options.withDescription("Select rules interactively"),
      Options.withDefault(false)
    ),
  },
}).pipe(
  Command.withDescription("Install rules into supported local tool config files."),
  Command.withHandler(({ options }) =>
    Effect.gen(function* () {
      const { loadInstalledRules, saveInstalledRules, searchRules } = yield* Install;
      const fs = yield* FileSystem.FileSystem;

      const normalizedTool = normalizeTool(options.tool);
      if (!normalizedTool) {
        const supportedTools = ["agent", "claude", "cursor", "vscode", "windsurf"];
        yield* Display.showError(
          `Tool '${options.tool}' is not supported by local file injection yet. Supported: ${supportedTools.join(", ")}`
        );
        return yield* Effect.fail(new UnsupportedToolError({
          tool: options.tool,
          supported: supportedTools,
        }));
      }
      const targetPath = installTargetByTool[normalizedTool];

      yield* Console.log(colorize("\nInstalling rules for " + normalizedTool + "...\n", "CYAN"));

      let rulesToInstall = yield* searchRules({
        skillLevel: Option.getOrUndefined(options.skillLevel),
        useCase: Option.getOrUndefined(options.useCase),
      });

      if (options.interactive) {
        const choices = rulesToInstall.map((rule) => ({
          title: `${rule.title} (${rule.skillLevel || "general"})`,
          value: rule,
          description: rule.description,
        }));

        rulesToInstall = yield* Prompt.multiSelect({
          message: "Select rules to install:",
          choices,
        });
      }

      if (rulesToInstall.length === 0) {
        yield* Display.showWarning("No rules selected or found matching criteria.");
        return;
      }

      const generatedAt = new Date().toISOString();
      const rulesMarkdown = [
        "# Effect Patterns Rules",
        "",
        `Generated by ep on ${generatedAt}.`,
        "Source: Effect Patterns Database",
        "",
        ...rulesToInstall.flatMap((rule) => [
          `## ${rule.title}`,
          "",
          `- ID: ${rule.id}`,
          `- Skill Level: ${rule.skillLevel ?? "general"}`,
          `- Use Cases: ${(rule.useCase ?? []).join(", ") || "none"}`,
          "",
          rule.description,
          "",
          rule.content,
          "",
        ]),
      ].join("\n");

      if (normalizedTool === "agent" || normalizedTool === "claude") {
        const markers = markerByTool[normalizedTool];
        if (!markers) {
          return yield* Effect.fail(new Error(`Missing marker configuration for tool: ${normalizedTool}`));
        }

        const managedBody =
          normalizedTool === "agent"
            ? buildAgentSection(rulesToInstall, generatedAt)
            : buildClaudeSection(rulesToInstall, generatedAt);
        const exists = yield* fs.exists(targetPath);
        const current = exists ? yield* fs.readFileString(targetPath) : "";
        const nextContent = upsertManagedSection(
          current,
          markers.start,
          markers.end,
          managedBody
        );

        yield* fs.writeFileString(targetPath, nextContent);
      } else {
        yield* fs.makeDirectory(path.dirname(targetPath), { recursive: true });
        yield* fs.writeFileString(targetPath, rulesMarkdown);
      }

      // Save install state
      const current = yield* loadInstalledRules();
      const newRules: InstalledRule[] = rulesToInstall.map((r) => ({
        ...r,
        installedAt: new Date().toISOString(),
        tool: normalizedTool,
        version: "1.0.0",
      }));
      const merged = [
        ...current.filter((c) => !newRules.find((n) => n.id === c.id && n.tool === c.tool)),
        ...newRules,
      ];
      yield* saveInstalledRules(merged);

      if (normalizedTool === "agent" || normalizedTool === "claude") {
        yield* Console.log(`âœ… Installed Effect Skills to ${targetPath}`);
      } else {
        yield* Display.showSuccess(`Installed ${rulesToInstall.length} rule(s) to ${targetPath}`);
      }
      yield* Display.showInfo(`Next: ep install list --installed`);
    })
  )
);

/**
 * Display installed rules or message if none exist
 */
const displayInstalledRules = (
  loadInstalledRules: () => Effect.Effect<InstalledRule[], unknown>
): Effect.Effect<void, unknown> =>
  Effect.gen(function* () {
    const rules = yield* loadInstalledRules();
    if (rules.length === 0) {
      yield* Console.log("No rules installed.");
      return;
    }
    yield* Console.log(colorize("\nðŸ“¦ Installed Rules\n", "BRIGHT"));
    console.table(rules.map(r => ({
      ID: r.id,
      Title: r.title,
      Tool: r.tool,
      Installed: r.installedAt
    })));
  });

/**
 * Display supported AI tools
 */
const displaySupportedTools = (): Effect.Effect<void, unknown> =>
  Effect.gen(function* () {
    yield* Console.log(colorize("\nðŸ“‹ Supported AI Tools\n", "BRIGHT"));
    yield* Console.log("  â€¢ agent");
    yield* Console.log("  â€¢ claude");
    yield* Console.log("  â€¢ cursor");
    yield* Console.log("  â€¢ vscode");
    yield* Console.log("  â€¢ windsurf");
  });

/**
 * install:list - List supported tools or installed rules
 */
export const installListCommand = Command.make("list", {
  options: {
    installed: Options.boolean("installed").pipe(
      Options.withDescription("List installed rules"),
      Options.withDefault(false)
    ),
    json: Options.boolean("json").pipe(
      Options.withDescription("Output results as JSON"),
      Options.withDefault(false)
    ),
  }
}).pipe(
  Command.withDescription("List supported AI tools or installed rules."),
  Command.withHandler(({ options }) =>
    Effect.gen(function* () {
      const { loadInstalledRules } = yield* Install;
      const supportedTools = ["agent", "claude", "cursor", "vscode", "windsurf"] as const;

      if (options.json) {
        if (options.installed) {
          const rules = yield* loadInstalledRules();
          yield* Console.log(JSON.stringify({
            count: rules.length,
            rules,
          }, null, 2));
          return;
        }

        yield* Console.log(JSON.stringify({
          tools: supportedTools,
        }, null, 2));
        return;
      }
      
      if (options.installed) {
        yield* displayInstalledRules(loadInstalledRules);
        yield* Display.showInfo("Tip: re-run with --json for machine-readable output.");
      } else {
        yield* displaySupportedTools();
        yield* Display.showInfo("Next: ep install add --tool cursor");
      }
    })
  )
);

/**
 * install - Main install command
 */
export const installCommand = Command.make("install").pipe(
  Command.withDescription("Install Effect patterns rules into AI tool configurations"),
  Command.withSubcommands([
    installAddCommand,
    installListCommand
  ])
);
