/**
 * README Generator Service
 *
 * Generates README.md from database patterns:
 * - Loads application patterns and effect patterns from PostgreSQL
 * - Groups patterns by application pattern
 * - Generates table of contents
 * - Creates formatted markdown sections
 */

import { createApplicationPatternRepository, createDatabase, createEffectPatternRepository } from "@effect-patterns/toolkit";
import { FileSystem } from "@effect/platform";
import { Effect } from "effect";

// --- TYPES ---

export interface PatternInfo {
	slug: string;
	title: string;
	skillLevel: string;
	summary: string;
	lessonOrder?: number | null;
	applicationPatternId: string | null;
}

export interface GeneratorConfig {
	readmePath: string;
}

// --- HELPERS ---

function getSkillLevel(skillLevel: string): string {
	return skillLevel.toLowerCase();
}

function generatePatternLink(
	slug: string,
	_applicationPatternSlug: string | null,
): string {
	return `#${slug}`;
}

function getSkillEmoji(skillLevel: string): string {
	const level = getSkillLevel(skillLevel);
	const emojiMap: Record<string, string> = {
		beginner: "üü¢",
		intermediate: "üü°",
		advanced: "üü†",
	};
	return emojiMap[level] || "‚ö™Ô∏è";
}

// --- README GENERATION ---

export const generateReadme = (
	config: GeneratorConfig,
): Effect.Effect<void, Error, FileSystem.FileSystem> =>
	Effect.gen(function* () {
		const fs = yield* FileSystem.FileSystem;

		// Connect to database
		const { db, close } = createDatabase();
		const apRepo = createApplicationPatternRepository(db);
		const epRepo = createEffectPatternRepository(db);

		try {
			// Load Application Patterns from database
			const applicationPatterns = yield* Effect.promise(() =>
				apRepo.findAll(),
			);
			const sortedAPs = applicationPatterns.sort(
				(a, b) => a.learningOrder - b.learningOrder,
			);

			// Load all Effect Patterns from database
			const allDbPatterns = yield* Effect.promise(() => epRepo.findAll());

			// Create a map of application pattern IDs to slugs
			const apIdToSlug = new Map(
				applicationPatterns.map((ap) => [ap.id, ap.slug]),
			);

			// Convert database patterns to PatternInfo
			const allPatterns: PatternInfo[] = allDbPatterns.map((dbPattern) => ({
				slug: dbPattern.slug,
				title: dbPattern.title,
				skillLevel: dbPattern.skillLevel,
				summary: dbPattern.summary,
				lessonOrder: dbPattern.lessonOrder,
				applicationPatternId: dbPattern.applicationPatternId || null,
			}));

			// Group patterns by Application Pattern slug
			const patternsByAP = new Map<string, PatternInfo[]>();

			for (const pattern of allPatterns) {
				const apSlug = pattern.applicationPatternId
					? apIdToSlug.get(pattern.applicationPatternId) || null
					: null;

				if (!apSlug) continue;

				if (!patternsByAP.has(apSlug)) {
					patternsByAP.set(apSlug, []);
				}
				patternsByAP.get(apSlug)?.push(pattern);
			}

			// Generate README content
			const sections: string[] = [];
			const toc: string[] = [];

			// Build TOC
			toc.push("### Effect Patterns\n");

			for (const ap of sortedAPs) {
				const patterns = patternsByAP.get(ap.slug);
				if (!patterns || patterns.length === 0) continue;

				const anchor = ap.slug.toLowerCase().replace(/\s+/g, "-");
				toc.push(`- [${ap.name}](#${anchor})`);
			}

			toc.push("\n");

			// Generate sections for each Application Pattern
			for (const ap of sortedAPs) {
				const patterns = patternsByAP.get(ap.slug);
				if (!patterns || patterns.length === 0) continue;

				sections.push(`## ${ap.name}\n`);
				sections.push(`${ap.description}\n\n`);

				// Sort patterns by skill level and lesson order
				const sortedPatterns = patterns.sort((a, b) => {
					const levels = { beginner: 0, intermediate: 1, advanced: 2 };
					const levelDiff =
						levels[getSkillLevel(a.skillLevel) as keyof typeof levels] -
						levels[getSkillLevel(b.skillLevel) as keyof typeof levels];
					if (levelDiff !== 0) return levelDiff;
					const orderA = a.lessonOrder ?? 999;
					const orderB = b.lessonOrder ?? 999;
					return orderA - orderB;
				});

				// Render patterns table
				sections.push(
					"| Pattern | Skill Level | Summary |\n| :--- | :--- | :--- |\n",
				);

				for (const pattern of sortedPatterns) {
					const skillLevel = getSkillLevel(pattern.skillLevel);
					const skillEmoji = getSkillEmoji(pattern.skillLevel);
					const link = generatePatternLink(pattern.slug, ap.slug);

					sections.push(
						`| [${pattern.title}](${link}) | ${skillEmoji} **${skillLevel.charAt(0).toUpperCase() + skillLevel.slice(1)}** | ${pattern.summary || ""} |\n`,
					);
				}

				sections.push("\n");
			}

			// Generate full README
			const readme = `<!--
  ‚ö†Ô∏è AUTO-GENERATED FILE - DO NOT EDIT MANUALLY

  This file is automatically generated by the publishing pipeline.
  Any manual edits will be overwritten when the pipeline runs.

  To modify this file:
  - Run: bun run admin pipeline
  - Or modify the generator service in src/services/publish/generator.ts

  For project information, see ABOUT.md
-->

> [!WARNING]
> **This is an auto-generated file.** Manual edits will be overwritten by the publishing pipeline.
> For project information, see [ABOUT.md](./ABOUT.md)

# The Effect Patterns Hub

A community-driven knowledge base of practical, goal-oriented patterns for building robust applications with Effect-TS.

This repository is designed to be a living document that helps developers move from core concepts to advanced architectural strategies by focusing on the "why" behind the code.

**Looking for machine-readable rules for AI IDEs and coding agents? See the [AI Coding Rules](#ai-coding-rules) section below.**

## Table of Contents

${toc.join("\n")}

---

${sections.join("")}`;

			// Write README
			yield* fs.writeFileString(config.readmePath, readme);

			// Close database connection
			yield* Effect.promise(() => close());

			return;
		} catch (error) {
			yield* Effect.promise(() => close());
			return yield* Effect.fail(
				new Error(`Failed to generate README: ${error}`),
			);
		}
	});

export const generateReadmeWithStats = (
	config: GeneratorConfig,
): Effect.Effect<
	{ applicationPatterns: number; effectPatterns: number },
	Error,
	FileSystem.FileSystem
> =>
	Effect.gen(function* () {
		const { db, close } = createDatabase();
		const apRepo = createApplicationPatternRepository(db);
		const epRepo = createEffectPatternRepository(db);

		try {
			const applicationPatterns = yield* Effect.promise(() =>
				apRepo.findAll(),
			);
			const effectPatterns = yield* Effect.promise(() => epRepo.findAll());

			yield* generateReadme(config);

			yield* Effect.promise(() => close());

			return {
				applicationPatterns: applicationPatterns.length,
				effectPatterns: effectPatterns.length,
			};
		} catch (error) {
			yield* Effect.promise(() => close());
			return yield* Effect.fail(
				new Error(`Failed to generate README with stats: ${error}`),
			);
		}
	});
