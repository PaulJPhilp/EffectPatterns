{
  "patterns": [
    {
      "id": "retry-with-backoff",
      "title": "Retry with Exponential Backoff",
      "description": "Automatically retry failed operations with exponentially increasing delays between attempts",
      "category": "error-handling",
      "difficulty": "intermediate",
      "tags": ["retry", "resilience", "error-handling", "backoff"],
      "examples": [
        {
          "language": "typescript",
          "code": "import { Effect, Schedule } from \"effect\";\n\nconst retryWithBackoff = Effect.retry(\n  apiCall,\n  Schedule.exponential(\"100 millis\").pipe(\n    Schedule.compose(Schedule.recurs(5))\n  )\n);\n\nexport { retryWithBackoff };",
          "description": "Retry an API call up to 5 times with exponential backoff"
        }
      ],
      "useCases": [
        "API calls that may fail due to network issues",
        "Database operations with transient failures",
        "External service integrations"
      ]
    },
    {
      "id": "concurrent-batch-processing",
      "title": "Concurrent Batch Processing",
      "description": "Process large datasets concurrently with controlled parallelism",
      "category": "concurrency",
      "difficulty": "intermediate",
      "tags": ["concurrency", "batch", "parallel", "performance"],
      "examples": [
        {
          "language": "typescript",
          "code": "import { Effect, Array } from \"effect\";\n\nconst processBatch = (items: string[]) =>\n  Effect.forEach(\n    items,\n    (item) => processItem(item),\n    { concurrency: 10 }\n  );\n\nexport { processBatch };",
          "description": "Process items with max 10 concurrent operations"
        }
      ],
      "useCases": [
        "Processing large datasets",
        "Bulk API operations",
        "Parallel file processing"
      ]
    },
    {
      "id": "simple-effect",
      "title": "Creating Simple Effects",
      "description": "Learn how to create basic Effect values for success and failure cases",
      "category": "error-handling",
      "difficulty": "beginner",
      "tags": ["basics", "effect", "success", "failure"],
      "examples": [
        {
          "language": "typescript",
          "code": "import { Effect } from \"effect\";\n\nconst success = Effect.succeed(\"Hello, Effect!\");\nconst failure = Effect.fail(\"Something went wrong\");\n\nexport { success, failure };",
          "description": "Basic Effect creation"
        }
      ],
      "useCases": [
        "Learning Effect basics",
        "Simple synchronous operations",
        "Error handling fundamentals"
      ]
    },
    {
      "id": "solve-promise-problems",
      "title": "Solve Promise Problems with Effect",
      "description": "Address common issues with Promises: error handling, cancellation, and composability",
      "category": "fundamentals",
      "difficulty": "beginner",
      "tags": ["promises", "async", "error-handling", "fundamentals"],
      "examples": [
        {
          "language": "typescript",
          "code": "import { Effect } from \"effect\";\n\n// Problem: Promises don't compose well\nconst fetchUser = (id: string) =>\n  Effect.tryPromise(() =>\n    fetch(`/api/users/${id}`).then(res => res.json())\n  );\n\n// Problem: Error handling is scattered\nconst getUserData = (id: string) =>\n  Effect.gen(function* () {\n    const user = yield* fetchUser(id);\n    const posts = yield* fetchUserPosts(user.id);\n    return { user, posts };\n  }).pipe(\n    Effect.catchAll(error =>\n      Effect.succeed({ user: null, posts: [], error })\n    )\n  );",
          "description": "Effect solves Promise composition and error handling issues"
        }
      ],
      "useCases": [
        "Replacing Promise-based async code",
        "Improving error handling in async operations",
        "Building composable async workflows"
      ]
    },
    {
      "id": "effects-are-lazy",
      "title": "Effects are Lazy Blueprints",
      "description": "Understand that Effects are lazy descriptions of computations that run only when executed",
      "category": "fundamentals",
      "difficulty": "beginner",
      "tags": ["lazy", "blueprint", "execution", "fundamentals"],
      "examples": [
        {
          "language": "typescript",
          "code": "import { Effect } from \"effect\";\n\n// Effects are lazy - nothing happens until execution\nconst lazyEffect = Effect.gen(function* () {\n  console.log(\"This won't print until we run the effect!\");\n  return \"Hello, lazy world!\";\n});\n\n// Only when we call runPromise does it execute\nEffect.runPromise(lazyEffect).then(result => {\n  console.log(\"Result:\", result); // \"Hello, lazy world!\"\n});",
          "description": "Effects describe computations but don't execute until explicitly run"
        }
      ],
      "useCases": [
        "Understanding Effect execution model",
        "Building lazy computation graphs",
        "Controlling when side effects occur"
      ]
    },
    {
      "id": "effect-channels",
      "title": "The Three Effect Channels (A, E, R)",
      "description": "Learn about Effect's three channels: Success (A), Error (E), and Requirements (R)",
      "category": "fundamentals",
      "difficulty": "beginner",
      "tags": ["channels", "success", "error", "requirements", "fundamentals"],
      "examples": [
        {
          "language": "typescript",
          "code": "import { Effect, Context } from \"effect\";\n\n// Define a service (Requirement - R)\nclass DatabaseService extends Context.Tag(\"DatabaseService\")<\n  DatabaseService,\n  { query: (sql: string) => Effect.Effect<any[], Error> }\n>() {}\n\n// Effect that requires DatabaseService (R)\nconst getUser = (id: string) =>\n  Effect.gen(function* () {\n    const db = yield* DatabaseService; // Requirement channel\n    return yield* db.query(`SELECT * FROM users WHERE id = ${id}`);\n  }).pipe(\n    Effect.catchAll(error =>\n      Effect.fail(new Error(`Database error: ${error.message}`)) // Error channel\n    )\n  );\n\n// Provide the service and run\nconst program = Effect.provideService(\n  DatabaseService,\n  { query: (sql) => Effect.succeed([{ id: \"1\", name: \"John\" }]) }\n)(getUser(\"1\"));\n\nEffect.runPromise(program).then(result => console.log(result)); // Success channel",
          "description": "Effect uses three channels: Success (A), Error (E), and Requirements (R)"
        }
      ],
      "useCases": [
        "Understanding Effect's type system",
        "Modeling dependencies and services",
        "Type-safe error handling and success values"
      ]
    },
    {
      "id": "execute-with-runpromise",
      "title": "Executing Effects (runPromise, runSync)",
      "description": "Learn how to execute Effect programs using runPromise for async and runSync for sync code",
      "category": "fundamentals",
      "difficulty": "beginner",
      "tags": ["execution", "runPromise", "runSync", "fundamentals"],
      "examples": [
        {
          "language": "typescript",
          "code": "import { Effect } from \"effect\";\n\n// Async execution with runPromise\nconst asyncEffect = Effect.promise(() =>\n  new Promise(resolve => setTimeout(() => resolve(\"Done!\"), 1000))\n);\n\nasyncEffect.pipe(\n  Effect.runPromise\n).then(result => console.log(result)); // \"Done!\"\n\n// Sync execution with runSync\nconst syncEffect = Effect.succeed(42);\n\nconst result = Effect.runSync(syncEffect); // 42\nconsole.log(result);\n\n// Handling different execution contexts\nconst program = Effect.gen(function* () {\n  const asyncResult = yield* asyncEffect;\n  const syncResult = yield* syncEffect;\n  return { asyncResult, syncResult };\n});\n\nEffect.runPromise(program).then(console.log);",
          "description": "Use runPromise for async Effects and runSync for synchronous Effects"
        }
      ],
      "useCases": [
        "Executing Effect programs",
        "Converting Effects to Promises",
        "Running Effects in different contexts"
      ]
    }
  ]
}
