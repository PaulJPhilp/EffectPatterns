---
title: Combining Values with zip
id: combinator-zip
skillLevel: beginner
useCase: core-concepts
summary: >-
  Use zip to combine two computations, pairing their results together in Effect,
  Stream, Option, or Either.
tags:
  - zip
  - combinator
  - pair
  - effect
  - stream
  - option
  - either
rule:
  description: >-
    Use zip to run two computations and combine their results into a tuple,
    preserving error and context handling.
related:
  - combinator-map
  - combinator-flatmap
  - combinator-all-race
author: PaulJPhilp
---

# Combining Values with `zip`

## Guideline

Use the `zip` combinator to combine two computations, pairing their results together.  
This works for `Effect`, `Stream`, `Option`, and `Either`, and is useful when you want to run two computations and work with both results.

## Rationale

`zip` lets you compose computations that are independent but whose results you want to use together.  
It preserves error handling and context, and keeps your code declarative and type-safe.

## Good Example

```typescript
import { Effect, Stream, Option, Either } from "effect";

// Effect: Combine two effects and get both results
const effectA = Effect.succeed(1);
const effectB = Effect.succeed("hello");
const zippedEffect = effectA.pipe(
  Effect.zip(effectB)
); // Effect<[number, string]>

// Option: Combine two options, only Some if both are Some
const optionA = Option.some(1);
const optionB = Option.some("hello");
const zippedOption = Option.all([optionA, optionB]); // Option<[number, string]>

// Either: Combine two eithers, only Right if both are Right
const eitherA = Either.right(1);
const eitherB = Either.right("hello");
const zippedEither = Either.all([eitherA, eitherB]); // Either<never, [number, string]>

// Stream: Pair up values from two streams
const streamA = Stream.fromIterable([1, 2, 3]);
const streamB = Stream.fromIterable(["a", "b", "c"]);
const zippedStream = streamA.pipe(
  Stream.zip(streamB)
); // Stream<[number, string]>
```

**Explanation:**  
`zip` runs both computations and pairs their results.  
If either computation fails (or is None/Left/empty), the result is a failure (or None/Left/empty).

## Anti-Pattern

Manually running two computations, extracting their results, and pairing them outside the combinator world.  
This breaks composability, loses error/context handling, and can lead to subtle bugs.
