description: Never use 'Live', 'Default', 'Impl', or 'Implementation' suffixes for service implementations. Never use .Default explicitly - Effect.Service handles provision automatically.
globs: "**/*.ts"
alwaysApply: true

# Never Use Live, Default, Impl, or Implementation Suffixes
**Rule:** Never use the suffixes `Live`, `Default`, `Impl`, or `Implementation` for service implementations. Never use `.Default` explicitly - `Effect.Service` handles service provision automatically.

### Why This Is Forbidden

When using `Effect.Service`, the service is automatically available when you yield it. You should never explicitly reference `.Default` or create exports with suffixes like `Live`, `Default`, `Impl`, or `Implementation`:

- **Automatic Provision**: `Effect.Service` handles service provision automatically - you don't need to reference `.Default`
- **Redundancy**: Creating exports with suffixes is unnecessary and redundant
- **Confusion**: Having both `ServiceLive` and explicit `.Default` usage creates confusion about which pattern to use
- **Inconsistency**: Mixing patterns makes the codebase harder to understand
- **Maintenance**: Extra exports that serve no purpose increase maintenance burden

### Anti-Pattern (Forbidden)

```typescript
// ❌ FORBIDDEN: Using 'Live' suffix
export class DatabaseService extends Effect.Service<DatabaseService>()(
  "DatabaseService",
  { sync: () => makeDatabase() }
) {}

export const DatabaseServiceLive = DatabaseService.Default; // ❌ FORBIDDEN

// ❌ FORBIDDEN: Using 'Default' suffix
export const DatabaseServiceDefault = DatabaseService.Default; // ❌ FORBIDDEN

// ❌ FORBIDDEN: Using 'Impl' suffix
export const DatabaseServiceImpl = DatabaseService.Default; // ❌ FORBIDDEN

// ❌ FORBIDDEN: Using 'Implementation' suffix
export const DatabaseServiceImplementation = DatabaseService.Default; // ❌ FORBIDDEN

// ❌ FORBIDDEN: Explicitly using .Default
Effect.provide(program, DatabaseService.Default); // ❌ FORBIDDEN

// ❌ FORBIDDEN: Using .Default in dependencies
dependencies: [ConfigService.Default] // ❌ FORBIDDEN

// ❌ FORBIDDEN: Naming implementation functions with these suffixes
const makeDatabaseLive = () => { /* ... */ }; // ❌ FORBIDDEN
const makeDatabaseDefault = () => { /* ... */ }; // ❌ FORBIDDEN
const makeDatabaseImpl = () => { /* ... */ }; // ❌ FORBIDDEN
const makeDatabaseImplementation = () => { /* ... */ }; // ❌ FORBIDDEN
```

### Correct Pattern (Required)

#### 1. Use Effect.Service - Services Are Automatically Available

```typescript
// ✅ CORRECT: Effect.Service automatically handles service provision
export class DatabaseService extends Effect.Service<DatabaseService>()(
  "DatabaseService",
  {
    sync: () => ({
      query: (sql: string) => Effect.succeed([]),
    }),
  }
) {}

// ✅ CORRECT: Just yield the service - Effect handles provision automatically
const program = Effect.gen(function* () {
  const db = yield* DatabaseService;
  return yield* db.query("SELECT * FROM users");
});

// ✅ CORRECT: Effect.Service automatically provides the service when needed
Effect.runPromise(program);
```

#### 2. Services with Dependencies - Automatically Inferred

```typescript
// ✅ CORRECT: Dependencies are automatically inferred from what you yield
export class DatabaseService extends Effect.Service<DatabaseService>()(
  "DatabaseService",
  {
    effect: Effect.gen(function* () {
      const config = yield* ConfigService; // Effect.Service infers ConfigService dependency
      return createDatabase(config);
    }),
    // ✅ CORRECT: No dependencies array needed - Effect.Service infers them automatically
  }
) {}
```

#### 3. Implementation Functions Should Be Private

```typescript
// ✅ CORRECT: Private implementation function with descriptive name
const makeDatabase = (): DatabaseServiceInterface => ({
  query: (sql: string) => Effect.succeed([]),
});

export class DatabaseService extends Effect.Service<DatabaseService>()(
  "DatabaseService",
  {
    sync: () => makeDatabase(),
  }
) {}
```

#### 4. Multiple Implementations Use Descriptive Names

```typescript
// ✅ CORRECT: Use descriptive names for different implementations
const makeInMemoryDatabase = (): DatabaseServiceInterface => ({
  query: (sql: string) => Effect.succeed([]),
});

const makePostgresDatabase = (config: Config): DatabaseServiceInterface => ({
  query: (sql: string) => Effect.tryPromise(() => postgres.query(sql)),
});

// ✅ CORRECT: Different implementations can be provided via Layer
export class DatabaseService extends Effect.Service<DatabaseService>()(
  "DatabaseService",
  {
    sync: () => makeInMemoryDatabase(), // Default implementation
  }
) {}

// ✅ CORRECT: Test implementation uses descriptive name
const makeTestDatabase = (): DatabaseServiceInterface => ({
  query: () => Effect.succeed([{ id: 1, name: "test" }]),
});

const DatabaseServiceTest = Layer.succeed(
  DatabaseService,
  makeTestDatabase()
);
```

#### 5. Layer Composition - Services Are Automatically Available

```typescript
// ✅ CORRECT: Effect.Service handles layer composition automatically
// Services are available when you yield them - no explicit layer merging needed
const program = Effect.gen(function* () {
  const db = yield* DatabaseService;
  const logger = yield* LoggerService;
  const config = yield* ConfigService;
  // All services are automatically available
});

// ❌ FORBIDDEN: Don't create layers with .Default
const AppLayer = Layer.merge(
  DatabaseService.Default, // ❌ FORBIDDEN
  LoggerService.Default,    // ❌ FORBIDDEN
  ConfigService.Default     // ❌ FORBIDDEN
);

// ❌ FORBIDDEN: Don't create intermediate variables with suffixes
const DatabaseServiceLive = DatabaseService.Default; // ❌ FORBIDDEN
```

### Migration Guide

When migrating from old patterns:

1. **Remove `Live` suffix exports**: Delete `export const ServiceLive = ...`
2. **Remove `.Default` usage**: Never explicitly use `Service.Default`
3. **Remove redundant re-exports**: Don't create `ServiceDefault`, `ServiceImpl`, etc.
4. **Update imports**: Remove imports of `ServiceLive` or `Service.Default`
5. **Just yield services**: Services are automatically available when you yield them

**Example Migration:**

```typescript
// Before (❌ FORBIDDEN)
export class StateStore extends Effect.Service<StateStore>()(
  "StateStore",
  { sync: () => makeStateStore() }
) {}
export const StateStoreLive = StateStore.Default; // ❌ FORBIDDEN

// Usage (❌ FORBIDDEN)
Effect.provide(program, StateStoreLive);
// OR
Effect.provide(program, StateStore.Default); // ❌ FORBIDDEN

// After (✅ CORRECT)
export class StateStore extends Effect.Service<StateStore>()(
  "StateStore",
  { sync: () => makeStateStore() }
) {}
// No separate export needed

// Usage (✅ CORRECT)
// Just yield the service - Effect handles provision automatically
const program = Effect.gen(function* () {
  const store = yield* StateStore;
  // Use the service
});
Effect.runPromise(program); // Service is automatically provided
```

### Exception: Test Implementations

Test implementations may use descriptive suffixes that indicate they are test-specific:

```typescript
// ✅ ACCEPTABLE: Test-specific naming is clear
const makeTestDatabase = (): DatabaseServiceInterface => { /* ... */ };
const DatabaseServiceTest = Layer.succeed(DatabaseService, makeTestDatabase());

// ✅ ACCEPTABLE: Mock-specific naming
const makeMockDatabase = (): DatabaseServiceInterface => { /* ... */ };
const DatabaseServiceMock = Layer.succeed(DatabaseService, makeMockDatabase());
```

**Explanation:**  
The `Effect.Service` pattern automatically handles service provision. You should never explicitly reference `.Default` or create exports with suffixes like `Live`, `Default`, `Impl`, or `Implementation`. Simply yield the service class in your `Effect.gen` blocks, and Effect will automatically provide it. Use descriptive names for implementation functions and test-specific layers.
