# Effect-TS Patterns - Compact Rules

- **Access Configuration from the Context**: Access configuration from the Effect context.
- **Access Environment Variables**: Use Effect to access environment variables with proper error handling.
- **Accessing the Current Time with Clock**: Use the Clock service to get the current time, enabling deterministic testing with TestClock.
- **Accumulate Multiple Errors with Either**: Use Either to accumulate multiple validation errors instead of failing on the first one.
- **Accumulate Multiple Errors with Either**: Use Either to model computations that may fail, making errors explicit and type-safe.
- **Add Caching by Wrapping a Layer**: Use a wrapping Layer to add cross-cutting concerns like caching to a service without altering its original implementation.
- **Add Custom Metrics to Your Application**: Use Metric.counter, Metric.gauge, and Metric.histogram to instrument code for monitoring.
- **Add Custom Metrics to Your Application**: Use Effect's Metric module to define and update custom metrics for business and performance monitoring.
- **Add Rate Limiting to APIs**: Use a rate limiter service to enforce request quotas per client.
- **Add Timeouts to HTTP Requests**: Always set timeouts on HTTP requests to ensure your application doesn't hang.
- **Automatically Retry Failed Operations**: Compose a Stream with the .retry(Schedule) operator to automatically recover from transient failures.
- **Avoid Long Chains of .andThen; Use Generators Instead**: Prefer generators over long chains of .andThen.
- **Beyond the Date Type - Real World Dates, Times, and Timezones**: Use the Clock service for testable time-based logic and immutable primitives for timestamps.
- **Build a Basic HTTP Server**: Use a managed Runtime created from a Layer to handle requests in a Node.js HTTP server.
- **Cache HTTP Responses**: Use an in-memory or persistent cache to store HTTP responses.
- **Chaining Computations with flatMap**: Use flatMap to sequence computations, flattening nested structures and preserving error and context handling.
- **Checking Option and Either Cases**: Use isSome, isNone, isLeft, and isRight to check Option and Either cases for simple, type-safe conditional logic.
- **Collect All Results into a List**: Use Stream.runCollect to execute a stream and collect all its emitted values into a Chunk.
- **Combining Values with zip**: Use zip to run two computations and combine their results into a tuple, preserving error and context handling.
- **Comparing Data by Value with Data.struct**: Use Data.struct to define objects whose equality is based on their contents, enabling safe and predictable comparisons.
- **Comparing Data by Value with Structural Equality**: Use Data.struct or implement the Equal interface for value-based comparison of objects and classes.
- **Compose API Middleware**: Use Effect composition to build a middleware pipeline that processes requests.
- **Compose Resource Lifecycles with `Layer.merge`**: Compose multiple scoped layers using `Layer.merge` or by providing one layer to another.
- **Concurrency Pattern 1: Coordinate Async Operations with Deferred**: Use Deferred for one-time async coordination between fibers, enabling multiple consumers to wait for a single producer's result.
- **Concurrency Pattern 2: Rate Limit Concurrent Access with Semaphore**: Use Semaphore to limit concurrent access to resources, preventing overload and enabling fair resource distribution.
- **Concurrency Pattern 3: Coordinate Multiple Fibers with Latch**: Use Latch to coordinate multiple fibers awaiting a common completion signal, enabling fan-out/fan-in and barrier synchronization patterns.
- **Concurrency Pattern 4: Distribute Work with Queue**: Use Queue to distribute work between producers and consumers with built-in backpressure, enabling flexible pipeline coordination.
- **Concurrency Pattern 5: Broadcast Events with PubSub**: Use PubSub to broadcast events to multiple subscribers, enabling event-driven architectures where publishers and subscribers are loosely coupled.
- **Concurrency Pattern 6: Race and Timeout Competing Effects**: Use race to compete effects and timeout to enforce deadlines, enabling cancellation when operations exceed time limits or complete.
- **Conditional Branching with if, when, and cond**: Use combinators such as if, when, and cond to branch computations based on runtime conditions, without imperative if statements.
- **Conditionally Branching Workflows**: Use predicate-based operators like Effect.filter and Effect.if to declaratively control workflow branching.
- **Configure CORS for APIs**: Configure CORS headers to allow legitimate cross-origin requests while blocking unauthorized ones.
- **Configure Linting for Effect**: Use Biome for fast linting with Effect-friendly configuration.
- **Control Flow with Conditional Combinators**: Use conditional combinators for control flow.
- **Control Repetition with Schedule**: Use Schedule to create composable policies for controlling the repetition and retrying of effects.
- **Converting from Nullable, Option, or Either**: Use fromNullable, fromOption, and fromEither to lift nullable values, Option, or Either into Effects or Streams for safe, typeful interop.
- **Create a Basic HTTP Server**: Use Http.server.serve with a platform-specific layer to run an HTTP application.
- **Create a Managed Runtime for Scoped Resources**: Create a managed runtime for scoped resources.
- **Create a Reusable Runtime from Layers**: Create a reusable runtime from layers.
- **Create a Service Layer from a Managed Resource**: Provide a managed resource to the application context using `Layer.scoped`.
- **Create a Stream from a List**: Use Stream.fromIterable to begin a pipeline from an in-memory collection.
- **Create a Testable HTTP Client Service**: Define an HttpClient service with distinct Live and Test layers to enable testable API interactions.
- **Create Observability Dashboards**: Create focused dashboards that answer specific questions about system health.
- **Create Pre-resolved Effects with succeed and fail**: Create pre-resolved effects with succeed and fail.
- **Create Type-Safe Errors**: Use Data.TaggedError to create typed, distinguishable errors for your domain.
- **Creating from Collections**: Use fromIterable and fromArray to lift collections into Streams or Effects for batch or streaming processing.
- **Creating from Synchronous and Callback Code**: Use sync and async to create Effects from synchronous or callback-based computations, making them composable and type-safe.
- **Debug Effect Programs**: Use Effect.tap and logging to inspect values without changing program flow.
- **Decouple Fibers with Queues and PubSub**: Use Queue for point-to-point work distribution and PubSub for broadcast messaging between fibers.
- **Define a Type-Safe Configuration Schema**: Define a type-safe configuration schema.
- **Define Contracts Upfront with Schema**: Define contracts upfront with schema.
- **Define Type-Safe Errors with Data.TaggedError**: Define type-safe errors with Data.TaggedError.
- **Distinguish 'Not Found' from Errors**: Use Effect<Option<A>> to distinguish between recoverable 'not found' cases and actual failures.
- **Effectful Pattern Matching with matchEffect**: Use matchEffect to pattern match on the result of an Effect, running effectful logic for both success and failure cases.
- **Error Handling Pattern 1: Accumulating Multiple Errors**: Use error accumulation to report all problems at once rather than failing early, critical for validation and batch operations.
- **Error Handling Pattern 2: Error Propagation and Chains**: Use error propagation to preserve context through effect chains, enabling debugging and recovery at the right abstraction level.
- **Error Handling Pattern 3: Custom Error Strategies**: Use tagged errors and custom error types to enable type-safe error handling and business-logic-aware recovery strategies.
- **Execute Asynchronous Effects with Effect.runPromise**: Execute asynchronous effects with Effect.runPromise.
- **Execute Long-Running Apps with Effect.runFork**: Use Effect.runFork to launch a long-running application as a manageable, detached fiber.
- **Execute Synchronous Effects with Effect.runSync**: Execute synchronous effects with Effect.runSync.
- **Export Metrics to Prometheus**: Use Effect metrics and expose a /metrics endpoint for Prometheus scraping.
- **Extract Path Parameters**: Define routes with colon-prefixed parameters (e.g., /users/:id) and access their values within the handler.
- **Fan Out to Multiple Consumers**: Use broadcast or partition to send stream data to multiple consumers.
- **Filtering Results with filter**: Use filter to declaratively express conditional logic, keeping only values that satisfy a predicate.
- **Generate OpenAPI Documentation**: Use Schema definitions to automatically generate OpenAPI documentation for your API.
- **Handle a GET Request**: Use Http.router.get to associate a URL path with a specific response Effect.
- **Handle API Errors**: Model application errors as typed classes and use Http.server.serveOptions to map them to specific HTTP responses.
- **Handle Errors with catchTag, catchTags, and catchAll**: Handle errors with catchTag, catchTags, and catchAll.
- **Handle Flaky Operations with Retries and Timeouts**: Use Effect.retry and Effect.timeout to build resilience against slow or intermittently failing effects.
- **Handle Missing Values with Option**: Use Option instead of null/undefined to make missing values explicit and type-safe.
- **Handle Rate Limiting Responses**: Detect 429 responses and automatically retry after the Retry-After period.
- **Handle Resource Timeouts**: Always set timeouts on resource acquisition to prevent indefinite waits.
- **Handle Unexpected Errors by Inspecting the Cause**: Handle unexpected errors by inspecting the cause.
- **Handle Unexpected Errors by Inspecting the Cause**: Use Cause to inspect, analyze, and handle all possible failure modes of an Effect, including expected errors, defects, and interruptions.
- **Handle Your First Error with Effect.fail and catchAll**: Handle errors with Effect.fail and catchAll.
- **Handling Errors with catchAll, orElse, and match**: Use error handling combinators to recover from failures, provide fallback values, or transform errors in a composable way.
- **Handling Specific Errors with catchTag and catchTags**: Use catchTag and catchTags to handle specific tagged error types in the Effect failure channel, providing targeted recovery logic.
- **Hello World: Your First Effect**: Create your first Effect program with Effect.succeed.
- **Implement API Authentication**: Use middleware to validate authentication tokens before handling requests.
- **Implement Backpressure in Pipelines**: Use buffering and throttling to handle producers faster than consumers.
- **Implement Dead Letter Queues**: Capture failed items with context for debugging and retry instead of losing them.
- **Implement Distributed Tracing**: Propagate trace context across service boundaries to correlate requests.
- **Implement Graceful Shutdown for Your Application**: Use Effect.runFork and OS signal listeners to implement graceful shutdown for long-running applications.
- **Instrument and Observe Function Calls with Effect.fn**: Use Effect.fn to wrap functions with effectful instrumentation, such as logging, metrics, or tracing, in a composable and type-safe way.
- **Integrate Effect Tracing with OpenTelemetry**: Integrate Effect.withSpan with OpenTelemetry to export traces and visualize request flows across services.
- **Leverage Effect's Built-in Structured Logging**: Use Effect.log, Effect.logInfo, and Effect.logError to add structured, context-aware logging to your Effect code.
- **Leverage Effect's Built-in Structured Logging**: Leverage Effect's built-in structured logging.
- **Lifting Errors and Absence with fail, none, and left**: Use fail, none, and left to create Effect, Option, or Either that represent failure or absence.
- **Lifting Values with succeed, some, and right**: Use succeed, some, and right to create Effect, Option, or Either from plain values.
- **Log HTTP Requests and Responses**: Use Effect's logging to trace HTTP requests for debugging and monitoring.
- **Make an Outgoing HTTP Client Request**: Use the Http.client module to make outgoing requests to keep the entire operation within the Effect ecosystem.
- **Manage Hierarchical Resources**: Use nested Scopes to manage resources with parent-child dependencies.
- **Manage Resource Lifecycles with Scope**: Use Scope for fine-grained, manual control over resource lifecycles and cleanup guarantees.
- **Manage Resources Safely in a Pipeline**: Use Stream.acquireRelease to safely manage the lifecycle of a resource within a pipeline.
- **Manage Shared State Safely with Ref**: Use Ref to manage shared, mutable state concurrently, ensuring atomicity.
- **Manage Shared State Safely with Ref**: Use Ref to safely manage shared, mutable state in concurrent and effectful programs.
- **Manually Manage Lifecycles with `Scope`**: Use `Effect.scope` and `Scope.addFinalizer` for fine-grained control over resource cleanup.
- **Mapping and Chaining over Collections with forEach and all**: Use forEach and all to process collections of values with effectful functions, collecting results in a type-safe and composable way.
- **Mapping Errors to Fit Your Domain**: Use Effect.mapError to transform errors and create clean architectural boundaries between layers.
- **Matching on Success and Failure with match**: Use match to pattern match on the result of an Effect, Option, or Either, handling both success and failure cases declaratively.
- **Matching Tagged Unions with matchTag and matchTags**: Use matchTag and matchTags to handle specific cases of tagged unions or custom error types in a declarative, type-safe way.
- **Merge Multiple Streams**: Use merge, concat, or zip to combine multiple streams based on your requirements.
- **Mocking Dependencies in Tests**: Provide mock service implementations via a test-specific Layer to isolate the unit under test.
- **Model Dependencies as Services**: Model dependencies as services.
- **Model Optional Values Safely with Option**: Use Option<A> to explicitly model values that may be absent, avoiding null or undefined.
- **Model Optional Values Safely with Option**: Use Option to model values that may be present or absent, making absence explicit and type-safe.
- **Model Validated Domain Types with Brand**: Model validated domain types with Brand.
- **Modeling Effect Results with Exit**: Use Exit to capture the outcome of an Effect, including success, failure, and defects, for robust error handling and coordination.
- **Modeling Tagged Unions with Data.case**: Use Data.case to define tagged unions (ADTs) for modeling domain-specific states and enabling exhaustive pattern matching.
- **Modeling Validated Domain Types with Brand**: Use Brand to define types like Email, UserId, or PositiveInt, ensuring only valid values can be constructed and used.
- **Optional Pattern 1: Handling None and Some Values**: Use Option to represent values that may not exist, replacing null/undefined with type-safe Option that forces explicit handling.
- **Optional Pattern 2: Optional Chaining and Composition**: Use Option combinators (map, flatMap, ap) to compose operations that may fail, creating readable and maintainable pipelines.
- **Organize Layers into Composable Modules**: Organize services into modular Layers that are composed hierarchically to manage complexity in large applications.
- **Parse and Validate Data with Schema.decode**: Parse and validate data with Schema.decode.
- **Parse JSON Responses Safely**: Always validate HTTP responses with Schema to catch API changes at runtime.
- **Pattern Match on Option and Either**: Use Option.match() and Either.match() for declarative pattern matching on optional and error-prone values
- **Platform Pattern 1: Execute Shell Commands**: Use Command to spawn and manage external processes, capturing output and handling exit codes reliably with proper error handling.
- **Platform Pattern 2: Filesystem Operations**: Use FileSystem module for safe, resource-managed file operations with proper error handling and cleanup.
- **Platform Pattern 3: Persistent Key-Value Storage**: Use KeyValueStore for simple persistent storage of key-value pairs, enabling lightweight caching and session management.
- **Platform Pattern 4: Interactive Terminal I/O**: Use Terminal for user input/output in CLI applications, providing proper buffering and cross-platform character encoding.
- **Platform Pattern 5: Cross-Platform Path Manipulation**: Use Effect's platform-aware path utilities to handle separators, absolute/relative paths, and environment variables consistently.
- **Platform Pattern 6: Advanced FileSystem Operations**: Use advanced file system patterns to implement efficient, reliable file operations with proper error handling and resource cleanup.
- **Poll for Status Until a Task Completes**: Use Effect.race to run a repeating polling task that is automatically interrupted when a main task completes.
- **Pool Resources for Reuse**: Use Pool to manage expensive resources that can be reused across operations.
- **Process a Collection in Parallel with Effect.forEach**: Use Effect.forEach with the `concurrency` option to process a collection in parallel with a fixed limit.
- **Process a Large File with Constant Memory**: Use Stream.fromReadable with a Node.js Readable stream to process files efficiently.
- **Process collections of data asynchronously**: Leverage Stream to process collections effectfully with built-in concurrency control and resource safety.
- **Process Items Concurrently**: Use Stream.mapEffect with the `concurrency` option to process stream items in parallel.
- **Process Items in Batches**: Use Stream.grouped(n) to transform a stream of items into a stream of batched chunks.
- **Process Streaming Data with Stream**: Use Stream to model and process data that arrives over time in a composable, efficient way.
- **Profile Effect Applications**: Use Effect's timing features and Node.js profilers to find performance bottlenecks.
- **Property-Based Testing with Effect**: Use property-based testing to find edge cases your example-based tests miss.
- **Provide Configuration to Your App via a Layer**: Provide configuration to your app via a Layer.
- **Provide Dependencies to Routes**: Define dependencies with Effect.Service and provide them to your HTTP server using a Layer.
- **Race Concurrent Effects for the Fastest Result**: Use Effect.race to get the result from the first of several effects to succeed, automatically interrupting the losers.
- **Race Effects and Handle Timeouts**: Use Effect.race for fastest-wins, Effect.timeout for time limits.
- **Read Effect Type Errors**: Effect errors are verbose but structured - learn to extract the key information.
- **Redact and Handle Sensitive Data**: Use Redacted to wrap sensitive values, preventing accidental exposure in logs or error messages.
- **Representing Time Spans with Duration**: Use Duration to model and manipulate time spans, enabling safe and expressive time-based logic.
- **Representing Time Spans with Duration**: Use the Duration data type to represent time intervals instead of raw numbers.
- **Retry a Failed Operation with Effect.retry**: Retry failed operations with Effect.retry.
- **Retry Failed Operations**: Use Effect.retry with a Schedule to handle transient failures gracefully.
- **Retry HTTP Requests with Backoff**: Use Schedule to retry failed HTTP requests with configurable backoff strategies.
- **Retry Operations Based on Specific Errors**: Use predicate-based retry policies to retry an operation only for specific, recoverable errors.
- **Run a Pipeline for its Side Effects**: Use Stream.runDrain to execute a stream for its side effects when you don't need the final values.
- **Run Background Tasks with Effect.fork**: Use Effect.fork to start a non-blocking background process and manage its lifecycle via its Fiber.
- **Run Independent Effects in Parallel with Effect.all**: Use Effect.all to execute a collection of independent effects concurrently.
- **Run Multiple Effects in Parallel with Effect.all**: Run multiple Effects in parallel with Effect.all.
- **Running and Collecting Stream Results**: Choose the right Stream.run* method based on what you need from the results.
- **Safely Bracket Resource Usage with `acquireRelease`**: Bracket the use of a resource between an `acquire` and a `release` effect.
- **Scheduling Pattern 1: Repeat an Effect on a Fixed Interval**: Repeat effects at fixed intervals using Schedule.fixed for steady-state operations and background tasks.
- **Scheduling Pattern 2: Implement Exponential Backoff for Retries**: Use exponential backoff with jitter for retries to prevent overwhelming failing services and improve success likelihood through smart timing.
- **Scheduling Pattern 3: Schedule Tasks with Cron Expressions**: Use cron expressions to schedule periodic tasks at specific calendar times, enabling flexible scheduling beyond simple fixed intervals.
- **Scheduling Pattern 4: Debounce and Throttle Execution**: Use debounce to wait for silence before executing, and throttle to limit execution frequency, both critical for handling rapid events.
- **Scheduling Pattern 5: Advanced Retry Chains and Circuit Breakers**: Use retry chains with circuit breakers to handle complex failure scenarios, detect cascade failures early, and prevent resource exhaustion.
- **Send a JSON Response**: Use Http.response.json to automatically serialize data structures into a JSON response.
- **Sequencing with andThen, tap, and flatten**: Use sequencing combinators to run computations in order, perform side effects, or flatten nested structures, while preserving error and context handling.
- **Set Up a New Effect Project**: Set up a new Effect project.
- **Set Up Alerting**: Create alerts based on SLOs and symptoms, not causes.
- **Set Up CI/CD for Effect Projects**: Use GitHub Actions with proper caching for fast Effect project CI/CD.
- **Set Up Your Effect Development Environment**: Install the Effect extension and configure TypeScript for optimal Effect development.
- **Sink Pattern 1: Batch Insert Stream Records into Database**: Batch stream records before database operations to improve throughput and reduce transaction overhead.
- **Sink Pattern 2: Write Stream Events to Event Log**: Append stream events to an event log with metadata to maintain a complete, ordered record of what happened.
- **Sink Pattern 3: Write Stream Lines to File**: Write streaming lines to a file efficiently using buffered output and proper resource management.
- **Sink Pattern 4: Send Stream Records to Message Queue**: Stream records to message queues with proper batching and acknowledgment for reliable distributed data flow.
- **Sink Pattern 5: Fall Back to Alternative Sink on Failure**: Implement fallback sinks to handle failures gracefully and ensure data is persisted even when the primary destination is unavailable.
- **Sink Pattern 6: Retry Failed Stream Operations**: Implement retry strategies in sinks to handle transient failures and improve resilience without manual intervention.
- **Solve Promise Problems with Effect**: Recognize that Effect solves the core limitations of Promises: untyped errors, no dependency injection, and no cancellation.
- **State Management Pattern 1: Synchronized Reference with SynchronizedRef**: Use SynchronizedRef for thread-safe mutable state that must be updated consistently across concurrent operations, with atomic modifications.
- **State Management Pattern 2: Observable State with SubscriptionRef**: Combine Ref with PubSub to create observable state where changes trigger notifications, enabling reactive state management.
- **Stream Pattern 1: Transform Streams with Map and Filter**: Use map and filter combinators to transform stream elements declaratively, creating pipelines that reshape data without materializing intermediate results.
- **Stream Pattern 2: Merge and Combine Multiple Streams**: Use merge and concat combinators to combine multiple streams, enabling aggregation of data from multiple independent sources.
- **Stream Pattern 3: Control Backpressure in Streams**: Use backpressure control to manage flow between fast producers and slow consumers, preventing memory exhaustion and resource overflow.
- **Stream Pattern 4: Stateful Operations with Scan and Fold**: Use scan for stateful element-by-element processing and fold for final aggregation, enabling complex stream analytics without buffering entire stream.
- **Stream Pattern 5: Grouping and Windowing Streams**: Use groupBy to partition streams by key and tumbling/sliding windows to aggregate streams over time windows.
- **Stream Pattern 6: Resource Management in Streams**: Use Stream.bracket or effect scoping to guarantee resource cleanup, preventing leaks even when streams fail or are interrupted.
- **Stream Pattern 7: Error Handling in Streams**: Use Stream error handlers to recover from failures, retry operations, and maintain stream integrity even when individual elements fail.
- **Stream Pattern 8: Advanced Stream Transformations**: Use advanced stream operators to build sophisticated data pipelines that compose elegantly and maintain performance at scale.
- **Stream vs Effect - When to Use Which**: Use Effect for single values, Stream for sequences of values.
- **Supercharge Your Editor with the Effect LSP**: Install and use the Effect LSP extension for enhanced type information and error checking in your editor.
- **Take and Drop Stream Elements**: Use take/drop to control stream size, takeWhile/dropWhile for conditional limits.
- **Teach your AI Agents Effect with the MCP Server**: Use the MCP server to provide live application context to AI coding agents, enabling more accurate assistance.
- **Test Concurrent Code**: Use TestClock and controlled concurrency to make concurrent tests deterministic.
- **Test Effects with Services**: Provide test implementations of services to make Effect programs testable.
- **Test Streaming Effects**: Use Stream.runCollect and assertions to verify stream behavior.
- **Trace Operations Across Services with Spans**: Use Effect.withSpan to create and annotate tracing spans for operations, enabling distributed tracing and performance analysis.
- **Trace Operations Across Services with Spans**: Use Effect.withSpan to create custom tracing spans for important operations.
- **Transform Data During Validation with Schema**: Use Schema.transform to safely convert data types during the validation and parsing process.
- **Transform Effect Values with map and flatMap**: Transform Effect values with map and flatMap.
- **Transform Values with Effect.map**: Transform Effect values with map.
- **Transforming Values with map**: Use map to apply a pure function to the value inside an Effect, Stream, Option, or Either.
- **Turn a Paginated API into a Single Stream**: Use Stream.paginateEffect to model a paginated data source as a single, continuous stream.
- **Type Classes for Equality, Ordering, and Hashing with Data.Class**: Use Data.Class to define and derive type classes for your data types, supporting composable equality, ordering, and hashing.
- **Understand Fibers as Lightweight Threads**: Understand that a Fiber is a lightweight, virtual thread managed by the Effect runtime for massive concurrency.
- **Understand Layers for Dependency Injection**: Understand that a Layer is a blueprint describing how to construct a service and its dependencies.
- **Understand that Effects are Lazy Blueprints**: Understand that effects are lazy blueprints.
- **Understand the Three Effect Channels (A, E, R)**: Understand that an Effect&lt;A, E, R&gt; describes a computation with a success type (A), an error type (E), and a requirements type (R).
- **Understanding Fibers**: Fibers are lightweight threads managed by Effect, enabling efficient concurrency without OS thread overhead.
- **Use .pipe for Composition**: Use .pipe for composition.
- **Use Chunk for High-Performance Collections**: Use Chunk to model immutable, high-performance collections for efficient data processing and transformation.
- **Use Chunk for High-Performance Collections**: Prefer Chunk over Array for immutable collection operations within data processing pipelines for better performance.
- **Use Effect DevTools**: Use Effect's built-in debugging features and logging for development.
- **Use Effect.gen for Business Logic**: Use Effect.gen for business logic.
- **Use the Auto-Generated .Default Layer in Tests**: Use the auto-generated .Default layer in tests.
- **Validate Request Body**: Use Http.request.schemaBodyJson with a Schema to automatically parse and validate request bodies.
- **Validating and Parsing Branded Types**: Combine Schema and Brand to validate and parse branded types, guaranteeing only valid domain values are created at runtime.
- **Why Effect? Comparing Effect to Promise**: Understand why Effect is better than raw Promises.
- **Work with Arbitrary-Precision Numbers using BigDecimal**: Use BigDecimal to represent and compute with decimal numbers that require arbitrary precision, such as in finance or scientific domains.
- **Work with Dates and Times using DateTime**: Use DateTime to represent and manipulate dates and times in a type-safe, immutable, and time-zone-aware way.
- **Work with Immutable Sets using HashSet**: Use HashSet to represent sets of unique values with efficient, immutable operations for membership, union, intersection, and difference.
- **Working with Immutable Arrays using Data.array**: Use Data.array to define arrays whose equality is based on their contents, enabling safe, predictable comparisons and functional operations.
- **Working with Tuples using Data.tuple**: Use Data.tuple to define tuples whose equality is based on their contents, enabling safe and predictable comparisons and pattern matching.
- **Wrap Asynchronous Computations with tryPromise**: Wrap asynchronous computations with tryPromise.
- **Wrap Synchronous Computations with sync and try**: Wrap synchronous computations with sync and try.
- **Wrapping Synchronous and Asynchronous Computations**: Use try and tryPromise to lift code that may throw or reject into Effect, capturing errors in the failure channel.
- **Write Sequential Code with Effect.gen**: Write sequential code with Effect.gen.
- **Write Tests That Adapt to Application Code**: Write tests that adapt to application code.
- **Your First Domain Model**: Start domain modeling by defining clear interfaces for your business entities.
- **Your First Effect Test**: Use Effect.runPromise in tests to run and assert on Effect results.
- **Your First Error Handler**: Use catchAll or catchTag to recover from errors and keep your program running.
- **Your First HTTP Request**: Use @effect/platform HttpClient for type-safe HTTP requests with automatic error handling.
- **Your First Logs**: Use Effect.log and related functions for structured, contextual logging.
- **Your First Parallel Operation**: Use Effect.all with concurrency option to run independent effects in parallel.
- **Your First Platform Operation**: Use @effect/platform for cross-platform system operations with Effect integration.
- **Your First Schedule**: Use Schedule to control when and how often effects run.
- **Your First Stream**: Use Stream to process sequences of data lazily and efficiently.
