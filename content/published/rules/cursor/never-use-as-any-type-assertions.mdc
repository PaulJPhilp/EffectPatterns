description: Never use 'as any' type assertions - they bypass TypeScript's type safety.
globs: "**/*.ts"
alwaysApply: true

# Never Use 'as any' Type Assertions
**Rule:** Never use `as any` type assertions. They bypass TypeScript's type safety and are an anti-pattern.

### Why This Is Forbidden

Using `as any` disables TypeScript's type checking, which defeats the purpose of using a type-safe language. It can lead to:
- Runtime errors that could have been caught at compile time
- Loss of IDE autocomplete and type hints
- Hidden bugs that surface in production
- Reduced code maintainability

### Anti-Pattern (Forbidden)

```typescript
// ❌ FORBIDDEN: Using 'as any' to bypass type checking
const result = someFunction() as any;
const value = (someOption as any).value;
const effect = someEffect.gen(function* () {
  // ...
}) as any;
```

### Correct Approaches

#### 1. Fix Type Mismatches Properly

If you encounter type errors, fix the underlying issue:

```typescript
// ✅ CORRECT: Fix the type definition or use proper type narrowing
const result: ExpectedType = someFunction();
const value = Option.isSome(someOption) ? someOption.value : defaultValue;
```

#### 2. Use Type Guards

```typescript
// ✅ CORRECT: Use type guards for runtime type checking
function isExpectedType(value: unknown): value is ExpectedType {
  return typeof value === "object" && value !== null && "property" in value;
}

if (isExpectedType(value)) {
  // TypeScript knows value is ExpectedType here
  console.log(value.property);
}
```

#### 3. Use Proper Type Assertions

If you must assert a type, use a more specific assertion:

```typescript
// ✅ CORRECT: Use specific type assertions when you're certain
const result = someValue as SpecificType;
// Or use type predicates
const result = someValue as unknown as SpecificType;
```

#### 4. Fix Dependency Version Conflicts

If type errors are caused by multiple versions of the same library:

```typescript
// ✅ CORRECT: Resolve dependency conflicts at the package level
// Update package.json to use consistent versions
// Use workspace hoisting or resolution strategies
```

#### 5. Use Effect's Type System Properly

For Effect-specific type issues:

```typescript
// ✅ CORRECT: Use Effect's type system features
const effect = Effect.gen(function* () {
  const value = yield* someEffect;
  return value;
});

// ✅ CORRECT: Use Effect.map, Effect.flatMap, etc. for type transformations
const transformed = effect.pipe(
  Effect.map((value) => value.property)
);
```

**Explanation:**  
Type safety is one of TypeScript's core benefits. Using `as any` throws away this protection and should never be used. Always fix the underlying type issue instead of bypassing it.
