---
title: Your First Parallel Operation
id: concurrency-hello-world
skillLevel: beginner
useCase: concurrency-getting-started
summary: >-
  Run multiple effects in parallel with Effect.all and understand when to use parallel vs sequential execution.
tags:
  - concurrency
  - parallel
  - effect-all
  - getting-started
rule:
  description: Use Effect.all with concurrency option to run independent effects in parallel.
author: PaulJPhilp
related:
  - concurrency-understanding-fibers
  - concurrency-race-timeout
---

## Guideline

Use `Effect.all` with `{ concurrency: "unbounded" }` to run independent effects in parallel. Without the option, effects run sequentially.

---

## Rationale

Parallel execution speeds up independent operations:

1. **Fetch multiple APIs** - Get user, products, cart simultaneously
2. **Process files** - Read multiple files at once
3. **Database queries** - Run independent queries in parallel

---

## Good Example

```typescript
import { Effect } from "effect"

// Simulate async operations
const fetchUser = Effect.gen(function* () {
  yield* Effect.sleep("100 millis")
  return { id: 1, name: "Alice" }
})

const fetchProducts = Effect.gen(function* () {
  yield* Effect.sleep("150 millis")
  return [{ id: 1, name: "Widget" }, { id: 2, name: "Gadget" }]
})

const fetchCart = Effect.gen(function* () {
  yield* Effect.sleep("80 millis")
  return { items: 3, total: 99.99 }
})

// ============================================
// SEQUENTIAL: One after another (~330ms)
// ============================================

const sequential = Effect.all([fetchUser, fetchProducts, fetchCart])

// ============================================
// PARALLEL: All at once (~150ms)
// ============================================

const parallel = Effect.all(
  [fetchUser, fetchProducts, fetchCart],
  { concurrency: "unbounded" }
)

// ============================================
// PARALLEL WITH LIMIT: Max 2 at a time
// ============================================

const limited = Effect.all(
  [fetchUser, fetchProducts, fetchCart],
  { concurrency: 2 }
)

// ============================================
// DEMO
// ============================================

const demo = Effect.gen(function* () {
  const start = Date.now()
  
  const [user, products, cart] = yield* parallel
  
  const elapsed = Date.now() - start
  yield* Effect.log(`Fetched in ${elapsed}ms`)
  yield* Effect.log(`User: ${user.name}`)
  yield* Effect.log(`Products: ${products.length}`)
  yield* Effect.log(`Cart total: $${cart.total}`)
})

Effect.runPromise(demo)
// Output: Fetched in ~150ms (not ~330ms!)
```

## Concurrency Options

| Option | Behavior |
|--------|----------|
| **(none)** | Sequential, one at a time |
| `{ concurrency: "unbounded" }` | All in parallel |
| `{ concurrency: N }` | Max N in parallel |
| `{ concurrency: "inherit" }` | Use parent's setting |

## When to Use Parallel

✅ **Use parallel when:**
- Operations are independent
- No shared mutable state
- Speed matters

❌ **Use sequential when:**
- Operations depend on each other
- Order matters
- Rate limiting required

## Quick Reference

```typescript
// Sequential (default)
Effect.all([a, b, c])

// Parallel (all at once)
Effect.all([a, b, c], { concurrency: "unbounded" })

// Limited parallel (max 5)
Effect.all([a, b, c], { concurrency: 5 })
```

