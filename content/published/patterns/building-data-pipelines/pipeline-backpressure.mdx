---
title: Implement Backpressure in Pipelines
id: pipeline-backpressure
skillLevel: advanced
applicationPatternId: building-data-pipelines
summary: >-
  Control data flow rates to prevent overwhelming slow consumers.
tags:
  - data-pipelines
  - backpressure
  - flow-control
  - streams
rule:
  description: Use buffering and throttling to handle producers faster than consumers.
author: PaulJPhilp
related:
  - process-concurrently
  - process-batches
---

## Guideline

Use Stream's built-in backpressure mechanisms and explicit buffering to handle situations where data producers are faster than consumers.

---

## Rationale

Backpressure prevents system overload:

1. **Memory safety** - Don't buffer unlimited data
2. **Stability** - Slow consumers don't crash
3. **Fairness** - Distribute load appropriately
4. **Predictability** - Consistent performance

---

## Good Example

```typescript
import { Effect, Stream, Schedule, Duration, Queue, Chunk } from "effect"

// ============================================
// 1. Stream with natural backpressure
// ============================================

// Streams have built-in backpressure - consumers pull data
const fastProducer = Stream.fromIterable(Array.from({ length: 1000 }, (_, i) => i))

const slowConsumer = fastProducer.pipe(
  Stream.tap((n) =>
    Effect.gen(function* () {
      yield* Effect.sleep("10 millis")  // Slow processing
      yield* Effect.log(`Processed: ${n}`)
    })
  ),
  Stream.runDrain
)

// Producer automatically slows down to match consumer

// ============================================
// 2. Explicit buffer with drop strategy
// ============================================

const bufferedStream = (source: Stream.Stream<number>) =>
  source.pipe(
    // Buffer up to 100 items, drop oldest when full
    Stream.buffer({ capacity: 100, strategy: "dropping" })
  )

// ============================================
// 3. Throttling - limit rate
// ============================================

const throttledStream = (source: Stream.Stream<number>) =>
  source.pipe(
    // Process at most 10 items per second
    Stream.throttle({
      cost: () => 1,
      units: 10,
      duration: "1 second",
      strategy: "enforce",
    })
  )

// ============================================
// 4. Debounce - wait for quiet period
// ============================================

const debouncedStream = (source: Stream.Stream<number>) =>
  source.pipe(
    // Wait 100ms of no new items before emitting
    Stream.debounce("100 millis")
  )

// ============================================
// 5. Bounded queue for producer-consumer
// ============================================

const boundedQueueExample = Effect.gen(function* () {
  // Create bounded queue - blocks producer when full
  const queue = yield* Queue.bounded<number>(10)

  // Fast producer
  const producer = Effect.gen(function* () {
    for (let i = 0; i < 100; i++) {
      yield* Queue.offer(queue, i)
      yield* Effect.log(`Produced: ${i}`)
    }
    yield* Queue.shutdown(queue)
  })

  // Slow consumer
  const consumer = Effect.gen(function* () {
    let count = 0
    while (true) {
      const item = yield* Queue.take(queue).pipe(
        Effect.catchTag("QueueShutdown", () => Effect.fail("done" as const))
      )
      if (item === "done") break
      yield* Effect.sleep("50 millis")  // Slow processing
      yield* Effect.log(`Consumed: ${item}`)
      count++
    }
    return count
  }).pipe(Effect.catchAll(() => Effect.succeed(0)))

  // Run both - producer will block when queue is full
  yield* Effect.all([producer, consumer], { concurrency: 2 })
})

// ============================================
// 6. Sliding window - keep most recent
// ============================================

const slidingWindowStream = (source: Stream.Stream<number>) =>
  source.pipe(
    Stream.sliding(5),  // Keep last 5 items
    Stream.map((window) => ({
      items: window,
      average: Chunk.reduce(window, 0, (a, b) => a + b) / Chunk.size(window),
    }))
  )

// ============================================
// 7. Run example
// ============================================

const program = Effect.gen(function* () {
  yield* Effect.log("=== Backpressure Demo ===")

  // Throttled stream
  const throttled = Stream.fromIterable([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]).pipe(
    Stream.tap((n) => Effect.log(`Emitting: ${n}`)),
    Stream.throttle({
      cost: () => 1,
      units: 2,
      duration: "1 second",
      strategy: "enforce",
    }),
    Stream.tap((n) => Effect.log(`After throttle: ${n}`)),
    Stream.runDrain
  )

  yield* throttled
})

Effect.runPromise(program)
```

## Backpressure Strategies

| Strategy | Behavior | Use When |
|----------|----------|----------|
| **Block** | Producer waits | Data loss unacceptable |
| **Drop oldest** | Discard old items | Real-time data |
| **Drop newest** | Discard new items | Batch processing |
| **Throttle** | Limit rate | API rate limits |
| **Sample** | Keep periodic | High-frequency data |

## Key Functions

| Function | Purpose |
|----------|---------|
| `Stream.buffer` | Add explicit buffer |
| `Stream.throttle` | Limit items per time |
| `Stream.debounce` | Wait for quiet period |
| `Queue.bounded` | Bounded queue |
| `Stream.sliding` | Moving window |

## Best Practices

1. **Size buffers appropriately** - Too small = blocking, too large = memory
2. **Monitor queue depth** - Alerts when consistently full
3. **Choose strategy per use case** - Real-time vs batch
4. **Test under load** - Verify behavior at limits

