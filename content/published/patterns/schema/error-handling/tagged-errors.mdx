---
id: error-handling-tagged-errors
title: Custom Tagged Errors
category: error-handling
skillLevel: beginner
tags:
  - error-handling
  - tagged-errors
  - type-safety
  - error-types
  - discriminated-unions
lessonOrder: 14
rule:
  description: >-
    Custom Tagged Errors using Schema.
summary: >-
  Your application throws generic `Error` objects. When calling a function, you don't know what errors it might throw. Is it a validation error? Network timeout? Permission denied? Code that calls your...
---

# Problem

Your application throws generic `Error` objects. When calling a function, you don't know what errors it might throw. Is it a validation error? Network timeout? Permission denied? Code that calls your function has no way to handle specific errors differently. You need type-safe, discriminated error types that document what can go wrong and enable precise error handling.

# Solution

```typescript
import { Data, Effect } from "effect"

// ============================================
// 1. Define custom tagged errors
// ============================================

// Simple tagged error
class ValidationError extends Data.TaggedError("ValidationError") {
  constructor(readonly field: string, readonly message: string) {
    super()
  }
}

// Network-related errors
class NetworkError extends Data.TaggedError("NetworkError") {
  constructor(readonly message: string, readonly statusCode?: number) {
    super()
  }
}

class TimeoutError extends Data.TaggedError("TimeoutError") {
  constructor(readonly durationMs: number) {
    super()
  }
}

// Authorization errors
class UnauthorizedError extends Data.TaggedError("UnauthorizedError") {
  constructor(readonly reason: string) {
    super()
  }
}

class ForbiddenError extends Data.TaggedError("ForbiddenError") {
  constructor(readonly resource: string, readonly action: string) {
    super()
  }
}

// Domain-specific errors
class UserNotFoundError extends Data.TaggedError("UserNotFoundError") {
  constructor(readonly userId: string) {
    super()
  }
}

class InsufficientBalanceError extends Data.TaggedError("InsufficientBalanceError") {
  constructor(readonly required: number, readonly available: number) {
    super()
  }
}

// ============================================
// 2. Use tagged errors in effects
// ============================================

const fetchUser = (
  id: string
): Effect.Effect<{ id: string; name: string }, UserNotFoundError | NetworkError> =>
  Effect.gen(function* () {
    if (!id) {
      return yield* Effect.fail(new UserNotFoundError(id))
    }

    // Simulate network call
    const response = yield* Effect.tryPromise({
      try: () => fetch(`/api/users/${id}`),
      catch: () => new NetworkError("Failed to reach server"),
    })

    if (!response.ok) {
      return yield* Effect.fail(new UserNotFoundError(id))
    }

    return yield* Effect.tryPromise({
      try: () => response.json(),
      catch: () => new NetworkError("Invalid response format"),
    })
  })

const validateEmail = (email: string): Effect.Effect<string, ValidationError> =>
  Effect.sync(() => {
    if (!email.includes("@")) {
      return Effect.fail(new ValidationError("email", "Must contain @"))
    }
    return email
  }).pipe(Effect.flatMap(Effect.succeed))

const processPayment = (
  userId: string,
  amount: number
): Effect.Effect<
  { success: boolean },
  UnauthorizedError | InsufficientBalanceError | NetworkError
> =>
  Effect.gen(function* () {
    // Validate authorization
    if (!userId) {
      return yield* Effect.fail(
        new UnauthorizedError("User ID required")
      )
    }

    // Check balance
    if (amount > 1000) {
      return yield* Effect.fail(
        new InsufficientBalanceError(amount, 1000)
      )
    }

    console.log(`✅ Processing payment of $${amount}`)
    return { success: true }
  })

// ============================================
// 3. Pattern match on error types
// ============================================

const handleUserFetchError = (
  error: UserNotFoundError | NetworkError
): string => {
  if (error._tag === "UserNotFoundError") {
    return `User ${error.userId} not found`
  }
  if (error._tag === "NetworkError") {
    return `Network error: ${error.message}`
  }
  return "Unknown error"
}

const handlePaymentError = (
  error: UnauthorizedError | InsufficientBalanceError | NetworkError
): string => {
  if (error._tag === "UnauthorizedError") {
    return `Not authorized: ${error.reason}`
  }
  if (error._tag === "InsufficientBalanceError") {
    return `Insufficient balance. Need $${error.required}, have $${error.available}`
  }
  if (error._tag === "NetworkError") {
    return `Network issue: ${error.message}`
  }
  return "Unknown error"
}

// ============================================
// 4. Application logic with error handling
// ============================================

const appLogic = Effect.gen(function* () {
  console.log("=== Scenario 1: Fetch user ===")

  // Success case
  const user = yield* fetchUser("user_123").pipe(
    Effect.catchTags({
      UserNotFoundError: (error) => {
        console.log(`❌ User error: ${error.userId}`)
        return Effect.succeed(null)
      },
      NetworkError: (error) => {
        console.log(`❌ Network error: ${error.message}`)
        return Effect.succeed(null)
      },
    })
  )

  if (user) {
    console.log(`✅ Found user: ${user.name}`)
  }

  console.log("\n=== Scenario 2: Validate email ===")

  // Email validation
  const email = yield* validateEmail("invalid-email").pipe(
    Effect.catchTag("ValidationError", (error) => {
      console.log(`❌ Validation error on ${error.field}: ${error.message}`)
      return Effect.succeed("default@example.com")
    })
  )

  console.log(`✅ Using email: ${email}`)

  console.log("\n=== Scenario 3: Process payment ===")

  // Payment with specific error handling
  const payment = yield* processPayment("user_123", 2000).pipe(
    Effect.catchTags({
      UnauthorizedError: (error) => {
        console.log(`❌ Auth error: ${error.reason}`)
        return Effect.succeed({ success: false })
      },
      InsufficientBalanceError: (error) => {
        console.log(`❌ Balance error: need $${error.required}, have $${error.available}`)
        return Effect.succeed({ success: false })
      },
      NetworkError: (error) => {
        console.log(`❌ Network error: ${error.message}`)
        return Effect.succeed({ success: false })
      },
    })
  )

  console.log(`Payment result: ${payment.success ? "Success" : "Failed"}`)

  return { user, email, payment }
})

// Run application
Effect.runPromise(appLogic)
  .then(() => console.log("\n✅ Application completed"))
  .catch((error) => console.error(`Uncaught error: ${error.message}`))
```

# Why This Works

| Concept | Explanation |
|---------|-------------|
| **Tagged errors** | Each error type has a unique `_tag` for type-safe matching |
| **Type union** | Effect types document all possible errors: `Effect<A, E, R>` |
| **Structured data** | Errors contain relevant context (field name, user ID, etc.) |
| **Pattern matching** | `catchTag` handles specific error types with compile-time safety |
| **Type inference** | TypeScript knows which error types can occur at each point |
| **No instanceof** | No brittle `instanceof Error` checks needed |
| **Composable** | Chain multiple operations with clear error propagation |
| **Immutable** | Errors are data, no hidden state or side effects |

# When to Use

- API handlers that need to return specific error codes
- Database operations that can fail in different ways
- Form validation with field-specific error messages
- Authentication/authorization flows
- Payment processing with multiple failure modes
- File operations (not found, permission denied, etc.)
- Any operation with multiple, distinct error types

# Related Patterns

- [Error Aggregation](./error-aggregation.md)
- [Recovery Strategies](./recovery-strategies.md)
- [User-Friendly Error Messages](./user-friendly-messages.md)
- [Basic Form Validation](../form-validation/basic.md)
