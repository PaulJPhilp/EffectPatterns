---
id: schema-ai-parsing-partial-responses
title: Parsing Partial/Incomplete Responses
category: ai-schemas
skillLevel: intermediate
tags:
  - schema
  - ai
  - partial-data
  - optional-fields
  - streaming
  - graceful-degradation
lessonOrder: 26
---

# Problem

An LLM streaming response gets cut off mid-generation, or the user cancels before completion. You receive incomplete JSON with missing closing braces or truncated fields. Standard parsing fails. You need to detect incomplete data, handle partial results gracefully, and still extract what's available without losing information.

# Solution

```typescript
import { Effect, Schema, Option } from "effect"

// 1. Define schema with optional fields
const StreamedAnalysis = Schema.Struct({
  title: Schema.String,
  sections: Schema.Array(
    Schema.Struct({
      heading: Schema.String,
      content: Schema.String,
    })
  ).pipe(Schema.optional),
  conclusion: Schema.String.pipe(Schema.optional),
  isComplete: Schema.Boolean.pipe(
    Schema.optional,
    Schema.withDefault(false)
  ),
})

type StreamedAnalysis = typeof StreamedAnalysis.Type

// 2. Detect if response is truncated
const isLikelyTruncated = (json: string): boolean => {
  const trimmed = json.trim()
  // Missing closing braces, incomplete string, etc.
  return (
    !trimmed.endsWith("}") ||
    (trimmed.match(/{/g) || []).length >
      (trimmed.match(/}/g) || []).length ||
    trimmed.endsWith(',') ||
    trimmed.endsWith('"') ||
    trimmed.includes('...')
  )
}

// 3. Attempt repair of truncated JSON
const repairJSON = (json: string): string => {
  let repaired = json.trim()

  // Close unclosed objects
  const openBraces =
    (repaired.match(/{/g) || []).length -
    (repaired.match(/}/g) || []).length
  repaired += "}".repeat(Math.max(0, openBraces))

  // Close unclosed arrays
  const openBrackets =
    (repaired.match(/\[/g) || []).length -
    (repaired.match(/\]/g) || []).length
  repaired += "]".repeat(Math.max(0, openBrackets))

  // Handle trailing comma before close
  repaired = repaired.replace(/,\s*}/, "}")
  repaired = repaired.replace(/,\s*]/, "]")

  return repaired
}

// 4. Parse with truncation awareness
const parseStreamed = (json: string) =>
  Effect.gen(function* () {
    const truncated = isLikelyTruncated(json)

    // Try exact parse first
    let data: unknown
    try {
      data = JSON.parse(json)
    } catch {
      if (truncated) {
        // Attempt repair
        const repaired = repairJSON(json)
        try {
          data = JSON.parse(repaired)
        } catch (e) {
          return yield* Effect.fail(
            new Error(
              `Cannot parse even after repair: ${e}`
            )
          )
        }
      } else {
        return yield* Effect.fail(
          new Error(`Invalid JSON: ${json}`)
        )
      }
    }

    // Validate against schema
    const parsed = yield* Schema.decodeUnknown(
      StreamedAnalysis
    )(data).pipe(
      Effect.mapError((error) => ({
        _tag: "ValidationError" as const,
        message: `Schema validation failed: ${error.message}`,
        truncated,
      }))
    )

    return {
      ...parsed,
      isComplete: !truncated && parsed.isComplete !== false,
    }
  })

// 5. Handle streaming data
const handleStream = (chunks: AsyncIterable<string>) =>
  Effect.tryPromise(async () => {
    let accumulated = ""
    const results: StreamedAnalysis[] = []

    for await (const chunk of chunks) {
      accumulated += chunk

      // Try parse on each chunk
      const attempt = await Effect.runPromise(
        parseStreamed(accumulated).pipe(
          Effect.option
        )
      )

      if (Option.isSome(attempt)) {
        console.log(
          "Got complete analysis at",
          accumulated.length,
          "bytes"
        )
        results.push(attempt.value)
        accumulated = "" // Reset for next response
      }
    }

    // Handle final partial data if streaming ended
    if (accumulated.length > 0) {
      const final = await Effect.runPromise(
        parseStreamed(accumulated).pipe(
          Effect.orElse(() =>
            Effect.succeed({
              title: "Incomplete",
              sections: undefined,
              conclusion: undefined,
              isComplete: false,
            } as StreamedAnalysis)
          )
        )
      )

      results.push(final)
    }

    return results
  })

// 6. Usage example
const exampleStreamData = [
  '{"title": "Effect Guide", "sections": [',
  '{"heading": "Basics", "content": "Effect is...",},',
  '{"heading": "Advanced", "content": "Use layers...',
  // Streaming cut off here
]

// Simulate incomplete JSON
const truncatedJSON = `{
  "title": "Incomplete Analysis",
  "sections": [
    {"heading": "Section 1", "content": "Text here"},
    {"heading": "Section 2", "content": "More te`

Effect.runPromise(parseStreamed(truncatedJSON))
  .then((result) => {
    console.log("Parsed despite truncation:")
    console.log(
      `Title: ${result.title} (complete: ${result.isComplete})`
    )
    console.log(`Sections: ${result.sections?.length || 0}`)
  })
  .catch((error) => {
    console.error("Failed to parse:", error.message)
  })
```

# Why This Works

| Concept | Explanation |
|---------|-------------|
| Optional fields | Schema allows missing data from incomplete streams |
| Truncation detection | Check for unclosed braces, trailing commas |
| JSON repair | Auto-close objects/arrays when safe to infer |
| Incremental parsing | Try parse on each chunk, keep best result |
| `isComplete` flag | Caller knows if data is partial vs full |

# When to Use

- Streaming LLM responses (SSE, WebSocket)
- User cancels mid-stream
- Network interruptions
- Chunked data that might be cut off
- Mobile apps with unreliable connections

# Related Patterns

- [Basic AI Response Parsing](./basic.md)
- [Handling Malformed AI Outputs](./error-recovery.md)
- [Retry Strategies for Parse Failures](./retry-on-failure.md)
- [Validating Streaming AI Responses](./streaming-validation.md)
