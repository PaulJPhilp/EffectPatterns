---
id: schema-ai-parsing-basic
title: Basic AI Response Parsing
category: ai-schemas
skill: beginner
tags:
  - schema
  - ai
  - parsing
  - validation
  - decode
  - llm
---

# Problem

You've called an LLM with a JSON schema, but the response is still `unknown`. The model might have hallucinated extra fields, used wrong types, or returned malformed JSON despite your instructions. You need to parse the response safely and get typed errors when it fails, not thrown exceptions.

# Solution

```typescript
import { Effect, Schema } from "effect"
import { Anthropic } from "@anthropic-ai/sdk"

// 1. Define expected schema
const Analysis = Schema.Struct({
  summary: Schema.String,
  score: Schema.Number.pipe(Schema.between(0, 100)),
  tags: Schema.Array(Schema.String),
})

type Analysis = typeof Analysis.Type

// 2. Create parser
const parseAnalysis = Schema.decodeUnknown(Analysis)

// 3. Parse LLM response in pipeline
const analyzeSafely = (llmResponse: unknown) =>
  Effect.gen(function* () {
    const parsed = yield* Effect.tryPromise({
      try: () => parseAnalysis(llmResponse),
      catch: (error) => ({
        _tag: "ParseError" as const,
        message: `AI returned invalid response: ${error}`,
        raw: llmResponse,
      }),
    })
    return parsed
  })

// 4. Full flow: call LLM and parse
const analyzeText = (text: string) =>
  Effect.gen(function* () {
    const client = new Anthropic()

    const response = yield* Effect.tryPromise({
      try: () =>
        client.messages.create({
          model: "claude-3-5-sonnet-20241022",
          max_tokens: 1024,
          messages: [
            {
              role: "user",
              content: `Analyze this text and return JSON:\n${text}`,
            },
          ],
        }),
      catch: (error) => new Error(`API failed: ${error}`),
    })

    const textContent = response.content.find(
      (c) => c.type === "text"
    ) as any

    if (!textContent) {
      return yield* Effect.fail(
        new Error("No text in response")
      )
    }

    // Parse the JSON string
    const parsed = yield* Effect.tryPromise({
      try: () => JSON.parse(textContent.text),
      catch: (error) => new Error(`Invalid JSON: ${error}`),
    })

    // Validate against schema
    const analysis = yield* analyzeSafely(parsed)
    return analysis
  })

// 5. Usage
Effect.runPromise(
  analyzeText("This product is amazing but too expensive.")
)
  .then((result) => {
    console.log(`Score: ${result.score}`)
    console.log(`Tags: ${result.tags.join(", ")}`)
  })
  .catch((error) => {
    console.error(`Analysis failed: ${error.message}`)
  })
```

# Why This Works

| Concept | Explanation |
|---------|-------------|
| `Schema.decodeUnknown` | Returns `Effect<A, ParseError>` — no thrown exceptions |
| `Effect.tryPromise` | Catches JSON parsing errors without throwing |
| `Schema.between` | Runtime validation beyond type checking—catches out-of-range values |
| Typed error channel | Caller must explicitly handle parse failures |
| Validation at boundaries | Parse once at system edge, trust types downstream |

# When to Use

- Any LLM JSON response
- Tool call outputs from Claude/GPT
- Structured generation results
- When you don't trust the model followed instructions
- Streaming responses that might be incomplete

# Related Patterns

- [Handling Malformed AI Outputs](./error-recovery.md)
- [Retry Strategies for Parse Failures](./retry-on-failure.md)
- [Parsing Partial/Incomplete Responses](./partial-responses.md)
- [Defining AI Output Schemas](../defining-ai-output-schemas/basic.md)
