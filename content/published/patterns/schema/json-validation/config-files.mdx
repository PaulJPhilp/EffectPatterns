---
id: schema-json-file-config-files
title: Validating Config Files
category: json-validation
skillLevel: beginner
tags:
  - schema
  - json
  - file
  - config
  - environment
lessonOrder: 32
rule:
  description: >-
    Validate Config Files using Schema.
summary: >-
  Configuration files are often JSON and must be loaded and validated at application startup. Config files have specific requirements: certain fields are required, others are optional, and values must...
---

# Problem

Configuration files are often JSON and must be loaded and validated at application startup. Config files have specific requirements: certain fields are required, others are optional, and values must fall within valid ranges. You need to load a config file, validate its structure and values, and fail fast if the config is invalid with clear error messages.

# Solution

```typescript
import { Schema, Effect } from "effect";
import { FileSystem } from "@effect/platform";
import { NodeFileSystem } from "@effect/platform-node";

// 1. Define configuration schema
const AppConfig = Schema.Struct({
  // Required fields
  appName: Schema.String.pipe(Schema.minLength(1)),
  port: Schema.Number.pipe(
    Schema.int(),
    Schema.between(1, 65535)
  ),
  environment: Schema.Literal("development", "staging", "production"),

  // Optional fields with defaults handled later
  debug: Schema.Boolean.pipe(Schema.optional),
  logLevel: Schema.Literal("error", "warn", "info", "debug").pipe(
    Schema.optional
  ),
  maxConnections: Schema.Number.pipe(
    Schema.int(),
    Schema.positive()
  ).pipe(Schema.optional),
});

type AppConfig = typeof AppConfig.Type;

// 2. Load and validate config from file
const loadConfig = (filePath: string) =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;

    // Read and parse file
    const content = yield* fs.readFileString(filePath).pipe(
      Effect.mapError((error) => ({
        _tag: "ConfigLoadError" as const,
        message: `Cannot read config file: ${error.message}`,
      }))
    );

    let jsonData: unknown;
    try {
      jsonData = JSON.parse(content);
    } catch (error) {
      return yield* Effect.fail({
        _tag: "ConfigParseError" as const,
        message: `Invalid JSON in config file: ${String(error)}`,
      });
    }

    // Validate config
    const config = yield* Schema.decodeUnknown(AppConfig)(
      jsonData
    ).pipe(
      Effect.mapError((error) => ({
        _tag: "ConfigValidationError" as const,
        message: `Invalid config: ${error.message}`,
      }))
    );

    return config;
  });

// 3. Practical usage: Initialize app with config
const initializeApp = (configPath: string) =>
  Effect.gen(function* () {
    console.log(`üìã Loading config from ${configPath}...`);

    const config = yield* loadConfig(configPath);

    console.log(`‚úÖ Config loaded:`);
    console.log(`  App: ${config.appName}`);
    console.log(`  Port: ${config.port}`);
    console.log(`  Environment: ${config.environment}`);
    console.log(`  Debug: ${config.debug ?? false}`);
    console.log(`  Log Level: ${config.logLevel ?? "info"}`);
    console.log(`  Max Connections: ${config.maxConnections ?? "unlimited"}`);

    return config;
  });

// 4. Error handling with recovery
const loadConfigWithFallback = (
  primaryPath: string,
  fallbackPath: string
) =>
  Effect.gen(function* () {
    const config = yield* loadConfig(primaryPath).pipe(
      Effect.catchAll(() =>
        Effect.gen(function* () {
          console.log(
            `‚ö†Ô∏è  Failed to load ${primaryPath}, trying fallback...`
          );
          return yield* loadConfig(fallbackPath);
        })
      )
    );

    return config;
  });

// Usage example
Effect.runPromise(
  initializeApp("./config.json").pipe(
    Effect.provideLayer(NodeFileSystem.layer)
  )
)
  .then(() => {
    console.log("üöÄ App initialized successfully");
  })
  .catch((error) => {
    console.error(`‚ùå Failed to initialize: ${error.message}`);
    process.exit(1);
  });

// Example config.json:
// {
//   "appName": "MyApp",
//   "port": 3000,
//   "environment": "development",
//   "debug": true,
//   "logLevel": "debug",
//   "maxConnections": 100
// }
```

# Why This Works

| Concept | Explanation |
|---------|-------------|
| `Schema.Struct` | Type-safe configuration object validation |
| `Schema.Literal` | Restrict values to allowed options (enums) |
| `Schema.between` | Validate numeric ranges (port, connections) |
| `Schema.optional` | Mark fields as not required |
| `Effect.catchAll` | Recover from first file load, try fallback |
| Clear error hierarchy | Different error tags for different failure modes |
| Startup validation | Fail fast if config is invalid before app starts |
| Type safety | TypeScript prevents accessing missing config fields |

# When to Use

- Loading `.json` configuration files at application startup
- Validating environment-specific configs (dev/staging/prod)
- Enforcing required config fields and value constraints
- Fallback config loading (primary ‚Üí secondary ‚Üí default)
- Multi-environment deployments with different config requirements
- API servers that require config files for ports, SSL certs, etc.
- Preventing "invalid config" runtime errors hours into production

# Related Patterns

- [Basic JSON File Validation](./basic.md)
- [Schema with Default Values](./with-defaults.md)
- [Validating Multiple Config Files](./multiple-files.md)
- [Dependent Field Validation](../form-validation/dependent-fields.md)
