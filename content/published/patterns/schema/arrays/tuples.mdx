---
id: schema-tuples
title: Tuple Schemas
category: arrays
skillLevel: beginner
tags:
  - schema
  - tuple
  - fixed-length
  - typed-array
lessonOrder: 29
rule:
  description: >-
    Tuple Schemas.
---

# Problem

Sometimes you need fixed-length arrays where each position has a specific type. A coordinate is [x, y], an RGB color is [r, g, b], a range is [start, end]. Regular arrays allow any length. You need schemas for typed tuples.

# Solution

```typescript
import { Schema } from "effect"

// ============================================
// BASIC TUPLES
// ============================================

// 2D coordinate [x, y]
const Point2D = Schema.Tuple(Schema.Number, Schema.Number)
type Point2D = typeof Point2D.Type  // readonly [number, number]

// 3D coordinate [x, y, z]
const Point3D = Schema.Tuple(Schema.Number, Schema.Number, Schema.Number)
type Point3D = typeof Point3D.Type  // readonly [number, number, number]

// RGB color [r, g, b]
const RGB = Schema.Tuple(Schema.Number, Schema.Number, Schema.Number)
type RGB = typeof RGB.Type

// Date range [start, end]
const DateRange = Schema.Tuple(Schema.Date, Schema.Date)
type DateRange = typeof DateRange.Type  // readonly [Date, Date]

// ============================================
// MIXED TYPE TUPLES
// ============================================

// Key-value pair [key, value]
const KeyValue = Schema.Tuple(Schema.String, Schema.Unknown)
type KeyValue = typeof KeyValue.Type  // readonly [string, unknown]

// Named point ["label", x, y]
const NamedPoint = Schema.Tuple(Schema.String, Schema.Number, Schema.Number)
type NamedPoint = typeof NamedPoint.Type

// Result tuple [success, data | error]
const StringResult = Schema.Tuple(Schema.Boolean, Schema.String)
type StringResult = typeof StringResult.Type  // readonly [boolean, string]

// ============================================
// TUPLES WITH OPTIONAL ELEMENTS
// ============================================

// Optional third element [x, y, z?]
const Point2Dor3D = Schema.Tuple(
  Schema.Number,
  Schema.Number,
).pipe(Schema.optionalElement(Schema.Number))
// readonly [number, number, number?]

// ============================================
// TUPLES WITH REST ELEMENTS
// ============================================

// Fixed start, variable rest: [header, ...items]
const ListWithHeader = Schema.Tuple(
  [Schema.String],                    // First element: header
  Schema.rest(Schema.Number)          // Rest: numbers
)
type ListWithHeader = typeof ListWithHeader.Type
// readonly [string, ...number[]]

// ============================================
// USING IN STRUCTS
// ============================================

const Shape = Schema.Struct({
  name: Schema.String,
  position: Point2D,
  color: RGB,
})

const Route = Schema.Struct({
  name: Schema.String,
  waypoints: Schema.Array(Point2D),  // Array of tuples
})

// ============================================
// VALIDATION IN ACTION
// ============================================

const decodePoint2D = Schema.decodeUnknownSync(Point2D)
const decodeRGB = Schema.decodeUnknownSync(RGB)
const decodeNamedPoint = Schema.decodeUnknownSync(NamedPoint)

// Valid 2D point
const point = decodePoint2D([10, 20])
console.log(`✅ Point: (${point[0]}, ${point[1]})`)

// Valid RGB
const red = decodeRGB([255, 0, 0])
console.log(`✅ Color: rgb(${red[0]}, ${red[1]}, ${red[2]})`)

// Valid named point
const home = decodeNamedPoint(["Home", 0, 0])
console.log(`✅ ${home[0]}: (${home[1]}, ${home[2]})`)

// Invalid - wrong length
try {
  decodePoint2D([10])  // Missing y
} catch {
  console.log("❌ Point needs exactly 2 elements")
}

try {
  decodePoint2D([10, 20, 30])  // Too many
} catch {
  console.log("❌ Point needs exactly 2 elements")
}

// Invalid - wrong type at position
try {
  decodeNamedPoint([42, 10, 20])  // First should be string
} catch {
  console.log("❌ First element must be string")
}

// ============================================
// PRACTICAL EXAMPLE: BOUNDS
// ============================================

const BoundingBox = Schema.Struct({
  topLeft: Point2D,
  bottomRight: Point2D,
})

const decodeBox = Schema.decodeUnknownSync(BoundingBox)

const box = decodeBox({
  topLeft: [0, 0],
  bottomRight: [100, 100],
})

const width = box.bottomRight[0] - box.topLeft[0]
const height = box.bottomRight[1] - box.topLeft[1]
console.log(`\n✅ Box: ${width}x${height}`)
```

# Why This Works

| Schema | Purpose |
|--------|---------|
| **Schema.Tuple(S1, S2, ...)** | Fixed-length typed array |
| **optionalElement** | Optional trailing elements |
| **rest** | Variable-length tail |
| **Position types** | Each position has specific type |
| **Length validation** | Exact length enforced |

# When to Use

- Coordinates [x, y] or [x, y, z]
- Colors [r, g, b] or [r, g, b, a]
- Ranges [start, end]
- Key-value pairs [key, value]
- Function arguments as arrays

# Related Patterns

- [Array Validation](./basic-arrays.md)
- [Basic Objects](../objects/basic-objects.md)
- [Union Types](../unions/basic-unions.md)

