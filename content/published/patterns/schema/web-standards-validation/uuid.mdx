---
id: schema-web-standards-uuid
title: 'UUID Validation (v4, v7)'
category: web-standards-validation
skillLevel: beginner
tags:
  - schema
  - validation
  - web-standards
  - uuid
  - identifiers
  - branded-types
lessonOrder: 31
---

# Problem

Your API accepts IDs as strings, but there's no validation that they're actually valid UUIDs. Users submit malformed IDs, truncated strings, or wrong formats. You need to validate UUID format at runtime (v4 or v7), create a distinct type so UUIDs can't be confused with other strings, and safely parse them without exceptions.

# Solution

```typescript
import { Schema, Effect } from "effect"

// 1. Define UUID v4 validator
const UUIDv4 = Schema.String.pipe(
  Schema.pattern(
    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
  ).pipe(
    Schema.annotations({
      description: "Valid UUID v4 (36 chars with hyphens)",
    })
  ),
  Schema.brand("UUIDv4")
)

type UUIDv4 = typeof UUIDv4.Type

// 2. Define UUID v7 validator (sortable)
const UUIDv7 = Schema.String.pipe(
  Schema.pattern(
    /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
  ).pipe(
    Schema.annotations({
      description: "Valid UUID v7 (time-based, sortable)",
    })
  ),
  Schema.brand("UUIDv7")
)

type UUIDv7 = typeof UUIDv7.Type

// 3. Union of both versions
const UUID = Schema.Union(UUIDv4, UUIDv7).pipe(
  Schema.brand("UUID")
)

type UUID = typeof UUID.Type

// 4. Use in resource schemas
const UserProfile = Schema.Struct({
  id: UUIDv4,
  organizationId: UUID,
  createdAt: Schema.String,
  name: Schema.String,
})

type UserProfile = typeof UserProfile.Type

// 5. Fetch and validate resource
const getUserProfile = (userId: unknown) =>
  Effect.gen(function* () {
    const id = yield* Schema.decodeUnknown(UUIDv4)(userId).pipe(
      Effect.mapError((error) => ({
        _tag: "InvalidId" as const,
        message: `Invalid user ID: ${error.message}`,
      }))
    )

    // Fetch from database using validated UUID
    console.log(`Fetching user: ${id}`)

    // Simulate DB response
    const profile: UserProfile = {
      id,
      organizationId:
        "550e8400-e29b-41d4-a716-446655440000" as UUID,
      createdAt: "2024-01-15T10:30:00Z",
      name: "Alice",
    }

    return profile
  })

// 6. Generate and validate UUIDs
const createResourceId = () =>
  Effect.gen(function* () {
    // Generate UUID v4 (random)
    const v4 = crypto.randomUUID() as string

    // Validate it matches schema
    const validated = yield* Schema.decodeUnknown(UUIDv4)(
      v4
    ).pipe(
      Effect.catchTag("ParseError", (error) =>
        Effect.fail(new Error(`Generated invalid UUID: ${error}`))
      )
    )

    return validated
  })

// Usage
Effect.runPromise(
  getUserProfile("f47ac10b-58cc-4372-a567-0e02b2c3d479")
)
  .then((profile) => {
    console.log(`User: ${profile.name}`)
  })
  .catch((error) =>
    console.error(`Error: ${error.message}`)
  )

// Generate new ID
Effect.runPromise(createResourceId())
  .then((id) => console.log(`New resource: ${id}`))
```

# Why This Works

| Concept | Explanation |
|---------|-------------|
| UUID v4 pattern | Random UUID—standard for most applications |
| UUID v7 pattern | Time-based, sortable—better for databases |
| `Schema.Union` | Accept both v4 and v7, validate at runtime |
| `Schema.brand` | Creates nominal type—`UUIDv4 ≠ string` |
| Type safety | Database queries receive validated IDs |
| Compile-time checks | Functions requiring `UUID` reject plain strings |

# When to Use

- API request parameter validation (path/query IDs)
- Database record lookups
- Resource creation (generating new IDs)
- Cross-service communication with IDs
- REST API ID validation

# Related Patterns

- [Email Validation](./email.md)
- [URL Validation](./url.md)
- [ISO Date Validation](./iso-date.md)
