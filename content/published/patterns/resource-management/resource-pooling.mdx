---
title: Pool Resources for Reuse
id: resource-pooling
skillLevel: intermediate
applicationPatternId: resource-management
summary: >-
  Create and manage a pool of reusable resources like database connections or
  workers.
tags:
  - resource-management
  - pooling
  - connections
  - performance
rule:
  description: Use Pool to manage expensive resources that can be reused across operations.
author: PaulJPhilp
related:
  - bracket-acquire-release
  - manual-scope
lessonOrder: 4
---

## Guideline

Use `Pool` to manage a collection of reusable resources. The pool handles acquisition, release, and lifecycle management automatically.

---

## Rationale

Creating resources is expensive:

1. **Database connections** - TCP handshake, authentication
2. **HTTP clients** - Connection setup, TLS negotiation
3. **Worker threads** - Spawn overhead
4. **File handles** - System calls

Pooling amortizes this cost across many operations.

---

## Good Example

```typescript
import { Effect, Pool, Scope, Duration } from "effect"

// ============================================
// 1. Define a poolable resource
// ============================================

interface DatabaseConnection {
  readonly id: number
  readonly query: (sql: string) => Effect.Effect<unknown[]>
  readonly close: () => Effect.Effect<void>
}

let connectionId = 0

const createConnection = Effect.gen(function* () {
  const id = ++connectionId
  yield* Effect.log(`Creating connection ${id}`)
  
  // Simulate connection setup time
  yield* Effect.sleep("100 millis")
  
  const connection: DatabaseConnection = {
    id,
    query: (sql) => Effect.gen(function* () {
      yield* Effect.log(`[Conn ${id}] Executing: ${sql}`)
      return [{ result: "data" }]
    }),
    close: () => Effect.gen(function* () {
      yield* Effect.log(`Closing connection ${id}`)
    }),
  }
  
  return connection
})

// ============================================
// 2. Create a pool
// ============================================

const makeConnectionPool = Pool.make({
  acquire: createConnection,
  size: 5,  // Maximum 5 connections
})

// ============================================
// 3. Use the pool
// ============================================

const runQuery = (pool: Pool.Pool<DatabaseConnection>, sql: string) =>
  Effect.scoped(
    Effect.gen(function* () {
      // Get a connection from the pool
      const connection = yield* pool.get
      
      // Use it
      const results = yield* connection.query(sql)
      
      // Connection automatically returned to pool when scope ends
      return results
    })
  )

// ============================================
// 4. Run multiple queries concurrently
// ============================================

const program = Effect.scoped(
  Effect.gen(function* () {
    const pool = yield* makeConnectionPool
    
    yield* Effect.log("Starting concurrent queries...")
    
    // Run 10 queries with only 5 connections
    const queries = Array.from({ length: 10 }, (_, i) =>
      runQuery(pool, `SELECT * FROM users WHERE id = ${i}`)
    )
    
    const results = yield* Effect.all(queries, { concurrency: "unbounded" })
    
    yield* Effect.log(`Completed ${results.length} queries`)
    return results
  })
)

Effect.runPromise(program)
```

## Pool Configuration

| Option | Purpose |
|--------|---------|
| `size` | Maximum number of resources |
| `acquire` | How to create a new resource |
| `timeToLive` | Max time a resource lives |
| `timeToLiveStrategy` | When to check TTL |

## Pool with TTL

```typescript
const poolWithTTL = Pool.make({
  acquire: createConnection,
  size: 10,
  timeToLive: Duration.minutes(5),  // Refresh connections every 5 min
})
```

## When to Use Pools

| Resource | Pool? | Why |
|----------|-------|-----|
| DB connections | ✅ Yes | Expensive to create |
| HTTP clients | ✅ Yes | Connection reuse |
| Worker threads | ✅ Yes | Spawn overhead |
| File handles | Maybe | Depends on usage |
| Memory buffers | Maybe | If allocation is slow |

