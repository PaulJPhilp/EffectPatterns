---
title: 'Sink Pattern 5: Fall Back to Alternative Sink on Failure'
id: sink-pattern-fall-back-to-alternative-sink-on-failure
skillLevel: intermediate
applicationPatternId: streams-sinks
summary: >-
  Use Sink to attempt writing to a primary destination, and automatically fall
  back to an alternative destination if the primary fails, enabling progressive
  degradation and high availability.
tags:
  - sink
  - stream
  - error-handling
  - fallback
  - resilience
  - degradation
rule:
  description: >-
    Implement fallback sinks to handle failures gracefully and ensure data is
    persisted even when the primary destination is unavailable.
related:
  - process-streaming-data-with-stream
  - handle-errors-with-catch
  - sink-pattern-batch-insert-stream-records-into-database
author: effect_website
lessonOrder: 5
---

## Guideline

When consuming a stream to a primary destination that might fail, wrap it in a fallback pattern. If the primary sink fails, automatically redirect the stream to an alternative sink. This enables progressive degradation where the system degrades gracefully rather than failing completely.

---

## Rationale

Production systems need resilience:

- **Primary failures**: Database down, network timeout, quota exceeded
- **Progressive degradation**: Keep the system running, even at reduced capacity
- **No data loss**: Fallback ensures data is persisted somewhere
- **Operational flexibility**: Choose fallback based on failure type
- **Monitoring**: Track when fallbacks are used to alert operators

Without fallback patterns:

- System fails when primary destination fails
- Data is lost if primary is unavailable
- No clear signal that degradation occurred

With fallback sinks:

- Stream continues even when primary fails
- Data is safely persisted to alternative
- Clear audit trail of which sink was used

---

## Good Example

This example demonstrates a system that tries to write order records to a fast in-memory cache first, falls back to database if cache fails, and falls back to a dead letter file if database fails.

```typescript
import { Effect, Stream, Sink, Chunk, Either, Data } from "effect";

interface Order {
  readonly orderId: string;
  readonly customerId: string;
  readonly total: number;
  readonly timestamp: number;
}

class CacheSinkError extends Data.TaggedError("CacheSinkError")<{
  readonly reason: string;
}> {}

class DatabaseSinkError extends Data.TaggedError("DatabaseSinkError")<{
  readonly reason: string;
}> {}

// Mock in-memory cache sink (fast but limited)
const createCacheSink = (): Sink.Sink<number, CacheSinkError, Order> => {
  const cache: Order[] = [];
  const MAX_CACHE_SIZE = 1000;

  return Sink.fold(
    0,
    (count, order) =>
      Effect.gen(function* () {
        if (cache.length >= MAX_CACHE_SIZE) {
          yield* Effect.fail(
            new CacheSinkError({
              reason: `Cache full (${cache.length}/${MAX_CACHE_SIZE})`,
            })
          );
        }

        cache.push(order);
        console.log(`[CACHE] Cached order ${order.orderId}`);
        return count + 1;
      }),
    (count) =>
      Effect.gen(function* () {
        console.log(`[CACHE] Final: ${count} orders in cache`);
        return count;
      })
  );
};

// Mock database sink (slower but reliable)
const createDatabaseSink = (): Sink.Sink<number, DatabaseSinkError, Order> => {
  const orders: Order[] = [];

  return Sink.fold(
    0,
    (count, order) =>
      Effect.gen(function* () {
        // Simulate occasional database failures
        if (Math.random() < 0.1) {
          yield* Effect.fail(
            new DatabaseSinkError({
              reason: "Connection timeout",
            })
          );
        }

        orders.push(order);
        console.log(`[DATABASE] Persisted order ${order.orderId}`);
        return count + 1;
      }),
    (count) =>
      Effect.gen(function* () {
        console.log(`[DATABASE] Final: ${count} orders in database`);
        return count;
      })
  );
};

// Mock file sink (always works but slow)
const createDeadLetterSink = (): Sink.Sink<number, never, Order> => {
  const deadLetters: Order[] = [];

  return Sink.fold(
    0,
    (count, order) =>
      Effect.gen(function* () {
        deadLetters.push(order);
        console.log(
          `[DEAD-LETTER] Wrote order ${order.orderId} to dead letter file`
        );
        return count + 1;
      }),
    (count) =>
      Effect.gen(function* () {
        console.log(
          `[DEAD-LETTER] Final: ${count} orders in dead letter file`
        );
        return count;
      })
  );
};

// Create a fallback sink that tries cache -> database -> file
const createFallbackSink = (): Sink.Sink<
  { readonly cached: number; readonly persisted: number; readonly deadLetters: number },
  never,
  Order
> =>
  Sink.fold(
    { cached: 0, persisted: 0, deadLetters: 0 },
    (state, order) =>
      Effect.gen(function* () {
        // Try cache first
        const cacheResult = yield* createCacheSink()
          .pipe(Sink.feed(Chunk.of(order)))
          .pipe(Effect.either);

        if (Either.isRight(cacheResult)) {
          return {
            ...state,
            cached: state.cached + cacheResult.right,
          };
        }

        console.log(
          `[FALLBACK] Cache failed (${cacheResult.left.reason}), trying database`
        );

        // Cache failed, try database
        const dbResult = yield* createDatabaseSink()
          .pipe(Sink.feed(Chunk.of(order)))
          .pipe(Effect.either);

        if (Either.isRight(dbResult)) {
          return {
            ...state,
            persisted: state.persisted + dbResult.right,
          };
        }

        console.log(
          `[FALLBACK] Database failed (${dbResult.left.reason}), falling back to dead letter`
        );

        // Database failed, use dead letter
        const dlResult = yield* createDeadLetterSink()
          .pipe(Sink.feed(Chunk.of(order)));

        return {
          ...state,
          deadLetters: state.deadLetters + dlResult,
        };
      }),
    (state) =>
      Effect.gen(function* () {
        console.log(`\n[SUMMARY]`);
        console.log(`  Cached:      ${state.cached}`);
        console.log(`  Persisted:   ${state.persisted}`);
        console.log(`  Dead Letter: ${state.deadLetters}`);
        return state;
      })
  );

// Simulate a stream of orders
const orderStream: Stream.Stream<Order> = Stream.fromIterable([
  {
    orderId: "order-1",
    customerId: "cust-1",
    total: 99.99,
    timestamp: Date.now(),
  },
  {
    orderId: "order-2",
    customerId: "cust-2",
    total: 149.99,
    timestamp: Date.now() + 100,
  },
  {
    orderId: "order-3",
    customerId: "cust-1",
    total: 49.99,
    timestamp: Date.now() + 200,
  },
  {
    orderId: "order-4",
    customerId: "cust-3",
    total: 199.99,
    timestamp: Date.now() + 300,
  },
  {
    orderId: "order-5",
    customerId: "cust-2",
    total: 89.99,
    timestamp: Date.now() + 400,
  },
]);

// Run the stream with fallback sink
const program = Effect.gen(function* () {
  const result = yield* orderStream.pipe(Stream.run(createFallbackSink()));
  console.log(`\nTotal orders processed: ${result.cached + result.persisted + result.deadLetters}`);
});

Effect.runPromise(program);
```

This pattern:

1. **Tries cache first** (fast, limited capacity)
2. **Falls back to database** if cache is full
3. **Falls back to dead letter** if database fails
4. **Tracks which sink** was used for each record
5. **Reports summary** of where data went

---

## Advanced: Error-Type Based Routing

Route to different fallbacks based on the error type:

```typescript
type FallbackStrategy = "retry" | "cache" | "file" | "drop";

const determineFallback = (error: CacheSinkError | DatabaseSinkError): FallbackStrategy => {
  if (error._tag === "CacheSinkError") {
    // Cache is full, try database
    return "retry";
  }
  if (error._tag === "DatabaseSinkError") {
    if (error.reason.includes("timeout")) {
      // Network issue, retry
      return "retry";
    } else if (error.reason.includes("quota")) {
      // Quota exceeded, use file
      return "file";
    }
  }
  // Unknown error, drop
  return "drop";
};

const createIntelligentFallbackSink = (): Sink.Sink<
  { readonly cached: number; readonly persisted: number; readonly deadLetters: number; readonly dropped: number },
  never,
  Order
> =>
  Sink.fold(
    { cached: 0, persisted: 0, deadLetters: 0, dropped: 0 },
    (state, order) =>
      Effect.gen(function* () {
        // Try cache
        const cacheAttempt = yield* createCacheSink()
          .pipe(Sink.feed(Chunk.of(order)))
          .pipe(Effect.either);

        if (Either.isRight(cacheAttempt)) {
          return { ...state, cached: state.cached + 1 };
        }

        const strategy = determineFallback(cacheAttempt.left);

        if (strategy === "retry") {
          // Try database
          const dbAttempt = yield* createDatabaseSink()
            .pipe(Sink.feed(Chunk.of(order)))
            .pipe(Effect.either);

          if (Either.isRight(dbAttempt)) {
            return { ...state, persisted: state.persisted + 1 };
          }
        }

        if (strategy === "file" || strategy === "retry") {
          // Try dead letter
          const dlResult = yield* createDeadLetterSink()
            .pipe(Sink.feed(Chunk.of(order)));
          return { ...state, deadLetters: state.deadLetters + 1 };
        }

        // Drop
        console.log(`[DROPPED] Order ${order.orderId}`);
        return { ...state, dropped: state.dropped + 1 };
      }),
    (state) =>
      Effect.gen(function* () {
        console.log(`\n[SUMMARY]`);
        console.log(`  Cached:      ${state.cached}`);
        console.log(`  Persisted:   ${state.persisted}`);
        console.log(`  Dead Letter: ${state.deadLetters}`);
        console.log(`  Dropped:     ${state.dropped}`);
        return state;
      })
  );
```

---

## Advanced: Fallback Chain with Retries

Retry primary before falling back:

```typescript
interface FallbackConfig {
  readonly maxRetries: number;
  readonly retryDelayMs: number;
  readonly backoffFactor: number;
}

const createResilientFallbackSink = (
  config: FallbackConfig
): Sink.Sink<{ readonly primary: number; readonly fallback: number }, never, Order> =>
  Sink.fold(
    { primary: 0, fallback: 0 },
    (state, order) =>
      Effect.gen(function* () {
        // Try primary with retries
        const primaryAttempt = yield* createCacheSink()
          .pipe(Sink.feed(Chunk.of(order)))
          .pipe(
            Effect.retry({
              times: config.maxRetries,
              delay: () =>
                Effect.sleep(`${config.retryDelayMs} millis`),
              onFailure: (error, attempt) =>
                Effect.log(
                  `Primary sink retry ${attempt}/${config.maxRetries}: ${error}`
                ),
            })
          )
          .pipe(Effect.either);

        if (Either.isRight(primaryAttempt)) {
          return { ...state, primary: state.primary + 1 };
        }

        // Primary exhausted retries, use fallback
        console.log(`[FALLBACK] Primary sink exhausted retries, using fallback`);

        const fallbackResult = yield* createDatabaseSink()
          .pipe(Sink.feed(Chunk.of(order)))
          .pipe(
            Effect.catchAll(() =>
              createDeadLetterSink().pipe(Sink.feed(Chunk.of(order)))
            )
          );

        return {
          ...state,
          fallback: state.fallback + 1,
        };
      }),
    (state) =>
      Effect.gen(function* () {
        console.log(`\n[SUMMARY]`);
        console.log(`  Primary: ${state.primary}`);
        console.log(`  Fallback: ${state.fallback}`);
        return state;
      })
  );
```

---

## When to Use This Pattern

✅ **Use fallback sinks when:**

- Primary destination might fail (database, cache, service)
- Need high availability with degradation
- Different sinks have different characteristics (speed vs. reliability)
- Want to avoid data loss when primary is unavailable
- Building fault-tolerant systems

⚠️ **Trade-offs:**

- Increased complexity (managing multiple sinks)
- Potential inconsistency (data in multiple places)
- Monitoring complexity (need to track which sink was used)
- Fallback may be slower/more expensive

---

## See Also

- [Handle Errors with catchTag](./handle-errors-with-catch.mdx) - Error recovery basics
- [Sink Pattern 1: Batch Insert](./sink-pattern-batch-insert-stream-records-into-database.mdx) - Primary sink pattern
- [Sink Pattern 3: Write Lines to File](./sink-pattern-write-stream-lines-to-file.mdx) - File-based fallback
- [Process Streaming Data with Stream](./process-streaming-data-with-stream.mdx) - Stream fundamentals
