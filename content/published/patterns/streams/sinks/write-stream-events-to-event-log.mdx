---
title: 'Sink Pattern 2: Write Stream Events to Event Log'
id: sink-pattern-write-stream-events-to-event-log
skillLevel: intermediate
applicationPatternId: streams-sinks
summary: >-
  Use Sink to append stream events to an event log with metadata and causal
  ordering, enabling event sourcing and audit trail patterns.
tags:
  - sink
  - stream
  - event-sourcing
  - persistence
  - append-only
  - audit-log
rule:
  description: >-
    Append stream events to an event log with metadata to maintain a complete,
    ordered record of what happened.
related:
  - process-streaming-data-with-stream
  - batch-insert-stream-records-into-database
  - define-tagged-errors
author: effect_website
lessonOrder: 2
---

## Guideline

When consuming a stream of events that represent changes in your system, append each event to an event log using `Sink`. Event logs provide immutable, ordered records that enable event sourcing, audit trails, and temporal queries.

---

## Rationale

Event logs are foundational to many patterns:

- **Event Sourcing**: Instead of storing current state, store the sequence of events that led to it
- **Audit Trails**: Complete, tamper-proof record of who did what and when
- **Temporal Queries**: Reconstruct state at any point in time
- **Consistency**: Single source of truth for what happened
- **Replay**: Rebuild state or test changes by replaying events

Unlike batch inserts which are transactional, event logs are append-only. Each event is immutable once written. This simplicity enables:

- Fast appends (no updates, just sequential writes)
- Natural ordering (events in write order)
- Easy distribution (replicate the log)
- Strong consistency (events are facts that don't change)

---

## Good Example

This example demonstrates an event sourcing pattern where a user account stream of events is appended to an event log with metadata.

```typescript
import { Effect, Stream, Sink, DateTime, Data } from "effect";

// Event types
type AccountEvent =
  | AccountCreated
  | MoneyDeposited
  | MoneyWithdrawn
  | AccountClosed;

class AccountCreated extends Data.TaggedError("AccountCreated")<{
  readonly accountId: string;
  readonly owner: string;
  readonly initialBalance: number;
}> {}

class MoneyDeposited extends Data.TaggedError("MoneyDeposited")<{
  readonly accountId: string;
  readonly amount: number;
}> {}

class MoneyWithdrawn extends Data.TaggedError("MoneyWithdrawn")<{
  readonly accountId: string;
  readonly amount: number;
}> {}

class AccountClosed extends Data.TaggedError("AccountClosed")<{
  readonly accountId: string;
}> {}

// Event envelope with metadata
interface StoredEvent {
  readonly eventId: string; // Unique identifier per event
  readonly eventType: string; // Type of event
  readonly aggregateId: string; // What this event is about
  readonly aggregateType: string; // What kind of thing (Account)
  readonly data: any; // Event payload
  readonly metadata: {
    readonly timestamp: number;
    readonly version: number; // Position in log
    readonly causationId?: string; // What caused this
  };
}

// Mock event log that appends events
const eventLog: StoredEvent[] = [];
let eventVersion = 0;

const appendToEventLog = (
  event: AccountEvent,
  aggregateId: string
): Effect.Effect<StoredEvent> =>
  Effect.gen(function* () {
    const now = yield* DateTime.now;
    const storedEvent: StoredEvent = {
      eventId: `evt-${eventVersion}-${Date.now()}`,
      eventType: event._tag,
      aggregateId,
      aggregateType: "Account",
      data: event,
      metadata: {
        timestamp: now.toEpochMillis(),
        version: ++eventVersion,
      },
    };

    // Append to log (simulated)
    eventLog.push(storedEvent);
    console.log(
      `[v${storedEvent.metadata.version}] ${storedEvent.eventType}: ${aggregateId}`
    );

    return storedEvent;
  });

// Simulate a stream of events from various account operations
const accountEvents: Stream.Stream<[string, AccountEvent]> = Stream.fromIterable([
  [
    "acc-1",
    new AccountCreated({
      accountId: "acc-1",
      owner: "Alice",
      initialBalance: 1000,
    }),
  ],
  ["acc-1", new MoneyDeposited({ accountId: "acc-1", amount: 500 })],
  ["acc-1", new MoneyWithdrawn({ accountId: "acc-1", amount: 200 })],
  [
    "acc-2",
    new AccountCreated({
      accountId: "acc-2",
      owner: "Bob",
      initialBalance: 2000,
    }),
  ],
  ["acc-2", new MoneyDeposited({ accountId: "acc-2", amount: 1000 })],
  ["acc-1", new AccountClosed({ accountId: "acc-1" })],
]);

// Sink that appends each event to the log
const eventLogSink: Sink.Sink<number, never, [string, AccountEvent]> = Sink.fold(
  0,
  (count, [aggregateId, event]) =>
    appendToEventLog(event, aggregateId).pipe(
      Effect.map(() => count + 1)
    ),
  (count) => Effect.succeed(count)
);

// Run the stream and append all events
const program = Effect.gen(function* () {
  const totalEvents = yield* accountEvents.pipe(Stream.run(eventLogSink));

  console.log(`\nTotal events appended: ${totalEvents}`);
  console.log(`\nEvent log contents:`);
  eventLog.forEach((event) => {
    console.log(`  [v${event.metadata.version}] ${event.eventType}`);
  });
});

Effect.runPromise(program);
```

This pattern:

1. **Defines event types** using tagged errors (AccountCreated, MoneyDeposited, etc.)
2. **Creates event envelopes** with metadata (timestamp, version, causation)
3. **Streams events** from various sources
4. **Appends to log** with proper versioning and ordering
5. **Maintains history** for reconstruction and audit

---

## Advanced: Event Causation Tracking

Track which events caused other events (for distributed systems):

```typescript
interface EnhancedStoredEvent extends StoredEvent {
  readonly metadata: StoredEvent["metadata"] & {
    readonly causationId?: string; // Event that caused this one
    readonly correlationId?: string; // Part of same logical operation
  };
}

const appendWithCausation = (
  event: AccountEvent,
  aggregateId: string,
  causationId?: string
): Effect.Effect<EnhancedStoredEvent> =>
  Effect.gen(function* () {
    const now = yield* DateTime.now;
    const storedEvent: EnhancedStoredEvent = {
      eventId: `evt-${eventVersion}-${Date.now()}`,
      eventType: event._tag,
      aggregateId,
      aggregateType: "Account",
      data: event,
      metadata: {
        timestamp: now.toEpochMillis(),
        version: ++eventVersion,
        causationId, // Link to causing event
      },
    };

    eventLog.push(storedEvent);
    return storedEvent;
  });
```

---

## Advanced: Reconstructing State from Events

Read events back from the log to reconstruct current state:

```typescript
interface AccountState {
  readonly accountId: string;
  readonly owner: string;
  readonly balance: number;
  readonly closed: boolean;
}

const reconstructAccount = (
  accountId: string
): Effect.Effect<AccountState | null> =>
  Effect.sync(() => {
    const events = eventLog.filter(
      (e) => e.aggregateId === accountId && e.aggregateType === "Account"
    );

    if (events.length === 0) return null;

    let state: AccountState = {
      accountId,
      owner: "",
      balance: 0,
      closed: false,
    };

    for (const event of events) {
      if (event.eventType === "AccountCreated") {
        const created = event.data as AccountCreated;
        state = {
          ...state,
          owner: created.owner,
          balance: created.initialBalance,
        };
      } else if (event.eventType === "MoneyDeposited") {
        const deposited = event.data as MoneyDeposited;
        state = { ...state, balance: state.balance + deposited.amount };
      } else if (event.eventType === "MoneyWithdrawn") {
        const withdrawn = event.data as MoneyWithdrawn;
        state = { ...state, balance: state.balance - withdrawn.amount };
      } else if (event.eventType === "AccountClosed") {
        state = { ...state, closed: true };
      }
    }

    return state;
  });

// Usage
const currentState = yield* reconstructAccount("acc-1");
console.log(`Account balance: ${currentState?.balance}`);
```

---

## When to Use This Pattern

✅ **Use event logs when:**

- You need a complete audit trail
- You want to replay events to understand what happened
- You're implementing event sourcing
- You need temporal queries ("What was the balance on date X?")
- You want strong consistency and traceability
- Multiple systems need to stay in sync

⚠️ **Trade-offs:**

- State reconstruction requires replaying events (slower than queries)
- Event log grows indefinitely (storage considerations)
- Schema changes require event migration strategies
- More complex than simple CRUD operations

---

## See Also

- [Batch Insert Stream Records into Database](./batch-insert-stream-records-into-database.mdx) - Bulk persistence
- [Process Streaming Data with Stream](./process-streaming-data-with-stream.mdx) - Stream fundamentals
- [Define Tagged Errors](./define-tagged-errors.mdx) - Event type definition
