---
title: "Define Contracts Upfront with Schema"
id: "define-contracts-with-schema"
skillLevel: "intermediate"
useCase: ["Domain Modeling"]
summary: "Use Schema to define the types for your data models and function signatures before writing the implementation, creating clear, type-safe contracts."
tags: ["schema", "design", "architecture", "type-safety", "contract-first", "data-modeling"]
rule:
  description: "Define contracts upfront with schema."
related: ["parse-with-schema-decode", "define-config-schema"]
author: "Sandro Maglione"
---

# Define Contracts Upfront with Schema

## Guideline

Before writing implementation logic, define the shape of your data models and
function signatures using `Effect/Schema`.

## Rationale

This "schema-first" approach separates the "what" (the data shape) from the
"how" (the implementation). It provides a single source of truth for both
compile-time static types and runtime validation.

## Good Example

```typescript
import { Schema, Effect } from "effect";

const User = Schema.Struct({
  id: Schema.Number,
  name: Schema.String,
});
type User = Schema.Schema.Type<typeof User>;

const DatabaseServiceSchema = Schema.Struct({
  getUser: Schema.Function(Schema.Number, Effect.Effect(User)),
});
```

**Explanation:**  
Defining schemas upfront clarifies your contracts and ensures both type safety
and runtime validation.

## Anti-Pattern

Defining logic with implicit `any` types first and adding validation later as
an afterthought. This leads to brittle code that lacks a clear contract.
