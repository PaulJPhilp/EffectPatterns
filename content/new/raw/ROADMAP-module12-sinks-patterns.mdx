---
title: "Sinks Patterns Learning Roadmap"
description: "Master Effect Sinks for consuming streams into results and managing data flow"
---

# Module 12: Sinks Patterns - From Understanding to Production

**Status**: In Development  
**Level**: Intermediate to Advanced  
**Focus**: Master Effect Sinks for consuming streams efficiently and safely

---

## ğŸ¯ Module Overview

This module takes you from understanding what Sinks are to building sophisticated, production-ready stream consumption patterns. You'll learn how to:

- Consume streams into final results
- Write streaming data to persistent storage
- Handle errors that occur during stream consumption
- Batch stream elements for efficient processing
- Deduplicate elements coming from a stream
- Compose multiple sinks together
- Build resilient stream consumers

---

## ğŸ“ Stage 1: The Foundations - What Are Sinks?

Learn why Sinks matter and how they differ from Streams.

### Conceptual Understanding

- **1. Streams vs. Sinks** `(Intermediate)`
  - ğŸŸ£ Understanding the Stream/Sink duality
  - ğŸŸ£ When to use Sinks vs. other patterns
  - ğŸŸ£ The "consumer" pattern in Effect

- **2. Sink Anatomy** `(Intermediate)`
  - ğŸŸ£ How Sinks process stream elements
  - ğŸŸ£ Sink state and accumulation
  - ğŸŸ£ Left-over handling

- **3. Basic Sink Operations** `(Intermediate)`
  - ğŸŸ£ Running a sink with a stream
  - ğŸŸ£ Extracting the final result
  - ğŸŸ£ Understanding Sink composition

---

## ğŸ“ Stage 2: Consumption Fundamentals - Getting Results from Streams

Learn the core patterns for turning streams into usable results.

### Basic Collection

- **4. Collect Stream Elements into a Collection** `(Intermediate)`
  - ğŸŸ£ Using `Sink.collectAll` for simple gathering
  - ğŸŸ£ Collecting into arrays, sets, and custom collections
  - ğŸŸ£ Understanding element ordering in results

- **5. Reduce a Stream to a Single Value** `(Intermediate)`
  - ğŸŸ£ Using `Sink.fold` for aggregation
  - ğŸŸ£ Computing sums, products, counts from streams
  - ğŸŸ£ Maintaining state across elements

- **6. Partition Stream Elements** `(Intermediate)`
  - ğŸŸ£ Splitting streams into groups
  - ğŸŸ£ Grouping by criteria during consumption
  - ğŸŸ£ Creating multi-partition results

---

## ğŸ“ Stage 3: Persistence - Write Streaming Data to Persistent Storage

Learn how to safely write stream data to databases, files, and external systems.

### Database Persistence

- **7. Batch Insert Stream Records into Database** `(Intermediate)`
  - ğŸŸ£ [Collecting records and batching for DB inserts](./content/published/patterns/core/stream-from-paginated-api.mdx)
  - ğŸŸ£ Configurable batch sizes for performance
  - ğŸŸ£ Handling partial batch failures
  - ğŸŸ£ Transaction semantics for inserts

- **8. Write Stream Events to Event Log** `(Intermediate)`
  - ğŸŸ£ Append-only writes for event sourcing
  - ğŸŸ£ Maintaining causal ordering
  - ğŸŸ£ Managing event metadata

### File I/O

- **9. Write Stream Lines to File** `(Intermediate)`
  - ğŸŸ£ Line-based streaming writes
  - ğŸŸ£ Buffering for I/O efficiency
  - ğŸŸ£ File rotation and rollover

- **10. Append to Append-Only Log** `(Intermediate)`
  - ğŸŸ£ Sequential append operations
  - ğŸŸ£ Log file management
  - ğŸŸ£ Read-after-write guarantees

### External Systems

- **11. Send Stream Records to Message Queue** `(Intermediate)`
  - ğŸŸ£ Publishing to Kafka, RabbitMQ, etc.
  - ğŸŸ£ Partitioning across queue topics
  - ğŸŸ£ Acknowledgment and retry semantics

---

## ğŸ“ Stage 4: Error Handling - Handle Errors During Stream Consumption

Learn resilient patterns for dealing with failures during stream processing.

### Error Recovery

- **12. Fall Back to Alternative Sink on Failure** `(Intermediate)`
  - ğŸŸ£ Try primary sink, use fallback on error
  - ğŸŸ£ Progressive degradation patterns
  - ğŸŸ£ Error type-based routing

- **13. Retry Failed Stream Operations** `(Intermediate)`
  - ğŸŸ£ Retrying with exponential backoff
  - ğŸŸ£ Configurable retry policies
  - ğŸŸ£ Exhaustion handling

### Error Capture

- **14. Capture Errors to Dead Letter Queue** `(Intermediate)`
  - ğŸŸ£ Collecting failed elements separately
  - ğŸŸ£ Error metadata capture
  - ğŸŸ£ Inspection and replay of failures

- **15. Continue Despite Partial Failures** `(Intermediate)`
  - ğŸŸ£ Partial success in batch operations
  - ğŸŸ£ Tracking successes vs. failures
  - ğŸŸ£ Summary statistics on completion

---

## ğŸ“ Stage 5: Efficiency - Batch Stream Elements for Efficient Processing

Learn optimization patterns for high-performance stream consumption.

### Batching Strategies

- **16. Batch Elements by Size** `(Intermediate)`
  - ğŸŸ£ Collecting N elements before processing
  - ğŸŸ£ Trade-offs between latency and throughput
  - ğŸŸ£ Configurable batch sizes

- **17. Batch Elements by Time Window** `(Intermediate)`
  - ğŸŸ£ Collecting elements within a time period
  - ğŸŸ£ Mixed time and size-based batching
  - ğŸŸ£ Flushing partial batches at deadline

### Performance Optimization

- **18. Drain Stream with Minimal Allocations** `(Intermediate)`
  - ğŸŸ£ Resource-conscious consumption
  - ğŸŸ£ Garbage collection considerations
  - ğŸŸ£ Memory-efficient aggregation

- **19. Parallelize Sink Operations** `(Intermediate)`
  - ğŸŸ£ Processing batches concurrently
  - ğŸŸ£ Thread pool sizing
  - ğŸŸ£ Maintaining ordering guarantees where needed

---

## ğŸ“ Stage 6: Quality - Deduplicate Elements Coming from a Stream

Learn patterns for handling duplicates and ensuring data quality.

### Deduplication Techniques

- **20. Deduplicate by Element Equality** `(Intermediate)`
  - ğŸŸ£ Removing exact duplicate elements
  - ğŸŸ£ Set-based deduplication
  - ğŸŸ£ Memory overhead considerations

- **21. Deduplicate by Key** `(Intermediate)`
  - ğŸŸ£ Using a key function to identify duplicates
  - ğŸŸ£ Keeping first/last occurrence
  - ğŸŸ£ Duplicate metrics and tracking

### Windowed Deduplication

- **22. Deduplicate Within Time Window** `(Intermediate)`
  - ğŸŸ£ Sliding window deduplication
  - ğŸŸ£ Forgetting old elements after window
  - ğŸŸ£ Handling duplicates arriving out-of-order

- **23. Deduplicate with Correlation ID** `(Intermediate)`
  - ğŸŸ£ Idempotency key tracking
  - ğŸŸ£ Exactly-once semantics
  - ğŸŸ£ Distributed deduplication

---

## ğŸ“ Stage 7: Advanced Patterns - Building Sophisticated Stream Consumers

Master advanced Sink techniques for complex domains.

### Composition & Transformation

- **24. Chain Multiple Sinks Together** `(Advanced)`
  - ğŸŸ£ Sink composition and sequencing
  - ğŸŸ£ Conditional sink selection
  - ğŸŸ£ Pipeline construction

- **25. Transform Data During Consumption** `(Advanced)`
  - ğŸŸ£ Mapping elements before sink operation
  - ğŸŸ£ Validation during consumption
  - ğŸŸ£ Schema enforcement

### Distribution

- **26. Distribute Stream to Multiple Sinks** `(Advanced)`
  - ğŸŸ£ Fan-out patterns
  - ğŸŸ£ Broadcasting to parallel sinks
  - ğŸŸ£ Synchronization between sinks

- **27. Route Elements to Different Sinks** `(Advanced)`
  - ğŸŸ£ Conditional routing based on content
  - ğŸŸ£ Dynamic sink selection
  - ğŸŸ£ Maintaining ordering within routes

### Observability

- **28. Observe Sink Operations with Tracing** `(Advanced)`
  - ğŸŸ£ Distributed tracing for sink spans
  - ğŸŸ£ Timing and duration tracking
  - ğŸŸ£ OpenTelemetry integration

- **29. Emit Metrics from Sink Processing** `(Advanced)`
  - ğŸŸ£ Counting elements processed
  - ğŸŸ£ Recording latencies and throughput
  - ğŸŸ£ Error rate metrics

---

## ğŸ“ Stage 8: Integration - Sinks in Context

Combine Sinks with other Effect patterns for complete solutions.

### With Services & Layers

- **30. Use Sinks in Service Implementations** `(Advanced)`
  - ğŸŸ£ Sinks as service boundaries
  - ğŸŸ£ Dependency injection for sink providers
  - ğŸŸ£ Testing sink-based services

- **31. Compose Sinks into Reusable Layers** `(Advanced)`
  - ğŸŸ£ Creating sink libraries
  - ğŸŸ£ Sharing sink implementations
  - ğŸŸ£ Configurable sink factories

### Testing & Verification

- **32. Verify Sink Behavior in Tests** `(Advanced)`
  - ğŸŸ£ Capturing sink results for assertions
  - ğŸŸ£ Mocking sinks in tests
  - ğŸŸ£ Property-based testing of sinks

- **33. Debug Sink Operations** `(Advanced)`
  - ğŸŸ£ Logging intermediary results
  - ğŸŸ£ Inspecting sink state
  - ğŸŸ£ Tracing element flow through sinks

---

## ğŸ“ Learning Path by Job to be Done

### Job: "Write streaming data to persistent storage"
**Stages 3-4 Focus**
- Stage 3: Database, File, and Queue persistence patterns
- Stage 4: Error handling for failed writes
- Patterns 7-15 address this job
- Prerequisites: Understanding streams, basic sink operations

### Job: "Handle errors that occur during stream consumption"
**Stages 4-7 Focus**
- Stage 4: Error recovery and capture
- Stage 7: Advanced observability for errors
- Patterns 12-15, 28-29 address this job
- Prerequisites: Error handling fundamentals

### Job: "Batch stream elements for efficient processing"
**Stages 5-6 Focus**
- Stage 5: Batching strategies and performance
- Stage 6: Quality control in batches
- Patterns 16-19 address this job
- Prerequisites: Stream consumption basics

### Job: "Deduplicate elements coming from a stream"
**Stages 6-7 Focus**
- Stage 6: Core deduplication patterns
- Stage 7: Advanced distributed deduplication
- Patterns 20-23 address this job
- Prerequisites: Stream concepts, state management

---

## ğŸ”— Cross-Module References

### Prerequisites (Module 11: Schema)
- Pattern 25 builds on schema validation
- Pattern validation semantics

### Synergies (Module 10: Error Management)
- Patterns 12-15 extend error handling to streams
- Error recovery strategies

### Building Blocks (Module 9: Streams)
- Patterns consume what Streams produce
- Complementary APIs and concepts

---

## âœ… Knowledge Checkpoints

### After Stage 2
You can:
- Explain the Stream/Sink duality
- Create basic sinks that collect results
- Run sinks with streams and extract results

### After Stage 4
You can:
- Write stream data to persistent storage safely
- Implement error recovery patterns
- Choose appropriate fallback strategies

### After Stage 6
You can:
- Optimize sink performance with batching
- Implement deduplication correctly
- Handle quality concerns in high-volume streams

### After Stage 8
You can:
- Build production-ready stream consumption systems
- Test sink implementations thoroughly
- Integrate sinks into larger applications

---

## ğŸ“Š Pattern Statistics

- **Total Patterns in Module:** 33
- **Intermediate Patterns:** 25
- **Advanced Patterns:** 8
- **Estimated Study Time:** 15-20 hours
- **Hands-On Coding:** 8-10 hours
- **Prerequisites:** Module 9 (Streams), Module 10 (Error Management)

---

## ğŸ¯ Module Goals

By completing this module, you will:

1. âœ… Understand when and how to use Sinks for stream consumption
2. âœ… Implement patterns for all four core jobs
3. âœ… Write production-ready stream consumers
4. âœ… Handle errors and edge cases in stream processing
5. âœ… Optimize for performance and correctness
6. âœ… Test and debug sink-based systems
7. âœ… Integrate sinks into larger Effect applications

---

**Last Updated:** December 17, 2025  
**Status:** Roadmap in Development  
**Next Steps:** Implement pattern templates for each of the 33 patterns
