---
title: "Working with Tuples using Data.tuple"
id: "data-tuple"
skillLevel: "beginner"
useCase: ["Data Types", "Tuples", "Structural Equality", "Domain Modeling"]
summary: "Use Data.tuple to create immutable, type-safe tuples that support value-based equality and pattern matching."
tags: ["Data.tuple", "tuple", "structural-equality", "immutable", "data-type", "effect"]
rule:
  description: "Use Data.tuple to define tuples whose equality is based on their contents, enabling safe and predictable comparisons and pattern matching."
related: ["data-struct", "data-array"]
author: "PaulJPhilp"
---

# Working with Tuples using `Data.tuple`

## Guideline

Use `Data.tuple` to create immutable, type-safe tuples that support value-based equality and pattern matching.  
This is useful for modeling fixed-size, heterogeneous collections of values in a safe and expressive way.

## Rationale

JavaScript arrays are mutable and compared by reference, which can lead to bugs in value-based logic.  
`Data.tuple` provides immutable tuples with structural equality, making them ideal for domain modeling and functional programming patterns.

## Good Example

```typescript
import { Data, Equal, Effect, HashSet } from "effect";

const t1 = Data.tuple(1, "Alice");
const t2 = Data.tuple(1, "Alice");
const areEqual = Equal.equals(t1, t2);
const set = HashSet.make(t1);
const hasT2 = HashSet.has(set, t2);
const [id, name] = t1;

const program = Effect.gen(function* () {
  yield* Effect.log(`t1: [${t1[0]}, ${t1[1]}]`);
  yield* Effect.log(`t2: [${t2[0]}, ${t2[1]}]`);
  yield* Effect.log(`Equal.equals(t1, t2): ${areEqual}`);
  yield* Effect.log(`HashSet.has(set, t2): ${hasT2}`);
  yield* Effect.log(`Pattern matched tuple: id=${id}, name=${name}`);
});

Effect.runPromise(program);

```

**Explanation:**  
- `Data.tuple` creates immutable tuples with value-based equality.
- Useful for modeling pairs, coordinates, or any fixed-size, heterogeneous data.
- Supports safe pattern matching and collection operations.

## Anti-Pattern

Using plain arrays for value-based logic or as keys in sets/maps, which compares by reference and can lead to incorrect behavior.