---
title: Lifting Errors and Absence with fail, none, and left
id: constructor-fail-none-left
skillLevel: beginner
provider: google
model: gemini-2.5-flash
useCase:
  - Constructors
  - Lifting
  - Error Handling
  - Absence
summary: Use fail, none, and left to represent errors or absence in Effect,
  Option, or Either, making failures explicit and type-safe.
tags:
  - fail
  - none
  - left
  - constructor
  - effect
  - option
  - either
  - error
  - absence
rule:
  description: Use fail, none, and left to create Effect, Option, or Either that
    represent failure or absence.
related:
  - constructor-succeed-some-right
  - constructor-try-trypromise
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.713Z level=INFO fiber=#0 message="Effect.fail
  result: Error: Something went wrong"

  timestamp=2025-08-07T18:29:29.715Z level=INFO fiber=#0 message="Option.none
  result: None"

  timestamp=2025-08-07T18:29:29.715Z level=INFO fiber=#0 message="Either.left
  result: Left: Invalid input"
---

# Lifting Errors and Absence with `fail`, `none`, and `left`

## Guideline

Use the `fail`, `none`, and `left` constructors to represent errors or absence in the Effect, Option, or Either world.  
This makes failures explicit, type-safe, and composable.

## Rationale

By lifting errors and absence into these structures, you can handle them declaratively with combinators, rather than relying on exceptions, `null`, or `undefined`.  
This leads to more robust and maintainable code.

## Good Example

```typescript
import { Effect, Option, Either } from "effect";

const effect = Effect.fail("Something went wrong");
const option = Option.none();
const either = Either.left("Invalid input");

const program = Effect.gen(function* () {
  yield* Effect.either(effect).pipe(
    Effect.tap((res) =>
      Effect.log(
        `Effect.fail result: ${
          res._tag === "Left" ? `Error: ${res.left}` : res.right
        }`
      )
    )
  );
  yield* Effect.log(
    `Option.none result: ${Option.isNone(option) ? "None" : option.value}`
  );
  yield* Effect.log(
    `Either.left result: ${
      Either.isLeft(either) ? `Left: ${either.left}` : either.right
    }`
  );
});

Effect.runPromise(program);

```

**Explanation:**  
- `Effect.fail(error)` creates an effect that always fails with `error`.
- `Option.none()` creates an option that is always absent.
- `Either.left(error)` creates an either that always represents failure.

## Anti-Pattern

Throwing exceptions, returning `null` or `undefined`, or using error codes outside the Effect, Option, or Either world.  
This makes error handling ad hoc, less type-safe, and harder to compose.