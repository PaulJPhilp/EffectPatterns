---
title: "Combining Values with zip"
id: "combinator-zip"
skillLevel: "beginner"
useCase: ["Combinators", "Composition", "Pairing"]
summary: "Use zip to combine two computations, pairing their results together in Effect, Stream, Option, or Either."
tags: ["zip", "combinator", "pair", "effect", "stream", "option", "either"]
rule:
  description: "Use zip to run two computations and combine their results into a tuple, preserving error and context handling."
related: ["combinator-map", "combinator-flatmap", "combinator-all-race"]
author: "PaulJPhilp"
---

# Combining Values with `zip`

## Guideline

Use the `zip` combinator to combine two computations, pairing their results together.  
This works for `Effect`, `Stream`, `Option`, and `Either`, and is useful when you want to run two computations and work with both results.

## Rationale

`zip` lets you compose computations that are independent but whose results you want to use together.  
It preserves error handling and context, and keeps your code declarative and type-safe.

## Good Example

```typescript
import { Effect, Stream, Option, Either } from "effect";

const effectA = Effect.succeed(1);
const effectB = Effect.succeed("hello");
const zippedEffect = effectA.pipe(Effect.zip(effectB));

const optionA = Option.some(1);
const optionB = Option.some("hello");
const zippedOption =
  Option.isSome(optionA) && Option.isSome(optionB)
    ? Option.some([optionA.value, optionB.value] as [number, string])
    : Option.none();

const eitherA = Either.right(1);
const eitherB = Either.right("hello");
const zippedEither =
  Either.isRight(eitherA) && Either.isRight(eitherB)
    ? Either.right([eitherA.right, eitherB.right] as [number, string])
    : Either.isLeft(eitherA)
    ? Either.left(eitherA.left)
    : Either.left(eitherB.left);

const streamA = Stream.fromIterable([1, 2, 3]);
const streamB = Stream.fromIterable(["a", "b", "c"]);
const zippedStream = streamA.pipe(Stream.zip(streamB));

const program = Effect.gen(function* () {
  const effectResult = yield* zippedEffect;
  yield* Effect.log(
    `Effect.zip result: [${effectResult[0]}, ${effectResult[1]}]`
  );
  yield* Effect.log(
    `Option.zip result: ${
      Option.isSome(zippedOption)
        ? `[${zippedOption.value[0]}, ${zippedOption.value[1]}]`
        : "None"
    }`
  );
  yield* Effect.log(
    `Either.zip result: ${
      Either.isRight(zippedEither)
        ? `[${zippedEither.right[0]}, ${zippedEither.right[1]}]`
        : "Left"
    }`
  );
  const streamValues: Array<[number, string]> = [];
  yield* Stream.runForEach(zippedStream, (pair) =>
    Effect.sync(() => streamValues.push(pair))
  );
  yield* Effect.log(
    `Stream.zip result: [${streamValues
      .map(([n, s]) => `[${n}, ${s}]`)
      .join(", ")}]`
  );
});

Effect.runPromise(program);

```

**Explanation:**  
`zip` runs both computations and pairs their results.  
If either computation fails (or is None/Left/empty), the result is a failure (or None/Left/empty).

## Anti-Pattern

Manually running two computations, extracting their results, and pairing them outside the combinator world.  
This breaks composability, loses error/context handling, and can lead to subtle bugs.