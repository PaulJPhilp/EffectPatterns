---
title: "Modeling Validated Domain Types with Brand"
id: "brand-model-domain-type"
skillLevel: "intermediate"
useCase: ["Branded Types", "Domain Modeling", "Type Safety"]
summary: "Use Brand to create domain-specific types from primitives, making illegal states unrepresentable and preventing accidental misuse."
tags: ["Brand", "domain", "type-safety", "validation", "effect"]
rule:
  description: "Use Brand to define types like Email, UserId, or PositiveInt, ensuring only valid values can be constructed and used."
related: ["brand-validate-parse"]
author: "PaulJPhilp"
---

# Modeling Validated Domain Types with `Brand`

## Guideline

Use the `Brand` utility to create domain-specific types from primitives like `string` or `number`.  
This prevents accidental misuse and makes illegal states unrepresentable in your codebase.

## Rationale

Branded types add a layer of type safety, ensuring that values like `Email`, `UserId`, or `PositiveInt` are not confused with plain strings or numbers.  
They help you catch bugs at compile time and make your code more self-documenting.

## Good Example

```typescript
import { Brand, Effect } from "effect";

interface Email extends Brand.Branded<string, "Email"> {}

function sendWelcome(email: Email) {
  return Effect.log(`Welcome email sent to: ${email}`);
}

const email = "user@example.com" as Email;

const program = Effect.gen(function* () {
  yield* Effect.log("Demonstrating branded type Email:");
  yield* sendWelcome(email);
  return email;
});

Effect.runPromise(program);

```

**Explanation:**  
- `Brand.Branded<T, Name>` creates a new type that is distinct from its base type.
- Only values explicitly branded as `Email` can be used where an `Email` is required.
- This prevents accidental mixing of domain types.

## Anti-Pattern

Using plain strings or numbers for domain-specific values (like emails, user IDs, or currency codes), which can lead to accidental misuse and bugs that are hard to catch.