---
title: Structural Equality and Hashing with Data.struct
id: data-class
skillLevel: beginner
provider: google
model: gemini-2.5-flash
useCase:
  - Data Types
  - Structural Equality
  - Hashing
  - Collections
summary: Use Data.struct to create data types with built-in structural equality
  and hashing, enabling seamless use in collections and comparisons.
tags:
  - Data.struct
  - structural-equality
  - hashing
  - data-type
  - effect
  - collections
rule:
  description: Use Data.struct to create data types with automatic structural
    equality and hashing for use in collections and comparisons.
related:
  - data-struct
  - data-tuple
  - data-array
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.704Z level=INFO fiber=#0 message="User:
  {\"id\":1,\"name\":\"Alice\"}"

  timestamp=2025-08-07T18:29:29.705Z level=INFO fiber=#0
  message="Equal.equals(User, {id:1,name:'Alice'}): true"

  timestamp=2025-08-07T18:29:29.706Z level=INFO fiber=#0
  message="Hash.hash(User): -652630587"

  timestamp=2025-08-07T18:29:29.706Z level=INFO fiber=#0
  message="HashSet.has(set, {id:1,name:'Alice'}): true"

  timestamp=2025-08-07T18:29:29.706Z level=INFO fiber=#0 message="Sorted users
  by id: [Alice, Bob]"
---

# Structural Equality and Hashing with `Data.struct`

## Guideline

Use `Data.struct` to create data types with built-in structural equality and hashing.  
This enables your data types to work seamlessly with Effect's collections, comparisons, and algorithms without manual equality or hash implementations.

## Rationale

Structural equality and hashing are essential for using your data types in sets, maps, and for deduplication.  
`Data.struct` automatically provides these capabilities, making your types immediately compatible with Effect's collection types like `HashSet` and `HashMap`.

## Good Example

```typescript
import { Data, Equal, Hash, Effect, HashSet } from "effect";

const User = Data.struct({ id: 1, name: "Alice" });

const isEqual = Equal.equals(User, Data.struct({ id: 1, name: "Alice" }));
const userHash = Hash.hash(User);

const set = HashSet.make(User);
const hasUser = HashSet.has(set, Data.struct({ id: 1, name: "Alice" }));

const users = [Data.struct({ id: 2, name: "Bob" }), User];
const sorted = users.sort((a, b) => a.id - b.id);

const program = Effect.gen(function* () {
  yield* Effect.log(`User: ${JSON.stringify(User)}`);
  yield* Effect.log(`Equal.equals(User, {id:1,name:'Alice'}): ${isEqual}`);
  yield* Effect.log(`Hash.hash(User): ${userHash}`);
  yield* Effect.log(`HashSet.has(set, {id:1,name:'Alice'}): ${hasUser}`);
  yield* Effect.log(
    `Sorted users by id: [${sorted.map((u) => u.name).join(", ")}]`
  );
});

Effect.runPromise(
  program.pipe(Effect.catchAll(() => Effect.succeed(undefined)))
);

```

**Explanation:**  
- `Data.struct` creates data types with automatic structural equality and hashing.
- `Equal.equals` can compare `Data.struct` instances by their structure, not reference.
- `Hash.hash` generates consistent hash values for use in collections like `HashSet`.
- These capabilities make your data types immediately compatible with Effect's collections and algorithms.
- Structural equality works recursively, comparing all nested properties for deep equality.

## Anti-Pattern

Relying on reference equality or manual comparison functions for data types, or using plain objects that don't provide structural equality, which can lead to bugs and inconsistent behavior in collections.