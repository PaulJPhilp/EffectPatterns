---
title: "Type Classes for Equality, Ordering, and Hashing with Data.Class"
id: "data-class"
skillLevel: "intermediate"
useCase: ["Data Types", "Type Classes", "Equality", "Ordering", "Hashing"]
summary: "Use Data.Class to derive and implement type classes for equality, ordering, and hashing, enabling composable and type-safe abstractions."
tags: ["Data.Class", "type-class", "equality", "ordering", "hashing", "data-type", "effect"]
rule:
  description: "Use Data.Class to define and derive type classes for your data types, supporting composable equality, ordering, and hashing."
related: ["data-struct", "data-tuple", "data-array"]
author: "PaulJPhilp"
---

# Type Classes for Equality, Ordering, and Hashing with `Data.Class`

## Guideline

Use `Data.Class` to derive or implement type classes for equality, ordering, and hashing for your custom data types.  
This enables composable, type-safe abstractions and allows your types to work seamlessly with Effect’s collections and algorithms.

## Rationale

Type classes like `Equal`, `Order`, and `Hash` provide a principled way to define how your types are compared, ordered, and hashed.  
This is essential for using your types in sets, maps, and for sorting or deduplication.

## Good Example

```typescript
import { Data, Equal, Hash, Effect, HashSet } from "effect";

const User = Data.struct({ id: 1, name: "Alice" });

const isEqual = Equal.equals(User, Data.struct({ id: 1, name: "Alice" }));
const userHash = Hash.hash(User);

const set = HashSet.make(User);
const hasUser = HashSet.has(set, Data.struct({ id: 1, name: "Alice" }));

const users = [Data.struct({ id: 2, name: "Bob" }), User];
const sorted = users.sort((a, b) => a.id - b.id);

const program = Effect.gen(function* () {
  yield* Effect.log(`User: ${JSON.stringify(User)}`);
  yield* Effect.log(`Equal.equals(User, {id:1,name:'Alice'}): ${isEqual}`);
  yield* Effect.log(`Hash.hash(User): ${userHash}`);
  yield* Effect.log(`HashSet.has(set, {id:1,name:'Alice'}): ${hasUser}`);
  yield* Effect.log(
    `Sorted users by id: [${sorted.map((u) => u.name).join(", ")}]`
  );
});

Effect.runPromise(program);

```

**Explanation:**  
- `Data.Class.getEqual` derives an equality type class for your data type.
- `Data.Class.getOrder` derives an ordering type class, useful for sorting.
- `Data.Class.getHash` derives a hash function for use in sets and maps.
- These type classes make your types fully compatible with Effect’s collections and algorithms.

## Anti-Pattern

Relying on reference equality, ad-hoc comparison functions, or not providing type class instances for your custom types, which can lead to bugs and inconsistent behavior in collections.