---
title: "Validating and Parsing Branded Types"
id: "brand-validate-parse"
skillLevel: "intermediate"
useCase: ["Branded Types", "Domain Modeling", "Validation", "Parsing"]
summary: "Use Schema and Brand together to validate and parse branded types at runtime, ensuring only valid values are constructed."
tags: ["Brand", "Schema", "validation", "parsing", "domain", "type-safety", "effect"]
rule:
  description: "Combine Schema and Brand to validate and parse branded types, guaranteeing only valid domain values are created at runtime."
related: ["brand-model-domain-type"]
author: "PaulJPhilp"
---

# Validating and Parsing Branded Types

## Guideline

Use `Schema` in combination with `Brand` to validate and parse branded types at runtime.  
This ensures that only values passing your validation logic can be constructed as branded types, making your domain models robust and type-safe.

## Rationale

While branding types at the type level prevents accidental misuse, runtime validation is needed to ensure only valid values are constructed from user input, APIs, or external sources.

## Good Example

```typescript
import { Brand, Schema, Effect } from "effect";

// Official Effect branded type pattern for Email
export type Email = Brand.Brand<"Email">;
export const Email = Brand.nominal<Email>();

// Create a Schema for Email validation
export const EmailSchema = Schema.String.pipe(
  Schema.pattern(/^[^@]+@[^@]+\.[^@]+$/),
  Schema.brand("Email")
);

// Parse and validate an email at runtime
function parseEmail(input: string) {
  return Effect.gen(function* () {
    const email = yield* Schema.decodeUnknown(EmailSchema)(input);
    return email;
  }).pipe(
    Effect.catchTag("ParseError", (error) =>
      Effect.succeed(`Invalid email: ${error.message}`)
    )
  );
}

const program = Effect.gen(function* () {
  const valid = yield* parseEmail("user@example.com");
  const invalid = yield* parseEmail("not-an-email");
  yield* Effect.log(`Valid email parse result: ${valid}`);
  yield* Effect.log(`Invalid email parse result: ${invalid}`);
  return { valid, invalid };
});

Effect.runPromise(program);

```

**Explanation:**  
- `Schema` is used to define validation logic for the branded type.
- `Brand.schema<Email>()` attaches the brand to the schema, so only validated values can be constructed as `Email`.
- This pattern ensures both compile-time and runtime safety.

## Anti-Pattern

Branding values without runtime validation, or accepting unvalidated user input as branded types, which can lead to invalid domain values and runtime bugs.