---
title: Representing Time Spans with Duration
id: data-duration
skillLevel: beginner
provider: google
model: gemini-2.5-flash
useCase:
  - Data Types
  - Time
  - Duration
  - Domain Modeling
summary: Use Duration to represent time intervals in a type-safe,
  human-readable, and composable way.
tags:
  - Duration
  - time
  - interval
  - data-type
  - effect
rule:
  description: Use Duration to model and manipulate time spans, enabling safe and
    expressive time-based logic.
related:
  - data-datetime
  - data-cause
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.249Z level=INFO fiber=#0 message="oneSecond:
  1000 ms"

  timestamp=2025-08-07T18:29:29.306Z level=INFO fiber=#0 message="fiveMinutes:
  300000 ms"

  timestamp=2025-08-07T18:29:29.306Z level=INFO fiber=#0 message="twoHours:
  7200000 ms"

  timestamp=2025-08-07T18:29:29.352Z level=INFO fiber=#0 message="total
  (oneSecond + fiveMinutes): 301000 ms"

  timestamp=2025-08-07T18:29:29.353Z level=INFO fiber=#0 message="is twoHours >
  fiveMinutes: true"

  timestamp=2025-08-07T18:29:29.353Z level=INFO fiber=#0 message="fiveMinutes in
  ms: 300000"
---

# Representing Time Spans with `Duration`

## Guideline

Use the `Duration` data type to represent and manipulate time intervals in a type-safe, human-readable, and composable way.  
This enables robust time-based logic for scheduling, retries, timeouts, and more.

## Rationale

Working with raw numbers for time intervals (e.g., milliseconds) is error-prone and hard to read.  
`Duration` provides a clear, expressive API for modeling time spans, improving code safety and maintainability.

## Good Example

```typescript
import { Duration, Effect } from "effect";

const oneSecond = Duration.seconds(1);
const fiveMinutes = Duration.minutes(5);
const twoHours = Duration.hours(2);

const total = Duration.sum(oneSecond, fiveMinutes);
const isLonger = Duration.greaterThan(twoHours, fiveMinutes);
const ms = Duration.toMillis(fiveMinutes);

const program = Effect.gen(function* () {
  yield* Effect.log(`oneSecond: ${Duration.toMillis(oneSecond)} ms`);
  yield* Effect.log(`fiveMinutes: ${Duration.toMillis(fiveMinutes)} ms`);
  yield* Effect.log(`twoHours: ${Duration.toMillis(twoHours)} ms`);
  yield* Effect.log(
    `total (oneSecond + fiveMinutes): ${Duration.toMillis(total)} ms`
  );
  yield* Effect.log(`is twoHours > fiveMinutes: ${isLonger}`);
  yield* Effect.log(`fiveMinutes in ms: ${ms}`);
});

Effect.runPromise(program);

```

**Explanation:**  
- `Duration` is immutable and type-safe.
- Use helpers for common intervals and arithmetic for composition.
- Prefer `Duration` over raw numbers for all time-based logic.

## Anti-Pattern

Using raw numbers (e.g., `5000` for 5 seconds) for time intervals, which is error-prone, hard to read, and less maintainable.