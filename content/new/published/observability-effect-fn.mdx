---
title: Instrument and Observe Function Calls with Effect.fn
id: observability-effect-fn
skillLevel: intermediate
useCase:
  - Observability
  - Instrumentation
  - Function Calls
  - Debugging
summary: Use Effect.fn to wrap, instrument, and observe function calls, enabling
  composable logging, metrics, and tracing at function boundaries.
tags:
  - Effect.fn
  - observability
  - instrumentation
  - function
  - logging
  - metrics
  - tracing
rule:
  description: Use Effect.fn to wrap functions with effectful instrumentation,
    such as logging, metrics, or tracing, in a composable and type-safe way.
related:
  - observability-structured-logging
  - observability-custom-metrics
  - observability-tracing-spans
author: PaulJPhilp
provider: google
model: gemini-2.5-flash
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.570Z level=INFO fiber=#0 message="Calling add
  with 2 and 3"

  timestamp=2025-08-07T18:29:29.574Z level=INFO fiber=#0 message="Result: 5"

  timestamp=2025-08-07T18:29:29.575Z level=INFO fiber=#0 message="Sum is 5"
---

# Instrument and Observe Function Calls with `Effect.fn`

## Guideline

Use `Effect.fn` to wrap and instrument function calls with effectful logic, such as logging, metrics, or tracing.  
This enables you to observe, monitor, and debug function boundaries in a composable, type-safe way.

## Rationale

Instrumenting function calls is essential for observability, especially in complex or critical code paths.  
`Effect.fn` lets you add effectful logic (logging, metrics, tracing, etc.) before, after, or around any function call, without changing the functionâ€™s core logic.

## Good Example

```typescript
import { Effect } from "effect";

function add(a: number, b: number): number {
  return a + b;
}

const addWithLogging = Effect.fn((a: number, b: number) =>
  Effect.gen(function* () {
    yield* Effect.log(`Calling add with ${a} and ${b}`);
    const result = add(a, b);
    yield* Effect.log(`Result: ${result}`);
    return result;
  })
);

const program = Effect.gen(function* () {
  const sum = yield* addWithLogging(2, 3);
  yield* Effect.log(`Sum is ${sum}`);
});

Effect.runPromise(program);

```

**Explanation:**  
- `Effect.fn` wraps a function, returning a new function that produces an Effect.
- You can add logging, metrics, tracing, or any effectful logic before/after the call.
- Keeps instrumentation separate from business logic and fully composable.

## Anti-Pattern

Scattering logging, metrics, or tracing logic directly inside business functions, making code harder to test, maintain, and compose.