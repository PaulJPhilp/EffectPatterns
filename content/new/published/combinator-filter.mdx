---
title: Filtering Results with filter
id: combinator-filter
skillLevel: beginner
provider: google
model: gemini-2.5-flash
useCase:
  - Combinators
  - Composition
  - Conditional Logic
summary: Use filter to keep or discard results based on a predicate, across
  Effect, Stream, Option, and Either.
tags:
  - filter
  - combinator
  - predicate
  - effect
  - stream
  - option
  - either
rule:
  description: Use filter to declaratively express conditional logic, keeping only
    values that satisfy a predicate.
related:
  - combinator-map
  - combinator-flatmap
  - combinator-conditional
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.607Z level=INFO fiber=#0 message="Effect.filter
  result: 4"

  timestamp=2025-08-07T18:29:29.608Z level=INFO fiber=#0 message="Option.filter
  result: 4"

  timestamp=2025-08-07T18:29:29.608Z level=INFO fiber=#0 message="Either.filter
  result: 4"

  timestamp=2025-08-07T18:29:29.685Z level=INFO fiber=#0 message="Stream.filter
  result: [2, 4]"
---

# Filtering Results with `filter`

## Guideline

Use the `filterOrFail` combinator to keep only those values that satisfy a predicate in an Effect, providing a custom error if the predicate fails.  
This works for `Effect`, `Stream`, and `Option`, allowing you to express conditional logic declaratively and safely.  
For `Either`, use a conditional expression to construct a left or right value based on your predicate.

## Rationale

`filterOrFail` lets you express "only continue if..." logic without resorting to manual checks or imperative branching.  
It keeps your code composable and type-safe, and ensures that failures or empty results are handled consistently.

## Good Example

```typescript
import { Effect, Stream, Option, Either } from "effect";

const effect = Effect.succeed(4).pipe(
  Effect.filterOrFail(
    (n) => n % 2 === 0,
    () => "Filtered out (fail)"
  )
);

const option = Option.some(4).pipe(Option.filter((n) => n % 2 === 0));

const either = (() => {
  const e = Either.right(4);
  return Either.isRight(e) && e.right % 2 === 0
    ? e
    : Either.left("filtered out");
})();

const stream = Stream.fromIterable([1, 2, 3, 4]).pipe(
  Stream.filter((n: number) => n % 2 === 0)
);

const program = Effect.gen(function* () {
  const effectResult = yield* Effect.either(effect);
  yield* Effect.log(
    `Effect.filter result: ${
      effectResult._tag === "Right" ? effectResult.right : effectResult.left
    }`
  );
  yield* Effect.log(
    `Option.filter result: ${
      Option.isSome(option) ? option.value : "Filtered out (none)"
    }`
  );
  yield* Effect.log(
    `Either.filter result: ${
      Either.isRight(either) ? either.right : "Filtered out (left)"
    }`
  );
  const streamValues: number[] = [];
  yield* Stream.runForEach(stream, (n) =>
    Effect.sync(() => streamValues.push(n))
  );
  yield* Effect.log(`Stream.filter result: [${streamValues.join(", ")}]`);
});

Effect.runPromise(program);

```

**Explanation:**  
- `filterOrFail` applies a predicate to the value inside an Effect. If the predicate fails, the result is a failure (`Effect.fail`).
- `Option.filter` returns `Option.none` if the predicate fails.
- `Stream.filter` removes elements that do not satisfy the predicate.
- For `Either`, construct a `Right` if the predicate passes, or a `Left` if it fails.

## Anti-Pattern

Using `map` with a conditional that returns `Option` or `Either`, then manually flattening, instead of using `filterOrFail`, `Option.filter`, or a conditional for `Either`.  
This leads to unnecessary complexity and less readable code.