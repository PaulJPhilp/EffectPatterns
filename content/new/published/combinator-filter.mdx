---
title: "Filtering Results with filter"
id: "combinator-filter"
skillLevel: "beginner"
useCase: ["Combinators", "Composition", "Conditional Logic"]
summary: "Use filter to keep or discard results based on a predicate, across Effect, Stream, Option, and Either."
tags: ["filter", "combinator", "predicate", "effect", "stream", "option", "either"]
rule:
  description: "Use filter to declaratively express conditional logic, keeping only values that satisfy a predicate."
related: ["combinator-map", "combinator-flatmap", "combinator-conditional"]
author: "PaulJPhilp"
---

# Filtering Results with `filter`

## Guideline

Use the `filter` combinator to keep only those values that satisfy a predicate.  
This works for `Effect`, `Stream`, `Option`, and `Either`, allowing you to express conditional logic declaratively and safely.

## Rationale

`filter` lets you express "only continue if..." logic without resorting to manual checks or imperative branching.  
It keeps your code composable and type-safe, and ensures that failures or empty results are handled consistently.

## Good Example

```typescript
import { Effect, Stream, Option, Either } from "effect";

const effect = Effect.succeed(4).pipe(
  Effect.flatMap((n) =>
    n % 2 === 0 ? Effect.succeed(n) : Effect.fail("Filtered out (fail)")
  )
);

const option = Option.some(4).pipe(Option.filter((n) => n % 2 === 0));

const either = Either.right(4).pipe(
  Either.flatMap((n) =>
    n % 2 === 0 ? Either.right(n) : Either.left("filtered out")
  )
);

const stream = Stream.fromIterable([1, 2, 3, 4]).pipe(
  Stream.filter((n) => n % 2 === 0)
);

const program = Effect.gen(function* () {
  const effectResult = yield* Effect.either(effect);
  yield* Effect.log(
    `Effect.filter result: ${
      effectResult._tag === "Right" ? effectResult.right : effectResult.left
    }`
  );
  yield* Effect.log(
    `Option.filter result: ${
      Option.isSome(option) ? option.value : "Filtered out (none)"
    }`
  );
  yield* Effect.log(
    `Either.filter result: ${
      Either.isRight(either) ? either.right : "Filtered out (left)"
    }`
  );
  const streamValues: number[] = [];
  yield* Stream.runForEach(stream, (n) =>
    Effect.sync(() => streamValues.push(n))
  );
  yield* Effect.log(`Stream.filter result: [${streamValues.join(", ")}]`);
});

Effect.runPromise(program);

```

**Explanation:**  
`filter` applies a predicate to the value(s) inside the structure. If the predicate fails, the result is a failure (`Effect.fail`, `Either.left`), `Option.none`, or an empty stream.

## Anti-Pattern

Using `map` with a conditional that returns `Option` or `Either`, then manually flattening, instead of using `filter`.  
This leads to unnecessary complexity and less readable code.