---
title: "Transform Effect Values with map and flatMap"
id: "transform-effect-values"
skillLevel: "beginner"
useCase: ["Core Concepts"]
summary: "Use Effect.map for synchronous transformations and Effect.flatMap to chain operations that return another Effect."
tags: ["map", "flatMap", "composition", "transformation", "chaining"]
rule:
  description: "Transform Effect values with map and flatMap."
related: ["effects-are-lazy", "write-sequential-code-with-gen"]
author: "Paul Philp"
---

# Transform Effect Values with map and flatMap

## Guideline

To work with the success value of an `Effect`, use `Effect.map` for simple,
synchronous transformations and `Effect.flatMap` for effectful transformations.

## Rationale

`Effect.map` is like `Array.prototype.map`. `Effect.flatMap` is like
`Promise.prototype.then` and is used when your transformation function itself
returns an `Effect`.

## Good Example

```typescript
import { Effect } from "effect";

const getUser = (id: number): Effect.Effect<{ id: number; name: string }> =>
  Effect.succeed({ id, name: "Paul" });

const getPosts = (userId: number): Effect.Effect<{ title: string }[]> =>
  Effect.succeed([{ title: "My First Post" }]);

const userPosts = getUser(123).pipe(
  Effect.flatMap((user) => getPosts(user.id)),
);
```

**Explanation:**  
Use `flatMap` to chain effects that depend on each other, and `map` for
simple value transformations.

## Anti-Pattern

Using `map` when you should be using `flatMap`. This results in a nested
`Effect<Effect<...>>`, which is usually not what you want.
