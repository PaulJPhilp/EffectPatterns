---
title: Manage Shared State Safely with Ref
id: data-ref
skillLevel: intermediate
provider: google
model: gemini-2.5-flash
useCase:
  - Data Types
  - State
  - Concurrency
  - Mutable State
summary: Use Ref<A> to model shared, mutable state in a concurrent environment,
  ensuring all updates are atomic and free of race conditions.
tags:
  - Ref
  - state
  - concurrency
  - mutable
  - data-type
  - effect
rule:
  description: Use Ref to safely manage shared, mutable state in concurrent and
    effectful programs.
related:
  - data-chunk
  - data-hashset
author: PaulJPhilp
expectedOutput: 'timestamp=2025-08-07T18:29:29.704Z level=INFO fiber=#0
  message="Counter value: 1"'
---

# Manage Shared State Safely with `Ref`

## Guideline

Use the `Ref<A>` data type to model shared, mutable state in a concurrent environment.  
`Ref` provides atomic, thread-safe operations for reading and updating state in effectful programs.

## Rationale

Managing shared state with plain variables or objects is unsafe in concurrent or asynchronous code.  
`Ref` ensures all updates are atomic and free of race conditions, making your code robust and predictable.

## Good Example

```typescript
import { Effect, Ref } from "effect";

const program = Effect.gen(function* () {
  const counter = yield* Ref.make(0);
  yield* Ref.update(counter, (n) => n + 1);
  const value = yield* Ref.get(counter);
  yield* Effect.log(`Counter value: ${value}`);
});

Effect.runPromise(
  program.pipe(Effect.catchAll(() => Effect.succeed(undefined)))
);

```

**Explanation:**  
- `Ref` is an atomic, mutable reference for effectful and concurrent code.
- All operations are safe, composable, and free of race conditions.
- Use `Ref` for counters, caches, or any shared mutable state.

## Anti-Pattern

Using plain variables or objects for shared state in concurrent or async code, which can lead to race conditions, bugs, and unpredictable behavior.