---
title: Model Optional Values Safely with Option
id: data-option
skillLevel: beginner
provider: google
model: gemini-2.5-flash
useCase:
  - Data Types
  - Domain Modeling
  - Optional Values
summary: Use Option<A> to explicitly represent a value that may or may not
  exist, eliminating null and undefined errors.
tags:
  - Option
  - optional
  - data-type
  - domain
  - effect
rule:
  description: Use Option to model values that may be present or absent, making
    absence explicit and type-safe.
related:
  - data-either
  - data-struct
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.385Z level=INFO fiber=#0
  message="Option.some(42) match: Value: 42"

  timestamp=2025-08-07T18:29:29.386Z level=INFO fiber=#0 message="Option.none()
  match: No value"

  timestamp=2025-08-07T18:29:29.386Z level=INFO fiber=#0
  message="Option.fromNullable result: Value: hello"

  timestamp=2025-08-07T18:29:29.386Z level=INFO fiber=#0 message="findUser(1):
  User: Alice"

  timestamp=2025-08-07T18:29:29.386Z level=INFO fiber=#0 message="findUser(2):
  User not found"
---

# Model Optional Values Safely with `Option`

## Guideline

Use the `Option.Option<A>` data type to represent values that may or may not exist.  
This eliminates the need for `null` or `undefined`, making absence explicit and type-safe.

## Rationale

`Option` makes it impossible to forget to handle the "no value" case.  
It improves code safety, readability, and composability, and is a foundation for robust domain modeling.

## Good Example

```typescript
import { Option, Effect } from "effect";

const someValue = Option.some(42);
const noValue = Option.none();
const fromNullable = Option.fromNullable(Math.random() > 0.5 ? "hello" : null);

const result = someValue.pipe(
  Option.match({
    onNone: () => "No value",
    onSome: (n) => `Value: ${n}`,
  })
);

function findUser(id: number): Option.Option<{ id: number; name: string }> {
  return id === 1 ? Option.some({ id, name: "Alice" }) : Option.none();
}

const program = Effect.gen(function* () {
  yield* Effect.log(`Option.some(42) match: ${result}`);
  yield* Effect.log(
    `Option.none() match: ${noValue.pipe(
      Option.match({ onNone: () => "No value", onSome: (n) => `Value: ${n}` })
    )}`
  );
  yield* Effect.log(
    `Option.fromNullable result: ${fromNullable.pipe(
      Option.match({ onNone: () => "No value", onSome: (v) => `Value: ${v}` })
    )}`
  );
  const user = findUser(1);
  yield* Effect.log(
    `findUser(1): ${user.pipe(
      Option.match({
        onNone: () => "User not found",
        onSome: (u) => `User: ${u.name}`,
      })
    )}`
  );
  const user2 = findUser(2);
  yield* Effect.log(
    `findUser(2): ${user2.pipe(
      Option.match({
        onNone: () => "User not found",
        onSome: (u) => `User: ${u.name}`,
      })
    )}`
  );
});

Effect.runPromise(program);

```

**Explanation:**  
- Use `Option.Option<A>` for type annotations.
- `Option.some(value)` represents a present value.
- `Option.none()` represents absence.
- `Option.fromNullable` safely lifts nullable values into Option.
- Pattern matching ensures all cases are handled.

## Anti-Pattern

Using `null` or `undefined` to represent absence, or forgetting to handle the "no value" case, which leads to runtime errors and less maintainable code.