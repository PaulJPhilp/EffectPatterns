---
title: Work with Arbitrary-Precision Integers using bigint
id: data-bigint
skillLevel: beginner
provider: google
model: gemini-2.5-flash
useCase:
  - Data Types
  - Numeric Precision
  - Large Numbers
summary: Use bigint for safe, arbitrary-precision integer arithmetic in
  TypeScript, especially for domains like cryptography, counters, or large IDs.
tags:
  - bigint
  - numeric
  - precision
  - integer
  - data-type
  - effect
rule:
  description: Use bigint to represent and compute with integers that exceed the
    safe range of JavaScript's number type.
related:
  - data-bigdecimal
  - data-tuple
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.638Z level=INFO fiber=#0 message="a:
  9007199254740991"

  timestamp=2025-08-07T18:29:29.648Z level=INFO fiber=#0 message="b:
  123456789012345678901234567890"

  timestamp=2025-08-07T18:29:29.648Z level=INFO fiber=#0 message="sum:
  123456789012354686100489308881"

  timestamp=2025-08-07T18:29:29.648Z level=INFO fiber=#0 message="product:
  1111999897984715765336370576532525057755378990"
---

# Work with Arbitrary-Precision Integers using `bigint`

## Guideline

Use the built-in `bigint` type for integers that may exceed the safe range of JavaScript's `number` type (`Number.MAX_SAFE_INTEGER`).  
This is especially important for domains like cryptography, distributed systems, or any application dealing with very large integer values.

## Rationale

JavaScript's `number` type cannot safely represent integers larger than 2^53 - 1.  
`bigint` provides true arbitrary-precision integer arithmetic, ensuring correctness for large values.

## Good Example

```typescript
import { Effect } from "effect";

const a: bigint = 9007199254740991n; // Number.MAX_SAFE_INTEGER
const b: bigint = 123456789012345678901234567890n;

const sum = a + b;
const product = a * b;

const program = Effect.gen(function* () {
  yield* Effect.log(`a: ${a}`);
  yield* Effect.log(`b: ${b}`);
  yield* Effect.log(`sum: ${sum}`);
  yield* Effect.log(`product: ${product}`);
});

Effect.runPromise(
  program.pipe(Effect.catchAll(() => Effect.succeed(undefined)))
);

```

**Explanation:**  
- Use the `n` suffix to create `bigint` literals.
- All standard arithmetic operators work with `bigint`.
- Use `bigint` for IDs, counters, or calculations where precision and range are critical.

## Anti-Pattern

Using JavaScript's native `number` type for large integers, which can lead to precision loss and subtle bugs. 