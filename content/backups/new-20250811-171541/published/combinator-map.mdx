---
title: Transforming Values with map
id: combinator-map
skillLevel: beginner
provider: google
model: gemini-2.5-flash
useCase:
  - Combinators
  - Composition
summary: Use map to transform the result of an Effect, Stream, Option, or Either
  in a declarative, type-safe way.
tags:
  - map
  - combinator
  - functor
  - effect
  - stream
  - option
  - either
rule:
  description: Use map to apply a pure function to the value inside an Effect,
    Stream, Option, or Either.
related:
  - combinator-flatmap
  - combinator-filter
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.562Z level=INFO fiber=#0 message="Effect.map
  result: 20"

  timestamp=2025-08-07T18:29:29.565Z level=INFO fiber=#0 message="Option.map
  result: 20"

  timestamp=2025-08-07T18:29:29.565Z level=INFO fiber=#0 message="Either.map
  result: 20"

  timestamp=2025-08-07T18:29:29.633Z level=INFO fiber=#0 message="Stream.map
  result: [10, 20, 30]"
---

# Transforming Values with `map`

## Guideline

Use the `map` combinator to apply a pure function to the value inside an `Effect`, `Stream`, `Option`, or `Either`.  
This lets you transform results without changing the structure or error-handling behavior of the original type.

## Rationale

`map` is the most fundamental combinator in functional programming.  
It allows you to focus on *what* you want to do with a value, not *how* to extract it.  
The same mental model applies across all major Effect types.

## Good Example

```typescript
import { Effect, Stream, Option, Either } from "effect";

const effect = Effect.succeed(2).pipe(Effect.map((n) => n * 10));

const option = Option.some(2).pipe(Option.map((n) => n * 10));

const either = Either.right(2).pipe(Either.map((n) => n * 10));

const stream = Stream.fromIterable([1, 2, 3]).pipe(Stream.map((n) => n * 10));

const program = Effect.gen(function* () {
  const effectResult = yield* effect;
  yield* Effect.log(`Effect.map result: ${effectResult}`);
  yield* Effect.log(
    `Option.map result: ${Option.isSome(option) ? option.value : "None"}`
  );
  yield* Effect.log(
    `Either.map result: ${Either.isRight(either) ? either.right : either.left}`
  );
  const streamValues: number[] = [];
  yield* Stream.runForEach(stream, (n) =>
    Effect.sync(() => streamValues.push(n))
  );
  yield* Effect.log(`Stream.map result: [${streamValues.join(", ")}]`);
});

Effect.runPromise(program);

```

**Explanation:**  
No matter which type you use, `map` lets you apply a function to the value inside, without changing the error or context.

## Anti-Pattern

Manually extracting the value (e.g., with `.getOrElse`, `.unsafeRunSync`, or similar) just to transform it, then re-wrapping it.  
This breaks composability and loses the benefits of type safety and error handling.