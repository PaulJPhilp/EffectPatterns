---
title: Conditional Branching with if, when, and cond
id: combinator-conditional
skillLevel: beginner
provider: google
model: gemini-2.5-flash
useCase:
  - Combinators
  - Composition
  - Conditional Logic
summary: Use combinators like if, when, and cond to express conditional logic
  declaratively across Effect, Stream, Option, and Either.
tags:
  - conditional
  - if
  - when
  - cond
  - combinator
  - effect
  - stream
  - option
  - either
rule:
  description: Use combinators such as if, when, and cond to branch computations
    based on runtime conditions, without imperative if statements.
related:
  - combinator-filter
  - combinator-map
  - combinator-flatmap
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.171Z level=INFO fiber=#0 message="Effect.if
  result: yes"

  timestamp=2025-08-07T18:29:29.172Z level=INFO fiber=#0 message="Option result:
  yes"

  timestamp=2025-08-07T18:29:29.172Z level=INFO fiber=#0 message="Either result:
  yes"

  timestamp=2025-08-07T18:29:29.413Z level=INFO fiber=#0 message="Stream result:
  []"
---

# Conditional Branching with `if`, `when`, and `cond`

## Guideline

Use combinators like `Effect.if`, `Effect.when`, and `Effect.cond` to express conditional logic in a declarative, composable way for effects.  
For `Option` and `Either`, use standard conditional expressions to construct values.

## Rationale

Declarative branching keeps your code composable, testable, and easy to reason about.  
It also ensures that error handling and context propagation are preserved, and that your code remains consistent across different Effect types.

## Good Example

```typescript
import { Effect, Stream, Option, Either } from "effect";

const effect = Effect.if(true, {
  onTrue: () => Effect.succeed("yes"),
  onFalse: () => Effect.succeed("no"),
});

const option = true ? Option.some("yes") : Option.none();

const either = true ? Either.right("yes") : Either.left("error");

const stream: Stream.Stream<number> = false
  ? Stream.fromIterable([1, 2])
  : Stream.empty;

const program = Effect.gen(function* () {
  const result = yield* effect;
  yield* Effect.log(`Effect.if result: ${result}`);
  yield* Effect.log(
    `Option result: ${Option.isSome(option) ? option.value : "None"}`
  );
  yield* Effect.log(
    `Either result: ${Either.isRight(either) ? either.right : either.left}`
  );
  const streamValues: number[] = [];
  yield* Stream.runForEach(stream, (n) =>
    Effect.sync(() => streamValues.push(n))
  );
  yield* Effect.log(`Stream result: [${streamValues.join(", ")}]`);
});

Effect.runPromise(program);

```

**Explanation:**  
Use `Effect.if` to branch effectful computations.  
For `Option` and `Either`, use ternary or if/else to construct the value.  
This keeps your code composable and type-safe.

## Anti-Pattern

Using imperative `if` statements to branch inside effectful computations (instead of using `Effect.if` or `Effect.when`) breaks composability and makes error/context handling less predictable.

For `Option` and `Either`, conditional expressions (ternary or if/else) are idiomatic and not an anti-pattern.