---
title: Work with Immutable Sets using HashSet
id: data-hashset
skillLevel: beginner
provider: google
model: gemini-2.5-flashmediate
useCase:
  - Data Types
  - Collections
  - Set Operations
summary: Use HashSet<A> to model immutable, high-performance sets for efficient
  membership checks and set operations.
tags:
  - HashSet
  - set
  - collection
  - immutable
  - data-type
  - effect
rule:
  description: Use HashSet to represent sets of unique values with efficient,
    immutable operations for membership, union, intersection, and difference.
related:
  - data-chunk
  - data-array
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.223Z level=INFO fiber=#0 message="setA: [1, 2,
  3]"

  timestamp=2025-08-07T18:29:29.300Z level=INFO fiber=#0 message="setB: [3, 4,
  5]"

  timestamp=2025-08-07T18:29:29.359Z level=INFO fiber=#0 message="setA has 2:
  true"

  timestamp=2025-08-07T18:29:29.360Z level=INFO fiber=#0 message="union: [1, 2,
  3, 4, 5]"

  timestamp=2025-08-07T18:29:29.360Z level=INFO fiber=#0 message="intersection:
  [3]"

  timestamp=2025-08-07T18:29:29.360Z level=INFO fiber=#0 message="difference
  (setA - setB): [1, 2]"

  timestamp=2025-08-07T18:29:29.360Z level=INFO fiber=#0 message="withSix: [1,
  2, 3, 6]"

  timestamp=2025-08-07T18:29:29.360Z level=INFO fiber=#0 message="withoutOne:
  [2, 3]"
---

# Work with Immutable Sets using `HashSet`

## Guideline

Use the `HashSet<A>` data type to represent sets of unique values with efficient, immutable operations.  
`HashSet` is ideal for membership checks, set algebra, and modeling collections where uniqueness matters.

## Rationale

`HashSet` provides high-performance, immutable set operations that are safe for concurrent and functional programming.  
It avoids the pitfalls of mutable JavaScript `Set` and is optimized for use in Effect workflows.

## Good Example

```typescript
import { HashSet, Effect } from "effect";

const setA = HashSet.fromIterable([1, 2, 3]);
const setB = HashSet.fromIterable([3, 4, 5]);
const hasTwo = HashSet.has(setA, 2);
const union = HashSet.union(setA, setB);
const intersection = HashSet.intersection(setA, setB);
const difference = HashSet.difference(setA, setB);
const withSix = HashSet.add(setA, 6);
const withoutOne = HashSet.remove(setA, 1);

const program = Effect.gen(function* () {
  yield* Effect.log(`setA: [${Array.from(setA).join(", ")}]`);
  yield* Effect.log(`setB: [${Array.from(setB).join(", ")}]`);
  yield* Effect.log(`setA has 2: ${hasTwo}`);
  yield* Effect.log(`union: [${Array.from(union).join(", ")}]`);
  yield* Effect.log(`intersection: [${Array.from(intersection).join(", ")}]`);
  yield* Effect.log(
    `difference (setA - setB): [${Array.from(difference).join(", ")}]`
  );
  yield* Effect.log(`withSix: [${Array.from(withSix).join(", ")}]`);
  yield* Effect.log(`withoutOne: [${Array.from(withoutOne).join(", ")}]`);
});

Effect.runPromise(program);

```

**Explanation:**  
- `HashSet` is immutable and supports efficient set operations.
- Use it for membership checks, set algebra, and modeling unique collections.
- Safe for concurrent and functional workflows.

## Anti-Pattern

Using mutable JavaScript `Set` for shared or concurrent data, or for set operations in functional code, which can lead to bugs and unpredictable behavior.