---
title: Add Custom Metrics to Your Application
id: observability-custom-metrics
skillLevel: intermediate
useCase:
  - Observability
  - Metrics
  - Monitoring
  - Performance
summary: Use Effect's Metric module to instrument your code with counters,
  gauges, and histograms to track key business and performance indicators.
tags:
  - metrics
  - observability
  - monitoring
  - performance
  - effect
rule:
  description: Use Effect's Metric module to define and update custom metrics for
    business and performance monitoring.
related:
  - observability-structured-logging
  - observability-tracing-spans
author: PaulJPhilp
provider: google
model: gemini-2.5-flash
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.446Z level=INFO fiber=#0 message="Job processed"

  timestamp=2025-08-07T18:29:29.447Z level=INFO fiber=#0 message="User signed
  in"

  timestamp=2025-08-07T18:29:29.447Z level=INFO fiber=#0 message="User signed
  out"

  timestamp=2025-08-07T18:29:29.447Z level=INFO fiber=#0 message="Recorded
  request duration: 0.7s"
---

# Add Custom Metrics to Your Application

## Guideline

Use Effect's `Metric` module to define and update custom metrics such as counters, gauges, and histograms.  
This allows you to track business events, performance indicators, and system health in a type-safe and composable way.

## Rationale

Metrics provide quantitative insight into your application's behavior and performance.  
By instrumenting your code with metrics, you can monitor key events, detect anomalies, and drive business decisions.

## Good Example

```typescript
import { Effect, Metric, MetricBoundaries } from "effect";

const jobsProcessed = Metric.counter("jobs_processed");
const processJob = Effect.gen(function* () {
  yield* Effect.log("Job processed");
  yield* Metric.increment(jobsProcessed);
});

const activeUsers = Metric.gauge("active_users");
const userSignedIn = Metric.set(activeUsers, 1);
const userSignedOut = Metric.set(activeUsers, 0);

const requestDuration = Metric.histogram(
  "request_duration",
  MetricBoundaries.linear({ start: 0, width: 0.5, count: 11 }),
  "Request duration in seconds"
);
const recordDuration = (duration: number) =>
  Metric.update(requestDuration, duration);

const program = Effect.gen(function* () {
  yield* processJob;
  yield* userSignedIn;
  yield* Effect.log("User signed in");
  yield* userSignedOut;
  yield* Effect.log("User signed out");
  yield* recordDuration(0.7);
  yield* Effect.log("Recorded request duration: 0.7s");
});

Effect.runPromise(program);

```

**Explanation:**  
- `Metric.counter` tracks counts of events.
- `Metric.gauge` tracks a value that can go up or down (e.g., active users).
- `Metric.histogram` tracks distributions (e.g., request durations).
- `Effect.updateMetric` updates the metric in your workflow.

## Anti-Pattern

Relying solely on logs for monitoring, or using ad-hoc counters and variables that are not integrated with your observability stack.