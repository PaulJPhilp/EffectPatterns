---
title: Matching on Success and Failure with match
id: pattern-match
skillLevel: beginner
useCase:
  - Pattern Matching
  - Error Handling
  - Branching
summary: Use match to handle both success and failure cases in a single,
  declarative place for Effect, Option, and Either.
tags:
  - match
  - pattern-matching
  - effect
  - option
  - either
  - error-handling
  - branching
rule:
  description: Use match to pattern match on the result of an Effect, Option, or
    Either, handling both success and failure cases declaratively.
related:
  - pattern-matchtag
  - pattern-matcheffect
  - pattern-option-either-match
author: PaulJPhilp
provider: google
model: gemini-2.5-flash
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.359Z level=INFO fiber=#0 message="Effect.match
  result: Error: Oops!"

  timestamp=2025-08-07T18:29:29.420Z level=INFO fiber=#0 message="Option.match
  result: Value: 42"

  timestamp=2025-08-07T18:29:29.420Z level=INFO fiber=#0 message="Either.match
  result: Error: fail"
---

# Matching on Success and Failure with `match`

## Guideline

Use the `match` combinator to handle both success and failure cases in a single, declarative place.  
This works for `Effect`, `Option`, and `Either`, and is the foundation for robust, readable error handling and branching.

## Rationale

Pattern matching with `match` keeps your code clear and type-safe, ensuring you handle all possible outcomes.  
It avoids scattered if/else or switch statements and makes your intent explicit.

## Good Example

```typescript
import { Effect, Option, Either } from "effect";

const effect = Effect.fail("Oops!").pipe(
  Effect.match({
    onFailure: (err) => `Error: ${err}`,
    onSuccess: (value) => `Success: ${value}`,
  })
);

const option = Option.some(42).pipe(
  Option.match({
    onNone: () => "No value",
    onSome: (n) => `Value: ${n}`,
  })
);

const either = Either.left("fail").pipe(
  Either.match({
    onLeft: (err) => `Error: ${err}`,
    onRight: (value) => `Value: ${value}`,
  })
);

const program = Effect.gen(function* () {
  const effectResult = yield* effect;
  yield* Effect.log(`Effect.match result: ${effectResult}`);
  yield* Effect.log(`Option.match result: ${option}`);
  yield* Effect.log(`Either.match result: ${either}`);
});

Effect.runPromise(program);

```

**Explanation:**  
- `Effect.match` lets you handle both the error and success channels in one place.
- `Option.match` and `Either.match` let you handle all possible cases for these types, making your code exhaustive and safe.

## Anti-Pattern

Using nested if/else or switch statements to check for success/failure, or ignoring possible error/none/left cases, which leads to brittle and less readable code.