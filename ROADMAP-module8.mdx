# Module 8: Branded Types

Branded types let you create domain-specific types that are more precise than primitives like `string` or `number`.  
They help you make illegal states unrepresentable, add validation at the type level, and prevent accidental misuse of values that happen to have the same underlying type.

This module will teach you how to define, validate, and use branded types in the Effect ecosystem for safer, more expressive code.

---

## Branded Types Quick Reference

| Tool / Pattern         | Purpose / Mental Model                                 | Pattern Link                                 |
|------------------------|-------------------------------------------------------|----------------------------------------------|
| `Brand`                | Create a domain-specific type from a primitive         | [Modeling Validated Domain Types with Brand](./patterns/brand-model-domain-type) |
| `Schema` + `Brand`     | Validate and parse branded types at runtime            | [Validating and Parsing Branded Types](./patterns/brand-validate-parse) |

---

## Learning Path

1.  #### [Modeling Validated Domain Types with Brand](./patterns/brand-model-domain-type)
    **Goal**: Learn how to create a branded type (e.g., `Email`, `UserId`) from a primitive and use it for type safety.

2.  #### [Validating and Parsing Branded Types](./patterns/brand-validate-parse)
    **Goal**: Use `Schema` and `Brand` together to validate and parse branded types at runtime, ensuring only valid values are constructed.

---

**By the end of this module, youâ€™ll be able to:**
- Define domain-specific types that prevent accidental misuse.
- Validate and parse branded types at runtime for robust, type-safe applications.

---

Ready to get started? Begin with [Modeling Validated Domain Types with Brand](./patterns/brand-model-domain-type).