---
title: Mapping and Chaining over Collections with forEach and all
id: combinator-foreach-all
skillLevel: intermediate
provider: google
model: gemini-2.5-flash
useCase:
  - Combinators
  - Collections
  - Parallelism
  - Batch Processing
summary: Use forEach and all to apply effectful functions to collections and
  combine the results, enabling batch and parallel processing.
tags:
  - forEach
  - all
  - collections
  - parallelism
  - batch
  - combinator
  - effect
  - stream
  - option
  - either
rule:
  description: Use forEach and all to process collections of values with effectful
    functions, collecting results in a type-safe and composable way.
related:
  - combinator-map
  - combinator-flatmap
  - combinator-all-race
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.716Z level=INFO fiber=#0 message="Effect.forEach
  result: [2, 4, 6]"

  timestamp=2025-08-07T18:29:29.717Z level=INFO fiber=#0 message="Effect.all
  result: [1, 2]"

  timestamp=2025-08-07T18:29:29.717Z level=INFO fiber=#0 message="Option
  collection result: [1, 3]"

  timestamp=2025-08-07T18:29:29.717Z level=INFO fiber=#0 message="Either
  collection result: [1, 3]"

  timestamp=2025-08-07T18:29:29.725Z level=INFO fiber=#0 message="Stream.flatMap
  result: [1, 2, 3, 4]"
---

# Mapping and Chaining over Collections with `forEach` and `all`

## Guideline

Use the `forEach` and `all` combinators to apply an effectful function to every item in a collection and combine the results.  
This enables you to process lists, arrays, or other collections in a type-safe, composable, and often parallel way.

## Rationale

Batch and parallel processing are common in real-world applications.  
These combinators let you express "do this for every item" declaratively, without manual loops or imperative control flow, and they preserve error handling and context propagation.

## Good Example

```typescript
import { Effect, Stream, Option, Either } from "effect";

const numbers = [1, 2, 3];
const effect = Effect.forEach(numbers, (n) => Effect.succeed(n * 2));

const effects = [Effect.succeed(1), Effect.succeed(2)];
const allEffect = Effect.all(effects);

const options = [Option.some(1), Option.none(), Option.some(3)];
const filtered = options.filter(Option.isSome).map((o) => o.value);

const eithers = [Either.right(1), Either.left("fail"), Either.right(3)];
const rights = eithers
  .map(Either.getRight)
  .filter((o) => o._tag === "Some")
  .map((o) => o.value);

const stream = Stream.fromIterable([
  [1, 2],
  [3, 4],
]).pipe(Stream.flatMap((arr) => Stream.fromIterable(arr)));

const program = Effect.gen(function* () {
  const effectResult = yield* effect;
  yield* Effect.log(`Effect.forEach result: [${effectResult.join(", ")}]`);
  const allResult = yield* allEffect;
  yield* Effect.log(`Effect.all result: [${allResult.join(", ")}]`);
  yield* Effect.log(`Option collection result: [${filtered.join(", ")}]`);
  yield* Effect.log(`Either collection result: [${rights.join(", ")}]`);
  const streamValues: number[] = [];
  yield* Stream.runForEach(stream, (n) =>
    Effect.sync(() => streamValues.push(n))
  );
  yield* Effect.log(`Stream.flatMap result: [${streamValues.join(", ")}]`);
});

Effect.runPromise(program);

```

**Explanation:**  
`forEach` and `all` let you process collections in a way that is composable, type-safe, and often parallel.  
When working with arrays of `Either`, use `Either.getRight` to extract right values, then filter for `Option.isSome` and map to `.value`.  
They handle errors and context automatically, and can be used for batch jobs, parallel requests, or data transformations.

## Anti-Pattern

Using manual loops (`for`, `forEach`, etc.) with side effects, or collecting results imperatively, which breaks composability and loses error/context handling.