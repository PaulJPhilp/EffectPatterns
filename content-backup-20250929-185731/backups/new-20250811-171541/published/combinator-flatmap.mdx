---
title: Chaining Computations with flatMap
id: combinator-flatmap
skillLevel: beginner
provider: google
model: gemini-2.5-flash
useCase:
  - Combinators
  - Composition
  - Sequencing
summary: Use flatMap to chain together computations where each step may itself
  be effectful, optional, or error-prone.
tags:
  - flatMap
  - combinator
  - monad
  - effect
  - stream
  - option
  - either
rule:
  description: Use flatMap to sequence computations, flattening nested structures
    and preserving error and context handling.
related:
  - combinator-map
  - combinator-gen
  - combinator-foreach-all
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.389Z level=INFO fiber=#0 message="Effect.flatMap
  result: 20"

  timestamp=2025-08-07T18:29:29.389Z level=INFO fiber=#0 message="Option.flatMap
  result: 20"

  timestamp=2025-08-07T18:29:29.390Z level=INFO fiber=#0 message="Either.flatMap
  result: 20"

  timestamp=2025-08-07T18:29:29.412Z level=INFO fiber=#0 message="Stream.flatMap
  result: [1, 10, 2, 20]"
---

# Chaining Computations with `flatMap`

## Guideline

Use the `flatMap` combinator to chain together computations where each step may itself return an `Effect`, `Stream`, `Option`, or `Either`.  
`flatMap` ensures that the result is always "flattened"—you never get nested types.

## Rationale

`flatMap` is the key to sequencing dependent steps in functional programming.  
It allows you to express workflows where each step may fail, be optional, or produce multiple results, and ensures that errors and context are handled automatically.

## Good Example

```typescript
import { Effect, Stream, Option, Either } from "effect";

const effect = Effect.succeed(2).pipe(
  Effect.flatMap((n) => Effect.succeed(n * 10))
);

const option = Option.some(2).pipe(Option.flatMap((n) => Option.some(n * 10)));

const either = Either.right(2).pipe(
  Either.flatMap((n) => Either.right(n * 10))
);

const stream = Stream.fromIterable([1, 2]).pipe(
  Stream.flatMap((n) => Stream.fromIterable([n, n * 10]))
);

const program = Effect.gen(function* () {
  const effectResult = yield* effect;
  yield* Effect.log(`Effect.flatMap result: ${effectResult}`);
  yield* Effect.log(
    `Option.flatMap result: ${Option.isSome(option) ? option.value : "None"}`
  );
  yield* Effect.log(
    `Either.flatMap result: ${
      Either.isRight(either) ? either.right : either.left
    }`
  );
  const streamValues: number[] = [];
  yield* Stream.runForEach(stream, (n) =>
    Effect.sync(() => streamValues.push(n))
  );
  yield* Effect.log(`Stream.flatMap result: [${streamValues.join(", ")}]`);
});

Effect.runPromise(program);

```

**Explanation:**  
`flatMap` lets you build pipelines where each step can depend on the result of the previous one, and the structure is always flattened—no `Option<Option<A>>` or `Effect<Effect<A>>`.

## Anti-Pattern

Manually unwrapping the value (e.g., with `.getOrElse`, `.unsafeRunSync`, etc.), then creating a new effect/option/either/stream.  
This breaks composability, loses error/context handling, and leads to deeply nested or unsafe code.