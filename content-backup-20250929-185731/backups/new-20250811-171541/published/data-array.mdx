---
title: Working with Immutable Arrays using Data.array
id: data-array
skillLevel: beginner
provider: google
model: gemini-2.5-flash
useCase:
  - Data Types
  - Arrays
  - Structural Equality
  - Collections
summary: Use Data.array to create immutable, type-safe arrays that support
  value-based equality and safe functional operations.
tags:
  - Data.array
  - array
  - structural-equality
  - immutable
  - data-type
  - effect
rule:
  description: Use Data.array to define arrays whose equality is based on their
    contents, enabling safe, predictable comparisons and functional operations.
related:
  - data-chunk
  - data-struct
  - data-tuple
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.645Z level=INFO fiber=#0 message="arr1: [1, 2,
  3]"

  timestamp=2025-08-07T18:29:29.646Z level=INFO fiber=#0 message="arr2: [1, 2,
  3]"

  timestamp=2025-08-07T18:29:29.646Z level=INFO fiber=#0
  message="Equal.equals(arr1, arr2): true"

  timestamp=2025-08-07T18:29:29.647Z level=INFO fiber=#0
  message="HashSet.has(set, arr2): true"

  timestamp=2025-08-07T18:29:29.647Z level=INFO fiber=#0 message="arr1.map(n =>
  n * 2): [2, 4, 6]"
---

# Working with Immutable Arrays using `Data.array`

## Guideline

Use `Data.array` to create immutable, type-safe arrays that support value-based equality and safe functional operations.  
This is useful for modeling ordered collections where immutability and structural equality are important.

## Rationale

JavaScript arrays are mutable and compared by reference, which can lead to bugs in value-based logic and concurrent code.  
`Data.array` provides immutable arrays with structural equality, making them ideal for functional programming and safe domain modeling.

## Good Example

```typescript
import { Data, Equal, Effect, HashSet } from "effect";

const arr1 = Data.array([1, 2, 3]);
const arr2 = Data.array([1, 2, 3]);

const areEqual = Equal.equals(arr1, arr2); // true

const set = HashSet.make(arr1);
const hasArr2 = HashSet.has(set, arr2); // true

const doubled = arr1.map((n) => n * 2); // Data.array([2, 4, 6])

const program = Effect.gen(function* () {
  yield* Effect.log(`arr1: [${arr1.join(", ")}]`);
  yield* Effect.log(`arr2: [${arr2.join(", ")}]`);
  yield* Effect.log(`Equal.equals(arr1, arr2): ${areEqual}`);
  yield* Effect.log(`HashSet.has(set, arr2): ${hasArr2}`);
  yield* Effect.log(`arr1.map(n => n * 2): [${doubled.join(", ")}]`);
});

Effect.runPromise(
  program.pipe(Effect.catchAll(() => Effect.succeed(undefined)))
);

```

**Explanation:**  
- `Data.array` creates immutable arrays with value-based equality.
- Useful for modeling ordered collections in a safe, functional way.
- Supports all standard array operations, but with immutability and structural equality.
- If you encounter generator/yield type errors in TypeScript, add an explicit type annotation to the generator function (e.g., `Effect.Effect<never, void, never>`) for clarity and compatibility.

## Anti-Pattern

Using plain JavaScript arrays for value-based logic, as keys in sets/maps, or in concurrent code, which can lead to bugs due to mutability and reference-based comparison.