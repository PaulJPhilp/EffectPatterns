---
title: Combining Values with zip
id: combinator-zip
skillLevel: beginner
provider: google
model: gemini-2.5-flash
useCase:
  - Combinators
  - Composition
  - Pairing
summary: Use zip to combine two computations, pairing their results together in
  Effect, Stream, Option, or Either.
tags:
  - zip
  - combinator
  - pair
  - effect
  - stream
  - option
  - either
rule:
  description: Use zip to run two computations and combine their results into a
    tuple, preserving error and context handling.
related:
  - combinator-map
  - combinator-flatmap
  - combinator-all-race
author: PaulJPhilp
expectedOutput: >-
  timestamp=2025-08-07T18:29:29.434Z level=INFO fiber=#0 message="Effect.zip
  result: [1, hello]"

  timestamp=2025-08-07T18:29:29.435Z level=INFO fiber=#0 message="Option.zip
  result: [1, hello]"

  timestamp=2025-08-07T18:29:29.435Z level=INFO fiber=#0 message="Either.zip
  result: [1, hello]"

  timestamp=2025-08-07T18:29:29.464Z level=INFO fiber=#0 message="Stream.zip
  result: [[1, a], [2, b], [3, c]]"
---

# Combining Values with `zip`

## Guideline

Use the `zip` combinator to combine two computations, pairing their results together.  
This works for `Effect` and `Stream`.  
For `Option` and `Either`, use manual pattern matching to combine values if both are present/right.

## Rationale

`zip` lets you compose computations that are independent but whose results you want to use together.  
It preserves error handling and context, and keeps your code declarative and type-safe.

## Good Example

```typescript
import { Effect, Either, Option, Stream } from "effect";

const effectA = Effect.succeed(1);
const effectB = Effect.succeed("hello");
const zippedEffect = effectA.pipe(Effect.zip(effectB));

const optionA = Option.some(1);
const optionB = Option.some("hello");
const zippedOption = Option.zipWith(optionA, optionB, (a, b) => [a, b] as const);

const eitherA = Either.right(1);
const eitherB = Either.right("hello");
const zippedEither = Either.zipWith(eitherA, eitherB, (a, b) => [a, b] as const);

const streamA = Stream.fromIterable([1, 2, 3]);
const streamB = Stream.fromIterable(["a", "b", "c"]);
const zippedStream = streamA.pipe(Stream.zip(streamB));

const program = Effect.gen(function* () {
  const effectResult = yield* zippedEffect;
  yield* Effect.log(
    `Effect.zip result: [${effectResult[0]}, ${effectResult[1]}]`
  );
  yield* Effect.log(
    `Option.zip result: ${Option.isSome(zippedOption)
      ? `[${zippedOption.value[0]}, ${zippedOption.value[1]}]`
      : "None"
    }`
  );
  yield* Effect.log(
    `Either.zip result: ${Either.isRight(zippedEither)
      ? `[${zippedEither.right[0]}, ${zippedEither.right[1]}]`
      : "Left"
    }`
  );
  const streamValues: Array<[number, string]> = [];
  yield* Stream.runForEach(zippedStream, (pair) =>
    Effect.sync(() => streamValues.push(pair))
  );
  yield* Effect.log(
    `Stream.zip result: [${streamValues
      .map(([n, s]) => `[${n}, ${s}]`)
      .join(", ")}]`
  );
});

Effect.runPromise(
  program.pipe(Effect.catchAll(() => Effect.succeed(undefined)))
);

```

**Explanation:**  
`zip` runs both computations and pairs their results for `Effect` and `Stream`.  
For `Option` and `Either`, you can pair values using conditional logic: if both are `Some`/`Right`, return a tuple; otherwise, return `None`/`Left`.
If either computation fails (or is None/Left/empty), the result is a failure (or None/Left/empty).

## Anti-Pattern

Manually running two computations, extracting their results, and pairing them outside the combinator world for `Effect` and `Stream`.  
For `Option` and `Either`, avoid deeply nested conditionalsâ€”prefer concise pattern matching.
This breaks composability, loses error/context handling, and can lead to subtle bugs.