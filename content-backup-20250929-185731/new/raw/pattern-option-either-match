---
title: "Pattern Matching on Option and Either"
id: "pattern-option-either-match"
skillLevel: "beginner"
useCase: ["Pattern Matching", "Option", "Either", "Branching"]
summary: "Use Option.match and Either.match to handle all possible cases of Option and Either in a declarative, type-safe way."
tags: ["Option.match", "Either.match", "pattern-matching", "option", "either", "branching"]
rule:
  description: "Use Option.match and Either.match to exhaustively handle Some/None and Right/Left cases, making your code robust and explicit."
related: ["pattern-match", "pattern-option-either-checks"]
author: "PaulJPhilp"
---

# Pattern Matching on Option and Either

## Guideline

Use the `Option.match` and `Either.match` combinators to handle all possible cases of `Option` and `Either` in a single, declarative place.  
This ensures your code is exhaustive, type-safe, and easy to read.

## Rationale

Pattern matching on `Option` and `Either` makes it clear how your code handles presence/absence and success/failure.  
It avoids manual checks, scattered logic, and makes your intent explicit.

## Good Example

```typescript
import { Option, Either } from "effect";

// Option: Handle Some and None cases
const option = Option.some("hello").pipe(
  Option.match({
    onNone: () => "No value",
    onSome: (value) => `Value: ${value}`,
  })
); // string

// Either: Handle Right and Left cases
const either = Either.left("error").pipe(
  Either.match({
    onLeft: (err) => `Error: ${err}`,
    onRight: (value) => `Value: ${value}`,
  })
); // string
```

**Explanation:**  
- `Option.match` lets you handle both the Some and None cases in one place.
- `Either.match` lets you handle both the Right (success) and Left (failure) cases in one place.
- This makes your code exhaustive and robust.

## Anti-Pattern

Using if/else or manual property checks (e.g., `option._tag === "Some"`) to distinguish cases, which is less readable and more error-prone than using the provided combinators.