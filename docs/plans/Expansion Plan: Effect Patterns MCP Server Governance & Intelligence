# Expansion Plan: Effect Patterns MCP Server Governance & Intelligence

## Overview
This document outlines advanced functional expansions for the Effect Patterns MCP server. These enhancements move the server from a passive retrieval system to an active architectural governance and optimization engine.

---

## 1. Pattern Capture & Learning Loop
**Objective:** Enable the server to evolve by capturing high-quality code adaptations made by AI agents during the development process.

### Functional Requirements:
- **Tool:** `propose_pattern_variant`
- **Logic:** When an agent successfully refactors a complex service or adapts a library pattern to a specific edge case, it should be able to submit that back to the server.
- **Data Flow:**
  - Agent sends the modified code and a description of the "Context" (e.g., "High-concurrency database migration").
  - Server stores this in a "Pending Review" table in the Postgres database.
  - Admin can later promote these variants to the primary library.

---

## 2. Dependency Graph & Layer Orchestration
**Objective:** Simplify the complex task of "wiring" services in the Effect ecosystem by providing automated dependency analysis.

### Functional Requirements:
- **Tool:** `analyze_dependency_graph`
- **Logic:** Analyze a project’s directory to identify all defined `Effect.Service` instances and their dependencies.
- **Capabilities:**
  - Suggest the most efficient `Layer.provide` or `Layer.merge` structure for the application entry point.
  - Identify "Circular Dependencies" or "Dead Layers" (services defined but never provided or used).
- **Benefit:** Reduces manual boilerplate and ensures that the application’s service architecture remains clean as it scales.

---

## 3. Architectural Policy Enforcement (Guardrails)
**Objective:** Ensure all code generated or suggested by the server complies with project-specific security and performance standards.

### Functional Requirements:
- **Tool:** `validate_compliance`
- **Logic:** Check proposed code against a set of "Architectural Policies."
- **Examples of Policies:**
  - "No raw `console.log` calls within Effect blocks; use `Effect.log` instead."
  - "All external API calls must include a defined timeout and retry policy."
  - "Database queries must use the established repository pattern rather than direct client calls."
- **Response:** If code fails validation, the server returns a "Constraint Error" with a suggested fix.

---

## 4. Performance & Rationale Reporting
**Objective:** Provide educational context and performance justifications for why specific patterns are being recommended.

### Functional Requirements:
- **Enhancement to `generate_pattern`:**
  - Every generated pattern should include a `rationale` metadata block.
- **Content:**
  - **Efficiency:** Explain how the pattern manages memory or handles concurrency (e.g., "This uses `Effect.forEach` with a concurrency limit of 5 to prevent downstream API throttling").
  - **Safety:** Highlight the error-handling benefits (e.g., "This pattern ensures that resources are safely released even if the fiber is interrupted").
- **Benefit:** Increases the "Effectiveness" of the AI agent by providing it with the logical reasoning it needs to explain changes to the developer.

---

## 5. Implementation Priorities

### High Priority (Phase 1.5)
- **Dependency Graph Analysis:** This is the most immediate pain point for developers moving from small examples to large-scale monorepos.

### Medium Priority (Phase 2.5)
- **Architectural Policy Enforcement:** Essential for teams and organizations that require strict adherence to internal coding standards.
- **Pattern Capture:** To begin building a self-improving dataset of real-world Effect usage.

### Strategic Priority (Ongoing)
- **Performance Rationale:** Integrating this into the existing code generation tools to provide immediate value and context to the end user.