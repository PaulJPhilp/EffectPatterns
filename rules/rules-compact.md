# Effect-TS Patterns - Compact Rules

- **Access Configuration from the Context**: Access configuration from the Effect context.
- **Accessing the Current Time with Clock**: Use the Clock service to get the current time, enabling deterministic testing with TestClock.
- **Accumulate Multiple Errors with Either**: Use Either to accumulate multiple validation errors instead of failing on the first one.
- **Add Caching by Wrapping a Layer**: Use a wrapping Layer to add cross-cutting concerns like caching to a service without altering its original implementation.
- **Add Custom Metrics to Your Application**: Use Metric.counter, Metric.gauge, and Metric.histogram to instrument code for monitoring.
- **Automatically Retry Failed Operations**: Compose a Stream with the .retry(Schedule) operator to automatically recover from transient failures.
- **Avoid Long Chains of .andThen; Use Generators Instead**: Prefer generators over long chains of .andThen.
- **Beyond the Date Type - Real World Dates, Times, and Timezones**: Use the Clock service for testable time-based logic and immutable primitives for timestamps.
- **Build a Basic HTTP Server**: Use a managed Runtime created from a Layer to handle requests in a Node.js HTTP server.
- **Collect All Results into a List**: Use Stream.runCollect to execute a stream and collect all its emitted values into a Chunk.
- **Comparing Data by Value with Structural Equality**: Use Data.struct or implement the Equal interface for value-based comparison of objects and classes.
- **Compose Resource Lifecycles with `Layer.merge`**: Compose multiple scoped layers using `Layer.merge` or by providing one layer to another.
- **Conditionally Branching Workflows**: Use predicate-based operators like Effect.filter and Effect.if to declaratively control workflow branching.
- **Control Flow with Conditional Combinators**: Use conditional combinators for control flow.
- **Control Repetition with Schedule**: Use Schedule to create composable policies for controlling the repetition and retrying of effects.
- **Create a Basic HTTP Server**: Use Http.server.serve with a platform-specific layer to run an HTTP application.
- **Create a Managed Runtime for Scoped Resources**: Create a managed runtime for scoped resources.
- **Create a Reusable Runtime from Layers**: Create a reusable runtime from layers.
- **Create a Service Layer from a Managed Resource**: Provide a managed resource to the application context using `Layer.scoped`.
- **Create a Stream from a List**: Use Stream.fromIterable to begin a pipeline from an in-memory collection.
- **Create a Testable HTTP Client Service**: Define an HttpClient service with distinct Live and Test layers to enable testable API interactions.
- **Create Pre-resolved Effects with succeed and fail**: Create pre-resolved effects with succeed and fail.
- **Decouple Fibers with Queues and PubSub**: Use Queue for point-to-point work distribution and PubSub for broadcast messaging between fibers.
- **Define a Type-Safe Configuration Schema**: Define a type-safe configuration schema.
- **Define Contracts Upfront with Schema**: Define contracts upfront with schema.
- **Define Type-Safe Errors with Data.TaggedError**: Define type-safe errors with Data.TaggedError.
- **Distinguish 'Not Found' from Errors**: Use Effect<Option<A>> to distinguish between recoverable 'not found' cases and actual failures.
- **Execute Asynchronous Effects with Effect.runPromise**: Execute asynchronous effects with Effect.runPromise.
- **Execute Long-Running Apps with Effect.runFork**: Use Effect.runFork to launch a long-running application as a manageable, detached fiber.
- **Execute Synchronous Effects with Effect.runSync**: Execute synchronous effects with Effect.runSync.
- **Extract Path Parameters**: Define routes with colon-prefixed parameters (e.g., /users/:id) and access their values within the handler.
- **Handle a GET Request**: Use Http.router.get to associate a URL path with a specific response Effect.
- **Handle API Errors**: Model application errors as typed classes and use Http.server.serveOptions to map them to specific HTTP responses.
- **Handle Errors with catchTag, catchTags, and catchAll**: Handle errors with catchTag, catchTags, and catchAll.
- **Handle Flaky Operations with Retries and Timeouts**: Use Effect.retry and Effect.timeout to build resilience against slow or intermittently failing effects.
- **Handle Unexpected Errors by Inspecting the Cause**: Handle unexpected errors by inspecting the cause.
- **Implement Graceful Shutdown for Your Application**: Use Effect.runFork and OS signal listeners to implement graceful shutdown for long-running applications.
- **Leverage Effect's Built-in Structured Logging**: Leverage Effect's built-in structured logging.
- **Make an Outgoing HTTP Client Request**: Use the Http.client module to make outgoing requests to keep the entire operation within the Effect ecosystem.
- **Manage Resource Lifecycles with Scope**: Use Scope for fine-grained, manual control over resource lifecycles and cleanup guarantees.
- **Manage Resources Safely in a Pipeline**: Use Stream.acquireRelease to safely manage the lifecycle of a resource within a pipeline.
- **Manage Shared State Safely with Ref**: Use Ref to manage shared, mutable state concurrently, ensuring atomicity.
- **Manually Manage Lifecycles with `Scope`**: Use `Effect.scope` and `Scope.addFinalizer` for fine-grained control over resource cleanup.
- **Mapping Errors to Fit Your Domain**: Use Effect.mapError to transform errors and create clean architectural boundaries between layers.
- **Mocking Dependencies in Tests**: Provide mock service implementations via a test-specific Layer to isolate the unit under test.
- **Model Dependencies as Services**: Model dependencies as services.
- **Model Optional Values Safely with Option**: Use Option<A> to explicitly model values that may be absent, avoiding null or undefined.
- **Model Validated Domain Types with Brand**: Model validated domain types with Brand.
- **Organize Layers into Composable Modules**: Organize services into modular Layers that are composed hierarchically to manage complexity in large applications.
- **Parse and Validate Data with Schema.decode**: Parse and validate data with Schema.decode.
- **Poll for Status Until a Task Completes**: Use Effect.race to run a repeating polling task that is automatically interrupted when a main task completes.
- **Process a Collection in Parallel with Effect.forEach**: Use Effect.forEach with the `concurrency` option to process a collection in parallel with a fixed limit.
- **Process a Large File with Constant Memory**: Use Stream.fromReadable with a Node.js Readable stream to process files efficiently.
- **Process collections of data asynchronously**: Leverage Stream to process collections effectfully with built-in concurrency control and resource safety.
- **Process Items Concurrently**: Use Stream.mapEffect with the `concurrency` option to process stream items in parallel.
- **Process Items in Batches**: Use Stream.grouped(n) to transform a stream of items into a stream of batched chunks.
- **Process Streaming Data with Stream**: Use Stream to model and process data that arrives over time in a composable, efficient way.
- **Provide Configuration to Your App via a Layer**: Provide configuration to your app via a Layer.
- **Provide Dependencies to Routes**: Define dependencies with Effect.Service and provide them to your HTTP server using a Layer.
- **Race Concurrent Effects for the Fastest Result**: Use Effect.race to get the result from the first of several effects to succeed, automatically interrupting the losers.
- **Representing Time Spans with Duration**: Use the Duration data type to represent time intervals instead of raw numbers.
- **Retry Operations Based on Specific Errors**: Use predicate-based retry policies to retry an operation only for specific, recoverable errors.
- **Run a Pipeline for its Side Effects**: Use Stream.runDrain to execute a stream for its side effects when you don't need the final values.
- **Run Background Tasks with Effect.fork**: Use Effect.fork to start a non-blocking background process and manage its lifecycle via its Fiber.
- **Run Independent Effects in Parallel with Effect.all**: Use Effect.all to execute a collection of independent effects concurrently.
- **Safely Bracket Resource Usage with `acquireRelease`**: Bracket the use of a resource between an `acquire` and a `release` effect.
- **Send a JSON Response**: Use Http.response.json to automatically serialize data structures into a JSON response.
- **Set Up a New Effect Project**: Set up a new Effect project.
- **Solve Promise Problems with Effect**: Recognize that Effect solves the core limitations of Promises: untyped errors, no dependency injection, and no cancellation.
- **Supercharge Your Editor with the Effect LSP**: Install and use the Effect LSP extension for enhanced type information and error checking in your editor.
- **Teach your AI Agents Effect with the MCP Server**: Use the MCP server to provide live application context to AI coding agents, enabling more accurate assistance.
- **Trace Operations Across Services with Spans**: Use Effect.withSpan to create custom tracing spans for important operations.
- **Transform Data During Validation with Schema**: Use Schema.transform to safely convert data types during the validation and parsing process.
- **Transform Effect Values with map and flatMap**: Transform Effect values with map and flatMap.
- **Turn a Paginated API into a Single Stream**: Use Stream.paginateEffect to model a paginated data source as a single, continuous stream.
- **Understand Fibers as Lightweight Threads**: Understand that a Fiber is a lightweight, virtual thread managed by the Effect runtime for massive concurrency.
- **Understand Layers for Dependency Injection**: Understand that a Layer is a blueprint describing how to construct a service and its dependencies.
- **Understand that Effects are Lazy Blueprints**: Understand that effects are lazy blueprints.
- **Understand the Three Effect Channels (A, E, R)**: Understand that an Effect&lt;A, E, R&gt; describes a computation with a success type (A), an error type (E), and a requirements type (R).
- **Use .pipe for Composition**: Use .pipe for composition.
- **Use Chunk for High-Performance Collections**: Prefer Chunk over Array for immutable collection operations within data processing pipelines for better performance.
- **Use Effect.gen for Business Logic**: Use Effect.gen for business logic.
- **Use the Auto-Generated .Default Layer in Tests**: Use the auto-generated .Default layer in tests.
- **Validate Request Body**: Use Http.request.schemaBodyJson with a Schema to automatically parse and validate request bodies.
- **Wrap Asynchronous Computations with tryPromise**: Wrap asynchronous computations with tryPromise.
- **Wrap Synchronous Computations with sync and try**: Wrap synchronous computations with sync and try.
- **Write Sequential Code with Effect.gen**: Write sequential code with Effect.gen.
- **Write Tests That Adapt to Application Code**: Write tests that adapt to application code.
