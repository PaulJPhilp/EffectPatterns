description: Use Effect.fn to wrap functions with effectful instrumentation, such as logging, metrics, or tracing, in a composable and type-safe way.
globs: "**/*.ts"
alwaysApply: true

# Instrument and Observe Function Calls with Effect.fn
**Rule:** Use Effect.fn to wrap functions with effectful instrumentation, such as logging, metrics, or tracing, in a composable and type-safe way.

### Example
```typescript
import { Effect } from "effect";

// Use Effect.fn to wrap a function with automatic span creation
const fetchUser = Effect.fn("fetch-user")(function* (userId: string) {
  // Annotate the span with contextual information
  yield* Effect.annotateCurrentSpan({
    userId,
  });

  // Simulate async operation
  const user = yield* Effect.tryPromise(() =>
    Promise.resolve({ id: userId, name: "Alice" })
  );

  return user;
});

// Use the instrumented function in an Effect workflow
const program = Effect.gen(function* () {
  yield* Effect.logInfo("Fetching user");
  const user = yield* fetchUser("user-123");
  yield* Effect.logInfo(`Fetched user: ${user.name}`);
  return user;
});

// Run the program with OpenTelemetry integration
// Effect.runPromise(program);

```

**Explanation:**
- `Effect.fn("operation-name")(function*)` wraps a function and automatically creates OpenTelemetry spans with the given name.
- No manual span wrapping needed—the Effect runtime handles span creation and lifecycle automatically.
- Use `Effect.annotateCurrentSpan()` to add metadata and context to the span.
- Integrates seamlessly with OpenTelemetry for distributed tracing, logging, and metrics.
- Keeps instrumentation composable and type-safe without cluttering business logic.

### Anti-Pattern (Avoid)
Scattering logging, metrics, or tracing logic directly inside business functions, making code harder to test, maintain, and compose.

**Explanation:**  
Instrumenting function calls is essential for observability, especially in complex or critical code paths.  
`Effect.fn` lets you add effectful logic (logging, metrics, tracing, etc.) before, after, or around any function call, without changing the function’s core logic.
